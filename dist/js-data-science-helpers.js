(()=>{var vh=Object.defineProperty;var Nh=(t,e,n)=>e in t?vh(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n;var qr=(t=>typeof require!="undefined"?require:typeof Proxy!="undefined"?new Proxy(t,{get:(e,n)=>(typeof require!="undefined"?require:e)[n]}):t)(function(t){if(typeof require!="undefined")return require.apply(this,arguments);throw new Error('Dynamic require of "'+t+'" is not supported')});var c=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports);var Et=(t,e,n)=>(Nh(t,typeof e!="symbol"?e+"":e,n),n);var se=c((nS,yr)=>{var Mt=class extends Error{constructor(e){typeof window<"u"?super(e):super(`

\x1B[31m`+e+`
\x1B[0m`)}};yr.exports=Mt});var m=c((rS,br)=>{var wh=se();br.exports=function(t,e){if(!t)throw new wh(e)}});var C=c((sS,vr)=>{function Sh(t){try{return structuredClone(t)}catch{return t}}vr.exports=Sh});var p=c((iS,Nr)=>{function xh(t){try{return t instanceof Array||typeof t.constructor<"u"&&t.constructor.name==="Array"}catch{return!1}}Nr.exports=xh});var y=c((oS,wr)=>{function _h(t){try{return!!t._symbol&&t._symbol===Symbol.for("@jrc03c/js-math-tools/dataframe")}catch{return!1}}wr.exports=_h});var q=c((uS,Sr)=>{function Th(t){try{return!!t._symbol&&t._symbol===Symbol.for("@jrc03c/js-math-tools/series")}catch{return!1}}Sr.exports=Th});var T=c((aS,Tr)=>{var Oh=m(),Dh=C(),xr=p(),Fh=y(),Ih=q();function _r(t){if(Fh(t)||Ih(t))return _r(t.values);Oh(xr(t),"The `flatten` function only works on arrays, Series, and DataFrames!");function e(n){let r=[];return Dh(n).forEach(s=>{xr(s)?r=r.concat(e(s)):r.push(s)}),r}return e(t)}Tr.exports=_r});var A=c((cS,Or)=>{function Ah(t){return typeof t=="function"}Or.exports=Ah});var g=c((lS,Dr)=>{function Eh(t){return typeof t=="number"&&!isNaN(t)}Dr.exports=Eh});var v=c((fS,Fr)=>{function Mh(t){return t===null||typeof t>"u"}Fr.exports=Mh});var Q=c((hS,Ir)=>{var jh=p(),kh=v();function Ch(t){return typeof t=="object"&&!kh(t)&&!jh(t)}Ir.exports=Ch});var be=c((mS,Mr)=>{var zh=m(),Ar=p(),Rh=y(),Uh=A(),jt=g(),Er=Q(),Ph=q();function kt(t,e){if(Rh(t)){let i=kt(t.values,e);return i.length>0&&jt(i[0])&&i[0]>=0&&i[0]<t.index.length&&(i[0]=t.index[i[0]]),i.length>1&&jt(i[1])&&i[1]>=0&&i[1]<t.columns.length&&(i[1]=t.columns[i[1]]),i}if(Ph(t)){let i=kt(t.values,e);return i.length>0&&jt(i[0])&&i[0]>=0&&i[0]<t.index.length&&(i[0]=t.index[i[0]]),i}if(zh(Er(t)||Ar(t),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `indexOf` function!"),!Uh(e)){let i=e;e=o=>o===i}function n(i,o,u){if(u=u||[],u.indexOf(i)>-1)return null;if(Er(i)){u.push(i);let a=Object.keys(i);for(let l=0;l<a.length;l++){let f=a[l],h=i[f];if(o(h))return[f];let d=n(h,o,u);if(d&&d.length>0)return[f].concat(d)}}else if(Ar(i)){u.push(i);for(let a=0;a<i.length;a++){let l=i[a];if(o(l))return[a];let f=n(l,o,u);if(f&&f.length>0)return[a].concat(f)}}else if(o(i))return[];return null}function r(i){try{return e(i)}catch{return!1}}let s=n(t,r);return s&&s.length>0?s:null}Mr.exports=kt});var Ct=c((dS,jr)=>{var Bh=C(),Vh=be(),Yh=p(),Jh=y(),$h=q();jr.exports=function(e){function n(i,o,u){if(o=o||[],u=u||"",o.indexOf(i)>-1){let a=u.split("/").slice(u.startsWith("/")?1:0);if(a.some((f,h)=>{let d=a.slice(0,a.length-h-1),b=r;return d.forEach(S=>{b=b[S]}),b===i}))return`<reference to "${r===i?"/":"/"+Vh(r,i).join("/")}">`}return typeof i=="object"?i===null?null:(o.push(i),Yh(i)?i.map((a,l)=>n(a,o,u+"/"+l)):(Object.keys(i).forEach(a=>{i[a]=n(i[a],o,u+"/"+a)}),i)):i}let r=Bh(e),s=n(r);if(Jh(e)){let i=e.copy();i._values=s.values,i._columns=s.columns,i._index=s.index,s=i}if($h(e)){let i=e.copy();i.name=s.name,i._values=s.values,i._index=s.index,s=i}return s}});var R=c((pS,zr)=>{var kr=C(),Cr=Ct();function Gh(t,e){function n(r,s){let i=typeof r;if(i!==typeof s)return!1;if(i==="undefined")return!0;if(i==="boolean"||i==="symbol")return r===s;if(i==="number"||i==="bigint")return r.toString()==="NaN"&&s.toString()==="NaN"?!0:r===s;if(i==="string"||i==="function")return r===s;if(i==="object"){if(r===null||s===null)return r===null&&s===null;{let u=Object.keys(r),a=Object.keys(s);if(u.length!==a.length)return!1;for(let l=0;l<u.length;l++){let f=u[l];if(!n(r[f],s[f]))return!1}return!0}}}try{return n(kr(t),kr(e))}catch{return n(Cr(t),Cr(e))}}zr.exports=Gh});var z=c((gS,Br)=>{var Lh=m(),Wh=T(),Kh=p(),Rr=y(),Hh=A(),Ur=q(),Xh=v();function ve(t){let e="abcdefg1234567890",n="";for(;n.length<t;)n+=e[parseInt(Math.random()*e.length)];return n}var Qh=ve(256),Zh=ve(256),e0=ve(256),t0=ve(256),n0=ve(256);function Pr(t){if(Rr(t)||Ur(t))return Pr(t.values);Lh(Kh(t),"The `set` function only works on arrays, Series, and DataFrames!");let e=[],n={};return Wh(t).forEach(r=>{let s=typeof r=="object"&&r===null?Qh:Xh(r)?Zh:Hh(r)?r.toString():typeof r=="symbol"?r.toString()+" - "+n0:r===1/0?e0:r===-1/0?t0:Rr(r)?r.toJSONString():Ur(r)?JSON.stringify(r.toObject()):JSON.stringify(r);n[s]||e.push(r),n[s]=!0}),e}Br.exports=Pr});var Ue=c((qS,Jr)=>{var r0=m(),zt=T(),Vr=p(),s0=y(),Yr=R(),i0=A(),o0=q(),u0=z();function Re(t,e){if(s0(t)||o0(t))return arguments.length>1?Re(t.values,e):Re(t.values,t.values);if(r0(Vr(t),"The first argument to the `count` function must be an array, Series, or DataFrame!"),i0(e))return zt(t).filter(n=>e(n)).length;if(Vr(e)){let n=zt(t);return u0(e).map(r=>({item:r,count:n.filter(s=>Yr(s,r)).length}))}else return arguments.length>1?zt(t).filter(n=>Yr(n,e)).length:Re(t,t)}Jr.exports=Re});var Ne=c((yS,Gr)=>{var a0=m(),$r=p(),c0=y(),l0=q();function Rt(t){if(c0(t)||l0(t))return Rt(t.values);a0($r(t),"The `isJagged` function only works on arrays, Series, and DataFrames!");let e=0,n=null;for(let r=0;r<t.length;r++)if($r(t[r])){if(e++,Rt(t[r]))return!0;if(n===null)n=t[r].length;else if(t[r].length!==n)return!0}return e>0&&e<t.length}Gr.exports=Rt});var Pe=c((bS,Kr)=>{var f0=m(),Lr=p(),h0=y(),m0=q();function Wr(t){if(h0(t)||m0(t))return Wr(t.values);f0(Lr(t),"The `isNested` function only works on arrays, Series, and DataFrames!");for(let e=0;e<t.length;e++)if(Lr(t[e]))return!0;return!1}Kr.exports=Wr});var J=c((vS,Xr)=>{var Z=m(),d0=p(),p0=Pe(),g0=g(),q0=v(),ie="You must pass a natural number or a one-dimensional array of natural numbers into the `ndarray` function!";function Hr(t){Z(!q0(t),ie),d0(t)||(t=[t]),Z(!p0(t),ie),Z(t.length>0,ie);let e=t[0];if(Z(g0(e),ie),Z(parseInt(e)===e,ie),Z(e>=0,ie),Z(e!==1/0,"We can't create an array containing an infinite number of values!"),t.length===1){let n=[];for(let r=0;r<e;r++)n.push(void 0);return n}else{let n=[];for(let r=0;r<e;r++)n.push(Hr(t.slice(1)));return n}}Xr.exports=Hr});var we=c((NS,Qr)=>{var y0=m(),b0=p(),v0=y(),N0=q();function Ut(t){if(v0(t)||N0(t)){let n=t.copy();return n.values=Ut(n.values),n.index=Ut(n.index),n}y0(b0(t),"The `reverse` function only works on arrays, Series, and DataFrames!");let e=[];for(let n=t.length-1;n>=0;n--)e.push(t[n]);return e}Qr.exports=Ut});var M=c((wS,Zr)=>{var Pt=m(),Bt=g(),Vt=v(),w0=we();function S0(t,e,n=1){Pt(!Vt(t)&&!Vt(e)&&!Vt(n),"You must pass two numbers and optionally a step value to the `range` function!"),Pt(Bt(t)&&Bt(e)&&Bt(n),"You must pass two numbers and optionally a step value to the `range` function!"),Pt(n>0,"The step value must be greater than 0! (NOTE: The step value is a magnitude; it does not indicate direction.)");let r=!1;if(t>e){r=!0;let i=t;t=e+n,e=i+n}let s=[];for(let i=t;i<e;i+=n)s.push(i);return r&&(s=w0(s)),s}Zr.exports=S0});var x=c((SS,rs)=>{var x0=m(),es=p(),_0=y(),T0=R(),O0=q(),D0=v();function ts(t){if(!es(t))return;let e=[t.length],n=0,r=t.map(s=>{let i=ts(s);return D0(i)?i:(n++,i.length===1?i[0]:i)});return n>0?n===t.length&&r.slice(0,-1).every((i,o)=>T0(i,r[o+1]))?e.concat(r[0]):(e.push(r),e):e}function ns(t){return _0(t)||O0(t)?ns(t.values):(x0(es(t),"The `shape` function only works on arrays, Series, and DataFrames!"),ts(t))}rs.exports=ns});var cs=c((xS,as)=>{var ss=m(),F0=p(),I0=y(),A0=Ne(),E0=q(),M0=v(),is=se(),Be=J(),os=M(),j0=z(),k0=x();function us(t,e,n){if(M0(n)&&(n=0),ss(n===0||n===1||n==="vertical"||n==="horizontal",'The only valid axis values for use when appending data to a DataFrame are 0, 1, "vertical", and "horizontal". Note that 0 == "horizontal" and 1 == "vertical".'),F0(e)){ss(!A0(e),"The array of data you're trying to append to this DataFrame is jagged!");let r=k0(e);if(r.length===1)if(n===0){let s=t.copy();s._values.push(e);let i=Math.max(t.shape[1],r[0]);for(s._values.forEach(o=>{for(;o.length<i;)o.push(void 0)});s._index.length<s._values.length;)s._index.push("row"+s._index.length);for(;s._columns.length<i;)s._columns.push("col"+s._columns.length);return s}else{let s=Math.max(t.shape[0],r[0]),i=t.copy();for(os(0,s).forEach(o=>{o>=i._values.length&&i._values.push(Be(t.shape[1])),i._values[o].push(e[o])});i._index.length<i._values.length;)i._index.push("row"+i._index.length);for(;i._columns.length<i._values[0].length;)i._columns.push("col"+i._columns.length);return i}else if(r.length===2)if(n===0){let s=Math.max(...e.map(o=>o.length).concat([t.shape[1]])),i=t.copy();for(i._values=i._values.concat(e).map(o=>{for(;o.length<s;)o.push(void 0);return o});i._index.length<i._values.length;)i._index.push("row"+i._index.length);for(;i._columns.length<s;)i._columns.push("col"+i._columns.length);return i}else{let s=Math.max(...e.map(u=>u.length))+t.shape[1],i=Math.max(t.shape[0],r[0]),o=t.copy();for(os(0,i).forEach(u=>{for(u>=o._values.length&&o._values.push(Be(t.shape[1])),o._values[u]=o._values[u].concat(e[u]);o._values[u].length<s;)o._values[u].push(void 0)});o._index.length<o._values.length;)o._index.push("row"+o._index.length);for(;o._columns.length<s;)o._columns.push("col"+o._columns.length);return o}else throw new is("Only 1- and 2-dimensional arrays can be appended to a DataFrame!")}else if(E0(e)){let r=us(t,e.values,n);return n===0?r.index[r.index.length-1]=r.index.indexOf(e.name)>-1?e.name+" (2)":e.name:r.columns[r.columns.length-1]=r.columns.indexOf(e.name)>-1?e.name+" (2)":e.name,r}else if(I0(e))if(n===0){let r=t.copy(),s=j0(r._columns.concat(e._columns)).length;for(r._values.forEach(i=>{for(;i.length<s;)i.push(void 0)}),e.apply(i=>{let o=i.copy(),u=[];r._columns.forEach(a=>{let l=o._index.indexOf(a);l>-1?(u.push(o._values[l]),o._values.splice(l,1),o._index.splice(l,1)):u.push(void 0)}),r._values.push(u.concat(o._values))},1),r._columns=r._columns.concat(e._columns.filter(i=>r._columns.indexOf(i)<0));r._index.length<r._values.length;){let i="row"+r._index.length;r._index.push(i+(t._index.indexOf(i)>-1?" (2)":""))}return r}else{let r=t.copy();return r._index.forEach((s,i)=>{let o=e._index.indexOf(s);o>-1?r._values[i]=r._values[i].concat(e._values[o]):r._values[i]=r._values[i].concat(Be(e.shape[1]))}),e._index.forEach((s,i)=>{r._index.indexOf(s)<0&&(r._index.push(s),r._values.push(Be(r._columns.length).concat(e._values[i])))}),r._columns=r._columns.concat(e._columns.map(s=>s+(r._columns.indexOf(s)>-1?" (2)":""))),r}else throw new is("Only 1- or 2-dimensional arrays, Series, and DataFrames can be appended to a DataFrame!")}as.exports=us});var ds=c((_S,ms)=>{var ls=m(),fs=p(),C0=A(),hs=v();function z0(t,e,n,r,s){if(s=s||0,ls(C0(r),"The first parameter to the `apply` method must be a function."),ls(s===0||s===1,"The second parameter to the `apply` method (the `axis`) must be 0 or 1."),s===0){let i={},o;if(n.columns.forEach((u,a)=>{let l=new e(n.values.map(h=>h[a]));l.name=u,l.index=n.index;let f=r(l,a,n);f instanceof e?i[u]=f.values:i[u]=f,hs(o)&&(o=f instanceof e||fs(f))}),o){let u=new t(i);return u.index=n.index,u}else{let u=new e(n.columns.map(a=>i[a]));return u.index=n.columns,u}}else if(s===1){let i,o=n.values.map((u,a)=>{let l=new e(u);l.name=n.index[a],l.index=n.columns;let f=r(l,a,n);return hs(i)&&(i=f instanceof e||fs(f)),f instanceof e?f.values:f});if(i){let u=new t(o);return u.index=n.index,u.columns=n.columns,u}else{let u=new e(o);return u.index=n.index,u}}}ms.exports=z0});var j=c((TS,ps)=>{function R0(t){return typeof t=="string"}ps.exports=R0});var ys=c((OS,qs)=>{var gs=m(),U0=p(),P0=Ne(),B0=Q(),V0=j(),Y0=v(),J0=se(),$0=x();function G0(t,e,n,r,s){let i=u=>u instanceof t,o=u=>u instanceof e;if(Y0(s)){if(i(r))return n.append(r,1);if(o(r))return n.append(r,1);if(B0(r)){let u=Math.max(...Object.keys(r).map(a=>r[a].length));return Object.keys(r).forEach(a=>{for(;r[a].length<u;)r[a].push(void 0)}),n.append(new t(r),1)}else throw new J0("You must pass a DataFrame, Series, or object into the `assign` method!")}else{gs(V0(r),"If passing two arguments into the `assign` method, then the first argument must be a string name!"),gs(U0(s)&&!P0(s)&&$0(s).length===1,"If passing two arguments into the `assign` method, then the second argument must be a 1-dimensional array!");let u=n.append(s,1);return u.columns[u.columns.length-1]=r,u}}qs.exports=G0});var vs=c((DS,bs)=>{var L0=C();function W0(t,e){if(e.isEmpty)return new t;let n=new t(L0(e.values));return n.columns=e.columns.slice(),n.index=e.index.slice(),n}bs.exports=W0});var Os=c((FS,Ts)=>{var Ve=m(),Ns=p(),ws=g(),Ss=j(),xs=v(),_s=x();function K0(t,e,n,r,s){xs(r)&&(r=[]),xs(s)&&(s=[]),(Ss(r)||ws(r))&&(r=[r]),(Ss(s)||ws(s))&&(s=[s]),Ve(Ns(r),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),Ve(Ns(s),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),Ve(_s(r).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),Ve(_s(s).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");let i,o;n.index.forEach((a,l)=>{r.indexOf(a)<0&&r.indexOf(l)<0&&(i||(i=[]),i.push(a))}),n.columns.forEach((a,l)=>{s.indexOf(a)<0&&s.indexOf(l)<0&&(o||(o=[]),o.push(a))});let u=n.get(i,o);if(u instanceof e){let a=new t;a=a.assign(u),n.index.indexOf(u.name)>-1&&(a=a.transpose()),u=a}return u}Ts.exports=K0});var Se=c((IS,Ds)=>{var H0=g();function X0(t){return H0(t)&&parseInt(t)===t}function Q0(t){return X0(t)&&t>=0}Ds.exports=Q0});var Is=c((AS,Fs)=>{var Yt=m(),Z0=j(),Ye=v(),em=Se(),tm=x();function nm(t,e,n,r,s,i){r=r||0,Yt(r===0||r===1,"The first parameter of the `dropMissing` method (the `axis`) must be 0 or 1."),i=i||0,Yt(em(i),"The third parameter of the `dropMissing` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` null values)."),s=i>0?"none":s||"any",Yt(s==="any"||s==="all"||s==="none","The second parameter of the `dropMissing` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains null values, then it should be dropped; or that if 'all' of the data contains null values, then it should be dropped).");function o(l){if(i>0){let f=0;for(let h=0;h<l.length;h++){let d=l[h];if(Ye(d)&&f++,f>=i)return[]}}else if(s==="any")for(let f=0;f<l.length;f++){let h=l[f];if(Ye(h))return[]}else if(s==="all"){for(let f=0;f<l.length;f++){let h=l[f];if(!Ye(h))return l}return[]}return l}let u=n.copy(),a=Math.random().toString();if(r===0){u=u.assign(a,u.index);let l=u.values.map(o).filter(h=>h.length>0);if(tm(l).length<2)return new t;u.values=l;let f=u.get(null,a);if(Ye(f))return new t;Z0(f)&&(f=[f]),f instanceof e&&(f=f.values),u.index=f,u=u.drop(null,a)}else if(r===1){let l={};if(u.columns.forEach((h,d)=>{let b=u.values.map(O=>O[d]),S=o(b);S.length>0&&(l[h]=S)}),Object.keys(l).length===0)return new t;let f=new t(l);return f.index=u.index,f}return u}Fs.exports=nm});var Jt=c((ES,Es)=>{var rm=m(),sm=p(),im=y(),om=g(),um=q();function As(t){if(im(t)||um(t))return t.dropNaN(...Object.values(arguments).slice(1));rm(sm(t),"The `dropNaN` function only works on arrays, Series, and DataFrames!");let e=[];return t.forEach(n=>{try{return e.push(As(n))}catch{if(om(n))return e.push(n)}}),e}Es.exports=As});var js=c((MS,Ms)=>{var $t=m(),am=Jt(),cm=Se();function lm(t,e,n,r,s){n=n||0,$t(n===0||n===1,"The first parameter of the `dropNaN` method (the `axis`) must be 0 or 1."),s=s||0,$t(cm(s),"The third parameter of the `dropNaN` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` NaN values)."),r=s>0?"none":r||"any",$t(r==="any"||r==="all"||r==="none","The second parameter of the `dropNaN` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains NaN values, then it should be dropped; or that if 'all' of the data contains NaN values, then it should be dropped).");function i(u){let a=am(u);return s>0?u.length-a.length<s:r==="any"?a.length===u.length:r==="all"?a.length>0:!0}let o=e.copy();if(n===0){let u=o.index.filter(a=>{let l=o.get(a,null).values;return i(l)});return u.length>0?o.get(u,null):new t}else if(n===1){let u=o.columns.filter(a=>{let l=o.get(null,a).values;return i(l)});return u.length>0?o.get(null,u):new t}return o}Ms.exports=lm});var Rs=c((jS,zs)=>{var ks=m(),xe=T(),fm=A(),hm=v();function Cs(t){let e={};return xe(t).forEach((n,r)=>{e[n]=r}),e}function oe(t){return Object.keys(t).sort((e,n)=>t[e]-t[n])}function mm(t,e,n,r,s){ks(fm(r),"The `filter` method takes a single parameter: a function that is used to filter the values."),hm(s)&&(s=0),ks(s===0||s===1,"The `axis` parameter to the `filter` method must be 0 or 1.");let i=n.copy();if(i.isEmpty)return i;let o=Cs(i.index),u=Cs(i.columns);if(s===0){let a=i.values.filter((l,f)=>{let h=new e(l);h.name=n.index[f],h.index=n.columns;let d=r(h,f,n);return d||delete o[i.index[f]],d});if(xe(a).length===0)return new t;if(a.length===1){let l=new e(xe(a));return l.name=oe(o)[0],l.index=oe(u),l}i.values=a,i.index=oe(o)}else if(s===1){i=i.transpose();let a=i.values.filter((l,f)=>{let h=new e(l);h.name=n.columns[f],h.index=n.index;let d=r(h,f,n);return d||delete u[i.index[f]],d});if(xe(a).length===0)return new t;if(a.length===1){let l=new e(xe(a));return l.name=oe(u)[0],l.index=oe(o),l}i.values=a,i.index=oe(u),i=i.transpose()}return i}zs.exports=mm});var Bs=c((kS,Ps)=>{var k=m(),Je=g(),$e=j(),Us=v(),dm=z();function pm(t,e,n){($e(e)||Je(e))&&(e=[e]),($e(n)||Je(n))&&(n=[n]);let r=dm((e||[]).concat(n||[]).map(s=>typeof s));return k(r.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===1&&k(r[0]==="string"||r[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===2&&(k(r.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),k(r.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),Us(e)||(e=e.map(s=>{if($e(s))return k(t.index.indexOf(s)>-1,`Row "${s}" does not exist!`),s;if(Je(s))return k(s>=0,`Index ${s} is out of bounds!`),k(parseInt(s)===s,"Row numbers must be integers!"),k(s<t.index.length,`Index ${s} is out of bounds!`),t.index[s]})),Us(n)||(n=n.map(s=>{if($e(s))return k(t.columns.indexOf(s)>-1,`Column "${s}" does not exist!`),s;if(Je(s))return k(s>=0,`Column ${s} is out of bounds!`),k(parseInt(s)===s,"Column numbers must be integers!"),k(s<t.columns.length,`Column ${s} is out of bounds!`),t.columns[s]})),t.getSubsetByNames(e,n)}Ps.exports=pm});var $=c((CS,Ys)=>{var Vs=m(),gm=p(),qm=y(),ym=A(),bm=q(),vm=v();function Nm(t,e){try{return t<e?-1:t>e?1:0}catch{return t=typeof t=="object"&&t!==null?JSON.stringify(t):t.toString(),e=typeof e=="object"&&e!==null?JSON.stringify(e):e.toString(),t<e?-1:t>e?1:0}}function wm(t,e){if(vm(e)&&(e=Nm),qm(t)||bm(t))return t.sort(...Object.values(arguments).slice(1));Vs(gm(t),"The `sort` function only works on arrays, Series, and DataFrames!"),Vs(ym(e),"The second parameter of the `sort` function must be a comparison function!");let n=t.slice();return n.sort(e),n}Ys.exports=wm});var Ls=c((zS,Gs)=>{var Js=m(),$s=j(),Sm=v(),xm=z(),_m=$();function Tm(t){let e=t.toLowerCase(),n="";for(let s=0;s<e.length;s++){let i=e[s];i.match(/[a-z0-9]/g)?n+=i:n+=" "}let r=n.split(" ").filter(s=>s.length>0);return r[0]+r.slice(1).map(s=>s[0].toUpperCase()+s.substring(1)).join("")}function Om(t,e,n){Sm(n)?n=e.columns:$s(n)&&(n=[n]);let r={};n.forEach(i=>{Js($s(i),"You must pass either a string or a one-dimensional array of strings into the `getDummies` (AKA `oneHotEncode`) method!");let o=e.columns.indexOf(i);Js(o>-1,`The given DataFrame does not have a column called "${i}"!`);let u=e.values.map(l=>l[o]),a=_m(xm(u));u.forEach(l=>{a.forEach(f=>{let h=i+"_"+Tm(f.toString());r[h]||(r[h]=[]),l===f?r[h].push(1):r[h].push(0)})})});let s=new t(r);return s.index=e.index,s}Gs.exports=Om});var ti=c((RS,ei)=>{var G=m(),Ws=p(),Ks=g(),Hs=v(),Xs=Se(),Qs=M(),Zs=x();function Dm(t,e,n){let r=t.shape;Hs(e)&&(e=Qs(0,r[0])),Hs(n)&&(n=Qs(0,r[1])),Ks(e)&&(e=[e]),Ks(n)&&(n=[n]),G(Ws(e)&&Ws(n),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),G(Zs(e).length===1&&Zs(n).length===1,"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),G(e.length>0,"The `rowIndices` array must contain at least one index."),G(n.length>0,"The `colIndices` array must contain at least one index."),e.forEach(o=>{G(Xs(o),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),G(o<t.index.length,`The row index ${o} is out of bounds.`)}),n.forEach(o=>{G(Xs(o),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),G(o<t.columns.length,`The column index ${o} is out of bounds.`)});let s=e.map(o=>t.index[o]),i=n.map(o=>t.columns[o]);return t.getSubsetByNames(s,i)}ei.exports=Dm});var oi=c((US,ii)=>{var L=m(),Gt=T(),ni=p(),Ge=j(),ri=v(),si=x();function Fm(t,e,n,r,s){ri(r)&&(r=n.index),ri(s)&&(s=n.columns),Ge(r)&&(r=[r]),Ge(s)&&(s=[s]),L(ni(r)&&ni(s),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),L(si(r).length===1&&si(s).length===1,"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),L(r.length>0,"The `rows` array must contain at least one row name."),L(s.length>0,"The `cols` array must contain at least one column name."),r.forEach(u=>{L(Ge(u),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),L(n.index.indexOf(u)>-1,`The row name "${u}" does not exist in the list of rows.`)}),s.forEach(u=>{L(Ge(u),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),L(n.columns.indexOf(u)>-1,`The column name "${u}" does not exist in the list of columns.`)});let i=r.map(u=>s.map(a=>n.values[n.index.indexOf(u)][n.columns.indexOf(a)]));if(r.length===1&&s.length===1)return Gt(i)[0];if(r.length===1){let u=new e(Gt(i));return u.name=r[0],u.index=s,u}if(s.length===1){let u=new e(Gt(i));return u.name=s[0],u.index=r,u}let o=new t(i);return o.columns=s,o.index=r,o}ii.exports=Fm});var ai=c((PS,ui)=>{var Im=j(),_e=M();function Am(t,e,n){function r(d,b){return Im(d)&&d.length>b?d.substring(0,b-3)+"...":d}if(n.isEmpty)return console.table({}),console.log("Shape:",[0,0],`
`),n;let s=typeof window>"u"?20:10,i=parseInt(s/2),o=typeof window>"u"?Math.floor(process.stdout.columns/24)-1:10,u=parseInt(o/2),a=s>n.index.length?null:_e(0,i).concat(_e(n.index.length-i,n.index.length)),l=o>n.columns.length?null:_e(0,u).concat(_e(n.columns.length-u,n.columns.length)),f=n.get(a,l);f instanceof e&&(n.shape[0]===1?(f=new t([f.values]),f.index=n.index,f.columns=new e(n.columns).get(l).values):n.shape[1]===1&&(f=new t([f.values]).transpose(),f.index=new e(n.index).get(a).values,f.columns=n.columns)),s<=n.index.length&&(f._index.splice(i,0,"..."),f._values.splice(i,0,_e(0,f.columns.length).map(()=>"..."))),o<=n.columns.length&&(f._columns.splice(u,0,"..."),f._values=f._values.map(d=>(d.splice(u,0,"..."),d)));let h=28;return f instanceof e?(f.values=f.values.map(d=>r(d,h)),f.name=r(f.name,h),f.index=f.index.map(d=>r(d,h))):(f.values=f.values.map(d=>d.map(b=>r(b,h))),f.columns=f.columns.map(d=>r(d,h)),f.index=f.index.map(d=>r(d,h))),console.table(f.toObject()),console.log("Shape:",n.shape,`
`),n}ui.exports=Am});var Le=c((BS,ci)=>{var Em=m(),Mm=g();function jm(t,e){Em(Mm(t),"The `leftPad` function only works on numbers!");let n=t.toString();for(;n.length<e;)n="0"+n;return n}ci.exports=jm});var fi=c((VS,li)=>{var km=Le(),Cm=M();function zm(t,e){let n=e?t:t.copy();return n.index=Cm(0,t.shape[0]).map(r=>"row"+km(r,(n.index.length-1).toString().length)),n}li.exports=zm});var Te=c((YS,mi)=>{var Rm=m(),Um=T(),Pm=p(),Bm=y(),Vm=q();function hi(t){if(Bm(t)||Vm(t))return hi(t.values);Rm(Pm(t),"The `product` function only works on arrays, Series, and DataFrames!");try{return t.length===0?NaN:Um(t).reduce((e,n)=>e*n,1)}catch{return NaN}}mi.exports=hi});var We=c((JS,qi)=>{var Oe=m(),di=T(),pi=p(),Ym=y(),gi=g(),Jm=q(),$m=Te(),Gm=x();function Lt(t,e){if(Ym(t)||Jm(t))return Lt(t.values,e);if(Oe(pi(t),"The first argument passed into the `reshape` function must be an array!"),gi(e)&&(e=[e]),Oe(pi(e),"The second argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),Oe(Gm(e).length===1,"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),e.forEach(i=>{Oe(gi(i)&&parseInt(i)===i&&i>0,"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!")}),e.length===0)return di(t);let n=di(t);if(e.length===1&&e[0]===n.length)return n;Oe($m(e)===n.length,"The new shape doesn't match the number of values available in `x` (the first argument passed into the `reshape` function)!");let r=[],s=parseInt(n.length/e[0]);for(let i=0;i<e[0];i++){let o=n.slice(i*s,(i+1)*s);r.push(Lt(o,e.slice(1)))}return r}qi.exports=Lt});var ue=c(($S,xi)=>{var Lm=m(),vi=C(),Wm=p(),Km=g(),Ni=v(),Hm=J(),Xm=Te(),Qm=We(),wi=Math.pow(2,64),_=[];Si(parseInt(Math.random()*wi));function Zm(t,e){t=I(t);function n(){t+=I("0x9e3779b97f4a7c15");let s=vi(t);return s=(s^s>>30n)*I("0xbf58476d1ce4e5b9"),s=(s^s>>27n)*I("0x94d049bb133111eb"),s^s>>31n}let r=[];for(let s=0;s<e;s++)r.push(n());return r}function I(t){return BigInt.asUintN(64,BigInt(t))}function yi(t,e){return t=I(t),e=BigInt(e),I(I(t<<e)|I(t>>I(64n-e)))}function Si(t){if(Ni(t))return vi(_);{Lm(Km(t),"If passing a value into the `seed` function, then that value must be an integer!");let e=Zm(parseInt(t),4);_[0]=e[0],_[1]=e[1],_[2]=e[2],_[3]=e[3]}}function bi(){let t=I(yi(_[0]+_[3],23)+_[0]),e=I(_[1]<<17n);return _[2]=I(_[2]^_[0]),_[3]=I(_[3]^_[1]),_[1]=I(_[1]^_[2]),_[0]=I(_[0]^_[3]),_[2]=I(_[2]^e),_[3]=yi(_[3],45),parseInt(t)/wi}function ed(t){return Ni(t)?bi():(Wm(t)||(t=[t]),Qm(Hm(Xm(t)).map(bi),t))}xi.exports={random:ed,seed:Si}});var Ke=c((GS,_i)=>{var{random:td}=ue(),nd=m(),rd=p(),sd=y(),id=q();function od(t){if(sd(t)||id(t))return t.shuffle(...Object.values(arguments).slice(1));nd(rd(t),"The `shuffle` function only works on arrays, Series, and DataFrames!");let e=[],n=t.slice();for(let r=0;r<t.length;r++){let s=parseInt(td()*n.length);e.push(n.splice(s,1)[0])}return e}_i.exports=od});var Di=c((LS,Oi)=>{var ud=m(),ad=v(),Ti=Ke();function cd(t,e){return ad(e)&&(e=0),ud(e===0||e===1,"The `axis` parameter to the `shuffle` must be 0, 1, or undefined."),t.get(e===0?Ti(t.index):null,e===1?Ti(t.columns):null)}Oi.exports=cd});var Wt=c((WS,Fi)=>{function ld(t){return typeof t=="boolean"}Fi.exports=ld});var ji=c((KS,Mi)=>{var{random:fd}=ue(),E=m(),hd=T(),Ii=p(),Kt=Wt(),Ei=A(),He=g(),ae=j(),Ht=v(),md=M(),Ai=x(),Xt=$();function dd(t,e,n){return Ei(e)?pd(t,e,n):gd(t,e,n)}function pd(t,e,n){if(n=Ht(n)?0:n,E(Ei(e),"When sorting a DataFrame using a function, the first argument to the `sort` method must be a function!"),E(He(n),"When sorting a DataFrame using a function, the second argument to the `sort` method must be null, undefined, 0, or 1 to indicate the axis along which the data should be sorted! An axis of 0 means that the rows will be sorted relative to each other, whereas an axis of 1 means that the columns will be sorted relative to each other."),n===0){let r=Xt(t.index,(s,i)=>e(t.get(s,null),t.get(i,null)));return t.get(r,null)}else{let r=Xt(t.columns,(s,i)=>e(t.get(null,s),t.get(null,i)));return t.get(null,r)}}function gd(t,e,n){let r=t.copy(),s=fd().toString();return r=r.assign(s,r.index),Ht(e)&&(e=[s],n=[!0]),(He(e)||ae(e))&&(e=[e],(Kt(n)||ae(n))&&(n=[n])),E(Ii(e),"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),E(Ai(e).length===1,"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),Ht(n)&&(n=md(0,e.length).map(()=>!0)),E(Ii(n),"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),E(Ai(n).length===1,"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),E(e.length===n.length,"The arrays passed into the `sort` method must be equal in length."),e=e.map(i=>{if(E(ae(i)||He(i),"Column references can either be column names (as strings) or column indices (as whole numbers)."),ae(i)){let o=r.columns.indexOf(i);return E(o>-1,`The column "${i}" does not exist!`),o}if(He(i))return E(parseInt(i)===i,"Column indices must be whole numbers!"),E(i>=0,`The column index ${i} is out of bounds!`),E(i<r.columns.length,`The index ${i} is out of bounds!`),i}),n=n.map(i=>{if(E(ae(i)||Kt(i),"Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),ae(i)){let o=i.trim().toLowerCase();return E(o==="ascending"||o==="descending","Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),o==="ascending"}if(Kt(i))return i}),r.values=Xt(r.values,(i,o)=>{let u=0;for(;i[e[u]]===o[e[u]]&&u<e.length;)u++;let a=n[u];if(i[e[u]]===o[e[u]])return 0;if(i[e[u]]<o[e[u]])return a?-1:1;if(i[e[u]]>o[e[u]])return a?1:-1}),r.index=hd(r.get(null,s).values),r=r.dropColumns(s),r}Mi.exports=dd});var Qt=c((HS,ki)=>{function qd(t,e){return JSON.stringify(t.toObject(e))}ki.exports=qd});var Ci=c((XS,en)=>{var Zt=se(),yd=Qt();function bd(t,e,n){let r=yd(t,n),s=!1,i=!1,o,u;try{let a=e;if(e.includes("/")){let f=e.split("/");a=f[f.length-1]}let l=document.createElement("a");l.href=`data:application/json;charset=utf-8,${encodeURIComponent(r)}`,l.download=a,l.dispatchEvent(new MouseEvent("click")),s=!0}catch(a){o=a}try{let a=qr("fs"),l=qr("path");a.writeFileSync(l.resolve(e),r,"utf8"),i=!0}catch(a){u=a}if(!s&&!i)throw typeof window<"u"?new Zt(o):typeof en<"u"?new Zt(u):new Zt("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");return t}en.exports=bd});var Ri=c((QS,zi)=>{var vd=m(),Nd=v();function wd(t,e){Nd(e)?e=0:vd(e===0||e===1,"The axis parameter of the `toObject` method must be undefined, 0, or 1. An axis of 0 indicates that the returned object should be organized first by rows and then by columns. An axis of 1 indicates that the returned object should be organized first by columns and then by rows.");let n={};return e===0?t.index.forEach((r,s)=>{let i={};t.columns.forEach((o,u)=>{i[o]=t.values[s][u]}),n[r]=i}):t.columns.forEach((r,s)=>{let i={};t.index.forEach((o,u)=>{i[o]=t.values[u][s]}),n[r]=i}),n}zi.exports=wd});var ee=c((ZS,Bi)=>{var Ui=m(),Sd=p(),xd=y(),_d=q(),Td=J(),Pi=we(),Od=x();function Dd(t){if(xd(t)||_d(t))return t.transpose();Ui(Sd(t),"The `transpose` function only works on arrays, Series, and DataFrames!");let e=Od(t);if(Ui(e.length<=2,"I'm not smart enough to know how to transpose arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `transpose` function!"),e.length===1)return Pi(t);if(e.length===2){let n=Td(Pi(e));for(let r=0;r<e[0];r++)for(let s=0;s<e[1];s++)n[s][r]=t[r][s];return n}}Bi.exports=Dd});var $i=c((e2,Ji)=>{var Vi=m(),Fd=p(),Id=y(),Ad=Pe(),Ed=q(),Md=x();function Yi(t,e,n){if(Ed(n))return new t(e.values.concat(n.values));if(Fd(n)){let r=Md(n);Vi(r.length===1&&!Ad(r),"Only vectors can be appended to Series!");let s=e.copy();return n.forEach((i,o)=>{s._values.push(i),s._index.push("item"+(e.values.length+o))}),s}return Vi(!Id(n),"DataFrames cannot be appended to Series!"),Yi(e,[n])}Ji.exports=Yi});var Li=c((t2,Gi)=>{var jd=m(),kd=A();function Cd(t,e){jd(kd(e),"The parameter to the `apply` method must be a function.");let n=t.copy();return n._values=n._values.map((r,s)=>e(r,s)),n}Gi.exports=Cd});var Ki=c((n2,Wi)=>{var zd=v();function Rd(t){let e=t.copy(),n=[];return e._values=e.values.filter((r,s)=>zd(r)?!1:(n.push(e.index[s]),!0)),e._index=n,e}Wi.exports=Rd});var Xi=c((r2,Hi)=>{var Ud=g();function Pd(t,e){let n=[],r=[];e.values.forEach((i,o)=>{Ud(i)&&(r.push(i),n.push(e.index[o]))});let s=new t(r);return s.name=e.name,s.index=n,s}Hi.exports=Pd});var Zi=c((s2,Qi)=>{var Bd=C();function Vd(t,e,n){let r=e.copy(),s=Bd(r.index),i=[],o=r.values.filter((u,a)=>{let l=n(u,a,r.values);return l||i.push(r.index[a]),l});return i.forEach(u=>{s.splice(s.indexOf(u),1)}),o.length===0?(r=new t,r.name=e.name,r):(r.values=o,r.index=s,r)}Qi.exports=Vd});var to=c((i2,eo)=>{var W=m(),Yd=g(),Jd=j(),$d=v(),Gd=z();function Ld(t,e){(Jd(e)||Yd(e))&&(e=[e]);let n=Gd((e||[]).map(r=>typeof r));return W(n.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===1&&W(n[0]==="string"||n[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===2&&(W(n.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),W(n.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),$d(e)||(e=e.map(r=>{if(typeof r=="string")return W(t.index.indexOf(r)>-1,`Index "${r}" does not exist!`),r;if(typeof r=="number")return W(r>=0,`Index ${r} is out of bounds!`),W(parseInt(r)===r,"Indices must be integers!"),W(r<t.index.length,`Index ${r} is out of bounds!`),t.index[r]})),t.getSubsetByNames(e)}eo.exports=Ld});var ro=c((o2,no)=>{var De=m(),Wd=p(),Kd=v(),Hd=Se(),Xd=M(),Qd=x();function Zd(t,e){let n=t.shape;Kd(e)&&(e=Xd(0,n[0])),De(Wd(e),"The `indices` array must be 1-dimensional array of whole numbers."),De(Qd(e).length===1,"The `indices` array must be a 1-dimensional array of whole numbers."),De(e.length>0,"The `indices` array must contain at least one index."),e.forEach(s=>{De(Hd(s),"The `indices` array must be a 1-dimensional array of whole numbers."),De(s<t.index.length,`The row index ${s} is out of bounds.`)});let r=e.map(s=>t.index[s]);return t.getSubsetByNames(r)}no.exports=Zd});var io=c((u2,so)=>{var Fe=m(),ep=p(),tp=j(),np=v(),rp=x();function sp(t,e,n){np(n)&&(n=e.index),Fe(ep(n),"The `indices` array must be a 1-dimensional array of strings."),Fe(rp(n).length===1,"The `indices` array must be a 1-dimensional array of strings."),Fe(n.length>0,"The `indices` array must contain at least one index name."),n.forEach(i=>{Fe(tp(i),"The `indices` array must contain only strings."),Fe(e.index.indexOf(i)>-1,`The name "${i}" does not exist in the index.`)});let r=n.map(i=>e.values[e.index.indexOf(i)]);if(r.length===1)return r[0];let s=new t(r);return s.index=n,s.name=e.name,s}so.exports=sp});var ao=c((a2,uo)=>{var ip=C(),oo=M();function op(t){let e=t.copy(),n=typeof window>"u"?20:10;if(e.index.length>n){e=e.get(oo(0,n/2).concat(oo(e.index.length-n/2,e.index.length)));let s=ip(e.index);s.splice(parseInt(s.length/2),0,"..."),e.values.push("..."),e.index.push("..."),e=e.get(s)}let r={};return e.values.forEach((s,i)=>{let o={};o[e.name]=s,r[e.index[i]]=o}),console.table(r),console.log("Shape:",t.shape,`
`),t}uo.exports=op});var lo=c((c2,co)=>{var up=Ke();function ap(t){let e=t.copy();return e.get(up(e.index))}co.exports=ap});var ho=c((l2,fo)=>{var cp=m(),lp=A(),fp=v(),hp=$(),mp=ee();function dp(t,e,n){n=n||((a,l)=>a<l?-1:1),cp(fp(n)||lp(n),"You must pass undefined, null, or a comparison function as the second argument to the `sort` method!");let r=mp([e.values,e.index]),s=hp(r,(a,l)=>n(a[0],l[0])),i=[],o=[];s.forEach(a=>{i.push(a[0]),o.push(a[1])});let u=new t;return u._values=i,u._index=o,u.name=e.name,u}fo.exports=dp});var go=c((f2,po)=>{var pp=$(),mo=ee();function gp(t,e){let n=mo([e.values,e.index]);n=mo(pp(n,(s,i)=>{if(s[1]===i[1])return 0;if(s[1]<i[1])return-1;if(s[1]>i[1])return 1}));let r=new t(n[0]);return r.index=n[1],r.name=e.name,r}po.exports=gp});var yo=c((h2,qo)=>{function qp(t){let e={};return e[t.name]={},t.index.forEach((n,r)=>{e[t.name][n]=t.values[r]}),e}qo.exports=qp});var So=c((m2,wo)=>{var V=m(),Xe=C(),tn=p(),yp=j(),bp=v(),bo=Le(),vo=M(),Qe=we(),vp=$i(),Np=Li(),wp=Ki(),Sp=Xi(),xp=Zi(),_p=to(),Tp=ro(),Op=io(),Dp=ao(),Fp=lo(),Ip=ho(),Ap=go(),Ep=yo(),Ie=x(),Mp=ee(),No=Symbol.for("@jrc03c/js-math-tools/series");wo.exports=function(t){class e{static[Symbol.hasInstance](r){try{return!!r._symbol&&r._symbol===No}catch{return!1}}constructor(r){let s=this;if(s.name="data",Object.defineProperty(s,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:No}),Object.defineProperty(s,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(s,"values",{configurable:!0,enumerable:!0,get(){return s._values},set(i){V(tn(i),"The new values must be a 1-dimensional array!");let o=Ie(i);V(o.length===1,"The new array of values must be 1-dimensional!"),o[0]<s._index.length?s._index=s._index.slice(0,o[0]):o[0]>s._index.length&&(s._index=s._index.concat(vo(s._index.length,o[0]).map(u=>"item"+bo(u,(i.length-1).toString().length)))),s._values=i}}),Object.defineProperty(s,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(s,"index",{configurable:!0,enumerable:!0,get(){return s._index},set(i){V(tn(i),"The new index must be a 1-dimensional array of strings!"),V(i.length===s.shape[0],"The new index must be the same length as the old index!"),V(Ie(i).length===1,"The new index must be a 1-dimensional array of strings!"),i.forEach(o=>{V(yp(o),"All of the row names must be strings!")}),s._index=i}}),r){if(r instanceof e)s.name=r.name,s.values=Xe(r.values),s.index=Xe(r.index);else if(tn(r)){let i=Ie(r);V(i.length===1,"When passing an array into the constructor of a Series, the array must be 1-dimensional!"),s.values=r}else if(r instanceof Object){let i=Object.keys(r);V(i.length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");let o=i[0],u=r[o];V(Ie(u).length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!"),s.name=o,s.values=u.slice()}}}get shape(){return Ie(this.values)}get length(){return this.shape[0]}get isEmpty(){return this.values.filter(s=>!bp(s)).length===0}clear(){let s=this.copy();return s.values.forEach((i,o)=>{s.values[o]=void 0}),s}get(r){return _p(this,r)}getSubsetByNames(r){return Op(e,this,r)}getSubsetByIndices(r){return Tp(this,r)}loc(r){return this.getSubsetByNames(r)}iloc(r){return this.getSubsetByIndices(r)}reverse(){let r=this,s=new e(Qe(r.values));return s.index=Qe(r.index),s.name=r.name,s}resetIndex(){let r=this,s=r.copy();return s.index=vo(0,r.shape[0]).map(i=>"item"+bo(i,(s.index.length-1).toString().length)),s}copy(){let r=this,s=new e;return s._values=Xe(r.values),s._index=Xe(r.index),s.name=r.name,s}append(r){return vp(e,this,r)}apply(r){return Np(this,r)}concat(r){return this.append(r)}dropMissing(r,s){return wp(this,r,s)}dropNaN(){return Sp(e,this)}toObject(){return Ep(this)}print(){return Dp(this)}shuffle(){return Fp(this)}sort(r){return Ip(e,this,r)}sortByIndex(){return Ap(e,this)}filter(r){return xp(e,this,r)}toDataFrame(){let r=this,s=new t(Mp([r.values]));return s.columns=[r.name],s.index=r.index,s}transpose(){let s=this.copy();return s.values=Qe(s.values),s.index=Qe(s.index),s}getDummies(){return this.toDataFrame().getDummies()}oneHotEncode(){return this.getDummies()}}return e}});var Ee=c((d2,Fo)=>{var U=m(),nn=C(),xo=Ue(),jp=cs(),kp=ds(),Cp=ys(),zp=vs(),Rp=Os(),Up=Is(),Pp=js(),Bp=Rs(),Vp=Bs(),_o=Ls(),Yp=ti(),Jp=oi(),$p=ai(),Gp=fi(),Lp=Di(),Wp=ji(),Kp=Ci(),Hp=Qt(),Xp=Ri(),Qp=T(),Ae=p(),Zp=Q(),To=v(),rn=Le(),eg=J(),sn=M(),ce=x(),Oo=ee(),Do=Symbol.for("@jrc03c/js-math-tools/dataframe");function Ze(t){let e="abcdefghijklmnopqrstuvwxyz1234567890",n="";for(let r=0;r<t;r++)n+=e[parseInt(Math.random()*e.length)];return n}var D=class{static[Symbol.hasInstance](e){try{return!!e._symbol&&e._symbol===Do}catch{return!1}}constructor(e){let n=this;if(Object.defineProperty(n,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:Do}),Object.defineProperty(n,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(n,"values",{configurable:!0,enumerable:!0,get(){return n._values.length===0||!To(n._values[0])&&n._values[0].length===0?[[]]:n._values},set(r){U(Ae(r),"The new values must be a 2-dimensional array!");let s=ce(r);U(s.length===2,"The new array of values must be 2-dimensional!"),s[0]<n._index.length?n._index=n._index.slice(0,s[0]):s[0]>n._index.length&&(n._index=n._index.concat(sn(n._index.length,s[0]).map(i=>"row"+rn(i,(s[0]-1).toString().length)))),s[1]<n._columns.length?n._columns=n._columns.slice(0,s[1]):s[1]>n._columns.length&&(n._columns=n._columns.concat(sn(n._columns.length,s[1]).map(i=>"col"+rn(i,(s[1]-1).toString().length)))),n._values=r}}),Object.defineProperty(n,"_columns",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(n,"columns",{configurable:!0,enumerable:!0,get(){return n._columns},set(r){U(Ae(r),"The new columns list must be a 1-dimensional array of strings!"),U(n.isEmpty||r.length===n.shape[1],"The new columns list must be the same length as the old columns list!"),U(ce(r).length===1,"The new columns list must be a 1-dimensional array of strings!"),r=r.map(i=>(typeof i!="string"&&(i=JSON.stringify(i)||i.toString()),i.trim().length===0?"untitled_"+Ze(8):i.trim()));let s=(()=>{let i=xo(r),o={};return i.forEach(u=>{o[u.item]=u.count}),o})();r=r.map(i=>s[i]>1?i+"_"+Ze(8):i),n._columns=r}}),Object.defineProperty(n,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(n,"index",{configurable:!0,enumerable:!0,get(){return n._index},set(r){U(Ae(r),"The new index must be a 1-dimensional array of strings!"),U(n.isEmpty||r.length===n.shape[0],"The new index must be the same length as the old index!"),U(ce(r).length===1,"The new index must be a 1-dimensional array of strings!"),r=r.map(i=>(typeof i!="string"&&(i=JSON.stringify(i)||i.toString()),i.trim().length===0?"untitled_"+Ze(8):i.trim()));let s=(()=>{let i=xo(r),o={};return i.forEach(u=>{o[u.item]=u.count}),o})();r=r.map(i=>s[i]>1?i+"_"+Ze(8):i),n._index=r}}),U(To(e)||Zp(e)||Ae(e),"The `data` passed into the constructor of a DataFrame must be either (1) an object where the key-value pairs are (respectively) column names and 1-dimensional arrays of values, or (2) a 2-dimensional array of values."),e)if(e instanceof D)n.values=nn(e.values),n.columns=nn(e.columns),n.index=nn(e.index);else if(Ae(e)){let r=ce(e);U(r.length===2,"The `data` array passed into the constructor of a DataFrame must be 2-dimensional!"),n.values=e}else{n._columns=Object.keys(e);let r=[];n._columns.forEach(i=>{let o=e[i];r.push(o)}),n._values=Oo(r);let s=ce(n.values);n._index=sn(0,s[0]).map(i=>"row"+rn(i,(s[0]-1).toString().length))}}get shape(){return ce(this.values)}get length(){return this.shape[0]}get width(){return this.shape[1]}get rows(){return this.index}set rows(e){let n=this;n.index=e}get isEmpty(){return Qp(this.values).length===0}clear(){let e=this,n=new D(eg(e.shape));return n.columns=e.columns.slice(),n.index=e.index.slice(),n}get(e,n){let r=this;if(arguments.length===0)return r;if(arguments.length===1)try{return r.get(null,e)}catch{return r.get(e,null)}return Vp(r,e,n)}getSubsetByNames(e,n){return Jp(D,K,this,e,n)}getSubsetByIndices(e,n){return Yp(this,e,n)}getDummies(e){return _o(D,this,e)}oneHotEncode(e){return _o(D,this,e)}transpose(){let e=this,n=new D(Oo(e.values));return n.columns=e.index.slice(),n.index=e.columns.slice(),n}get T(){return this.transpose()}resetIndex(e){return Gp(this,e)}copy(){return zp(D,this)}assign(e,n){return Cp(D,K,this,e,n)}apply(e,n){return kp(D,K,this,e,n)}dropMissing(e,n,r){return Up(D,K,this,e,n,r)}dropNaN(e,n,r){return Pp(D,this,e,n,r)}drop(e,n){return Rp(D,K,this,e,n)}dropColumns(e){return this.drop(null,e)}dropRows(e){return this.drop(e,null)}toObject(e){return Xp(this,e)}toJSONString(e){return Hp(this,e)}saveAsJSON(e,n){return Kp(this,e,n)}print(){return $p(D,K,this)}sort(e,n){return Wp(this,e,n)}sortByIndex(){return this.sort()}filter(e,n){return Bp(D,K,this,e,n)}shuffle(e){return Lp(this,e)}append(e,n){return jp(this,e,n)}concat(e,n){return this.append(e,n)}join(e,n){return this.append(e,n)}toString(){let e=this;return JSON.stringify(e)}},K=So()(D);Fo.exports={DataFrame:D,Series:K}});var le=c((p2,Ao)=>{var tg=m(),ng=T(),rg=p(),sg=y(),ig=q();function Io(t){if(sg(t)||ig(t))return Io(t.values);tg(rg(t),"The `max` function only works on arrays, Series, and DataFrames!");try{return Math.max(...ng(t))}catch{return NaN}}Ao.exports=Io});var N=c((g2,Co)=>{var{DataFrame:Eo,Series:Mo}=Ee(),jo=m(),Me=p(),on=y(),ko=R(),og=A(),un=q(),ug=le(),ag=M(),et=x();function cg(t){return Me(t)||un(t)||on(t)}function lg(t){return jo(og(t),"You must pass a function into the `vectorize` function!"),function e(){let n,r,s=[],i=[],o=Object.keys(arguments).filter(u=>{let a=arguments[u];return Me(a)?!0:un(a)?(n=!0,s.push(a),!0):on(a)?(r=!0,i.push(a),!0):!1}).map(u=>arguments[u]);if(o.slice(0,-1).forEach((u,a)=>{jo(ko(Me(u)?et(u):u.shape,Me(o[a+1])?et(o[a+1]):o[a+1].shape),`When passing multiple arrays into the \`${t.name}\` function, all of the arrays must have the same shape!`)}),o.length>0){let u=ug(o.map(l=>l.length?l.length:l.values.length)),a=ag(0,u).map(l=>{let f=Object.keys(arguments).map(h=>{if(cg(arguments[h])){if(Me(arguments[h]))return arguments[h][l];if(un(arguments[h]))return arguments[h].values[l];if(on(arguments[h]))return arguments[h].values[l]}else return arguments[h]});return e(...f)});if(r)try{if(i.length===1&&ko(et(i[0]),et(a))){let l=new Eo(a);return l.index=i[0].index.slice(),l.columns=i[0].columns.slice(),l}else return new Eo(a)}catch{return a}if(n)try{if(s.length===1&&s[0].length===a.length){let l=new Mo(a);return l.name=s[0].name,l.index=s[0].index.slice(),l}else return new Mo(a)}catch{return a}return a}else return t(...arguments)}}Co.exports=lg});var tt=c((q2,zo)=>{var fg=g(),hg=N();function mg(t){try{return fg(t)?Math.abs(t):NaN}catch{return NaN}}zo.exports=hg(mg)});var nt=c((y2,Ro)=>{var dg=g(),pg=N();function gg(){try{let t=0,e=Object.values(arguments);for(let n=0;n<e.length;n++){if(!dg(e[n]))return NaN;t+=e[n]}return t}catch{return NaN}}Ro.exports=pg(gg)});var rt=c((b2,Uo)=>{var qg=N();function yg(t,e){try{return e(t)}catch{return NaN}}Uo.exports=qg(yg)});var Bo=c((v2,Po)=>{var bg=g(),vg=N();function Ng(t){try{return bg(t)?Math.acos(t):NaN}catch{return NaN}}Po.exports=vg(Ng)});var Yo=c((N2,Vo)=>{var wg=g(),Sg=N();function xg(t){try{return wg(t)?Math.asin(t):NaN}catch{return NaN}}Vo.exports=Sg(xg)});var $o=c((w2,Jo)=>{var _g=g(),Tg=N();function Og(t){try{return _g(t)?Math.atan(t):NaN}catch{return NaN}}Jo.exports=Tg(Og)});var Lo=c((S2,Go)=>{var Dg=m(),Fg=be(),Ig=p(),Ag=y(),Eg=q(),Mg=le();function an(t){if(Ag(t)){let e=an(t.values);return[t.index[e[0]],t.columns[e[1]]]}if(Eg(t)){let e=an(t.values);return[t.index[e]]}Dg(Ig(t),"The `argmax` function only works on arrays, Series, and DataFrames!");try{let e=Fg(t,Mg(t));return e?e.length===0?void 0:e.length===1?e[0]:e:void 0}catch{return}}Go.exports=an});var st=c((x2,Ko)=>{var jg=m(),kg=T(),Cg=p(),zg=y(),Rg=q();function Wo(t){if(zg(t)||Rg(t))return Wo(t.values);jg(Cg(t),"The `min` function only works on arrays, Series, and DataFrames!");try{return Math.min(...kg(t))}catch{return NaN}}Ko.exports=Wo});var Xo=c((_2,Ho)=>{var Ug=m(),Pg=be(),Bg=p(),Vg=y(),Yg=q(),Jg=st();function cn(t){if(Vg(t)){let e=cn(t.values);return[t.index[e[0]],t.columns[e[1]]]}if(Yg(t)){let e=cn(t.values);return[t.index[e]]}Ug(Bg(t),"The `argmin` function only works on arrays, Series, and DataFrames!");try{let e=Pg(t,Jg(t));return e?e.length===0?void 0:e.length===1?e[0]:e:void 0}catch{return}}Ho.exports=cn});var Zo=c((T2,Qo)=>{var $g=g(),Gg=N();function Lg(t){try{return $g(t)?Math.ceil(t):NaN}catch{return NaN}}Qo.exports=Gg(Lg)});var nu=c((O2,tu)=>{var Wg=tt(),eu=g(),Kg=v(),Hg=N();function Xg(t,e){try{if(!eu(t))return NaN;if(Kg(e))e=1e-10;else if(!eu(e))return NaN;return Wg(t)<e?0:t}catch{return NaN}}tu.exports=Hg(Xg)});var su=c((D2,ru)=>{var ln=g(),Qg=N();function Zg(t,e,n){try{return ln(t)?ln(e)?ln(n)?t<e?e:t>n?n:t:NaN:NaN:NaN}catch{return NaN}}ru.exports=Qg(Zg)});var ou=c((F2,iu)=>{var fn=m(),eq=T(),tq=p(),nq=y(),rq=g(),sq=q();function hn(t,e){if(nq(t)||sq(t))return hn(t.values,e);if(fn(tq(t),"The `combinations` function only works on arrays, Series, and DataFrames!"),fn(rq(e),"`r` must be a whole number!"),t=eq(t),e>t.length)return[t];if(e<=0)return[[]];if(fn(e===parseInt(e),"`r` must be a whole number!"),t.length<2)return t;let n=[];return t.forEach((r,s)=>{let i=t.slice(s+1);if(i.length<e-1)return;hn(i,e-1).forEach(u=>{n.push([r].concat(u))})}),n}iu.exports=hn});var it=c((I2,au)=>{var iq=m(),oq=T(),uq=p(),aq=y(),cq=q();function uu(t){if(aq(t)||cq(t))return uu(t.values);iq(uq(t),"The `mean` function only works on arrays, Series, and DataFrames!");try{let e=oq(t),n=0;return e.forEach(r=>{n+=r}),n/e.length}catch{return NaN}}au.exports=uu});var dn=c((A2,du)=>{var cu=m(),lu=p(),ot=g(),fu=q(),hu=it(),mu=x();function mn(t,e){if(fu(t))return mn(t.values,e);if(fu(e))return mn(t,e.values);cu(lu(t)&&lu(e)&&mu(t).length===1&&mu(e).length===1,"The `covariance` function only works on 1-dimensional arrays and Series!"),cu(t.length===e.length,"The two arrays or Series passed into the `covariance` function must have the same length!");try{let n=hu(t),r=hu(e);if(!ot(n)||!ot(r))return NaN;let s=Math.max(t.length,e.length),i=0;for(let o=0;o<s;o++){if(!ot(t[o]))return NaN;if(!ot(e[o]))return NaN;i+=(t[o]-n)*(e[o]-r)}return i/t.length}catch{return NaN}}du.exports=mn});var ut=c((E2,pu)=>{var lq=g(),fq=N();function hq(t){try{return lq(t)?Math.sqrt(t):NaN}catch{return NaN}}pu.exports=fq(hq)});var pn=c((M2,qu)=>{var mq=m(),dq=T(),pq=p(),gq=y(),qq=g(),yq=q(),bq=it();function gu(t){if(gq(t)||yq(t))return gu(t.values);mq(pq(t),"The `variance` function only works on arrays, Series, and DataFrames!");try{let e=dq(t),n=bq(e),r=0;for(let s=0;s<e.length;s++){if(!qq(e[s]))return NaN;r+=(e[s]-n)*(e[s]-n)}return r/e.length}catch{return NaN}}qu.exports=gu});var at=c((j2,bu)=>{var vq=m(),Nq=p(),wq=y(),Sq=q(),xq=ut(),_q=pn();function yu(t){if(wq(t)||Sq(t))return yu(t.values);vq(Nq(t),"The `std` function only works on arrays, Series, and DataFrames!");try{return xq(_q(t))}catch{return NaN}}bu.exports=yu});var Tu=c((k2,_u)=>{var vu=m(),Tq=dn(),Nu=p(),wu=q(),Su=x(),xu=at();function gn(t,e){if(wu(t))return gn(t.values,e);if(wu(e))return gn(t,e.values);vu(Nu(t)&&Nu(e)&&Su(t).length===1&&Su(e).length===1,"The `correl` function only works on 1-dimensional arrays and Series!"),vu(t.length===e.length,"The two arrays or Series passed into the `correl` function must have the same length!");try{return Tq(t,e)/(xu(t)*xu(e))}catch{return NaN}}_u.exports=gn});var Du=c((C2,Ou)=>{var Oq=g(),Dq=N();function Fq(t){try{return Oq(t)?Math.cos(t):NaN}catch{return NaN}}Ou.exports=Dq(Fq)});var ju=c((z2,Mu)=>{var Iq=m(),Fu=p(),Iu=y(),Aq=R(),Au=q(),Eu=z();function qn(t,e){if(Iu(t)||Au(t))return qn(t.values,e);if(Iu(e)||Au(e))return qn(t,e.values);Iq(Fu(t)&&Fu(e),"The `diff` function only works on arrays, Series, and DataFrames!");let n=Eu(t),r=Eu(e),s=[];return n.forEach(i=>{r.findIndex(o=>Aq(o,i))<0&&s.push(i)}),s}Mu.exports=qn});var ct=c((R2,Cu)=>{var ku=g(),Eq=N();function Mq(t,e){try{return ku(t)?ku(e)?Math.pow(t,e):NaN:NaN}catch{return NaN}}Cu.exports=Eq(Mq)});var yn=c((U2,zu)=>{var jq=g(),kq=N();function Cq(){try{let t=Object.values(arguments);if(t.length===0)return NaN;let e=1;for(let n=0;n<t.length;n++){if(!jq(t[n]))return NaN;e*=t[n]}return e}catch{return NaN}}zu.exports=kq(Cq)});var fe=c((P2,Ru)=>{var zq=yn();function Rq(){return zq(...arguments)}Ru.exports=Rq});var bn=c((B2,Uu)=>{var Uq=nt(),Pq=fe();function Bq(t,e){return Uq(t,Pq(e,-1))}Uu.exports=Bq});var lt=c((V2,Bu)=>{var Vq=m(),Yq=T(),Jq=p(),$q=y(),Gq=q();function Pu(t){if($q(t)||Gq(t))return Pu(t.values);Vq(Jq(t),"The `sum` function only works on arrays, Series, and DataFrames!");try{return t.length===0?NaN:Yq(t).reduce((e,n)=>e+n,0)}catch{return NaN}}Bu.exports=Pu});var Wu=c((Y2,Lu)=>{var Lq=tt(),Wq=m(),Vu=p(),Yu=y(),Kq=R(),Ju=g(),$u=q(),Hq=ct(),Gu=x(),Xq=ut(),Qq=bn(),Zq=lt();function vn(t,e){if(Ju(t)&&Ju(e))return Lq(t-e);if(Yu(t)||$u(t))return vn(t.values,e);if(Yu(e)||$u(e))return vn(t,e.values);Vu(t)&&Vu(e)&&Wq(Kq(Gu(t),Gu(e)),"If passing two arrays, Series, or DataFrames into the `distance` function, then those objects must have the same shape!");try{return Xq(Zq(Hq(Qq(t,e),2)))}catch{return NaN}}Lu.exports=vn});var Hu=c((J2,Ku)=>{var ey=ct(),ty=fe();function ny(t,e){return ty(t,ey(e,-1))}Ku.exports=ny});var wn=c(($2,na)=>{var{DataFrame:Xu,Series:Qu}=Ee(),ft=m(),Zu=T(),ea=p(),Nn=y(),ry=g(),ht=q(),sy=fe(),mt=x(),iy=lt(),ta=ee();function H(t,e){if(Nn(t)){let s=H(t.values,e);if(mt(s).length===1){let i=new Qu(s);return i.name=ht(e)?e.name:i.name,i.index=t.index.slice(),i}else{let i=new Xu(s);return i.index=t.index.slice(),Nn(e)&&(i.columns=e.columns.slice()),i}}if(Nn(e)){let s=H(t,e.values);if(mt(s).length===1){let i=new Qu(s);return i.name=ht(t)?t.name:i.name,i.index=e.columns.slice(),i}else{let i=new Xu(s);return i.columns=e.columns.slice(),i}}if(ht(t))return H(t.values,e);if(ht(e))return H(t,e.values);ft(ea(t)&&ea(e),"The `dot` function only works on arrays, Series, and DataFrames!"),Zu(t).concat(Zu(e)).forEach(s=>{ft(ry(s),"One of the arrays you passed into the `dot` function contains non-numerical values!")});let n=mt(t),r=mt(e);if(ft(n.length<=2&&r.length<=2,"I'm not smart enough to know how to get the dot-product of arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `dot` function!"),ft(n[n.length-1]===r[0],`There's a dimension misalignment in the two arrays you passed into the \`dot\` function. (${n[n.length-1]} !== ${r[0]})`),n.length===1&&r.length===1)return iy(sy(t,e));if(n.length===1&&r.length===2)return ta(e).map(s=>H(t,s));if(n.length===2&&r.length===1)return t.map(s=>H(s,e));if(n.length===2&&r.length===2){let s=ta(e),i=[];for(let o=0;o<t.length;o++){let u=[];for(let a=0;a<s.length;a++)u.push(H(t[o],s[a]));i.push(u)}return i}}na.exports=H});var Sn=c((G2,sa)=>{var oy=m(),uy=p(),ay=y(),cy=q(),ly=v();function ra(t){if(ay(t)||cy(t))return t.dropMissing(...Object.values(arguments).slice(1));oy(uy(t),"The `dropMissing` function only works on arrays, Series, and DataFrames!");let e=[];return t.forEach(n=>{try{return e.push(ra(n))}catch{ly(n)||e.push(n)}}),e}sa.exports=ra});var ha=c((L2,fa)=>{var ia=m(),oa=p(),ua=y(),fy=R(),aa=q(),ca=v(),la=x();function dt(t,e){if(ua(t)||aa(t))return dt(t.values,e);if(ua(e)||aa(e))return dt(t,e.values);ia(oa(t)&&oa(e),"The `dropMissingPairwise` function only works on arrays, Series, and DataFrames!"),ia(fy(la(t),la(e)),"The two arrays, Series, and/or DataFrames passed into the `dropMissingPairwise` function must have the same shape!");let n=[],r=[];for(let s=0;s<t.length;s++)try{let[i,o]=dt(t[s],e[s]);n.push(i),r.push(o)}catch{!ca(t[s])&&!ca(e[s])&&(n.push(t[s]),r.push(e[s]))}return[n,r]}fa.exports=dt});var va=c((W2,ba)=>{var ma=m(),da=p(),pa=y(),hy=R(),ga=g(),qa=q(),ya=x();function pt(t,e){if(pa(t)||qa(t))return pt(t.values,e);if(pa(e)||qa(e))return pt(t,e.values);ma(da(t)&&da(e),"The `dropNaNPairwise` only works on arrays, Series, and DataFrames!"),ma(hy(ya(t),ya(e)),"The two arrays, Series, and/or DataFrames passed into the `dropNaNPairwise` must have the same shape!");let n=[],r=[];for(let s=0;s<t.length;s++)try{let[i,o]=pt(t[s],e[s]);n.push(i),r.push(o)}catch{ga(t[s])&&ga(e[s])&&(n.push(t[s]),r.push(e[s]))}return[n,r]}ba.exports=pt});var wa=c((K2,Na)=>{var my=Sn();function dy(t){return my(t)}Na.exports=dy});var xa=c((H2,Sa)=>{var py=g(),gy=N();function qy(t){try{return py(t)?Math.exp(t):NaN}catch{return NaN}}Sa.exports=gy(qy)});var Oa=c((X2,Ta)=>{var yy=N();function _a(t){try{return t!==parseInt(t)?NaN:t<=1?1:t*_a(t-1)}catch{return NaN}}Ta.exports=yy(_a)});var Aa=c((Q2,Ia)=>{var by=m(),vy=T(),Da=p(),Ny=y(),wy=A(),Fa=Q(),Sy=q();function xn(t,e){if(Ny(t))return xn(vy(t.values),e);if(Sy(t))return xn(t.values,e);if(by(Fa(t)||Da(t),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `find` function!"),!wy(e)){let s=e;e=i=>i===s}function n(s,i,o){if(o=o||[],o.indexOf(s)>-1)return null;if(Fa(s)){o.push(s);let u=Object.keys(s);for(let a=0;a<u.length;a++){let l=u[a],f=s[l];if(i(f))return f;let h=n(f,i,o);if(h)return h}}else if(Da(s)){o.push(s);for(let u=0;u<s.length;u++){let a=s[u];if(i(a))return a;let l=n(a,i,o);if(l)return l}}else if(i(s))return s;return null}function r(s){try{return e(s)}catch{return!1}}return n(t,r)}Ia.exports=xn});var ka=c((Z2,ja)=>{var xy=m(),_y=T(),Ea=p(),Ty=y(),Oy=A(),Ma=Q(),Dy=q();function _n(t,e){if(Ty(t))return _n(_y(t.values),e);if(Dy(t))return _n(t.values,e);if(xy(Ma(t)||Ea(t),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `findAll` function!"),!Oy(e)){let i=e;e=o=>o===i}function n(i,o,u){if(u=u||[],u.indexOf(i)>-1)return null;if(Ma(i)){u.push(i);let a=Object.keys(i),l=[];for(let f=0;f<a.length;f++){let h=a[f],d=i[h],b=!1;o(d)&&(l.push(d),b=!0);let S=n(d,o,u);S&&S.length>0&&S.slice(b?1:0).forEach(O=>l.push(O))}return l}else if(Ea(i)){u.push(i);let a=[];for(let l=0;l<i.length;l++){let f=i[l],h=!1;o(f)&&(a.push(f),h=!0);let d=n(f,o,u);d&&d.length>0&&d.slice(h?1:0).forEach(b=>a.push(b))}return a}else if(o(i))return[i];return null}function r(i){try{return e(i)}catch{return!1}}let s=n(t,r);return s&&s.length>0?s:null}ja.exports=_n});var za=c((ex,Ca)=>{var Fy=g(),Iy=N();function Ay(t){try{if(t==="Infinity")return 1/0;if(t==="-Infinity")return-1/0;let e=JSON.parse(t);return Fy(e)?e:NaN}catch{return NaN}}Ca.exports=Iy(Ay)});var Ua=c((tx,Ra)=>{var Ey=g(),My=N();function jy(t){try{return Ey(t)?Math.floor(t):NaN}catch{return NaN}}Ra.exports=My(jy)});var Tn=c((nx,Pa)=>{var ky=g(),Cy=Te(),zy=We();function Ry(t){ky(t)&&(t=[t]);let e=[],n=Cy(t);for(let r=0;r<n;r++)e.push(0);return zy(e,t)}Pa.exports=Ry});var Va=c((rx,Ba)=>{var gt=m(),Uy=g(),Py=v(),By=Tn();function Vy(t){gt(!Py(t),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),gt(Uy(t),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),gt(parseInt(t)===t,"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),gt(t>0,"You must pass an integer greater than 0 (representing the size) into the `identity` function!");let e=By([t,t]);for(let n=0;n<t;n++)e[n][n]=1;return e}Ba.exports=Vy});var Ja=c((sx,Ya)=>{var Yy=g(),Jy=N();function $y(t){try{let e=JSON.parse(t);return Yy(e)?parseInt(e):NaN}catch{return NaN}}Ya.exports=Jy($y)});var Ga=c((ix,$a)=>{var Gy=m(),Ly=p(),Wy=y(),Ky=R(),Hy=q(),On=z();function Xy(){let t=Object.values(arguments).map(n=>Wy(n)||Hy(n)?On(n.values):(Gy(Ly(n),"The `intersect` function only works on arrays, Series, and DataFrames!"),On(n)));return On(t).filter(n=>t.every(r=>r.findIndex(s=>Ky(s,n))>-1))}$a.exports=Xy});var Ha=c((ox,Ka)=>{var La=nt(),X=m(),Qy=wn(),Zy=T(),e1=p(),t1=y(),Dn=g(),Wa=fe(),n1=x();function qt(t){if(t1(t)){let n=t.copy();return n.values=qt(n.values),n}X(e1(t),"The `inverse` function only works on square 2-dimensional arrays or DataFrames!"),Zy(t).forEach(n=>X(Dn(n),"The array passed into the `inverse` function must contain only numbers!"));let e=n1(t);if(X(e.length===2,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),X(e[0]===e[1],"The array passed into the `inverse` function must be exactly two-dimensional and square!"),X(e[0]>=0,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),e[0]===0)return t;if(e[0]===1)return X(t[0][0]!==0,"This matrix cannot be inverted!"),1/t[0][0];if(e[0]===2){let n=t[0][0],r=t[0][1],s=t[1][0],i=t[1][1],o=n*i-r*s;X(o!==0,"This matrix cannot be inverted!");let u=[[i,-r],[-s,n]];return Wa(u,1/o)}else if(e[0]>1){let n=(r,s)=>Dn(r)||Dn(s)?Wa(r,s):Qy(r,s);for(let r=1;r<e[0]-1;r++)try{let s=t.slice(0,r).map(O=>O.slice(0,r)),i=t.slice(0,r).map(O=>O.slice(r,e[0])),o=t.slice(r,e[0]).map(O=>O.slice(0,r)),u=t.slice(r,e[0]).map(O=>O.slice(r,e[0])),a=qt(s),l=qt(La(u,n(-1,n(n(o,a),i)))),f=La(a,n(n(n(n(a,i),l),o),a)),h=n(-1,n(n(a,i),l)),d=n(-1,n(n(l,o),a)),b=l;return f.map((O,B)=>O.concat(h[B])).concat(d.map((O,B)=>O.concat(b[B])))}catch{}X(!1,"This matrix cannot be inverted!")}}Ka.exports=qt});var Qa=c((ux,Xa)=>{var Fn=g(),r1=N();function s1(t,e,n){try{return Fn(t)?Fn(e)?Fn(n)?n*(e-t)+t:NaN:NaN:NaN}catch{return NaN}}Xa.exports=r1(s1)});var tc=c((ax,ec)=>{var Za=g(),i1=v(),o1=N();function u1(t,e){try{return e=i1(e)?Math.E:e,Za(t)?Za(e)?Math.log(t)/Math.log(e):NaN:NaN}catch{return NaN}}ec.exports=o1(u1)});var sc=c((cx,rc)=>{var a1=m(),c1=T(),l1=p(),f1=y(),h1=q(),m1=$();function nc(t){if(f1(t)||h1(t))return nc(t.values);a1(l1(t),"The `median` function only works on arrays, Series, and DataFrames!");try{let e=m1(c1(t));return e.length===0?NaN:e.length%2===0?(e[e.length/2-1]+e[e.length/2])/2:e[parseInt(e.length/2)]}catch{return NaN}}rc.exports=nc});var uc=c((lx,oc)=>{var ic=g(),d1=N();function p1(t,e){try{return ic(t)?ic(e)?t%e:NaN:NaN}catch{return NaN}}oc.exports=d1(p1)});var fc=c((fx,lc)=>{var g1=m(),q1=Ue(),y1=T(),b1=p(),v1=y(),N1=q(),w1=z(),ac=$();function cc(t){if(v1(t)||N1(t))return cc(t.values);g1(b1(t),"The `mode` function only works on arrays, Series, and DataFrames!");try{if(t.length===0)return NaN;let e=y1(t);if(e.length===0)return NaN;let n={},r=w1(e);r.forEach(u=>{n[u]=q1(e,u)});let s=ac(r,(u,a)=>n[a]-n[u]),i=s[0];return ac(s.filter(u=>n[u]===n[i]))}catch{return NaN}}lc.exports=cc});var pc=c((hx,dc)=>{var{random:hc}=ue(),S1=rt(),x1=v(),_1=J();function mc(){let t=hc(),e=hc();return Math.sqrt(-2*Math.log(t))*Math.cos(2*Math.PI*e)}function T1(t){return x1(t)?mc():S1(_1(t),mc)}dc.exports=T1});var qc=c((mx,gc)=>{var O1=rt(),D1=J();function F1(t){return O1(D1(t),()=>1)}gc.exports=F1});var bc=c((dx,yc)=>{var In=m(),I1=T(),A1=p(),E1=y(),M1=g(),j1=q(),k1=v();function yt(t,e){if(E1(t)||j1(t))return yt(t.values,e);if(In(A1(t),"The `permutations` function only works on arrays, Series, and DataFrames!"),k1(e)&&(e=t.length),In(M1(e),"`r` must be a whole number!"),t=I1(t),e>t.length)return yt(t);if(e<=0)return[[]];if(In(e===parseInt(e),"`r` must be a whole number!"),t.length<2)return t;let n=[];return t.forEach((r,s)=>{let i=t.slice(0,s),o=t.slice(s+1),u=i.concat(o);yt(u,e-1).forEach(l=>{n.push([r].concat(l))})}),n}yc.exports=yt});var Nc=c((px,vc)=>{var{DataFrame:C1,Series:z1}=Ee(),R1=p(),U1=y(),P1=Ne(),B1=q(),V1=x();function Y1(){Object.keys(arguments).forEach(t=>{let e=arguments[t];if(R1(e))if(P1(e))console.log(e);else{let n=V1(e);n.length===1?new z1(e).print():n.length==2?new C1(e).print():console.log(e)}else U1(e)||B1(e)?e.print():console.log(e)})}vc.exports=Y1});var xc=c((gx,Sc)=>{var J1=p(),$1=g(),wc=v(),G1=le(),L1=st(),W1=N(),K1=W1(function(t,e,n,r,s){try{return[t,e,n,r,s].every(i=>$1(i))?n-e===0?NaN:(s-r)*(t-e)/(n-e)+r:NaN}catch{return NaN}});function H1(t,e,n,r,s){return J1(t)&&wc(r)&&wc(s)&&(r=e,s=n,e=L1(t),n=G1(t)),K1(t,e,n,r,s)}Sc.exports=H1});var Tc=c((qx,_c)=>{var X1=g(),Q1=N();function Z1(t){try{return X1(t)?Math.round(t):NaN}catch{return NaN}}_c.exports=Q1(Z1)});var Dc=c((yx,Oc)=>{var eb=g(),tb=N();function nb(t){try{return eb(t)?t<0?-1:t>0?1:0:NaN}catch{return NaN}}Oc.exports=tb(nb)});var Ic=c((bx,Fc)=>{var rb=g(),sb=N();function ib(t){try{return rb(t)?Math.sin(t):NaN}catch{return NaN}}Fc.exports=sb(ib)});var Ec=c((vx,Ac)=>{var ob=at();function ub(t){return ob(t)}Ac.exports=ub});var jc=c((Nx,Mc)=>{var ab=g(),cb=N();function lb(t){try{return ab(t)?Math.tan(t):NaN}catch{return NaN}}Mc.exports=cb(lb)});var bt=c((wx,zc)=>{var kc=m(),Cc=A();function fb(t,e){kc(Cc(t),"`fn` must be a function!");let n=new Date;return e?t(...e):t(),new Date-n}async function hb(t,e){kc(Cc(t),"`fn` must be a function!");let n=new Date;return e?await t(...e):await t(),new Date-n}zc.exports={timeSync:fb,timeAsync:hb}});var Uc=c((Sx,Rc)=>{var mb=p(),db=y(),pb=q(),gb=z();function qb(){return gb([...arguments].map(t=>mb(t)?t:db(t)||pb(t)?t.values:[t]))}Rc.exports=qb});var Bc=c((xx,Pc)=>{var yb=m(),bb=p(),vb=y(),Nb=q(),wb=v(),Sb=le(),xb=M();function _b(){let t=[],e=Object.values(arguments).map(n=>((vb(n)||Nb(n))&&(n=n.values),yb(bb(n),"The `zip` function only works on arrays, Series, and DataFrames!"),n));return xb(0,Sb(e.map(n=>n.length))).forEach(n=>{let r=[];e.forEach(s=>{let i=s[n];r.push(wb(i)?void 0:i)}),t.push(r)}),t}Pc.exports=_b});var w=c((_x,An)=>{var{DataFrame:Tb,Series:Ob}=Ee(),he={abs:tt(),add:nt(),apply:rt(),arccos:Bo(),arcsin:Yo(),arctan:$o(),argmax:Lo(),argmin:Xo(),assert:m(),ceil:Zo(),chop:nu(),clamp:su(),combinations:ou(),copy:C(),correl:Tu(),cos:Du(),count:Ue(),covariance:dn(),DataFrame:Tb,decycle:Ct(),diff:ju(),distance:Wu(),divide:Hu(),dot:wn(),dropMissing:Sn(),dropMissingPairwise:ha(),dropNaN:Jt(),dropNaNPairwise:va(),dropUndefined:wa(),exp:xa(),factorial:Oa(),find:Aa(),findAll:ka(),flatten:T(),float:za(),floor:Ua(),identity:Va(),indexOf:be(),int:Ja(),intersect:Ga(),inverse:Ha(),isArray:p(),isBoolean:Wt(),isDataFrame:y(),isEqual:R(),isFunction:A(),isJagged:Ne(),isNested:Pe(),isNumber:g(),isObject:Q(),isSeries:q(),isString:j(),isUndefined:v(),lerp:Qa(),log:tc(),MathError:se(),max:le(),mean:it(),median:sc(),min:st(),mod:uc(),mode:fc(),multiply:yn(),ndarray:J(),normal:pc(),ones:qc(),permutations:bc(),pow:ct(),print:Nc(),product:Te(),random:ue().random,range:M(),remap:xc(),reshape:We(),reverse:we(),round:Tc(),scale:fe(),seed:ue().seed,Series:Ob,set:z(),shape:x(),shuffle:Ke(),sign:Dc(),sin:Ic(),sort:$(),sqrt:ut(),std:at(),stdev:Ec(),subtract:bn(),sum:lt(),tan:jc(),time:bt().timeSync,timeSync:bt().timeSync,timeAsync:bt().timeAsync,transpose:ee(),union:Uc(),variance:pn(),vectorize:N(),zeros:Tn(),zip:Bc(),dump:function(){let t=typeof global<"u"?global:window;if(!t)throw new he.MathError("Cannot dump functions into global scope because neither `global` nor `window` exist in the current context!");Object.keys(he).forEach(e=>{try{Object.defineProperty(t,e,{configurable:!1,enumerable:!0,writable:!1,value:he[e]})}catch{t[e]=he[e]}})}};typeof An<"u"&&(An.exports=he);typeof window<"u"&&(window.JSMathTools=he)});var P=c((Tx,Vc)=>{Vc.exports={shouldIgnoreNaNValues:!0}});var me=c((Ox,Jc)=>{var{assert:Db,flatten:Fb,isArray:Ib,isDataFrame:Ab,isNumber:Eb,isSeries:Mb}=w();function Yc(t){if(Ab(t)||Mb(t))return Yc(t.values);Db(Ib(t),"The `containsOnlyNumbers` function only works on arrays, Series, and DataFrames!");let e=Fb(t);for(let n=0;n<e.length;n++)if(!Eb(e[n]))return!1;return!0}Jc.exports=Yc});var Mn=c((Dx,$c)=>{var{dropMissing:jb,flatten:kb,isArray:Cb,isDataFrame:zb,isSeries:Rb}=w();function En(t){return typeof t=="number"?t===0||t===1:zb(t)||Rb(t)?En(t.values):Cb(t)?t.length===0?!1:jb(kb(t)).every(n=>En(n)):!1}$c.exports=En});var jn=c((Fx,el)=>{var{abs:Gc,apply:Lc,assert:Wc,clamp:Ub,copy:Pb,divide:Bb,dropNaN:Vb,flatten:Yb,isArray:Jb,isDataFrame:$b,isNumber:Kc,isSeries:Gb,max:Hc,median:Xc,min:Lb,sort:Wb,subtract:Qc}=w(),Kb=P(),Hb=me(),Xb=Mn();function Zc(t,e){if($b(t)||Gb(t)){let a=t.copy();return a._values=Zc(a._values,e),a}if(Wc(Jb(t),"The `clipOutliers` function only works on arrays, Series, and DataFrames!"),e=e||5,Wc(Kc(e),"Any `maxScore` value passed into the `clipOutliers` function must be a number!"),!Kb.shouldIgnoreNaNValues&&!Hb(t))return Lc(t,()=>NaN);let n=Yb(t),r=Vb(n);if(Xb(r)||r.length===0)return t;let s=Xc(r),i=Xc(Gc(Qc(r,s))),o=!1;if(i===0){let a=Wb(Pb(r)),l=a.filter(b=>b<s),f=a.filter(b=>b>s),h=s,d=s;if(l.length>0&&(h=Hc(l)),f.length>0&&(d=Lb(f)),i=(d-h)/2,i===0)return t;o=(s-h)/i>e||(d-s)/i>e}return Hc(Bb(Gc(Qc(r,s)),i))>e||o?Lc(t,a=>Kc(a)?Ub(a,s-e*i,s+e*i):a):t}el.exports=Zc});var Cn=c((Ix,al)=>{var{assert:tl,dropNaN:nl,isArray:rl,isSeries:sl,mean:il,shape:ol,variance:ul}=w(),Qb=P();function kn(t,e){if(sl(t))return kn(t.values,e);if(sl(e))return kn(t,e.values);tl(rl(t)&&rl(e)&&ol(t).length===1&&ol(e).length===1,"The `cohensd` function only works on 1-dimensional arrays and Series!"),tl(t.length===e.length,"Two arrays or Series passed into the `cohensd` function must have the same length!"),Qb.shouldIgnoreNaNValues&&(t=nl(t),e=nl(e));try{let n=il(t),r=il(e),s=Math.sqrt((ul(t)+ul(e))/2);return(n-r)/s}catch{return NaN}}al.exports=kn});var hl=c((Ax,fl)=>{var{assert:cl,DataFrame:Zb,isArray:ev,isSeries:tv,shape:nv,zeros:rv}=w();function ll(t){if(tv(t)){let r=new Zb(ll(t.values));return r.index=t.index.slice(),r.columns=t.index.slice(),r}cl(ev(t),"The `diagonalize` function only works on 1-dimensional arrays and Series!");let e=nv(t);cl(e.length===1,"The `diagonalize` function only works on 1-dimensional arrays and Series!");let n=rv([e[0],e[0]]);return t.forEach((r,s)=>n[s][s]=r),n}fl.exports=ll});var Pn=c((Ex,gl)=>{var{assert:zn,clamp:sv,correl:ml,DataFrame:vt,dropNaNPairwise:iv,isArray:dl,isDataFrame:Nt,isJagged:pl,isUndefined:ov,ndarray:uv}=w(),av=P();function Rn(t){let e="@jrc03c/js-data-science-helpers/get-correlation-matrix";return Object.defineProperty(t,e,{configurable:!1,enumerable:!1,writable:!1,value:Symbol.for(e)}),t}function Un(t,e){if(ov(e)&&(e=t),Nt(t)){let r=new vt(Un(t.values,e));return r.index=t.columns.slice(),r.columns=Nt(e)?e.columns.slice():new vt(e).columns.slice(),Rn(r)}if(Nt(e)){let r=new vt(Un(t,e.values));return r.index=Nt(t)?t.columns.slice():new vt(t).columns.slice(),r.columns=e.columns.slice(),Rn(r)}zn(dl(t)&&dl(e),"The `getCorrelationMatrix` function only works on 2-dimensional arrays and DataFrames!"),zn(!pl(t)&&!pl(e),"The `getCorrelationMatrix` function only works on non-jagged 2-dimensional arrays and DataFrames!"),zn(t.length===e.length,'The dimensions of the matrices you passed into the `getCorrelationMatrix` function aren\'t compatible! ([shape(a).join(", ")] vs. [shape(b).join(", ")]) The function expects that you\'ll be comparing the columns of two matrices where the columns are all of the same length, so please make sure that the matrices are oriented accordingly.');let n=uv([t[0].length,e[0].length]);for(let r=0;r<t[0].length;r++){let s=t.map(i=>i[r]);for(let i=0;i<e[0].length;i++){let o=e.map(u=>u[i]);av.shouldIgnoreNaNValues?n[r][i]=ml(...iv(s,o)):n[r][i]=ml(s,o)}}return Rn(sv(n,-1,1))}gl.exports=Un});var Bn=c((Mx,ql)=>{function cv(t){try{let e="@jrc03c/js-data-science-helpers/get-correlation-matrix";return t[e]===Symbol.for(e)}catch{return!1}}ql.exports=cv});var Nl=c((jx,vl)=>{var{DataFrame:Vn,isArray:lv,isDataFrame:wt,isNumber:yl,MathError:fv,sort:hv}=w(),bl=Pn(),mv=Bn();function dv(t,e,n){n=Object.values(arguments).find(i=>yl(i))||1-1e-5;let r=(()=>{let i=Object.values(arguments).filter(o=>lv(o)||wt(o));if(i.length===1){let o=i[0];if(mv(o))return wt(o)?o:new Vn(o);{let u=bl(o,null);return wt(u)?u:new Vn(u)}}if(i.length===2){let o=bl(i[0],i[1]);return wt(o)?o:new Vn(o)}throw new fv("You must pass 1 or 2 2-dimensional arrays or DataFrames into the `getHighlyCorrelatedColumns` function!")})(),s={};return r.values.forEach((i,o)=>{i.forEach((u,a)=>{if(yl(u)&&u>n){let l=r.index[o],f=r.columns[a];s[l]||(s[l]=[]),s[l].indexOf(f)<0&&s[l].push(f),s[f]||(s[f]=[]),s[f].indexOf(l)<0&&s[f].push(l)}})}),Object.keys(s).forEach(i=>{s[i]=hv(s[i])}),s}vl.exports=dv});var Yn=c((kx,Sl)=>{var{dropNaN:pv,isArray:gv,isDataFrame:qv,isNumber:yv,isSeries:bv,pow:vv,sqrt:Nv,sum:wv}=w(),Sv=P();function wl(t){return qv(t)||bv(t)?wl(t.values):yv(t)?Math.abs(t):gv(t)?(Sv.shouldIgnoreNaNValues&&(t=pv(t)),Nv(wv(vv(t,2)))):NaN}Sl.exports=wl});var Jn=c((Cx,Tl)=>{var{assert:xl,DataFrame:xv,isArray:_v,isSeries:Tv,isString:Ov,isUndefined:Dv,set:Fv,shape:Iv,sort:Av}=w();function _l(){if(arguments.length===1&&Tv(arguments[0])){let{name:i,values:o}=arguments[0],u=_l(i,o),a=new xv(u);return a.index=arguments[0].index.slice(),a}let[t,e]=arguments;xl(Ov(t),"When passing two arguments into the `getOneHotEncodings` function, the first argument must be a string representing the name of the variable being encoded!"),xl(_v(e)&&Iv(e).length===1,"When passing two arguments into the `getOneHotEncodings` function, the second argument must be a 1-dimensional array!");let n={},r=t+"_"+e[0];return Av(Fv(e)).filter(i=>!Dv(i)).map(i=>t+"_"+i).filter(i=>i!==r).forEach(i=>{n[i]=e.map(o=>i===t+"_"+o?1:0)}),n}Tl.exports=_l});var Dl=c((zx,Ol)=>{var{count:Ev}=w();function Mv(t){return Ev(t).map(n=>(n.percentage=n.count/t.length,n))}Ol.exports=Mv});var Fl=c((Rx,jv)=>{jv.exports=[.5,.49601,.49202,.48803,.48405,.48006,.47608,.4721,.46812,.46414,.46017,.4562,.45224,.44828,.44433,.44038,.4364,.43251,.42858,.42465,.42074,.41683,.41294,.40905,.40517,.40129,.39743,.39358,.38974,.38591,.38209,.37828,.37448,.3707,.36693,.36317,.35942,.35569,.35197,.34827,.34458,.3409,.33724,.3336,.32997,.32636,.32276,.31918,.31561,.31207,.30854,.30503,.30153,.29806,.2946,.29116,.28774,.28434,.28096,.2776,.27425,.27093,.26763,.26435,.26109,.25785,.25463,.25143,.24825,.2451,.24196,.23885,.23576,.2327,.22965,.22663,.22363,.22065,.2177,.21476,.21186,.20897,.20611,.20327,.20045,.19766,.19489,.19215,.18943,.18673,.18406,.18141,.17879,.17619,.17361,.17106,.16853,.16602,.16354,.16109,.15866,.15625,.15386,.15151,.14917,.14686,.14457,.14231,.14007,.13786,.13567,.1335,.13136,.12924,.12714,.12507,.12302,.121,.119,.11702,.11507,.11314,.11123,.10935,.10749,.10565,.10383,.10204,.10027,.09853,.0968,.0951,.09342,.09176,.09012,.08851,.08692,.08534,.08379,.08226,.08076,.07927,.0778,.07636,.07493,.07353,.07215,.07078,.06944,.06811,.06681,.06552,.06426,.06301,.06178,.06057,.05938,.05821,.05705,.05592,.0548,.0537,.05262,.05155,.0505,.04947,.04846,.04746,.04648,.04551,.04457,.04363,.04272,.04182,.04093,.04006,.0392,.03836,.03754,.03673,.03593,.03515,.03438,.03362,.03288,.03216,.03144,.03074,.03005,.02938,.02872,.02807,.02743,.0268,.02619,.02559,.025,.02442,.02385,.0233,.02275,.02222,.02169,.02118,.02068,.02018,.0197,.01923,.01876,.01831,.01786,.01743,.017,.01659,.01618,.01578,.01539,.015,.01463,.01426,.0139,.01355,.01321,.01287,.01255,.01222,.01191,.0116,.0113,.01101,.01072,.01044,.01017,.0099,.00964,.00939,.00914,.00889,.00866,.00842,.0082,.00798,.00776,.00755,.00734,.00714,.00695,.00676,.00657,.00639,.00621,.00604,.00587,.0057,.00554,.00539,.00523,.00508,.00494,.0048,.00466,.00453,.0044,.00427,.00415,.00402,.00391,.00379,.00368,.00357,.00347,.00336,.00326,.00317,.00307,.00298,.00289,.0028,.00272,.00264,.00256,.00248,.0024,.00233,.00226,.00219,.00212,.00205,.00199,.00193,.00187,.00181,.00175,.00169,.00164,.00159,.00154,.00149,.00144,.00139,.00135,.00131,.00126,.00122,.00118,.00114,.00111,.00107,.00104,.001,97e-5,94e-5,9e-4,87e-5,84e-5,82e-5,79e-5,76e-5,74e-5,71e-5,69e-5,66e-5,64e-5,62e-5,6e-4,58e-5,56e-5,54e-5,52e-5,5e-4,48e-5,47e-5,45e-5,43e-5,42e-5,4e-4,39e-5,38e-5,36e-5,35e-5,34e-5,32e-5,31e-5,3e-4,29e-5,28e-5,27e-5,26e-5,25e-5,24e-5,23e-5,22e-5,22e-5,21e-5,2e-4,19e-5,19e-5,18e-5,17e-5,17e-5,16e-5,15e-5,15e-5,14e-5,14e-5,13e-5,13e-5,12e-5,12e-5,11e-5,11e-5,1e-4,1e-4,1e-4,9e-5,9e-5,8e-5,8e-5,8e-5,8e-5,7e-5,7e-5,7e-5,6e-5,6e-5,6e-5,6e-5,5e-5,5e-5,5e-5,5e-5,5e-5,4e-5,4e-5,4e-5,4e-5,4e-5,4e-5,3e-5,3e-5,3e-5,3e-5,3e-5,3e-5,3e-5,3e-5,2e-5,2e-5,2e-5,2e-5]});var Gn=c((Ux,Rl)=>{var{abs:Il,assert:kv,dropNaNPairwise:Cv,flatten:St,isArray:Al,isDataFrame:El,isEqual:zv,isSeries:Ml,mean:jl,remap:Rv,round:Uv,shape:kl,sqrt:Pv,std:Cl}=w(),Bv=P(),zl=Fl();function Vv(t){return Il(t)>4.1?0:zl[Uv(Rv(Il(t),0,4.1,0,zl.length))]}function $n(t,e){if(El(t)||Ml(t))return $n(t.values,e);if(El(e)||Ml(e))return $n(t,e.values);kv(Al(t)&&Al(e)&&zv(kl(t),kl(e)),"You must pass two identically-shaped arrays, Series, or DataFrames into the `pValue` function!");let[n,r]=Bv.shouldIgnoreNaNValues?Cv(St(t),St(e)):[St(t),St(e)];if(n.length===0||r.length===0)return NaN;let s=jl(n),i=jl(r),o=Cl(n),u=Cl(r),a=n.length,l=r.length,f=(s-i)/Pv(o*o/a+u*u/l);return 2*Vv(f)}Rl.exports=$n});var Yl=c((Px,Vl)=>{var{assert:Ln,clamp:Yv,DataFrame:xt,dropNaNPairwise:Jv,isArray:Ul,isDataFrame:_t,isJagged:Pl,isUndefined:$v,ndarray:Gv}=w(),Lv=P(),Bl=Gn();function Wn(t){let e="@jrc03c/js-data-science-helpers/get-p-value-matrix";return Object.defineProperty(t,e,{configurable:!1,enumerable:!1,writable:!1,value:Symbol.for(e)}),t}function Kn(t,e){if($v(e)&&(e=t),_t(t)){let r=new xt(Kn(t.values,e));return r.index=t.columns.slice(),r.columns=_t(e)?e.columns.slice():new xt(e).columns.slice(),Wn(r)}if(_t(e)){let r=new xt(Kn(t,e.values));return r.index=_t(t)?t.columns.slice():new xt(t).columns.slice(),r.columns=e.columns.slice(),Wn(r)}Ln(Ul(t)&&Ul(e),"The `getPValueMatrix` function only works on 2-dimensional arrays and DataFrames!"),Ln(!Pl(t)&&!Pl(e),"The `getPValueMatrix` function only works on non-jagged 2-dimensional arrays and DataFrames!"),Ln(t.length===e.length,'The dimensions of the matrices you passed into the `getPValueMatrix` function aren\'t compatible! ([shape(a).join(", ")] vs. [shape(b).join(", ")]) The function expects that you\'ll be comparing the columns of two matrices where the columns are all of the same length, so please make sure that the matrices are oriented accordingly.');let n=Gv([t[0].length,e[0].length]);for(let r=0;r<t[0].length;r++){let s=t.map(i=>i[r]);for(let i=0;i<e[0].length;i++){let o=e.map(u=>u[i]);Lv.shouldIgnoreNaNValues?n[r][i]=Bl(...Jv(s,o)):n[r][i]=Bl(s,o)}}return Wn(Yv(n,0,1))}Vl.exports=Kn});var Wl=c((Bx,Ll)=>{var{assert:Tt,intersect:Wv,isDataFrame:Jl,isSeries:$l,isUndefined:Gl}=w(),de=class{constructor(e){let n=this;Tt(Gl(e)||e===de.DROP_NAN_MODE||e===de.DROP_MISSING_MODE,"The `mode` value passed into the `IndexMatcher` constructor must be undefined or one of [IndexMatcher.DROP_NAN_MODE, IndexMatcher.DROP_MISSING_MODE]! (By default, the mode is `Indexer.DROP_MISSING_MODE`.)"),n.mode=Gl(e)?de.DROP_MISSING_MODE:e,n.index=null}fit(){let e=this,n=[];return Object.values(arguments).forEach(r=>{Tt(Jl(r)||$l(r),"The `IndexMatcher` only works on Series and DataFrames! To drop NaN values in a pair-wise fashion from regular arrays, use the `dropNaNPairwise` function from the @jrc03c/js-math-tools library."),e.mode===de.DROP_MISSING_MODE?n.push(r.dropMissing().index):n.push(r.dropNaN().index)}),e.index=Wv(...n),e}transform(){let e=this;Tt(!!e.index,"The IndexMatcher hasn't been fitted yet! Please call the `fit` method before calling the `transform` method.");let n=Object.values(arguments).map(r=>(Tt(Jl(r)||$l(r),"The `IndexMatcher` only works on Series and DataFrames! To drop NaN values in a pair-wise fashion from regular arrays, use the `dropNaNPairwise` function from the @jrc03c/js-math-tools library."),r.get(e.index,null)));return n.length===1?n[0]:n}fitAndTransform(){return this.fit(...arguments).transform(...arguments)}},je=de;Et(je,"DROP_NAN_MODE","DROP_NAN_MODE"),Et(je,"DROP_MISSING_MODE","DROP_MISSING_MODE");Ll.exports=je});var Qn=c((Vx,Hl)=>{var{apply:Kv,assert:Hv,count:Xv,flatten:Qv,float:Zv,isArray:Hn,isDataFrame:eN,isNumber:tN,isSeries:nN,isString:rN}=w(),Kl=["null","none","nan","na","n/a","","undefined"],sN=["true","false","yes","no"];function iN(t,e){if(t===void 0&&(t="undefined"),e==="null")return null;if(e==="number"){let n=Zv(t);return isNaN(n)?NaN:n}if(e==="boolean"){try{let n=t.trim().toLowerCase();if(n==="true"||n==="yes")return!0;if(n==="false"||n==="no")return!1}catch{}return null}if(e==="date"){let n=new Date(t);return n.toString()==="Invalid Date"?null:n}if(e==="object")try{let n=JSON.parse(t);return Hn(n)?null:n}catch{return null}if(e==="string"){try{if(Kl.indexOf(t.trim().toLowerCase())>-1)return null}catch{return null}return t}}function Xn(t){if(eN(t)){let s=t.copy(),i=Xn(t.values);return s.values=i.values,{type:i.type,values:s}}if(nN(t)){let s=t.copy(),i=Xn(t.values);return s.values=i.values,{type:i.type,values:s}}Hv(Hn(t),"The `inferType` function only works on arrays, Series, and DataFrames!");let e=Qv(t).map(s=>{if(s===void 0)return"null";rN(s)||(s=JSON.stringify(s));let o=s.toLowerCase().trim();if(Kl.indexOf(o)>-1)return"null";if(sN.indexOf(o)>-1)return"boolean";try{let u=JSON.parse(s);return tN(u)?"number":typeof u=="object"?Hn(u)?"string":"object":"string"}catch{return new Date(s).toString()!=="Invalid Date"?"date":"string"}}),r=Xv(e).sort((s,i)=>i.count-s.count)[0].item;return{type:r,values:Kv(t,s=>iN(s,r))}}Hl.exports=Xn});var er=c((Yx,tf)=>{var{assert:Zn,isArray:oN,isBoolean:uN,isDataFrame:Xl,isSeries:Ql,int:aN,isNumber:cN,isUndefined:Zl,range:ef,set:lN,shape:fN,shuffle:hN}=w();tf.exports=function(){let e=Array.from(arguments),n=e.find(b=>uN(b)),r=Zl(n)?!0:n,s=e.find(b=>cN(b)),i=Zl(s)?.1:s;Zn(i>0&&i<1,"`testSize` must be a number between 0 and 1 (exclusive on both ends)!");let o=e.filter(b=>oN(b)||Xl(b)||Ql(b));Zn(o.length>0,"You must pass at least one dataset into the `trainTestSplit` function!");let u=o.map(b=>fN(b)[0]);Zn(lN(u).length===1,`All datasets passed into the \`trainTestSplit\` function must be the same length at their shallowest dimension! The lengths of your datasets, though, are: ${u.join(", ")}`);let a=[],l=r?hN(ef(0,u[0])):ef(0,u[0]),f=aN((1-i)*l.length),h=l.slice(0,f),d=l.slice(f);return o.forEach(b=>{if(Xl(b))a.push(b.get(h,null)),a.push(b.get(d,null));else if(Ql(b))a.push(b.get(h)),a.push(b.get(d));else{let S=[],O=[];b.forEach((B,F)=>{h.indexOf(F)>-1?S.push(B):O.push(B)}),a.push(S),a.push(O)}}),a}});var Dt=c((Jx,af)=>{var{add:mN,argmin:dN,assert:pN,flatten:nf,isArray:gN,isDataFrame:rf,isEqual:qN,int:yN,isNumber:bN,isSeries:sf,normal:tr,pow:vN,random:NN,range:wN,scale:SN,shape:Ot,subtract:xN,sum:_N}=w(),TN=er();function nr(t,e){(rf(t)||sf(t))&&(t=t.values),(rf(e)||sf(e))&&(e=e.values),pN(qN(Ot(t),Ot(e)),"`yPred` and `yTrue` must have the same shape!");let n=nf(t),r=nf(e),s=0;return n.forEach((i,o)=>{i===r[o]&&s++}),s/n.length}function ON(t){test(`tests that the \`${t.name}\` model works correctly`,()=>{let e=tr([5,10]).map(h=>h.map(d=>d*100+tr()*100)),n=[],r=wN(0,500).map(()=>{let h=yN(NN()*e.length),d=e[h];return n.push(h),mN(d,SN(5,tr(Ot(d))))}),[s,i,o,u]=TN(r,n),a=new t({k:e.length});a.fit(s),a.centroids=of(e,a.centroids);let l=a.predict(s),f=a.predict(i);expect(nr(o,l)).toBeGreaterThan(.95),expect(nr(u,f)).toBeGreaterThan(.95)})}function DN(t){return gN(t)&&Ot(t).length===2}function FN(t){return bN(t)&&parseInt(t)===t&&t>=0}function of(t,e){return t.map(n=>e[dN(e.map(r=>uf(n,r)))])}function uf(t,e){return _N(vN(xN(t,e),2))}af.exports={accuracy:nr,createGenericTest:ON,isMatrix:DN,isWholeNumber:FN,orderCentroids:of,sse:uf}});var ir=c(($x,hf)=>{var{add:cf,argmin:IN,assert:te,copy:AN,distance:lf,divide:EN,isDataFrame:MN,isFunction:jN,isUndefined:Ft,normal:kN,random:CN,range:zN,scale:RN,shuffle:UN,zeros:ff}=w(),{isMatrix:PN,isWholeNumber:rr,sse:BN}=Dt(),sr=class{constructor(e){te(typeof e=="object","`config` must be an object! See the documentation for more information about the properties that the `config` object can contain."),te(rr(e.k),"`k` must be a whole number!"),te(rr(e.maxIterations)||Ft(e.maxIterations),"`maxIterations` must be a whole number or undefined!"),te(rr(e.maxRestarts)||Ft(e.maxRestarts),"`maxRestarts` must be a whole number or undefined!"),te(typeof e.tolerance=="number"||Ft(e.tolerance),"`tolerance` must be a number or undefined!");let n=this;n.k=e.k,n.maxRestarts=e.maxRestarts||25,n.maxIterations=e.maxIterations||100,n.tolerance=e.tolerance||1e-4,n.centroids=null,n._fitState=null}initializeCentroids(e){let n=this;return UN(e).slice(0,n.k)}fitStep(e,n){let r=this;if(te(PN(e),"`x` must be a matrix!"),MN(e)&&(e=e.values),Ft(n)||te(jN(n),"If defined, `progress` must be a function!"),r._fitState){if(r._fitState.isFinished)return r}else{let a=r.initializeCentroids(e);r._fitState={currentRestart:0,currentIteration:0,currentCentroids:a,bestCentroids:a,bestScore:-1/0,isFinished:!1}}let s=r.predict(e,r._fitState.currentCentroids),i=[],o=ff(r.k);e.forEach((a,l)=>{let f=s[l];i[f]||(i[f]=ff(a.length)),i[f]=cf(i[f],a),o[f]++});let u=zN(0,r.k).map(a=>o[a]===0?cf(r._fitState.currentCentroids[parseInt(CN()*r._fitState.currentCentroids.length)],RN(.001,kN(r._fitState.currentCentroids[0].length))):EN(i[a],o[a]));if(lf(r._fitState.currentCentroids,u)<r.tolerance?r._fitState.currentIteration=r.maxIterations-1:r._fitState.currentCentroids=u,n&&n((r._fitState.currentRestart+r._fitState.currentIteration/r.maxIterations)/r.maxRestarts,r),r._fitState.currentIteration++,r._fitState.currentIteration>=r.maxIterations){let a=r.score(e,r._fitState.currentCentroids);if(a>r._fitState.bestScore&&(r._fitState.bestScore=a,r._fitState.bestCentroids=AN(r._fitState.currentCentroids)),r._fitState.currentIteration=0,r._fitState.currentRestart++,r._fitState.currentRestart>=r.maxRestarts)r._fitState.isFinished=!0,r.centroids=r._fitState.bestCentroids,n&&n(1,r);else{let l=r.initializeCentroids(e);r._fitState.currentCentroids=l}}return r}fit(e,n){let r=this;for(r._fitState&&(r._fitState=null);!r._fitState||!r._fitState.isFinished;)r.fitStep(e,n);return r}predict(e,n){if(n=n||this.centroids,!n)throw new Error("No centroids were provided to the `predict` method, and the K-Means model hasn't been fitted yet. Please either pass centroids as a second parameter to the `predict` method or run the `fit` method first!");return e.map(s=>IN(n.map(i=>lf(s,i))))}score(e,n){let r=this;if(n=n||r.centroids,!n)throw new Error("No centroids were provided to the `score` method, and the K-Means model hasn't been fitted yet. Please either pass centroids as a second parameter to the `score` method or run the `fit` method first!");let i=r.predict(e,n).map(o=>n[o]);return-BN(e,i)}};hf.exports=sr});var ur=c((Gx,pf)=>{var{argmin:VN,distance:mf,divide:YN,max:JN,random:df}=w(),$N=ir(),or=class extends $N{initializeCentroids(e){let n=this,r=[e[parseInt(df()*e.length)]];for(;r.length<n.k;){let s=e.map(o=>mf(o,r[VN(r.map(u=>mf(o,u)))])),i=YN(s,JN(s));r.push(e[i.findIndex(o=>df()<o)])}return r}};pf.exports=or});var yf=c((Lx,qf)=>{var{assert:Y,isArray:GN,isDataFrame:LN,isEqual:WN,isFunction:KN,isUndefined:pe,range:HN,shape:gf}=w(),{isMatrix:XN,isWholeNumber:ar}=Dt(),QN=ur(),cr=class{constructor(e){pe(e)&&(e={}),Y(typeof e=="object","`config` must be an object! See the documentation for more information about the properties that the `config` object can contain."),pe(e.ks)&&(e.ks=HN(1,16)),Y(GN(e.ks),"`ks` must be an array of whole numbers!"),e.ks.forEach(r=>{Y(ar(r),"`ks` must be an array of whole numbers!")}),Y(ar(e.maxIterations)||pe(e.maxIterations),"`maxIterations` must be a whole number or undefined!"),Y(ar(e.maxRestarts)||pe(e.maxRestarts),"`maxRestarts` must be a whole number or undefined!"),Y(typeof e.tolerance=="number"||pe(e.tolerance),"`tolerance` must be a number or undefined!");let n=this;n.ks=e.ks,n.maxRestarts=e.maxRestarts||25,n.maxIterations=e.maxIterations||100,n.tolerance=e.tolerance||1e-4,n.scoreStopRatio=e.scoreStopRatio||.85,n.modelClass=e.modelClass||QN,n.fittedModel=null,n._fitState=null}fitStep(e,n){let r=this;if(Y(XN(e),"`x` must be a matrix!"),LN(e)&&(e=e.values),pe(n)||Y(KN(n),"If defined, `progress` must be a function!"),!r._fitState)r._fitState={isFinished:!1,lastScore:-1/0,currentIndex:0};else if(r._fitState.isFinished)return r;let s=r.ks[r._fitState.currentIndex],i=new r.modelClass({k:s,maxRestarts:10,maxIterations:20});i.fit(e,u=>n?n((r._fitState.currentIndex+u)/(r.ks.length+1)):null);let o=i.score(e);return o/r._fitState.lastScore>r.scoreStopRatio?(r._fitState.isFinished=!0,r._fitState.currentIndex--):(r._fitState.lastScore=o,r._fitState.currentIndex+1>=r.ks.length?r._fitState.isFinished=!0:r._fitState.currentIndex++),r._fitState.isFinished&&(r.fittedModel=new r.modelClass({k:r.ks[r._fitState.currentIndex],maxRestarts:r.maxRestarts,maxIterations:r.maxIterations}),r.fittedModel.fit(e,u=>n?n((r.ks.length+u)/(r.ks.length+1)):null),n&&n(1)),r}fit(e,n){let r=this;for(r._fitState=null;!r._fitState||!r._fitState.isFinished;)r.fitStep(e,n);return r}predict(e,n){return this.fittedModel.predict(e,n)}score(e,n){return this.fittedModel.score(e,n)}get k(){return this.fittedModel.k}set k(e){throw new Error("You can't set the k-value manually! It has to be set automatically via the `fit` method.")}get centroids(){return this.fittedModel.centroids}set centroids(e){let n=this;Y(WN(gf(e),gf(n.fittedModel.centroids)),"When assigning a new value to the `centroids` property, the new centroids must have the same shape as the old centroids!"),n.fittedModel.centroids=e}};qf.exports=cr});var vf=c((Wx,bf)=>{bf.exports={KMeansMeta:yf(),KMeansNaive:ir(),KMeansPlusPlus:ur(),helpers:Dt()}});var lr=c((Kx,Tf)=>{var{apply:ZN,assert:ew,dropNaN:Nf,isArray:tw,isDataFrame:nw,isSeries:rw,mean:wf,std:Sf}=w(),xf=P();function _f(t){if(nw(t)||rw(t)){let r=t.copy();return r.values=_f(r.values),r}ew(tw(t),"The `normalize` function only works on arrays, Series, and DataFrames!");let e=(()=>xf.shouldIgnoreNaNValues?wf(Nf(t)):wf(t))(),n=(()=>xf.shouldIgnoreNaNValues?Sf(Nf(t)):Sf(t))();return n===0?t:ZN(t,r=>(r-e)/n)}Tf.exports=_f});var hr=c((Hx,Af)=>{var{assert:ge,dot:Of,isArray:Df,isSeries:fr,scale:sw,Series:iw,shape:Ff}=w(),If=me();function It(t,e){if(fr(t)){if(fr(e))return new iw(It(t.values,e.values));{let n=t.copy();return n.values=It(t.values,e),n}}if(fr(e)){let n=e.copy();return n.values=It(t,e.values),n}return ge(Df(t),"`project` only works on vectors!"),ge(Df(e),"`project` only works on vectors!"),ge(If(t),"`project` only works on vectors of numbers!"),ge(If(e),"`project` only works on vectors of numbers!"),ge(Ff(t).length===1,"`project` only works on vectors!"),ge(Ff(e).length===1,"`project` only works on vectors!"),sw(Of(e,t)/Of(e,e),e)}Af.exports=It});var Cf=c((Xx,kf)=>{var{assert:Ef,copy:ow,DataFrame:uw,divide:aw,isArray:cw,isDataFrame:lw,isJagged:fw,shape:hw,subtract:mw,transpose:Mf}=w(),dw=me(),pw=Yn(),gw=hr();function jf(t){if(lw(t)){let s=new uw(jf(t.values));return s.index=t.index.slice(),s.columns=t.columns.slice(),s}Ef(cw(t)&&!fw(t)&&hw(t).length===2,"`orthonormalize` only works on matrices!"),Ef(dw(t),"`orthonormalize` only works on matrices of numbers!");let e=Mf(t),n=[];e.forEach(s=>{let i=ow(s);n.forEach(o=>{i=mw(i,gw(i,o))}),n.push(i)});let r=n.map(s=>aw(s,pw(s)));return Mf(r)}kf.exports=jf});var Yf=c((e_,Vf)=>{var{assert:qe,copy:Qx,correl:qw,DataFrame:zf,dropMissing:yw,isArray:bw,isDataFrame:vw,isEqual:Nw,isFunction:ww,isJagged:Sw,isNumber:ke,isUndefined:xw,set:_w,shape:Tw,transpose:Zx}=w(),Ow=jn(),Dw=Jn(),Rf=(t,e)=>t.map(n=>n[e]),Uf=Qn(),Pf=t=>ke(t)&&(parseInt(t)===t||t===1/0);function Bf(t,e){e=e||{};let n=ke(e.maxUniqueStrings)?e.maxUniqueStrings:7,r=ke(e.minNonMissingValues)?e.minNonMissingValues:15,s=ke(e.maxCorrelationThreshold)?e.maxCorrelationThreshold:1-1e-5,i=e.progress||null;if(bw(t))return qe(Tw(t).length===2&&!Sw(t),"The `preprocess` function only works on non-jagged 2-dimensional arrays and DataFrames!"),Bf(new zf(t));qe(vw(t),"You must pass a DataFrame into the `preprocess` function!"),qe(Pf(n),"`maxUniqueStrings` must be a whole number!"),qe(Pf(r),"`minNonMissingValues` must be a whole number!"),qe(ke(s),"`maxCorrelationThreshold` must be a number!"),xw(i)||qe(ww(i),"If defined, `progress` must be a function!");let o={},u={},a={},l=t.values;t.columns.forEach((h,d)=>{if(u[h])return;let b=Rf(l,d),S=(()=>{if(o[h])return o[h];{let F=Uf(b);return F.type==="date"&&(F.values=F.values.map(ne=>ne-0)),o[h]=F,F}})();if(S.type==="null"||S.type==="object"){u[h]=!0;return}let O=yw(S.values);if(O.length<=r){u[h]=!0;return}let B=_w(O);if(B.length<2){u[h]=!0;return}if(S.type==="string"&&B.length<=n){let F=Dw(h,S.values);Object.keys(F).forEach(ne=>{a[ne]=F[ne]}),u[h]=!0;return}S.type==="number"&&(S.values=Ow(S.values)),t.columns.slice(d+1).forEach((F,ne)=>{if(u[F])return;let yh=Rf(l,d+ne+1),ye=(()=>{if(o[F])return o[F];{let re=Uf(yh);return re.type==="date"&&(re.values=re.values.map(bh=>bh-0)),o[F]=re,re}})();if(ye.type===S.type){if(ye.type==="number"&&qw(ye.values,S.values)>s){u[F]=!0;return}if(ye.type==="string"&&Nw(ye.values,S.values)){u[F]=!0;return}}}),a[h]=S.values,i&&i(d/t.columns.length)});let f=new zf(a);return f.index=t.index.slice(),f}Vf.exports=Bf});var Zf=c((t_,Qf)=>{var{abs:Fw,add:Iw,assert:Ce,isArray:Jf,isDataFrame:$f,isEqual:Aw,isSeries:Gf,mean:Ew,pow:Lf,scale:Mw,shape:Wf,sign:jw,sqrt:kw,sum:Kf}=w(),Hf=me(),Xf=(t,e)=>Iw(t,Mw(e,-1));function mr(t,e){if($f(t)||Gf(t))return mr(t.values,e);if($f(e)||Gf(e))return mr(t,e.values);Ce(Jf(t),"You must pass two same-shaped numerical arrays into the `rScore` function!"),Ce(Jf(e),"You must pass two same-shaped numerical arrays into the `rScore` function!"),Ce(Aw(Wf(t),Wf(e)),"You must pass two same-shaped numerical arrays into the `rScore` function!"),Ce(Hf(t),"You must pass two same-shaped numerical arrays into the `rScore` function!"),Ce(Hf(e),"You must pass two same-shaped numerical arrays into the `rScore` function!");let n=Kf(Lf(Xf(t,e),2)),r=Kf(Lf(Xf(t,Ew(t)),2));if(r===0)return NaN;let s=1-n/r;return jw(s)*kw(Fw(s))}Qf.exports=mr});var sh=c((n_,rh)=>{var{argmax:eh,assert:ze,copy:Cw,DataFrame:zw,dot:Rw,isArray:Uw,isDataFrame:Pw,isEqual:th,isJagged:Bw,max:Vw,min:Yw,reverse:Jw,shape:$w,transpose:Gw}=w();function nh(t){if(Uw(t)){ze($w(t).length===2&&!Bw(t),"The `sortCorrelationMatrix` function only works on 2-dimensional arrays and DataFrames!");let s=new zw(t);return s.index=s.columns.slice(),nh(s).values}ze(Pw(t),"You must pass a DataFrame into the `sortCorrelationMatrix` function!"),ze(Vw(t.values)<=1&&Yw(t.values)>=-1,"The correlation matrix passed into the `sortCorrelationMatrix` function must not contain values less than -1 or greater than 1!"),ze(th(t.values,Gw(t.values)),"The correlation matrix passed into the `sortCorrelationMatrix` function must be symmetrical!"),ze(th(t.index,t.columns),"The correlation matrix passed into the `sortCorrelationMatrix` function must be symmetrical! (In this case, although the values themselves are symmetrical, the row and column names differ.)");let e=Cw(t.index),n=[];for(;e.length>0;)if(n.length===0){let s=eh(t.values.map(i=>Rw(i,i)));n.push(e[s]),e.splice(s,1)}else{let s=t.index.indexOf(n.at(-1)),i=eh(e.map(u=>t.values[t.index.indexOf(u)][s])),o=e[i];n.push(o),e.splice(i,1)}let r=Jw(n);return t.get(r,r)}rh.exports=nh});var oh=c((r_,ih)=>{var Lw=lr();function Ww(){return Lw(...arguments)}ih.exports=Ww});var ph=c((s_,dh)=>{var{assert:At,DataFrame:uh,dropNaN:Kw,flatten:ah,isArray:Hw,isDataFrame:dr,isSeries:pr,mean:ch,range:Xw,Series:lh,shape:fh,stdev:hh,transpose:mh}=w(),Qw=P(),gr=class{constructor(){let e=this;e.means=[],e.stdevs=[],e.wasFittedOnAVector=!1,e.hasBeenFitted=!1}_getDataArrayAndShape(e){if(dr(e))return[e.values,e.shape];if(pr(e)){let r=mh([e.values]);return[r,fh(r)]}At(Hw(e),"`x` must be a 1- or 2-dimensional array, DataFrame, or Series!");let n=fh(e);return At(n.length<3,"`x` must be a 1- or 2-dimensional array, DataFrame, or Series!"),n.length===1&&(n.push(1),e=mh([e])),[e,n]}fit(e){let n=this,r=n._getDataArrayAndShape(e);e=r[0];let s=r[1];return n.wasFittedOnAVector=s.indexOf(1)>-1,n.means=[],n.stdevs=[],Xw(0,s[1]).forEach(i=>{let o=e.map(u=>u[i]);if(Qw.shouldIgnoreNaNValues){let u=Kw(o);n.means.push(ch(u)),n.stdevs.push(hh(u))}else n.means.push(ch(o)),n.stdevs.push(hh(o))}),n.hasBeenFitted=!0,n}transform(e){let n=this;if(!n.hasBeenFitted)throw new Error("This `StandardScaler` instance hasn't been trained on any data yet! Please use the `fit` method to train it before calling the `transform` method.");if(dr(e)){let o=new uh(n.transform(e.values));return o.columns=e.columns,o.index=e.index,o}if(pr(e)){let o=new lh(n.transform(e.values));return o.name=e.name,o.index=e.index,o}let r=n._getDataArrayAndShape(e);e=r[0];let s=r[1];At(s[1]===n.means.length,"The data you passed into the `transform` function doesn't have the same number of columns as the data set on which this StandardScaler was fitted!");let i=e.map(o=>o.map((u,a)=>(u-n.means[a])/n.stdevs[a]));return n.wasFittedOnAVector?ah(i):i}untransform(e){let n=this;if(!n.hasBeenFitted)throw new Error("This `StandardScaler` instance hasn't been trained on any data yet! Please use the `fit` method to train it before calling the `transform` method.");if(dr(e)){let o=new uh(n.untransform(e.values));return o.columns=e.columns,o.index=e.index,o}if(pr(e)){let o=new lh(n.untransform(e.values));return o.name=e.name,o.index=e.index,o}let r=n._getDataArrayAndShape(e);e=r[0];let s=r[1];At(s[1]===n.means.length,"The data you passed into the `untransform` function doesn't have the same number of columns as the data set on which this StandardScaler was fitted!");let i=e.map(o=>o.map((u,a)=>u*n.stdevs[a]+n.means[a]));return n.wasFittedOnAVector?ah(i):i}};dh.exports=gr});var eS=c((i_,qh)=>{var{MathError:Zw}=w(),gh={clipOutliers:jn(),cohensD:Cn(),cohensd:Cn(),common:P(),containsOnlyNumbers:me(),diagonalize:hl(),getCorrelationMatrix:Pn(),getHighlyCorrelatedColumns:Nl(),getMagnitude:Yn(),getOneHotEncodings:Jn(),getPercentages:Dl(),getPValueMatrix:Yl(),IndexMatcher:Wl(),inferType:Qn(),isBinary:Mn(),isCorrelationMatrix:Bn(),KMeans:vf(),normalize:lr(),orthonormalize:Cf(),preprocess:Yf(),project:hr(),pValue:Gn(),rScore:Zf(),sortCorrelationMatrix:sh(),standardize:oh(),StandardScaler:ph(),trainTestSplit:er(),dump(){let t=this,e=typeof global<"u"?global:typeof window<"u"?window:null;if(!e)throw new Zw("Cannot dump functions into global scope because neither `global` nor `window` exist in the current context!");Object.keys(t).forEach(n=>{try{Object.defineProperty(e,n,{configurable:!1,enumerable:!0,writable:!1,value:t[n]})}catch{e[n]=t[n]}})}};try{window.JSDataScienceHelpers=gh}catch{}try{qh.exports=gh}catch{}});eS();})();
