(()=>{var jh=Object.defineProperty;var Ch=(t,e,n)=>e in t?jh(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n;var Ne=(t=>typeof require!="undefined"?require:typeof Proxy!="undefined"?new Proxy(t,{get:(e,n)=>(typeof require!="undefined"?require:e)[n]}):t)(function(t){if(typeof require!="undefined")return require.apply(this,arguments);throw new Error('Dynamic require of "'+t+'" is not supported')});var c=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports);var Rt=(t,e,n)=>(Ch(t,typeof e!="symbol"?e+"":e,n),n);var U=c((jS,Or)=>{var Pt=class extends Error{constructor(e){typeof window<"u"?super(e):super(`

\x1B[31m`+e+`
\x1B[0m`)}};Or.exports=Pt});var m=c((CS,Fr)=>{var kh=U();Fr.exports=function(t,e){if(!t)throw new kh(e)}});var R=c((kS,Dr)=>{function Vh(t){try{return structuredClone(t)}catch{return t}}Dr.exports=Vh});var p=c((VS,Er)=>{function zh(t){try{return t instanceof Array||typeof t.constructor<"u"&&t.constructor.name==="Array"}catch{return!1}}Er.exports=zh});var b=c((zS,Ir)=>{function Uh(t){try{return!!t._symbol&&t._symbol===Symbol.for("@jrc03c/js-math-tools/dataframe")}catch{return!1}}Ir.exports=Uh});var y=c((US,Mr)=>{function Rh(t){try{return!!t._symbol&&t._symbol===Symbol.for("@jrc03c/js-math-tools/series")}catch{return!1}}Mr.exports=Rh});var F=c((RS,Cr)=>{var Ph=m(),Bh=R(),Ar=p(),Jh=b(),Yh=y();function jr(t){if(Jh(t)||Yh(t))return jr(t.values);Ph(Ar(t),"The `flatten` function only works on arrays, Series, and DataFrames!");function e(n){let r=[];return Bh(n).forEach(s=>{Ar(s)?r=r.concat(e(s)):r.push(s)}),r}return e(t)}Cr.exports=jr});var j=c((PS,kr)=>{function $h(t){return typeof t=="function"}kr.exports=$h});var q=c((BS,Vr)=>{function Lh(t){return typeof t=="number"&&!isNaN(t)}Vr.exports=Lh});var w=c((JS,zr)=>{function Gh(t){return t===null||typeof t>"u"}zr.exports=Gh});var G=c((YS,Ur)=>{var Wh=p(),Kh=w();function Hh(t){return typeof t=="object"&&!Kh(t)&&!Wh(t)}Ur.exports=Hh});var ve=c(($S,Br)=>{var Qh=m(),Rr=p(),Xh=b(),Zh=j(),Bt=q(),Pr=G(),e0=y();function Jt(t,e){if(Xh(t)){let o=Jt(t.values,e);return o.length>0&&Bt(o[0])&&o[0]>=0&&o[0]<t.index.length&&(o[0]=t.index[o[0]]),o.length>1&&Bt(o[1])&&o[1]>=0&&o[1]<t.columns.length&&(o[1]=t.columns[o[1]]),o}if(e0(t)){let o=Jt(t.values,e);return o.length>0&&Bt(o[0])&&o[0]>=0&&o[0]<t.index.length&&(o[0]=t.index[o[0]]),o}if(Qh(Pr(t)||Rr(t),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `indexOf` function!"),!Zh(e)){let o=e;e=i=>i===o}function n(o,i,u){if(u=u||[],u.indexOf(o)>-1)return null;if(Pr(o)){u.push(o);let a=Object.keys(o);for(let l=0;l<a.length;l++){let f=a[l],h=o[f];if(i(h))return[f];let d=n(h,i,u);if(d&&d.length>0)return[f].concat(d)}}else if(Rr(o)){u.push(o);for(let a=0;a<o.length;a++){let l=o[a];if(i(l))return[a];let f=n(l,i,u);if(f&&f.length>0)return[a].concat(f)}}else if(i(o))return[];return null}function r(o){try{return e(o)}catch{return!1}}let s=n(t,r);return s&&s.length>0?s:null}Br.exports=Jt});var P=c((LS,$r)=>{var Jr=R(),t0=ve(),n0=p(),r0=b(),s0=y();function Yr(t){function e(r,s,o){if(r0(r)||s0(r))return r.copy();if(s=s||[],o=o||"",s.indexOf(r)>-1){let i=o.split("/").slice(o.startsWith("/")?1:0);if(i.some((a,l)=>{let f=i.slice(0,i.length-l-1),h=n;return f.forEach(d=>{h=h[d]}),h===r}))return`<reference to "${n===r?"/":"/"+t0(n,r).join("/")}">`}if(typeof r=="object"){if(r===null)return null;if(s.push(r),n0(r))return r.map((i,u)=>e(i,s,o+"/"+u));{let i={};return Object.keys(r).forEach(u=>{i[u]=e(r[u],s,o+"/"+u)}),i}}else return r}let n=t;return e(t)}function o0(t,e){function n(r,s){let o=typeof r;if(o!==typeof s)return!1;if(o==="undefined")return!0;if(o==="boolean"||o==="symbol")return r===s;if(o==="number"||o==="bigint")return r.toString()==="NaN"&&s.toString()==="NaN"?!0:r===s;if(o==="string"||o==="function")return r===s;if(o==="object"){if(r===null||s===null)return r===null&&s===null;{let u=Object.keys(r),a=Object.keys(s);if(u.length!==a.length)return!1;for(let l=0;l<u.length;l++){let f=u[l];if(!n(r[f],s[f]))return!1}return!0}}}try{return n(Jr(t),Jr(e))}catch{return n(Yr(t),Yr(e))}}$r.exports=o0});var z=c((GS,Kr)=>{var i0=m(),u0=F(),a0=p(),Lr=b(),c0=j(),Gr=y(),l0=w();function Se(t){let e="abcdefg1234567890",n="";for(;n.length<t;)n+=e[parseInt(Math.random()*e.length)];return n}var f0=Se(256),h0=Se(256),m0=Se(256),d0=Se(256),p0=Se(256);function Wr(t){if(Lr(t)||Gr(t))return Wr(t.values);i0(a0(t),"The `set` function only works on arrays, Series, and DataFrames!");let e=[],n={};return u0(t).forEach(r=>{let s=typeof r=="object"&&r===null?f0:l0(r)?h0:c0(r)?r.toString():typeof r=="symbol"?r.toString()+" - "+p0:r===1/0?m0:r===-1/0?d0:Lr(r)?r.toJSONString():Gr(r)?JSON.stringify(r.toObject()):JSON.stringify(r);n[s]||e.push(r),n[s]=!0}),e}Kr.exports=Wr});var Je=c((WS,Xr)=>{var g0=m(),Yt=F(),Hr=p(),q0=b(),Qr=P(),y0=j(),b0=y(),w0=z();function Be(t,e){if(q0(t)||b0(t))return arguments.length>1?Be(t.values,e):Be(t.values,t.values);if(g0(Hr(t),"The first argument to the `count` function must be an array, Series, or DataFrame!"),y0(e))return Yt(t).filter(n=>e(n)).length;if(Hr(e)){let n=Yt(t);return w0(e).map(r=>({item:r,count:n.filter(s=>Qr(s,r)).length}))}else return arguments.length>1?Yt(t).filter(n=>Qr(n,e)).length:Be(t,t)}Xr.exports=Be});var xe=c((KS,es)=>{var N0=m(),Zr=p(),v0=b(),S0=y();function $t(t){if(v0(t)||S0(t))return $t(t.values);N0(Zr(t),"The `isJagged` function only works on arrays, Series, and DataFrames!");let e=0,n=null;for(let r=0;r<t.length;r++)if(Zr(t[r])){if(e++,$t(t[r]))return!0;if(n===null)n=t[r].length;else if(t[r].length!==n)return!0}return e>0&&e<t.length}es.exports=$t});var Ye=c((HS,rs)=>{var x0=m(),ts=p(),T0=b(),_0=y();function ns(t){if(T0(t)||_0(t))return ns(t.values);x0(ts(t),"The `isNested` function only works on arrays, Series, and DataFrames!");for(let e=0;e<t.length;e++)if(ts(t[e]))return!0;return!1}rs.exports=ns});var W=c((QS,os)=>{var se=m(),O0=p(),F0=Ye(),D0=q(),E0=w(),ae="You must pass a natural number or a one-dimensional array of natural numbers into the `ndarray` function!";function ss(t){se(!E0(t),ae),O0(t)||(t=[t]),se(!F0(t),ae),se(t.length>0,ae);let e=t[0];if(se(D0(e),ae),se(parseInt(e)===e,ae),se(e>=0,ae),se(e!==1/0,"We can't create an array containing an infinite number of values!"),t.length===1){let n=[];for(let r=0;r<e;r++)n.push(void 0);return n}else{let n=[];for(let r=0;r<e;r++)n.push(ss(t.slice(1)));return n}}os.exports=ss});var Te=c((XS,is)=>{var I0=m(),M0=p(),A0=b(),j0=y();function Lt(t){if(A0(t)||j0(t)){let n=t.copy();return n.values=Lt(n.values),n.index=Lt(n.index),n}I0(M0(t),"The `reverse` function only works on arrays, Series, and DataFrames!");let e=[];for(let n=t.length-1;n>=0;n--)e.push(t[n]);return e}is.exports=Lt});var C=c((ZS,us)=>{var Gt=m(),Wt=q(),Kt=w(),C0=Te();function k0(t,e,n=1){Gt(!Kt(t)&&!Kt(e)&&!Kt(n),"You must pass two numbers and optionally a step value to the `range` function!"),Gt(Wt(t)&&Wt(e)&&Wt(n),"You must pass two numbers and optionally a step value to the `range` function!"),Gt(n>0,"The step value must be greater than 0! (NOTE: The step value is a magnitude; it does not indicate direction.)");let r=!1;if(t>e){r=!0;let o=t;t=e+n,e=o+n}let s=[];for(let o=t;o<e;o+=n)s.push(o);return r&&(s=C0(s)),s}us.exports=k0});var T=c((e2,fs)=>{var V0=m(),as=p(),z0=b(),U0=P(),R0=y(),P0=w();function cs(t){if(!as(t))return;let e=[t.length],n=0,r=t.map(s=>{let o=cs(s);return P0(o)?o:(n++,o.length===1?o[0]:o)});return n>0?n===t.length&&r.slice(0,-1).every((o,i)=>U0(o,r[i+1]))?e.concat(r[0]):(e.push(r),e):e}function ls(t){return z0(t)||R0(t)?ls(t.values):(V0(as(t),"The `shape` function only works on arrays, Series, and DataFrames!"),cs(t))}fs.exports=ls});var qs=c((t2,gs)=>{var hs=m(),B0=p(),J0=b(),Y0=xe(),$0=y(),L0=w(),ms=U(),$e=W(),ds=C(),G0=z(),W0=T();function ps(t,e,n){if(L0(n)&&(n=0),hs(n===0||n===1||n==="vertical"||n==="horizontal",'The only valid axis values for use when appending data to a DataFrame are 0, 1, "vertical", and "horizontal". Note that 0 == "horizontal" and 1 == "vertical".'),B0(e)){hs(!Y0(e),"The array of data you're trying to append to this DataFrame is jagged!");let r=W0(e);if(r.length===1)if(n===0){let s=t.copy();s._values.push(e);let o=Math.max(t.shape[1],r[0]);for(s._values.forEach(i=>{for(;i.length<o;)i.push(void 0)});s._index.length<s._values.length;)s._index.push("row"+s._index.length);for(;s._columns.length<o;)s._columns.push("col"+s._columns.length);return s}else{let s=Math.max(t.shape[0],r[0]),o=t.copy();for(ds(0,s).forEach(i=>{i>=o._values.length&&o._values.push($e(t.shape[1])),o._values[i].push(e[i])});o._index.length<o._values.length;)o._index.push("row"+o._index.length);for(;o._columns.length<o._values[0].length;)o._columns.push("col"+o._columns.length);return o}else if(r.length===2)if(n===0){let s=Math.max(...e.map(i=>i.length).concat([t.shape[1]])),o=t.copy();for(o._values=o._values.concat(e).map(i=>{for(;i.length<s;)i.push(void 0);return i});o._index.length<o._values.length;)o._index.push("row"+o._index.length);for(;o._columns.length<s;)o._columns.push("col"+o._columns.length);return o}else{let s=Math.max(...e.map(u=>u.length))+t.shape[1],o=Math.max(t.shape[0],r[0]),i=t.copy();for(ds(0,o).forEach(u=>{for(u>=i._values.length&&i._values.push($e(t.shape[1])),i._values[u]=i._values[u].concat(e[u]);i._values[u].length<s;)i._values[u].push(void 0)});i._index.length<i._values.length;)i._index.push("row"+i._index.length);for(;i._columns.length<s;)i._columns.push("col"+i._columns.length);return i}else throw new ms("Only 1- and 2-dimensional arrays can be appended to a DataFrame!")}else if($0(e)){let r=ps(t,e.values,n);return n===0?r.index[r.index.length-1]=r.index.indexOf(e.name)>-1?e.name+" (2)":e.name:r.columns[r.columns.length-1]=r.columns.indexOf(e.name)>-1?e.name+" (2)":e.name,r}else if(J0(e))if(n===0){let r=t.copy(),s=G0(r._columns.concat(e._columns)).length;for(r._values.forEach(o=>{for(;o.length<s;)o.push(void 0)}),e.apply(o=>{let i=o.copy(),u=[];r._columns.forEach(a=>{let l=i._index.indexOf(a);l>-1?(u.push(i._values[l]),i._values.splice(l,1),i._index.splice(l,1)):u.push(void 0)}),r._values.push(u.concat(i._values))},1),r._columns=r._columns.concat(e._columns.filter(o=>r._columns.indexOf(o)<0));r._index.length<r._values.length;){let o="row"+r._index.length;r._index.push(o+(t._index.indexOf(o)>-1?" (2)":""))}return r}else{let r=t.copy();return r._index.forEach((s,o)=>{let i=e._index.indexOf(s);i>-1?r._values[o]=r._values[o].concat(e._values[i]):r._values[o]=r._values[o].concat($e(e.shape[1]))}),e._index.forEach((s,o)=>{r._index.indexOf(s)<0&&(r._index.push(s),r._values.push($e(r._columns.length).concat(e._values[o])))}),r._columns=r._columns.concat(e._columns.map(s=>s+(r._columns.indexOf(s)>-1?" (2)":""))),r}else throw new ms("Only 1- or 2-dimensional arrays, Series, and DataFrames can be appended to a DataFrame!")}gs.exports=ps});var vs=c((n2,Ns)=>{var ys=m(),bs=p(),K0=j(),ws=w();function H0(t,e,n,r,s){if(s=s||0,ys(K0(r),"The first parameter to the `apply` method must be a function."),ys(s===0||s===1,"The second parameter to the `apply` method (the `axis`) must be 0 or 1."),s===0){let o={},i;if(n.columns.forEach((u,a)=>{let l=new e(n.values.map(h=>h[a]));l.name=u,l.index=n.index;let f=r(l,a,n);f instanceof e?o[u]=f.values:o[u]=f,ws(i)&&(i=f instanceof e||bs(f))}),i){let u=new t(o);return u.index=n.index,u}else{let u=new e(n.columns.map(a=>o[a]));return u.index=n.columns,u}}else if(s===1){let o,i=n.values.map((u,a)=>{let l=new e(u);l.name=n.index[a],l.index=n.columns;let f=r(l,a,n);return ws(o)&&(o=f instanceof e||bs(f)),f instanceof e?f.values:f});if(o){let u=new t(i);return u.index=n.index,u.columns=n.columns,u}else{let u=new e(i);return u.index=n.index,u}}}Ns.exports=H0});var I=c((r2,Ss)=>{function Q0(t){return typeof t=="string"}Ss.exports=Q0});var _s=c((s2,Ts)=>{var xs=m(),X0=p(),Z0=xe(),em=G(),tm=I(),nm=w(),rm=U(),sm=T();function om(t,e,n,r,s){let o=u=>u instanceof t,i=u=>u instanceof e;if(nm(s)){if(o(r))return n.append(r,1);if(i(r))return n.append(r,1);if(em(r)){let u=Math.max(...Object.keys(r).map(a=>r[a].length));return Object.keys(r).forEach(a=>{for(;r[a].length<u;)r[a].push(void 0)}),n.append(new t(r),1)}else throw new rm("You must pass a DataFrame, Series, or object into the `assign` method!")}else{xs(tm(r),"If passing two arguments into the `assign` method, then the first argument must be a string name!"),xs(X0(s)&&!Z0(s)&&sm(s).length===1,"If passing two arguments into the `assign` method, then the second argument must be a 1-dimensional array!");let u=n.append(s,1);return u.columns[u.columns.length-1]=r,u}}Ts.exports=om});var Fs=c((o2,Os)=>{var im=R();function um(t,e){if(e.isEmpty)return new t;let n=new t(im(e.values));return n.columns=e.columns.slice(),n.index=e.index.slice(),n}Os.exports=um});var Cs=c((i2,js)=>{var Le=m(),Ds=p(),Es=q(),Is=I(),Ms=w(),As=T();function am(t,e,n,r,s){Ms(r)&&(r=[]),Ms(s)&&(s=[]),(Is(r)||Es(r))&&(r=[r]),(Is(s)||Es(s))&&(s=[s]),Le(Ds(r),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),Le(Ds(s),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),Le(As(r).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),Le(As(s).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");let o,i;n.index.forEach((a,l)=>{r.indexOf(a)<0&&r.indexOf(l)<0&&(o||(o=[]),o.push(a))}),n.columns.forEach((a,l)=>{s.indexOf(a)<0&&s.indexOf(l)<0&&(i||(i=[]),i.push(a))});let u=n.get(o,i);if(u instanceof e){let a=new t;a=a.assign(u),n.index.indexOf(u.name)>-1&&(a=a.transpose()),u=a}return u}js.exports=am});var _e=c((u2,ks)=>{var cm=q();function lm(t){return cm(t)&&parseInt(t)===t}function fm(t){return lm(t)&&t>=0}ks.exports=fm});var zs=c((a2,Vs)=>{var Ht=m(),hm=I(),Ge=w(),mm=_e(),dm=T();function pm(t,e,n,r,s,o){r=r||0,Ht(r===0||r===1,"The first parameter of the `dropMissing` method (the `axis`) must be 0 or 1."),o=o||0,Ht(mm(o),"The third parameter of the `dropMissing` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` null values)."),s=o>0?"none":s||"any",Ht(s==="any"||s==="all"||s==="none","The second parameter of the `dropMissing` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains null values, then it should be dropped; or that if 'all' of the data contains null values, then it should be dropped).");function i(l){if(o>0){let f=0;for(let h=0;h<l.length;h++){let d=l[h];if(Ge(d)&&f++,f>=o)return[]}}else if(s==="any")for(let f=0;f<l.length;f++){let h=l[f];if(Ge(h))return[]}else if(s==="all"){for(let f=0;f<l.length;f++){let h=l[f];if(!Ge(h))return l}return[]}return l}let u=n.copy(),a=Math.random().toString();if(r===0){u=u.assign(a,u.index);let l=u.values.map(i).filter(h=>h.length>0);if(dm(l).length<2)return new t;u.values=l;let f=u.get(null,a);if(Ge(f))return new t;hm(f)&&(f=[f]),f instanceof e&&(f=f.values),u.index=f,u=u.drop(null,a)}else if(r===1){let l={};if(u.columns.forEach((h,d)=>{let g=u.values.map(v=>v[d]),N=i(g);N.length>0&&(l[h]=N)}),Object.keys(l).length===0)return new t;let f=new t(l);return f.index=u.index,f}return u}Vs.exports=pm});var Qt=c((c2,Rs)=>{var gm=m(),qm=p(),ym=b(),bm=q(),wm=y();function Us(t){if(ym(t)||wm(t))return t.dropNaN(...Object.values(arguments).slice(1));gm(qm(t),"The `dropNaN` function only works on arrays, Series, and DataFrames!");let e=[];return t.forEach(n=>{try{return e.push(Us(n))}catch{if(bm(n))return e.push(n)}}),e}Rs.exports=Us});var Bs=c((l2,Ps)=>{var Xt=m(),Nm=Qt(),vm=_e();function Sm(t,e,n,r,s){n=n||0,Xt(n===0||n===1,"The first parameter of the `dropNaN` method (the `axis`) must be 0 or 1."),s=s||0,Xt(vm(s),"The third parameter of the `dropNaN` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` NaN values)."),r=s>0?"none":r||"any",Xt(r==="any"||r==="all"||r==="none","The second parameter of the `dropNaN` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains NaN values, then it should be dropped; or that if 'all' of the data contains NaN values, then it should be dropped).");function o(u){let a=Nm(u);return s>0?u.length-a.length<s:r==="any"?a.length===u.length:r==="all"?a.length>0:!0}let i=e.copy();if(n===0){let u=i.index.filter(a=>{let l=i.get(a,null).values;return o(l)});return u.length>0?i.get(u,null):new t}else if(n===1){let u=i.columns.filter(a=>{let l=i.get(null,a).values;return o(l)});return u.length>0?i.get(null,u):new t}return i}Ps.exports=Sm});var Ls=c((f2,$s)=>{var Js=m(),Oe=F(),xm=j(),Tm=w();function Ys(t){let e={};return Oe(t).forEach((n,r)=>{e[n]=r}),e}function ce(t){return Object.keys(t).sort((e,n)=>t[e]-t[n])}function _m(t,e,n,r,s){Js(xm(r),"The `filter` method takes a single parameter: a function that is used to filter the values."),Tm(s)&&(s=0),Js(s===0||s===1,"The `axis` parameter to the `filter` method must be 0 or 1.");let o=n.copy();if(o.isEmpty)return o;let i=Ys(o.index),u=Ys(o.columns);if(s===0){let a=o.values.filter((l,f)=>{let h=new e(l);h.name=n.index[f],h.index=n.columns;let d=r(h,f,n);return d||delete i[o.index[f]],d});if(Oe(a).length===0)return new t;if(a.length===1){let l=new e(Oe(a));return l.name=ce(i)[0],l.index=ce(u),l}o.values=a,o.index=ce(i)}else if(s===1){o=o.transpose();let a=o.values.filter((l,f)=>{let h=new e(l);h.name=n.columns[f],h.index=n.index;let d=r(h,f,n);return d||delete u[o.index[f]],d});if(Oe(a).length===0)return new t;if(a.length===1){let l=new e(Oe(a));return l.name=ce(u)[0],l.index=ce(i),l}o.values=a,o.index=ce(u),o=o.transpose()}return o}$s.exports=_m});var Fe=c((h2,Gs)=>{function Om(t){return typeof t=="boolean"}Gs.exports=Om});var oe=c((m2,Ks)=>{var Fm=m(),Dm=F(),Em=p(),Im=b(),Mm=y();function Ws(t){if(Im(t)||Mm(t))return Ws(t.values);Fm(Em(t),"The `max` function only works on arrays, Series, and DataFrames!");try{return Math.max(...Dm(t))}catch{return NaN}}Ks.exports=Ws});var Zt=c((d2,Xs)=>{var We=U(),K=m(),H=p(),Hs=Fe(),Ke=I(),He=w(),Am=oe(),Qs=C();function jm(t,e,n,r,s,o){return n=(()=>{if(He(n))return!1;if(Hs(n))return n;throw new We("The `hasHeaderRow` parameter of the `fromCSV` method must be a boolean!")})(),r=(()=>{if(He(r))return!1;if(Hs(r))return r;throw new We("The `hasIndexColumn` parameter of the `fromCSV` method must be a boolean!")})(),s=(()=>{let u="The `fieldDelimiter` parameter of the `fromCSV` method must be one of:\n\n1) a single-character string (e.g., ',')\n2) an array containing two single-character strings, one each for a left delimiter and a right delimiter (e.g., ['<', '>'])";if(He(s))return",";if(Ke(s))return K(s.length===1,u),s;if(H(s))return K(s.length===2,u),K(s[0].length===1,u),K(s[1].length===1,u),s;throw new We(u)})(),o=(()=>{let u="The `stringDelimiter` parameter of the `fromCSV` method must be one of:\n\n1) a single-character string (e.g., '\"')\n2) an array containing two single-character strings, one each for a left delimiter and a right delimiter (e.g., ['\u201C', '\u201D'])";if(He(o))return'"';if(Ke(o))return K(o.length===1,u),o;if(H(o))return K(o.length===2,u),K(o[0].length===1,u),K(o[1].length===1,u),o;throw new We(u)})(),(()=>{let a=e.split(`
`).filter(g=>g.length>0).map(g=>{let N=[],v="",A=!1;for(let O=0;O<g.length;O++){let E=g[O];if(E.match(/\\/g))O++;else if(H(o)&&E===o[0])A=!0;else if(H(o)&&E===o[1])A=!1;else if(Ke(o)&&E===o)A=!A;else if(H(s)&&E===s[0]||H(s)&&E===s[1]||Ke(s)&&E===s)if(A)v+=E;else{let we=v;try{let Y=JSON.parse(we);H(Y)?N.push(we.trim()):N.push(Y)}catch{N.push(we.trim())}v=""}else v+=E}if(v.length>0){let O=v;try{let E=JSON.parse(O);H(E)?N.push(O.trim()):N.push(E)}catch{N.push(O.trim())}}return N}),l=(()=>{let g=n?a.shift():Qs(0,a[0].length).map(N=>"col"+N);return r&&g.shift(),g})(),f=(()=>r?a.map(N=>N.shift()):Qs(0,a.length).map(N=>"row"+N))(),h=Am(a.map(g=>g.length)),d=new t(a.map(g=>(g.length=h,g)));return n&&(d.columns=l),r&&(d.index=f),d})()}Xs.exports=jm});var eo=c((p2,Zs)=>{var Cm=U(),km=m(),Vm=Zt(),zm=I(),Um=w();async function Rm(t,e,n,r,s,o,i){n=(()=>Um(n)?"utf8":(km(zm(n),"The `encoding` parameter of the `fromCSV` method must be a string (e.g., 'utf8')!"),n))();let u=await(async()=>{try{return Ne("fs").readFileSync(e,n)}catch{}try{return await(await fetch(e)).text()}catch{}throw new Cm(`The path "${e}" could not be loaded!`)})();return Vm(t,u,r,s,o,i)}Zs.exports=Rm});var ro=c((g2,no)=>{var V=m(),Qe=q(),Xe=I(),to=w(),Pm=z();function Bm(t,e,n){(Xe(e)||Qe(e))&&(e=[e]),(Xe(n)||Qe(n))&&(n=[n]);let r=Pm((e||[]).concat(n||[]).map(s=>typeof s));return V(r.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===1&&V(r[0]==="string"||r[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===2&&(V(r.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),V(r.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),to(e)||(e=e.map(s=>{if(Xe(s))return V(t.index.indexOf(s)>-1,`Row "${s}" does not exist!`),s;if(Qe(s))return V(s>=0,`Index ${s} is out of bounds!`),V(parseInt(s)===s,"Row numbers must be integers!"),V(s<t.index.length,`Index ${s} is out of bounds!`),t.index[s]})),to(n)||(n=n.map(s=>{if(Xe(s))return V(t.columns.indexOf(s)>-1,`Column "${s}" does not exist!`),s;if(Qe(s))return V(s>=0,`Column ${s} is out of bounds!`),V(parseInt(s)===s,"Column numbers must be integers!"),V(s<t.columns.length,`Column ${s} is out of bounds!`),t.columns[s]})),t.getSubsetByNames(e,n)}no.exports=Bm});var Q=c((q2,oo)=>{var so=m(),Jm=p(),Ym=b(),$m=j(),Lm=y(),Gm=w();function Wm(t,e){try{return t<e?-1:t>e?1:0}catch{return t=typeof t=="object"&&t!==null?JSON.stringify(t):t.toString(),e=typeof e=="object"&&e!==null?JSON.stringify(e):e.toString(),t<e?-1:t>e?1:0}}function Km(t,e){if(Gm(e)&&(e=Wm),Ym(t)||Lm(t))return t.sort(...Object.values(arguments).slice(1));so(Jm(t),"The `sort` function only works on arrays, Series, and DataFrames!"),so($m(e),"The second parameter of the `sort` function must be a comparison function!");let n=t.slice();return n.sort(e),n}oo.exports=Km});var co=c((y2,ao)=>{var io=m(),uo=I(),Hm=w(),Qm=z(),Xm=Q();function Zm(t){let e=t.toLowerCase(),n="";for(let s=0;s<e.length;s++){let o=e[s];o.match(/[a-z0-9]/g)?n+=o:n+=" "}let r=n.split(" ").filter(s=>s.length>0);return r[0]+r.slice(1).map(s=>s[0].toUpperCase()+s.substring(1)).join("")}function ed(t,e,n){Hm(n)?n=e.columns:uo(n)&&(n=[n]);let r={};n.forEach(o=>{io(uo(o),"You must pass either a string or a one-dimensional array of strings into the `getDummies` (AKA `oneHotEncode`) method!");let i=e.columns.indexOf(o);io(i>-1,`The given DataFrame does not have a column called "${o}"!`);let u=e.values.map(l=>l[i]),a=Xm(Qm(u));u.forEach(l=>{a.forEach(f=>{let h=o+"_"+Zm(f.toString());r[h]||(r[h]=[]),l===f?r[h].push(1):r[h].push(0)})})});let s=new t(r);return s.index=e.index,s}ao.exports=ed});var yo=c((b2,qo)=>{var X=m(),lo=p(),fo=q(),ho=w(),mo=_e(),po=C(),go=T();function td(t,e,n){let r=t.shape;ho(e)&&(e=po(0,r[0])),ho(n)&&(n=po(0,r[1])),fo(e)&&(e=[e]),fo(n)&&(n=[n]),X(lo(e)&&lo(n),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),X(go(e).length===1&&go(n).length===1,"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),X(e.length>0,"The `rowIndices` array must contain at least one index."),X(n.length>0,"The `colIndices` array must contain at least one index."),e.forEach(i=>{X(mo(i),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),X(i<t.index.length,`The row index ${i} is out of bounds.`)}),n.forEach(i=>{X(mo(i),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),X(i<t.columns.length,`The column index ${i} is out of bounds.`)});let s=e.map(i=>t.index[i]),o=n.map(i=>t.columns[i]);return t.getSubsetByNames(s,o)}qo.exports=td});var So=c((w2,vo)=>{var Z=m(),en=F(),bo=p(),Ze=I(),wo=w(),No=T();function nd(t,e,n,r,s){wo(r)&&(r=n.index),wo(s)&&(s=n.columns),Ze(r)&&(r=[r]),Ze(s)&&(s=[s]),Z(bo(r)&&bo(s),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),Z(No(r).length===1&&No(s).length===1,"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),Z(r.length>0,"The `rows` array must contain at least one row name."),Z(s.length>0,"The `cols` array must contain at least one column name."),r.forEach(u=>{Z(Ze(u),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),Z(n.index.indexOf(u)>-1,`The row name "${u}" does not exist in the list of rows.`)}),s.forEach(u=>{Z(Ze(u),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),Z(n.columns.indexOf(u)>-1,`The column name "${u}" does not exist in the list of columns.`)});let o=r.map(u=>s.map(a=>n.values[n.index.indexOf(u)][n.columns.indexOf(a)]));if(r.length===1&&s.length===1)return en(o)[0];if(r.length===1){let u=new e(en(o));return u.name=r[0],u.index=s,u}if(s.length===1){let u=new e(en(o));return u.name=s[0],u.index=r,u}let i=new t(o);return i.columns=s,i.index=r,i}vo.exports=nd});var To=c((N2,xo)=>{var rd=I(),De=C();function sd(t,e,n){function r(d,g){return rd(d)&&d.length>g?d.substring(0,g-3)+"...":d}if(n.isEmpty)return console.table({}),console.log("Shape:",[0,0],`
`),n;let s=typeof window>"u"?20:10,o=parseInt(s/2),i=typeof window>"u"?Math.floor(process.stdout.columns/24)-1:10,u=parseInt(i/2),a=s>n.index.length?null:De(0,o).concat(De(n.index.length-o,n.index.length)),l=i>n.columns.length?null:De(0,u).concat(De(n.columns.length-u,n.columns.length)),f=n.get(a,l);f instanceof e&&(n.shape[0]===1?(f=new t([f.values]),f.index=n.index,f.columns=new e(n.columns).get(l).values):n.shape[1]===1&&(f=new t([f.values]).transpose(),f.index=new e(n.index).get(a).values,f.columns=n.columns)),s<=n.index.length&&(f._index.splice(o,0,"..."),f._values.splice(o,0,De(0,f.columns.length).map(()=>"..."))),i<=n.columns.length&&(f._columns.splice(u,0,"..."),f._values=f._values.map(d=>(d.splice(u,0,"..."),d)));let h=28;return f instanceof e?(f.values=f.values.map(d=>r(d,h)),f.name=r(f.name,h),f.index=f.index.map(d=>r(d,h))):(f.values=f.values.map(d=>d.map(g=>r(g,h))),f.columns=f.columns.map(d=>r(d,h)),f.index=f.index.map(d=>r(d,h))),console.table(f.toObject()),console.log("Shape:",n.shape,`
`),n}xo.exports=sd});var et=c((v2,_o)=>{var od=m(),id=q();function ud(t,e){od(id(t),"The `leftPad` function only works on numbers!");let n=t.toString();for(;n.length<e;)n="0"+n;return n}_o.exports=ud});var Fo=c((S2,Oo)=>{var ad=et(),cd=C();function ld(t,e){let n=e?t:t.copy();return n.index=cd(0,t.shape[0]).map(r=>"row"+ad(r,(n.index.length-1).toString().length)),n}Oo.exports=ld});var Ee=c((x2,Eo)=>{var fd=m(),hd=F(),md=p(),dd=b(),pd=y();function Do(t){if(dd(t)||pd(t))return Do(t.values);fd(md(t),"The `product` function only works on arrays, Series, and DataFrames!");try{return t.length===0?NaN:hd(t).reduce((e,n)=>e*n,1)}catch{return NaN}}Eo.exports=Do});var tt=c((T2,jo)=>{var Ie=m(),Io=F(),Mo=p(),gd=b(),Ao=q(),qd=y(),yd=Ee(),bd=T();function tn(t,e){if(gd(t)||qd(t))return tn(t.values,e);if(Ie(Mo(t),"The first argument passed into the `reshape` function must be an array!"),Ao(e)&&(e=[e]),Ie(Mo(e),"The second argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),Ie(bd(e).length===1,"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),e.forEach(o=>{Ie(Ao(o)&&parseInt(o)===o&&o>0,"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!")}),e.length===0)return Io(t);let n=Io(t);if(e.length===1&&e[0]===n.length)return n;Ie(yd(e)===n.length,"The new shape doesn't match the number of values available in `x` (the first argument passed into the `reshape` function)!");let r=[],s=parseInt(n.length/e[0]);for(let o=0;o<e[0];o++){let i=n.slice(o*s,(o+1)*s);r.push(tn(i,e.slice(1)))}return r}jo.exports=tn});var le=c((_2,Po)=>{var wd=m(),Vo=R(),Nd=p(),vd=q(),zo=w(),Sd=W(),xd=Ee(),Td=tt(),Uo=Math.pow(2,64),_=[];Ro(parseInt(Math.random()*Uo));function _d(t,e){t=M(t);function n(){t+=M("0x9e3779b97f4a7c15");let s=Vo(t);return s=(s^s>>30n)*M("0xbf58476d1ce4e5b9"),s=(s^s>>27n)*M("0x94d049bb133111eb"),s^s>>31n}let r=[];for(let s=0;s<e;s++)r.push(n());return r}function M(t){return BigInt.asUintN(64,BigInt(t))}function Co(t,e){return t=M(t),e=BigInt(e),M(M(t<<e)|M(t>>M(64n-e)))}function Ro(t){if(zo(t))return Vo(_);{wd(vd(t),"If passing a value into the `seed` function, then that value must be an integer!");let e=_d(parseInt(t),4);_[0]=e[0],_[1]=e[1],_[2]=e[2],_[3]=e[3]}}function ko(){let t=M(Co(_[0]+_[3],23)+_[0]),e=M(_[1]<<17n);return _[2]=M(_[2]^_[0]),_[3]=M(_[3]^_[1]),_[1]=M(_[1]^_[2]),_[0]=M(_[0]^_[3]),_[2]=M(_[2]^e),_[3]=Co(_[3],45),parseInt(t)/Uo}function Od(t){return zo(t)?ko():(Nd(t)||(t=[t]),Td(Sd(xd(t)).map(ko),t))}Po.exports={random:Od,seed:Ro}});var nt=c((O2,Bo)=>{var{random:Fd}=le(),Dd=m(),Ed=p(),Id=b(),Md=y();function Ad(t){if(Id(t)||Md(t))return t.shuffle(...Object.values(arguments).slice(1));Dd(Ed(t),"The `shuffle` function only works on arrays, Series, and DataFrames!");let e=[],n=t.slice();for(let r=0;r<t.length;r++){let s=parseInt(Fd()*n.length);e.push(n.splice(s,1)[0])}return e}Bo.exports=Ad});var $o=c((F2,Yo)=>{var jd=m(),Cd=w(),Jo=nt();function kd(t,e){return Cd(e)&&(e=0),jd(e===0||e===1,"The `axis` parameter to the `shuffle` must be 0, 1, or undefined."),t.get(e===0?Jo(t.index):null,e===1?Jo(t.columns):null)}Yo.exports=kd});var Ho=c((D2,Ko)=>{var{random:Vd}=le(),k=m(),zd=F(),Lo=p(),nn=Fe(),Wo=j(),rt=q(),fe=I(),rn=w(),Ud=C(),Go=T(),sn=Q();function Rd(t,e,n){return Wo(e)?Pd(t,e,n):Bd(t,e,n)}function Pd(t,e,n){if(n=rn(n)?0:n,k(Wo(e),"When sorting a DataFrame using a function, the first argument to the `sort` method must be a function!"),k(rt(n),"When sorting a DataFrame using a function, the second argument to the `sort` method must be null, undefined, 0, or 1 to indicate the axis along which the data should be sorted! An axis of 0 means that the rows will be sorted relative to each other, whereas an axis of 1 means that the columns will be sorted relative to each other."),n===0){let r=sn(t.index,(s,o)=>e(t.get(s,null),t.get(o,null)));return t.get(r,null)}else{let r=sn(t.columns,(s,o)=>e(t.get(null,s),t.get(null,o)));return t.get(null,r)}}function Bd(t,e,n){let r=t.copy(),s=Vd().toString();return r=r.assign(s,r.index),rn(e)&&(e=[s],n=[!0]),(rt(e)||fe(e))&&(e=[e],(nn(n)||fe(n))&&(n=[n])),k(Lo(e),"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),k(Go(e).length===1,"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),rn(n)&&(n=Ud(0,e.length).map(()=>!0)),k(Lo(n),"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),k(Go(n).length===1,"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),k(e.length===n.length,"The arrays passed into the `sort` method must be equal in length."),e=e.map(o=>{if(k(fe(o)||rt(o),"Column references can either be column names (as strings) or column indices (as whole numbers)."),fe(o)){let i=r.columns.indexOf(o);return k(i>-1,`The column "${o}" does not exist!`),i}if(rt(o))return k(parseInt(o)===o,"Column indices must be whole numbers!"),k(o>=0,`The column index ${o} is out of bounds!`),k(o<r.columns.length,`The index ${o} is out of bounds!`),o}),n=n.map(o=>{if(k(fe(o)||nn(o),"Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),fe(o)){let i=o.trim().toLowerCase();return k(i==="ascending"||i==="descending","Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),i==="ascending"}if(nn(o))return o}),r.values=sn(r.values,(o,i)=>{let u=0;for(;o[e[u]]===i[e[u]]&&u<e.length;)u++;let a=n[u];if(o[e[u]]===i[e[u]])return 0;if(o[e[u]]<i[e[u]])return a?-1:1;if(o[e[u]]>i[e[u]])return a?1:-1}),r.index=zd(r.get(null,s).values),r=r.dropColumns(s),r}Ko.exports=Rd});var on=c((E2,Xo)=>{var Jd=U(),Yd=Fe(),$d=G(),Ld=I(),Qo=w();function Gd(t,e){e=(()=>{if(Qo(e))return!0;if(Yd(e))return e;throw new Jd("The `shouldIncludeIndex` parameter of the `toCSVString` method must be a boolean!")})();let n=[""].concat(t.index);return[t.columns].concat(t.values).map((s,o)=>(e?[n[o]]:[]).concat(s).map(u=>Ld(u)?JSON.stringify(u):$d(u)?JSON.stringify(JSON.stringify(u)):Qo(u)?"":u.toString()).join(",")).join(`
`)}Xo.exports=Gd});var Zo=c((I2,an)=>{var un=U(),Wd=on();function Kd(t,e,n){let r=Wd(t,n),s=!1,o=!1,i,u;try{let a=e;if(e.includes("/")){let f=e.split("/");a=f[f.length-1]}let l=document.createElement("a");l.href=`data:text/csv;charset=utf-8,${encodeURIComponent(r)}`,l.download=a,l.dispatchEvent(new MouseEvent("click")),s=!0}catch(a){i=a}try{let a=Ne("fs"),l=Ne("path");a.writeFileSync(l.resolve(e),r,"utf8"),o=!0}catch(a){u=a}if(!s&&!o)throw typeof window<"u"?new un(i):typeof an<"u"?new un(u):new un("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");return t}an.exports=Kd});var cn=c((M2,ei)=>{function Hd(t,e){return JSON.stringify(t.toObject(e))}ei.exports=Hd});var ti=c((A2,fn)=>{var ln=U(),Qd=cn();function Xd(t,e,n){let r=Qd(t,n),s=!1,o=!1,i,u;try{let a=e;if(e.includes("/")){let f=e.split("/");a=f[f.length-1]}let l=document.createElement("a");l.href=`data:application/json;charset=utf-8,${encodeURIComponent(r)}`,l.download=a,l.dispatchEvent(new MouseEvent("click")),s=!0}catch(a){i=a}try{let a=Ne("fs"),l=Ne("path");a.writeFileSync(l.resolve(e),r,"utf8"),o=!0}catch(a){u=a}if(!s&&!o)throw typeof window<"u"?new ln(i):typeof fn<"u"?new ln(u):new ln("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");return t}fn.exports=Xd});var ri=c((j2,ni)=>{var Zd=m(),ep=w();function tp(t,e){ep(e)?e=0:Zd(e===0||e===1,"The axis parameter of the `toObject` method must be undefined, 0, or 1. An axis of 0 indicates that the returned object should be organized first by rows and then by columns. An axis of 1 indicates that the returned object should be organized first by columns and then by rows.");let n={};return e===0?t.index.forEach((r,s)=>{let o={};t.columns.forEach((i,u)=>{o[i]=t.values[s][u]}),n[r]=o}):t.columns.forEach((r,s)=>{let o={};t.index.forEach((i,u)=>{o[i]=t.values[u][s]}),n[r]=o}),n}ni.exports=tp});var ie=c((C2,ii)=>{var si=m(),np=p(),rp=b(),sp=y(),op=W(),oi=Te(),ip=T();function up(t){if(rp(t)||sp(t))return t.transpose();si(np(t),"The `transpose` function only works on arrays, Series, and DataFrames!");let e=ip(t);if(si(e.length<=2,"I'm not smart enough to know how to transpose arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `transpose` function!"),e.length===1)return oi(t);if(e.length===2){let n=op(oi(e));for(let r=0;r<e[0];r++)for(let s=0;s<e[1];s++)n[s][r]=t[r][s];return n}}ii.exports=up});var li=c((k2,ci)=>{var ui=m(),ap=p(),cp=b(),lp=Ye(),fp=y(),hp=T();function ai(t,e,n){if(fp(n))return new t(e.values.concat(n.values));if(ap(n)){let r=hp(n);ui(r.length===1&&!lp(r),"Only vectors can be appended to Series!");let s=e.copy();return n.forEach((o,i)=>{s._values.push(o),s._index.push("item"+(e.values.length+i))}),s}return ui(!cp(n),"DataFrames cannot be appended to Series!"),ai(e,[n])}ci.exports=ai});var hi=c((V2,fi)=>{var mp=m(),dp=j();function pp(t,e){mp(dp(e),"The parameter to the `apply` method must be a function.");let n=t.copy();return n._values=n._values.map((r,s)=>e(r,s)),n}fi.exports=pp});var di=c((z2,mi)=>{var gp=w();function qp(t){let e=t.copy(),n=[];return e._values=e.values.filter((r,s)=>gp(r)?!1:(n.push(e.index[s]),!0)),e._index=n,e}mi.exports=qp});var gi=c((U2,pi)=>{var yp=q();function bp(t,e){let n=[],r=[];e.values.forEach((o,i)=>{yp(o)&&(r.push(o),n.push(e.index[i]))});let s=new t(r);return s.name=e.name,s.index=n,s}pi.exports=bp});var yi=c((R2,qi)=>{var wp=R();function Np(t,e,n){let r=e.copy(),s=wp(r.index),o=[],i=r.values.filter((u,a)=>{let l=n(u,a,r.values);return l||o.push(r.index[a]),l});return o.forEach(u=>{s.splice(s.indexOf(u),1)}),i.length===0?(r=new t,r.name=e.name,r):(r.values=i,r.index=s,r)}qi.exports=Np});var wi=c((P2,bi)=>{var ee=m(),vp=q(),Sp=I(),xp=w(),Tp=z();function _p(t,e){(Sp(e)||vp(e))&&(e=[e]);let n=Tp((e||[]).map(r=>typeof r));return ee(n.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===1&&ee(n[0]==="string"||n[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===2&&(ee(n.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),ee(n.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),xp(e)||(e=e.map(r=>{if(typeof r=="string")return ee(t.index.indexOf(r)>-1,`Index "${r}" does not exist!`),r;if(typeof r=="number")return ee(r>=0,`Index ${r} is out of bounds!`),ee(parseInt(r)===r,"Indices must be integers!"),ee(r<t.index.length,`Index ${r} is out of bounds!`),t.index[r]})),t.getSubsetByNames(e)}bi.exports=_p});var vi=c((B2,Ni)=>{var Me=m(),Op=p(),Fp=w(),Dp=_e(),Ep=C(),Ip=T();function Mp(t,e){let n=t.shape;Fp(e)&&(e=Ep(0,n[0])),Me(Op(e),"The `indices` array must be 1-dimensional array of whole numbers."),Me(Ip(e).length===1,"The `indices` array must be a 1-dimensional array of whole numbers."),Me(e.length>0,"The `indices` array must contain at least one index."),e.forEach(s=>{Me(Dp(s),"The `indices` array must be a 1-dimensional array of whole numbers."),Me(s<t.index.length,`The row index ${s} is out of bounds.`)});let r=e.map(s=>t.index[s]);return t.getSubsetByNames(r)}Ni.exports=Mp});var xi=c((J2,Si)=>{var Ae=m(),Ap=p(),jp=I(),Cp=w(),kp=T();function Vp(t,e,n){Cp(n)&&(n=e.index),Ae(Ap(n),"The `indices` array must be a 1-dimensional array of strings."),Ae(kp(n).length===1,"The `indices` array must be a 1-dimensional array of strings."),Ae(n.length>0,"The `indices` array must contain at least one index name."),n.forEach(o=>{Ae(jp(o),"The `indices` array must contain only strings."),Ae(e.index.indexOf(o)>-1,`The name "${o}" does not exist in the index.`)});let r=n.map(o=>e.values[e.index.indexOf(o)]);if(r.length===1)return r[0];let s=new t(r);return s.index=n,s.name=e.name,s}Si.exports=Vp});var Oi=c((Y2,_i)=>{var zp=R(),Ti=C();function Up(t){let e=t.copy(),n=typeof window>"u"?20:10;if(e.index.length>n){e=e.get(Ti(0,n/2).concat(Ti(e.index.length-n/2,e.index.length)));let s=zp(e.index);s.splice(parseInt(s.length/2),0,"..."),e.values.push("..."),e.index.push("..."),e=e.get(s)}let r={};return e.values.forEach((s,o)=>{let i={};i[e.name]=s,r[e.index[o]]=i}),console.table(r),console.log("Shape:",t.shape,`
`),t}_i.exports=Up});var Di=c(($2,Fi)=>{var Rp=nt();function Pp(t){let e=t.copy();return e.get(Rp(e.index))}Fi.exports=Pp});var Ii=c((L2,Ei)=>{var Bp=m(),Jp=j(),Yp=w(),$p=Q(),Lp=ie();function Gp(t,e,n){n=n||((a,l)=>a<l?-1:1),Bp(Yp(n)||Jp(n),"You must pass undefined, null, or a comparison function as the second argument to the `sort` method!");let r=Lp([e.values,e.index]),s=$p(r,(a,l)=>n(a[0],l[0])),o=[],i=[];s.forEach(a=>{o.push(a[0]),i.push(a[1])});let u=new t;return u._values=o,u._index=i,u.name=e.name,u}Ei.exports=Gp});var ji=c((G2,Ai)=>{var Wp=Q(),Mi=ie();function Kp(t,e){let n=Mi([e.values,e.index]);n=Mi(Wp(n,(s,o)=>{if(s[1]===o[1])return 0;if(s[1]<o[1])return-1;if(s[1]>o[1])return 1}));let r=new t(n[0]);return r.index=n[1],r.name=e.name,r}Ai.exports=Kp});var ki=c((W2,Ci)=>{function Hp(t){let e={};return e[t.name]={},t.index.forEach((n,r)=>{e[t.name][n]=t.values[r]}),e}Ci.exports=Hp});var Pi=c((K2,Ri)=>{var $=m(),st=R(),hn=p(),Qp=I(),Xp=w(),Vi=et(),zi=C(),ot=Te(),Zp=li(),eg=hi(),tg=di(),ng=gi(),rg=yi(),sg=wi(),og=vi(),ig=xi(),ug=Oi(),ag=Di(),cg=Ii(),lg=ji(),fg=ki(),je=T(),hg=ie(),Ui=Symbol.for("@jrc03c/js-math-tools/series");Ri.exports=function(t){class e{static[Symbol.hasInstance](r){try{return!!r._symbol&&r._symbol===Ui}catch{return!1}}constructor(r){let s=this;if(s.name="data",Object.defineProperty(s,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:Ui}),Object.defineProperty(s,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(s,"values",{configurable:!0,enumerable:!0,get(){return s._values},set(o){$(hn(o),"The new values must be a 1-dimensional array!");let i=je(o);$(i.length===1,"The new array of values must be 1-dimensional!"),i[0]<s._index.length?s._index=s._index.slice(0,i[0]):i[0]>s._index.length&&(s._index=s._index.concat(zi(s._index.length,i[0]).map(u=>"item"+Vi(u,(o.length-1).toString().length)))),s._values=o}}),Object.defineProperty(s,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(s,"index",{configurable:!0,enumerable:!0,get(){return s._index},set(o){$(hn(o),"The new index must be a 1-dimensional array of strings!"),$(o.length===s.shape[0],"The new index must be the same length as the old index!"),$(je(o).length===1,"The new index must be a 1-dimensional array of strings!"),o.forEach(i=>{$(Qp(i),"All of the row names must be strings!")}),s._index=o}}),r){if(r instanceof e)s.name=r.name,s.values=st(r.values),s.index=st(r.index);else if(hn(r)){let o=je(r);$(o.length===1,"When passing an array into the constructor of a Series, the array must be 1-dimensional!"),s.values=r}else if(r instanceof Object){let o=Object.keys(r);$(o.length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");let i=o[0],u=r[i];$(je(u).length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!"),s.name=i,s.values=u.slice()}}}get shape(){return je(this.values)}get length(){return this.shape[0]}get isEmpty(){return this.values.filter(s=>!Xp(s)).length===0}clear(){let s=this.copy();return s.values.forEach((o,i)=>{s.values[i]=void 0}),s}get(r){return sg(this,r)}getSubsetByNames(r){return ig(e,this,r)}getSubsetByIndices(r){return og(this,r)}loc(r){return this.getSubsetByNames(r)}iloc(r){return this.getSubsetByIndices(r)}reverse(){let r=this,s=new e(ot(r.values));return s.index=ot(r.index),s.name=r.name,s}resetIndex(){let r=this,s=r.copy();return s.index=zi(0,r.shape[0]).map(o=>"item"+Vi(o,(s.index.length-1).toString().length)),s}copy(){let r=this,s=new e;return s._values=st(r.values),s._index=st(r.index),s.name=r.name,s}append(r){return Zp(e,this,r)}apply(r){return eg(this,r)}concat(r){return this.append(r)}dropMissing(r,s){return tg(this,r,s)}dropNaN(){return ng(e,this)}toObject(){return fg(this)}print(){return ug(this)}shuffle(){return ag(this)}sort(r){return cg(e,this,r)}sortByIndex(){return lg(e,this)}filter(r){return rg(e,this,r)}toDataFrame(){let r=this,s=new t(hg([r.values]));return s.columns=[r.name],s.index=r.index,s}transpose(){let s=this.copy();return s.values=ot(s.values),s.index=ot(s.index),s}getDummies(){return this.toDataFrame().getDummies()}oneHotEncode(){return this.getDummies()}}return e}});var ke=c((H2,Gi)=>{var B=m(),mn=R(),Bi=Je(),mg=qs(),dg=vs(),pg=_s(),gg=Fs(),qg=Cs(),yg=zs(),bg=Bs(),wg=Ls(),Ng=eo(),vg=Zt(),Sg=ro(),Ji=co(),xg=yo(),Tg=So(),_g=To(),Og=Fo(),Fg=$o(),Dg=Ho(),Eg=Zo(),Ig=on(),Mg=ti(),Ag=cn(),jg=ri(),Cg=F(),Ce=p(),kg=G(),Yi=w(),dn=et(),Vg=W(),pn=C(),he=T(),$i=ie(),Li=Symbol.for("@jrc03c/js-math-tools/dataframe");function it(t){let e="abcdefghijklmnopqrstuvwxyz1234567890",n="";for(let r=0;r<t;r++)n+=e[parseInt(Math.random()*e.length)];return n}var D=class{static[Symbol.hasInstance](e){try{return!!e._symbol&&e._symbol===Li}catch{return!1}}constructor(e){let n=this;if(Object.defineProperty(n,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:Li}),Object.defineProperty(n,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(n,"values",{configurable:!0,enumerable:!0,get(){return n._values.length===0||!Yi(n._values[0])&&n._values[0].length===0?[[]]:n._values},set(r){B(Ce(r),"The new values must be a 2-dimensional array!");let s=he(r);B(s.length===2,"The new array of values must be 2-dimensional!"),s[0]<n._index.length?n._index=n._index.slice(0,s[0]):s[0]>n._index.length&&(n._index=n._index.concat(pn(n._index.length,s[0]).map(o=>"row"+dn(o,(s[0]-1).toString().length)))),s[1]<n._columns.length?n._columns=n._columns.slice(0,s[1]):s[1]>n._columns.length&&(n._columns=n._columns.concat(pn(n._columns.length,s[1]).map(o=>"col"+dn(o,(s[1]-1).toString().length)))),n._values=r}}),Object.defineProperty(n,"_columns",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(n,"columns",{configurable:!0,enumerable:!0,get(){return n._columns},set(r){B(Ce(r),"The new columns list must be a 1-dimensional array of strings!"),B(n.isEmpty||r.length===n.shape[1],"The new columns list must be the same length as the old columns list!"),B(he(r).length===1,"The new columns list must be a 1-dimensional array of strings!"),r=r.map(o=>(typeof o!="string"&&(o=JSON.stringify(o)||o.toString()),o.trim().length===0?"untitled_"+it(8):o.trim()));let s=(()=>{let o=Bi(r),i={};return o.forEach(u=>{i[u.item]=u.count}),i})();r=r.map(o=>s[o]>1?o+"_"+it(8):o),n._columns=r}}),Object.defineProperty(n,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(n,"index",{configurable:!0,enumerable:!0,get(){return n._index},set(r){B(Ce(r),"The new index must be a 1-dimensional array of strings!"),B(n.isEmpty||r.length===n.shape[0],"The new index must be the same length as the old index!"),B(he(r).length===1,"The new index must be a 1-dimensional array of strings!"),r=r.map(o=>(typeof o!="string"&&(o=JSON.stringify(o)||o.toString()),o.trim().length===0?"untitled_"+it(8):o.trim()));let s=(()=>{let o=Bi(r),i={};return o.forEach(u=>{i[u.item]=u.count}),i})();r=r.map(o=>s[o]>1?o+"_"+it(8):o),n._index=r}}),B(Yi(e)||kg(e)||Ce(e),"The `data` passed into the constructor of a DataFrame must be either (1) an object where the key-value pairs are (respectively) column names and 1-dimensional arrays of values, or (2) a 2-dimensional array of values."),e)if(e instanceof D)n.values=mn(e.values),n.columns=mn(e.columns),n.index=mn(e.index);else if(Ce(e)){let r=he(e);B(r.length===2,"The `data` array passed into the constructor of a DataFrame must be 2-dimensional!"),n.values=e}else{n._columns=Object.keys(e);let r=[];n._columns.forEach(o=>{let i=e[o];r.push(i)}),n._values=$i(r);let s=he(n.values);n._index=pn(0,s[0]).map(o=>"row"+dn(o,(s[0]-1).toString().length))}}get shape(){return he(this.values)}get length(){return this.shape[0]}get width(){return this.shape[1]}get rows(){return this.index}set rows(e){let n=this;n.index=e}get isEmpty(){return Cg(this.values).length===0}clear(){let e=this,n=new D(Vg(e.shape));return n.columns=e.columns.slice(),n.index=e.index.slice(),n}get(e,n){let r=this;if(arguments.length===0)return r;if(arguments.length===1)try{return r.get(null,e)}catch{return r.get(e,null)}return Sg(r,e,n)}getSubsetByNames(e,n){return Tg(D,te,this,e,n)}getSubsetByIndices(e,n){return xg(this,e,n)}getDummies(e){return Ji(D,this,e)}oneHotEncode(e){return Ji(D,this,e)}transpose(){let e=this,n=new D($i(e.values));return n.columns=e.index.slice(),n.index=e.columns.slice(),n}get T(){return this.transpose()}resetIndex(e){return Og(this,e)}copy(){return gg(D,this)}assign(e,n){return pg(D,te,this,e,n)}apply(e,n){return dg(D,te,this,e,n)}dropMissing(e,n,r){return yg(D,te,this,e,n,r)}dropNaN(e,n,r){return bg(D,this,e,n,r)}drop(e,n){return qg(D,te,this,e,n)}dropColumns(e){return this.drop(null,e)}dropRows(e){return this.drop(e,null)}toObject(e){return jg(this,e)}toCSVString(e){return Ig(this,e)}saveAsCSV(e,n){return Eg(this,e,n)}toJSONString(e){return Ag(this,e)}saveAsJSON(e,n){return Mg(this,e,n)}print(){return _g(D,te,this)}sort(e,n){return Dg(this,e,n)}sortByIndex(){return this.sort()}filter(e,n){return wg(D,te,this,e,n)}shuffle(e){return Fg(this,e)}append(e,n){return mg(this,e,n)}concat(e,n){return this.append(e,n)}join(e,n){return this.append(e,n)}toString(){let e=this;return JSON.stringify(e)}};D.fromCSV=function(){return Ng(D,...arguments)};D.fromCSVString=function(){return vg(D,...arguments)};var te=Pi()(D);Gi.exports={DataFrame:D,Series:te}});var S=c((Q2,Xi)=>{var{DataFrame:Wi,Series:Ki}=ke(),Hi=m(),Ve=p(),gn=b(),Qi=P(),zg=j(),qn=y(),Ug=oe(),Rg=C(),ut=T();function Pg(t){return Ve(t)||qn(t)||gn(t)}function Bg(t){return Hi(zg(t),"You must pass a function into the `vectorize` function!"),function e(){let n,r,s=[],o=[],i=Object.keys(arguments).filter(u=>{let a=arguments[u];return Ve(a)?!0:qn(a)?(n=!0,s.push(a),!0):gn(a)?(r=!0,o.push(a),!0):!1}).map(u=>arguments[u]);if(i.slice(0,-1).forEach((u,a)=>{Hi(Qi(Ve(u)?ut(u):u.shape,Ve(i[a+1])?ut(i[a+1]):i[a+1].shape),`When passing multiple arrays into the \`${t.name}\` function, all of the arrays must have the same shape!`)}),i.length>0){let u=Ug(i.map(l=>l.length?l.length:l.values.length)),a=Rg(0,u).map(l=>{let f=Object.keys(arguments).map(h=>{if(Pg(arguments[h])){if(Ve(arguments[h]))return arguments[h][l];if(qn(arguments[h]))return arguments[h].values[l];if(gn(arguments[h]))return arguments[h].values[l]}else return arguments[h]});return e(...f)});if(r)try{if(o.length===1&&Qi(ut(o[0]),ut(a))){let l=new Wi(a);return l.index=o[0].index.slice(),l.columns=o[0].columns.slice(),l}else return new Wi(a)}catch{return a}if(n)try{if(s.length===1&&s[0].length===a.length){let l=new Ki(a);return l.name=s[0].name,l.index=s[0].index.slice(),l}else return new Ki(a)}catch{return a}return a}else return t(...arguments)}}Xi.exports=Bg});var at=c((X2,Zi)=>{var Jg=q(),Yg=S();function $g(t){try{return Jg(t)?Math.abs(t):NaN}catch{return NaN}}Zi.exports=Yg($g)});var ct=c((Z2,eu)=>{var Lg=q(),Gg=S();function Wg(){try{let t=0,e=Object.values(arguments);for(let n=0;n<e.length;n++){if(!Lg(e[n]))return NaN;t+=e[n]}return t}catch{return NaN}}eu.exports=Gg(Wg)});var lt=c((ex,tu)=>{var Kg=S();function Hg(t,e){try{return e(t)}catch{return NaN}}tu.exports=Kg(Hg)});var ru=c((tx,nu)=>{var Qg=q(),Xg=S();function Zg(t){try{return Qg(t)?Math.acos(t):NaN}catch{return NaN}}nu.exports=Xg(Zg)});var ou=c((nx,su)=>{var eq=q(),tq=S();function nq(t){try{return eq(t)?Math.asin(t):NaN}catch{return NaN}}su.exports=tq(nq)});var uu=c((rx,iu)=>{var rq=q(),sq=S();function oq(t){try{return rq(t)?Math.atan(t):NaN}catch{return NaN}}iu.exports=sq(oq)});var cu=c((sx,au)=>{var iq=m(),uq=ve(),aq=p(),cq=b(),lq=y(),fq=oe();function yn(t){if(cq(t)){let e=yn(t.values);return[t.index[e[0]],t.columns[e[1]]]}if(lq(t)){let e=yn(t.values);return[t.index[e]]}iq(aq(t),"The `argmax` function only works on arrays, Series, and DataFrames!");try{let e=uq(t,fq(t));return e?e.length===0?void 0:e.length===1?e[0]:e:void 0}catch{return}}au.exports=yn});var ft=c((ox,fu)=>{var hq=m(),mq=F(),dq=p(),pq=b(),gq=y();function lu(t){if(pq(t)||gq(t))return lu(t.values);hq(dq(t),"The `min` function only works on arrays, Series, and DataFrames!");try{return Math.min(...mq(t))}catch{return NaN}}fu.exports=lu});var mu=c((ix,hu)=>{var qq=m(),yq=ve(),bq=p(),wq=b(),Nq=y(),vq=ft();function bn(t){if(wq(t)){let e=bn(t.values);return[t.index[e[0]],t.columns[e[1]]]}if(Nq(t)){let e=bn(t.values);return[t.index[e]]}qq(bq(t),"The `argmin` function only works on arrays, Series, and DataFrames!");try{let e=yq(t,vq(t));return e?e.length===0?void 0:e.length===1?e[0]:e:void 0}catch{return}}hu.exports=bn});var pu=c((ux,du)=>{var Sq=q(),xq=S();function Tq(t){try{return Sq(t)?Math.ceil(t):NaN}catch{return NaN}}du.exports=xq(Tq)});var yu=c((ax,qu)=>{var _q=at(),gu=q(),Oq=w(),Fq=S();function Dq(t,e){try{if(!gu(t))return NaN;if(Oq(e))e=1e-10;else if(!gu(e))return NaN;return _q(t)<e?0:t}catch{return NaN}}qu.exports=Fq(Dq)});var wu=c((cx,bu)=>{var wn=q(),Eq=S();function Iq(t,e,n){try{return wn(t)?wn(e)?wn(n)?t<e?e:t>n?n:t:NaN:NaN:NaN}catch{return NaN}}bu.exports=Eq(Iq)});var vu=c((lx,Nu)=>{var Nn=m(),Mq=F(),Aq=p(),jq=b(),Cq=q(),kq=y();function vn(t,e){if(jq(t)||kq(t))return vn(t.values,e);if(Nn(Aq(t),"The `combinations` function only works on arrays, Series, and DataFrames!"),Nn(Cq(e),"`r` must be a whole number!"),t=Mq(t),e>t.length)return[t];if(e<=0)return[[]];if(Nn(e===parseInt(e),"`r` must be a whole number!"),t.length<2)return t;let n=[];return t.forEach((r,s)=>{let o=t.slice(s+1);if(o.length<e-1)return;vn(o,e-1).forEach(u=>{n.push([r].concat(u))})}),n}Nu.exports=vn});var ht=c((fx,xu)=>{var Vq=m(),zq=F(),Uq=p(),Rq=b(),Pq=y();function Su(t){if(Rq(t)||Pq(t))return Su(t.values);Vq(Uq(t),"The `mean` function only works on arrays, Series, and DataFrames!");try{let e=zq(t),n=0;return e.forEach(r=>{n+=r}),n/e.length}catch{return NaN}}xu.exports=Su});var xn=c((hx,Eu)=>{var Tu=m(),_u=p(),mt=q(),Ou=y(),Fu=ht(),Du=T();function Sn(t,e){if(Ou(t))return Sn(t.values,e);if(Ou(e))return Sn(t,e.values);Tu(_u(t)&&_u(e)&&Du(t).length===1&&Du(e).length===1,"The `covariance` function only works on 1-dimensional arrays and Series!"),Tu(t.length===e.length,"The two arrays or Series passed into the `covariance` function must have the same length!");try{let n=Fu(t),r=Fu(e);if(!mt(n)||!mt(r))return NaN;let s=Math.max(t.length,e.length),o=0;for(let i=0;i<s;i++){if(!mt(t[i]))return NaN;if(!mt(e[i]))return NaN;o+=(t[i]-n)*(e[i]-r)}return o/t.length}catch{return NaN}}Eu.exports=Sn});var dt=c((mx,Iu)=>{var Bq=q(),Jq=S();function Yq(t){try{return Bq(t)?Math.sqrt(t):NaN}catch{return NaN}}Iu.exports=Jq(Yq)});var Tn=c((dx,Au)=>{var $q=m(),Lq=F(),Gq=p(),Wq=b(),Kq=q(),Hq=y(),Qq=ht();function Mu(t){if(Wq(t)||Hq(t))return Mu(t.values);$q(Gq(t),"The `variance` function only works on arrays, Series, and DataFrames!");try{let e=Lq(t),n=Qq(e),r=0;for(let s=0;s<e.length;s++){if(!Kq(e[s]))return NaN;r+=(e[s]-n)*(e[s]-n)}return r/e.length}catch{return NaN}}Au.exports=Mu});var pt=c((px,Cu)=>{var Xq=m(),Zq=p(),ey=b(),ty=y(),ny=dt(),ry=Tn();function ju(t){if(ey(t)||ty(t))return ju(t.values);Xq(Zq(t),"The `std` function only works on arrays, Series, and DataFrames!");try{return ny(ry(t))}catch{return NaN}}Cu.exports=ju});var Bu=c((gx,Pu)=>{var ku=m(),sy=xn(),Vu=p(),zu=y(),Uu=T(),Ru=pt();function _n(t,e){if(zu(t))return _n(t.values,e);if(zu(e))return _n(t,e.values);ku(Vu(t)&&Vu(e)&&Uu(t).length===1&&Uu(e).length===1,"The `correl` function only works on 1-dimensional arrays and Series!"),ku(t.length===e.length,"The two arrays or Series passed into the `correl` function must have the same length!");try{return sy(t,e)/(Ru(t)*Ru(e))}catch{return NaN}}Pu.exports=_n});var Yu=c((qx,Ju)=>{var oy=q(),iy=S();function uy(t){try{return oy(t)?Math.cos(t):NaN}catch{return NaN}}Ju.exports=iy(uy)});var Hu=c((yx,Ku)=>{var ay=m(),$u=p(),Lu=b(),cy=P(),Gu=y(),Wu=z();function On(t,e){if(Lu(t)||Gu(t))return On(t.values,e);if(Lu(e)||Gu(e))return On(t,e.values);ay($u(t)&&$u(e),"The `diff` function only works on arrays, Series, and DataFrames!");let n=Wu(t),r=Wu(e),s=[];return n.forEach(o=>{r.findIndex(i=>cy(i,o))<0&&s.push(o)}),s}Ku.exports=On});var gt=c((bx,Xu)=>{var Qu=q(),ly=S();function fy(t,e){try{return Qu(t)?Qu(e)?Math.pow(t,e):NaN:NaN}catch{return NaN}}Xu.exports=ly(fy)});var Fn=c((wx,Zu)=>{var hy=q(),my=S();function dy(){try{let t=Object.values(arguments);if(t.length===0)return NaN;let e=1;for(let n=0;n<t.length;n++){if(!hy(t[n]))return NaN;e*=t[n]}return e}catch{return NaN}}Zu.exports=my(dy)});var me=c((Nx,ea)=>{var py=Fn();function gy(){return py(...arguments)}ea.exports=gy});var Dn=c((vx,ta)=>{var qy=ct(),yy=me();function by(t,e){return qy(t,yy(e,-1))}ta.exports=by});var qt=c((Sx,ra)=>{var wy=m(),Ny=F(),vy=p(),Sy=b(),xy=y();function na(t){if(Sy(t)||xy(t))return na(t.values);wy(vy(t),"The `sum` function only works on arrays, Series, and DataFrames!");try{return t.length===0?NaN:Ny(t).reduce((e,n)=>e+n,0)}catch{return NaN}}ra.exports=na});var la=c((xx,ca)=>{var Ty=at(),_y=m(),sa=p(),oa=b(),Oy=P(),ia=q(),ua=y(),Fy=gt(),aa=T(),Dy=dt(),Ey=Dn(),Iy=qt();function En(t,e){if(ia(t)&&ia(e))return Ty(t-e);if(oa(t)||ua(t))return En(t.values,e);if(oa(e)||ua(e))return En(t,e.values);sa(t)&&sa(e)&&_y(Oy(aa(t),aa(e)),"If passing two arrays, Series, or DataFrames into the `distance` function, then those objects must have the same shape!");try{return Dy(Iy(Fy(Ey(t,e),2)))}catch{return NaN}}ca.exports=En});var ha=c((Tx,fa)=>{var My=gt(),Ay=me();function jy(t,e){return Ay(t,My(e,-1))}fa.exports=jy});var Mn=c((_x,ya)=>{var{DataFrame:ma,Series:da}=ke(),yt=m(),pa=F(),ga=p(),In=b(),Cy=q(),bt=y(),ky=me(),wt=T(),Vy=qt(),qa=ie();function ne(t,e){if(In(t)){let s=ne(t.values,e);if(wt(s).length===1){let o=new da(s);return o.name=bt(e)?e.name:o.name,o.index=t.index.slice(),o}else{let o=new ma(s);return o.index=t.index.slice(),In(e)&&(o.columns=e.columns.slice()),o}}if(In(e)){let s=ne(t,e.values);if(wt(s).length===1){let o=new da(s);return o.name=bt(t)?t.name:o.name,o.index=e.columns.slice(),o}else{let o=new ma(s);return o.columns=e.columns.slice(),o}}if(bt(t))return ne(t.values,e);if(bt(e))return ne(t,e.values);yt(ga(t)&&ga(e),"The `dot` function only works on arrays, Series, and DataFrames!"),pa(t).concat(pa(e)).forEach(s=>{yt(Cy(s),"One of the arrays you passed into the `dot` function contains non-numerical values!")});let n=wt(t),r=wt(e);if(yt(n.length<=2&&r.length<=2,"I'm not smart enough to know how to get the dot-product of arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `dot` function!"),yt(n[n.length-1]===r[0],`There's a dimension misalignment in the two arrays you passed into the \`dot\` function. (${n[n.length-1]} !== ${r[0]})`),n.length===1&&r.length===1)return Vy(ky(t,e));if(n.length===1&&r.length===2)return qa(e).map(s=>ne(t,s));if(n.length===2&&r.length===1)return t.map(s=>ne(s,e));if(n.length===2&&r.length===2){let s=qa(e),o=[];for(let i=0;i<t.length;i++){let u=[];for(let a=0;a<s.length;a++)u.push(ne(t[i],s[a]));o.push(u)}return o}}ya.exports=ne});var An=c((Ox,wa)=>{var zy=m(),Uy=p(),Ry=b(),Py=y(),By=w();function ba(t){if(Ry(t)||Py(t))return t.dropMissing(...Object.values(arguments).slice(1));zy(Uy(t),"The `dropMissing` function only works on arrays, Series, and DataFrames!");let e=[];return t.forEach(n=>{try{return e.push(ba(n))}catch{By(n)||e.push(n)}}),e}wa.exports=ba});var Fa=c((Fx,Oa)=>{var Na=m(),va=p(),Sa=b(),Jy=P(),xa=y(),Ta=w(),_a=T();function Nt(t,e){if(Sa(t)||xa(t))return Nt(t.values,e);if(Sa(e)||xa(e))return Nt(t,e.values);Na(va(t)&&va(e),"The `dropMissingPairwise` function only works on arrays, Series, and DataFrames!"),Na(Jy(_a(t),_a(e)),"The two arrays, Series, and/or DataFrames passed into the `dropMissingPairwise` function must have the same shape!");let n=[],r=[];for(let s=0;s<t.length;s++)try{let[o,i]=Nt(t[s],e[s]);n.push(o),r.push(i)}catch{!Ta(t[s])&&!Ta(e[s])&&(n.push(t[s]),r.push(e[s]))}return[n,r]}Oa.exports=Nt});var ka=c((Dx,Ca)=>{var Da=m(),Ea=p(),Ia=b(),Yy=P(),Ma=q(),Aa=y(),ja=T();function vt(t,e){if(Ia(t)||Aa(t))return vt(t.values,e);if(Ia(e)||Aa(e))return vt(t,e.values);Da(Ea(t)&&Ea(e),"The `dropNaNPairwise` only works on arrays, Series, and DataFrames!"),Da(Yy(ja(t),ja(e)),"The two arrays, Series, and/or DataFrames passed into the `dropNaNPairwise` must have the same shape!");let n=[],r=[];for(let s=0;s<t.length;s++)try{let[o,i]=vt(t[s],e[s]);n.push(o),r.push(i)}catch{Ma(t[s])&&Ma(e[s])&&(n.push(t[s]),r.push(e[s]))}return[n,r]}Ca.exports=vt});var za=c((Ex,Va)=>{var $y=An();function Ly(t){return $y(t)}Va.exports=Ly});var Ra=c((Ix,Ua)=>{var Gy=q(),Wy=S();function Ky(t){try{return Gy(t)?Math.exp(t):NaN}catch{return NaN}}Ua.exports=Wy(Ky)});var Ja=c((Mx,Ba)=>{var Hy=S();function Pa(t){try{return t!==parseInt(t)?NaN:t<=1?1:t*Pa(t-1)}catch{return NaN}}Ba.exports=Hy(Pa)});var Ga=c((Ax,La)=>{var Qy=m(),Xy=F(),Ya=p(),Zy=b(),e1=j(),$a=G(),t1=y();function jn(t,e){if(Zy(t))return jn(Xy(t.values),e);if(t1(t))return jn(t.values,e);if(Qy($a(t)||Ya(t),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `find` function!"),!e1(e)){let s=e;e=o=>o===s}function n(s,o,i){if(i=i||[],i.indexOf(s)>-1)return null;if($a(s)){i.push(s);let u=Object.keys(s);for(let a=0;a<u.length;a++){let l=u[a],f=s[l];if(o(f))return f;let h=n(f,o,i);if(h)return h}}else if(Ya(s)){i.push(s);for(let u=0;u<s.length;u++){let a=s[u];if(o(a))return a;let l=n(a,o,i);if(l)return l}}else if(o(s))return s;return null}function r(s){try{return e(s)}catch{return!1}}return n(t,r)}La.exports=jn});var Qa=c((jx,Ha)=>{var n1=m(),r1=F(),Wa=p(),s1=b(),o1=j(),Ka=G(),i1=y();function Cn(t,e){if(s1(t))return Cn(r1(t.values),e);if(i1(t))return Cn(t.values,e);if(n1(Ka(t)||Wa(t),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `findAll` function!"),!o1(e)){let o=e;e=i=>i===o}function n(o,i,u){if(u=u||[],u.indexOf(o)>-1)return null;if(Ka(o)){u.push(o);let a=Object.keys(o),l=[];for(let f=0;f<a.length;f++){let h=a[f],d=o[h],g=!1;i(d)&&(l.push(d),g=!0);let N=n(d,i,u);N&&N.length>0&&N.slice(g?1:0).forEach(v=>l.push(v))}return l}else if(Wa(o)){u.push(o);let a=[];for(let l=0;l<o.length;l++){let f=o[l],h=!1;i(f)&&(a.push(f),h=!0);let d=n(f,i,u);d&&d.length>0&&d.slice(h?1:0).forEach(g=>a.push(g))}return a}else if(i(o))return[o];return null}function r(o){try{return e(o)}catch{return!1}}let s=n(t,r);return s&&s.length>0?s:null}Ha.exports=Cn});var Za=c((Cx,Xa)=>{var u1=q(),a1=S();function c1(t){try{if(t==="Infinity")return 1/0;if(t==="-Infinity")return-1/0;let e=JSON.parse(t);return u1(e)?e:NaN}catch{return NaN}}Xa.exports=a1(c1)});var tc=c((kx,ec)=>{var l1=q(),f1=S();function h1(t){try{return l1(t)?Math.floor(t):NaN}catch{return NaN}}ec.exports=f1(h1)});var kn=c((Vx,nc)=>{var m1=q(),d1=Ee(),p1=tt();function g1(t){m1(t)&&(t=[t]);let e=[],n=d1(t);for(let r=0;r<n;r++)e.push(0);return p1(e,t)}nc.exports=g1});var sc=c((zx,rc)=>{var St=m(),q1=q(),y1=w(),b1=kn();function w1(t){St(!y1(t),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),St(q1(t),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),St(parseInt(t)===t,"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),St(t>0,"You must pass an integer greater than 0 (representing the size) into the `identity` function!");let e=b1([t,t]);for(let n=0;n<t;n++)e[n][n]=1;return e}rc.exports=w1});var ic=c((Ux,oc)=>{var N1=q(),v1=S();function S1(t){try{let e=JSON.parse(t);return N1(e)?parseInt(e):NaN}catch{return NaN}}oc.exports=v1(S1)});var ac=c((Rx,uc)=>{var x1=m(),T1=p(),_1=b(),O1=P(),F1=y(),Vn=z();function D1(){let t=Object.values(arguments).map(n=>_1(n)||F1(n)?Vn(n.values):(x1(T1(n),"The `intersect` function only works on arrays, Series, and DataFrames!"),Vn(n)));return Vn(t).filter(n=>t.every(r=>r.findIndex(s=>O1(s,n))>-1))}uc.exports=D1});var hc=c((Px,fc)=>{var cc=ct(),re=m(),E1=Mn(),I1=F(),M1=p(),A1=b(),zn=q(),lc=me(),j1=T();function xt(t){if(A1(t)){let n=t.copy();return n.values=xt(n.values),n}re(M1(t),"The `inverse` function only works on square 2-dimensional arrays or DataFrames!"),I1(t).forEach(n=>re(zn(n),"The array passed into the `inverse` function must contain only numbers!"));let e=j1(t);if(re(e.length===2,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),re(e[0]===e[1],"The array passed into the `inverse` function must be exactly two-dimensional and square!"),re(e[0]>=0,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),e[0]===0)return t;if(e[0]===1)return re(t[0][0]!==0,"This matrix cannot be inverted!"),1/t[0][0];if(e[0]===2){let n=t[0][0],r=t[0][1],s=t[1][0],o=t[1][1],i=n*o-r*s;re(i!==0,"This matrix cannot be inverted!");let u=[[o,-r],[-s,n]];return lc(u,1/i)}else if(e[0]>1){let n=(r,s)=>zn(r)||zn(s)?lc(r,s):E1(r,s);for(let r=1;r<e[0]-1;r++)try{let s=t.slice(0,r).map(v=>v.slice(0,r)),o=t.slice(0,r).map(v=>v.slice(r,e[0])),i=t.slice(r,e[0]).map(v=>v.slice(0,r)),u=t.slice(r,e[0]).map(v=>v.slice(r,e[0])),a=xt(s),l=xt(cc(u,n(-1,n(n(i,a),o)))),f=cc(a,n(n(n(n(a,o),l),i),a)),h=n(-1,n(n(a,o),l)),d=n(-1,n(n(l,i),a)),g=l;return f.map((v,A)=>v.concat(h[A])).concat(d.map((v,A)=>v.concat(g[A])))}catch{}re(!1,"This matrix cannot be inverted!")}}fc.exports=xt});var dc=c((Bx,mc)=>{var Un=q(),C1=S();function k1(t,e,n){try{return Un(t)?Un(e)?Un(n)?n*(e-t)+t:NaN:NaN:NaN}catch{return NaN}}mc.exports=C1(k1)});var qc=c((Jx,gc)=>{var pc=q(),V1=w(),z1=S();function U1(t,e){try{return e=V1(e)?Math.E:e,pc(t)?pc(e)?Math.log(t)/Math.log(e):NaN:NaN}catch{return NaN}}gc.exports=z1(U1)});var wc=c((Yx,bc)=>{var R1=m(),P1=F(),B1=p(),J1=b(),Y1=y(),$1=Q();function yc(t){if(J1(t)||Y1(t))return yc(t.values);R1(B1(t),"The `median` function only works on arrays, Series, and DataFrames!");try{let e=$1(P1(t));return e.length===0?NaN:e.length%2===0?(e[e.length/2-1]+e[e.length/2])/2:e[parseInt(e.length/2)]}catch{return NaN}}bc.exports=yc});var Sc=c(($x,vc)=>{var Nc=q(),L1=S();function G1(t,e){try{return Nc(t)?Nc(e)?t%e:NaN:NaN}catch{return NaN}}vc.exports=L1(G1)});var Oc=c((Lx,_c)=>{var W1=m(),K1=Je(),H1=F(),Q1=p(),X1=b(),Z1=y(),eb=z(),xc=Q();function Tc(t){if(X1(t)||Z1(t))return Tc(t.values);W1(Q1(t),"The `mode` function only works on arrays, Series, and DataFrames!");try{if(t.length===0)return NaN;let e=H1(t);if(e.length===0)return NaN;let n={},r=eb(e);r.forEach(u=>{n[u]=K1(e,u)});let s=xc(r,(u,a)=>n[a]-n[u]),o=s[0];return xc(s.filter(u=>n[u]===n[o]))}catch{return NaN}}_c.exports=Tc});var Ic=c((Gx,Ec)=>{var{random:Fc}=le(),tb=lt(),nb=w(),rb=W();function Dc(){let t=Fc(),e=Fc();return Math.sqrt(-2*Math.log(t))*Math.cos(2*Math.PI*e)}function sb(t){return nb(t)?Dc():tb(rb(t),Dc)}Ec.exports=sb});var Ac=c((Wx,Mc)=>{var ob=lt(),ib=W();function ub(t){return ob(ib(t),()=>1)}Mc.exports=ub});var Cc=c((Kx,jc)=>{var Rn=m(),ab=F(),cb=p(),lb=b(),fb=q(),hb=y(),mb=w();function Tt(t,e){if(lb(t)||hb(t))return Tt(t.values,e);if(Rn(cb(t),"The `permutations` function only works on arrays, Series, and DataFrames!"),mb(e)&&(e=t.length),Rn(fb(e),"`r` must be a whole number!"),t=ab(t),e>t.length)return Tt(t);if(e<=0)return[[]];if(Rn(e===parseInt(e),"`r` must be a whole number!"),t.length<2)return t;let n=[];return t.forEach((r,s)=>{let o=t.slice(0,s),i=t.slice(s+1),u=o.concat(i);Tt(u,e-1).forEach(l=>{n.push([r].concat(l))})}),n}jc.exports=Tt});var Vc=c((Hx,kc)=>{var{DataFrame:db,Series:pb}=ke(),gb=p(),qb=b(),yb=xe(),bb=y(),wb=T();function Nb(){Object.keys(arguments).forEach(t=>{let e=arguments[t];if(gb(e))if(yb(e))console.log(e);else{let n=wb(e);n.length===1?new pb(e).print():n.length==2?new db(e).print():console.log(e)}else qb(e)||bb(e)?e.print():console.log(e)})}kc.exports=Nb});var Rc=c((Qx,Uc)=>{var vb=p(),Sb=q(),zc=w(),xb=oe(),Tb=ft(),_b=S(),Ob=_b(function(t,e,n,r,s){try{return[t,e,n,r,s].every(o=>Sb(o))?n-e===0?NaN:(s-r)*(t-e)/(n-e)+r:NaN}catch{return NaN}});function Fb(t,e,n,r,s){return vb(t)&&zc(r)&&zc(s)&&(r=e,s=n,e=Tb(t),n=xb(t)),Ob(t,e,n,r,s)}Uc.exports=Fb});var Bc=c((Xx,Pc)=>{var Db=q(),Eb=S();function Ib(t){try{return Db(t)?Math.round(t):NaN}catch{return NaN}}Pc.exports=Eb(Ib)});var Yc=c((Zx,Jc)=>{var Mb=q(),Ab=S();function jb(t){try{return Mb(t)?t<0?-1:t>0?1:0:NaN}catch{return NaN}}Jc.exports=Ab(jb)});var Lc=c((eT,$c)=>{var Cb=q(),kb=S();function Vb(t){try{return Cb(t)?Math.sin(t):NaN}catch{return NaN}}$c.exports=kb(Vb)});var Wc=c((tT,Gc)=>{var zb=pt();function Ub(t){return zb(t)}Gc.exports=Ub});var Hc=c((nT,Kc)=>{var Rb=q(),Pb=S();function Bb(t){try{return Rb(t)?Math.tan(t):NaN}catch{return NaN}}Kc.exports=Pb(Bb)});var _t=c((rT,Zc)=>{var Qc=m(),Xc=j();function Jb(t,e){Qc(Xc(t),"`fn` must be a function!");let n=new Date;return e?t(...e):t(),new Date-n}async function Yb(t,e){Qc(Xc(t),"`fn` must be a function!");let n=new Date;return e?await t(...e):await t(),new Date-n}Zc.exports={timeSync:Jb,timeAsync:Yb}});var tl=c((sT,el)=>{var $b=p(),Lb=b(),Gb=y(),Wb=z();function Kb(){return Wb([...arguments].map(t=>$b(t)?t:Lb(t)||Gb(t)?t.values:[t]))}el.exports=Kb});var rl=c((oT,nl)=>{var Hb=m(),Qb=p(),Xb=b(),Zb=y(),ew=w(),tw=oe(),nw=C();function rw(){let t=[],e=Object.values(arguments).map(n=>((Xb(n)||Zb(n))&&(n=n.values),Hb(Qb(n),"The `zip` function only works on arrays, Series, and DataFrames!"),n));return nw(0,tw(e.map(n=>n.length))).forEach(n=>{let r=[];e.forEach(s=>{let o=s[n];r.push(ew(o)?void 0:o)}),t.push(r)}),t}nl.exports=rw});var x=c((iT,Pn)=>{var{DataFrame:sw,Series:ow}=ke(),de={abs:at(),add:ct(),apply:lt(),arccos:ru(),arcsin:ou(),arctan:uu(),argmax:cu(),argmin:mu(),assert:m(),ceil:pu(),chop:yu(),clamp:wu(),combinations:vu(),copy:R(),correl:Bu(),cos:Yu(),count:Je(),covariance:xn(),DataFrame:sw,diff:Hu(),distance:la(),divide:ha(),dot:Mn(),dropMissing:An(),dropMissingPairwise:Fa(),dropNaN:Qt(),dropNaNPairwise:ka(),dropUndefined:za(),exp:Ra(),factorial:Ja(),find:Ga(),findAll:Qa(),flatten:F(),float:Za(),floor:tc(),identity:sc(),indexOf:ve(),int:ic(),intersect:ac(),inverse:hc(),isArray:p(),isBoolean:Fe(),isDataFrame:b(),isEqual:P(),isFunction:j(),isJagged:xe(),isNested:Ye(),isNumber:q(),isObject:G(),isSeries:y(),isString:I(),isUndefined:w(),lerp:dc(),log:qc(),MathError:U(),max:oe(),mean:ht(),median:wc(),min:ft(),mod:Sc(),mode:Oc(),multiply:Fn(),ndarray:W(),normal:Ic(),ones:Ac(),permutations:Cc(),pow:gt(),print:Vc(),product:Ee(),random:le().random,range:C(),remap:Rc(),reshape:tt(),reverse:Te(),round:Bc(),scale:me(),seed:le().seed,Series:ow,set:z(),shape:T(),shuffle:nt(),sign:Yc(),sin:Lc(),sort:Q(),sqrt:dt(),std:pt(),stdev:Wc(),subtract:Dn(),sum:qt(),tan:Hc(),time:_t().timeSync,timeSync:_t().timeSync,timeAsync:_t().timeAsync,transpose:ie(),union:tl(),variance:Tn(),vectorize:S(),zeros:kn(),zip:rl(),dump:function(){let t=typeof global<"u"?global:window;if(!t)throw new de.MathError("Cannot dump functions into global scope because neither `global` nor `window` exist in the current context!");Object.keys(de).forEach(e=>{try{Object.defineProperty(t,e,{configurable:!1,enumerable:!0,writable:!1,value:de[e]})}catch{t[e]=de[e]}})}};typeof Pn<"u"&&(Pn.exports=de);typeof window<"u"&&(window.JSMathTools=de)});var J=c((uT,sl)=>{sl.exports={shouldIgnoreNaNValues:!0}});var pe=c((aT,il)=>{var{assert:iw,flatten:uw,isArray:aw,isDataFrame:cw,isNumber:lw,isSeries:fw}=x();function ol(t){if(cw(t)||fw(t))return ol(t.values);iw(aw(t),"The `containsOnlyNumbers` function only works on arrays, Series, and DataFrames!");let e=uw(t);for(let n=0;n<e.length;n++)if(!lw(e[n]))return!1;return!0}il.exports=ol});var Jn=c((cT,ul)=>{var{dropMissing:hw,flatten:mw,isArray:dw,isDataFrame:pw,isSeries:gw}=x();function Bn(t){return typeof t=="number"?t===0||t===1:pw(t)||gw(t)?Bn(t.values):dw(t)?t.length===0?!1:hw(mw(t)).every(n=>Bn(n)):!1}ul.exports=Bn});var Yn=c((lT,gl)=>{var{abs:al,apply:cl,assert:ll,clamp:qw,copy:yw,divide:bw,dropNaN:ww,flatten:Nw,isArray:vw,isDataFrame:Sw,isNumber:fl,isSeries:xw,max:hl,median:ml,min:Tw,sort:_w,subtract:dl}=x(),Ow=J(),Fw=pe(),Dw=Jn();function pl(t,e){if(Sw(t)||xw(t)){let a=t.copy();return a._values=pl(a._values,e),a}if(ll(vw(t),"The `clipOutliers` function only works on arrays, Series, and DataFrames!"),e=e||5,ll(fl(e),"Any `maxScore` value passed into the `clipOutliers` function must be a number!"),!Ow.shouldIgnoreNaNValues&&!Fw(t))return cl(t,()=>NaN);let n=Nw(t),r=ww(n);if(Dw(r)||r.length===0)return t;let s=ml(r),o=ml(al(dl(r,s))),i=!1;if(o===0){let a=_w(yw(r)),l=a.filter(g=>g<s),f=a.filter(g=>g>s),h=s,d=s;if(l.length>0&&(h=hl(l)),f.length>0&&(d=Tw(f)),o=(d-h)/2,o===0)return t;i=(s-h)/o>e||(d-s)/o>e}return hl(bw(al(dl(r,s)),o))>e||i?cl(t,a=>fl(a)?qw(a,s-e*o,s+e*o):a):t}gl.exports=pl});var Ln=c((fT,xl)=>{var{assert:ql,dropNaN:yl,isArray:bl,isSeries:wl,mean:Nl,shape:vl,variance:Sl}=x(),Ew=J();function $n(t,e){if(wl(t))return $n(t.values,e);if(wl(e))return $n(t,e.values);ql(bl(t)&&bl(e)&&vl(t).length===1&&vl(e).length===1,"The `cohensd` function only works on 1-dimensional arrays and Series!"),ql(t.length===e.length,"Two arrays or Series passed into the `cohensd` function must have the same length!"),Ew.shouldIgnoreNaNValues&&(t=yl(t),e=yl(e));try{let n=Nl(t),r=Nl(e),s=Math.sqrt((Sl(t)+Sl(e))/2);return(n-r)/s}catch{return NaN}}xl.exports=$n});var Fl=c((hT,Ol)=>{var{assert:Tl,DataFrame:Iw,isArray:Mw,isSeries:Aw,shape:jw,zeros:Cw}=x();function _l(t){if(Aw(t)){let r=new Iw(_l(t.values));return r.index=t.index.slice(),r.columns=t.index.slice(),r}Tl(Mw(t),"The `diagonalize` function only works on 1-dimensional arrays and Series!");let e=jw(t);Tl(e.length===1,"The `diagonalize` function only works on 1-dimensional arrays and Series!");let n=Cw([e[0],e[0]]);return t.forEach((r,s)=>n[s][s]=r),n}Ol.exports=_l});var Hn=c((mT,Ml)=>{var{assert:Gn,clamp:kw,correl:Dl,DataFrame:Ot,dropNaNPairwise:Vw,isArray:El,isDataFrame:Ft,isJagged:Il,isUndefined:zw,ndarray:Uw}=x(),Rw=J();function Wn(t){let e="@jrc03c/js-data-science-helpers/get-correlation-matrix";return Object.defineProperty(t,e,{configurable:!1,enumerable:!1,writable:!1,value:Symbol.for(e)}),t}function Kn(t,e){if(zw(e)&&(e=t),Ft(t)){let r=new Ot(Kn(t.values,e));return r.index=t.columns.slice(),r.columns=Ft(e)?e.columns.slice():new Ot(e).columns.slice(),Wn(r)}if(Ft(e)){let r=new Ot(Kn(t,e.values));return r.index=Ft(t)?t.columns.slice():new Ot(t).columns.slice(),r.columns=e.columns.slice(),Wn(r)}Gn(El(t)&&El(e),"The `getCorrelationMatrix` function only works on 2-dimensional arrays and DataFrames!"),Gn(!Il(t)&&!Il(e),"The `getCorrelationMatrix` function only works on non-jagged 2-dimensional arrays and DataFrames!"),Gn(t.length===e.length,'The dimensions of the matrices you passed into the `getCorrelationMatrix` function aren\'t compatible! ([shape(a).join(", ")] vs. [shape(b).join(", ")]) The function expects that you\'ll be comparing the columns of two matrices where the columns are all of the same length, so please make sure that the matrices are oriented accordingly.');let n=Uw([t[0].length,e[0].length]);for(let r=0;r<t[0].length;r++){let s=t.map(o=>o[r]);for(let o=0;o<e[0].length;o++){let i=e.map(u=>u[o]);Rw.shouldIgnoreNaNValues?n[r][o]=Dl(...Vw(s,i)):n[r][o]=Dl(s,i)}}return Wn(kw(n,-1,1))}Ml.exports=Kn});var Qn=c((dT,Al)=>{function Pw(t){try{let e="@jrc03c/js-data-science-helpers/get-correlation-matrix";return t[e]===Symbol.for(e)}catch{return!1}}Al.exports=Pw});var Vl=c((pT,kl)=>{var{DataFrame:Xn,isArray:Bw,isDataFrame:Dt,isNumber:jl,MathError:Jw,sort:Yw}=x(),Cl=Hn(),$w=Qn();function Lw(t,e,n){n=Object.values(arguments).find(o=>jl(o))||1-1e-5;let r=(()=>{let o=Object.values(arguments).filter(i=>Bw(i)||Dt(i));if(o.length===1){let i=o[0];if($w(i))return Dt(i)?i:new Xn(i);{let u=Cl(i,null);return Dt(u)?u:new Xn(u)}}if(o.length===2){let i=Cl(o[0],o[1]);return Dt(i)?i:new Xn(i)}throw new Jw("You must pass 1 or 2 2-dimensional arrays or DataFrames into the `getHighlyCorrelatedColumns` function!")})(),s={};return r.values.forEach((o,i)=>{o.forEach((u,a)=>{if(jl(u)&&u>n){let l=r.index[i],f=r.columns[a];s[l]||(s[l]=[]),s[l].indexOf(f)<0&&s[l].push(f),s[f]||(s[f]=[]),s[f].indexOf(l)<0&&s[f].push(l)}})}),Object.keys(s).forEach(o=>{s[o]=Yw(s[o])}),s}kl.exports=Lw});var Zn=c((gT,Ul)=>{var{dropNaN:Gw,isArray:Ww,isDataFrame:Kw,isNumber:Hw,isSeries:Qw,pow:Xw,sqrt:Zw,sum:eN}=x(),tN=J();function zl(t){return Kw(t)||Qw(t)?zl(t.values):Hw(t)?Math.abs(t):Ww(t)?(tN.shouldIgnoreNaNValues&&(t=Gw(t)),Zw(eN(Xw(t,2)))):NaN}Ul.exports=zl});var er=c((qT,Bl)=>{var{assert:Rl,DataFrame:nN,isArray:rN,isSeries:sN,isString:oN,isUndefined:iN,set:uN,shape:aN,sort:cN}=x();function Pl(){if(arguments.length===1&&sN(arguments[0])){let{name:o,values:i}=arguments[0],u=Pl(o,i),a=new nN(u);return a.index=arguments[0].index.slice(),a}let[t,e]=arguments;Rl(oN(t),"When passing two arguments into the `getOneHotEncodings` function, the first argument must be a string representing the name of the variable being encoded!"),Rl(rN(e)&&aN(e).length===1,"When passing two arguments into the `getOneHotEncodings` function, the second argument must be a 1-dimensional array!");let n={},r=t+"_"+e[0];return cN(uN(e)).filter(o=>!iN(o)).map(o=>t+"_"+o).filter(o=>o!==r).forEach(o=>{n[o]=e.map(i=>o===t+"_"+i?1:0)}),n}Bl.exports=Pl});var Yl=c((yT,Jl)=>{var{count:lN}=x();function fN(t){return lN(t).map(n=>(n.percentage=n.count/t.length,n))}Jl.exports=fN});var $l=c((bT,hN)=>{hN.exports=[.5,.49601,.49202,.48803,.48405,.48006,.47608,.4721,.46812,.46414,.46017,.4562,.45224,.44828,.44433,.44038,.4364,.43251,.42858,.42465,.42074,.41683,.41294,.40905,.40517,.40129,.39743,.39358,.38974,.38591,.38209,.37828,.37448,.3707,.36693,.36317,.35942,.35569,.35197,.34827,.34458,.3409,.33724,.3336,.32997,.32636,.32276,.31918,.31561,.31207,.30854,.30503,.30153,.29806,.2946,.29116,.28774,.28434,.28096,.2776,.27425,.27093,.26763,.26435,.26109,.25785,.25463,.25143,.24825,.2451,.24196,.23885,.23576,.2327,.22965,.22663,.22363,.22065,.2177,.21476,.21186,.20897,.20611,.20327,.20045,.19766,.19489,.19215,.18943,.18673,.18406,.18141,.17879,.17619,.17361,.17106,.16853,.16602,.16354,.16109,.15866,.15625,.15386,.15151,.14917,.14686,.14457,.14231,.14007,.13786,.13567,.1335,.13136,.12924,.12714,.12507,.12302,.121,.119,.11702,.11507,.11314,.11123,.10935,.10749,.10565,.10383,.10204,.10027,.09853,.0968,.0951,.09342,.09176,.09012,.08851,.08692,.08534,.08379,.08226,.08076,.07927,.0778,.07636,.07493,.07353,.07215,.07078,.06944,.06811,.06681,.06552,.06426,.06301,.06178,.06057,.05938,.05821,.05705,.05592,.0548,.0537,.05262,.05155,.0505,.04947,.04846,.04746,.04648,.04551,.04457,.04363,.04272,.04182,.04093,.04006,.0392,.03836,.03754,.03673,.03593,.03515,.03438,.03362,.03288,.03216,.03144,.03074,.03005,.02938,.02872,.02807,.02743,.0268,.02619,.02559,.025,.02442,.02385,.0233,.02275,.02222,.02169,.02118,.02068,.02018,.0197,.01923,.01876,.01831,.01786,.01743,.017,.01659,.01618,.01578,.01539,.015,.01463,.01426,.0139,.01355,.01321,.01287,.01255,.01222,.01191,.0116,.0113,.01101,.01072,.01044,.01017,.0099,.00964,.00939,.00914,.00889,.00866,.00842,.0082,.00798,.00776,.00755,.00734,.00714,.00695,.00676,.00657,.00639,.00621,.00604,.00587,.0057,.00554,.00539,.00523,.00508,.00494,.0048,.00466,.00453,.0044,.00427,.00415,.00402,.00391,.00379,.00368,.00357,.00347,.00336,.00326,.00317,.00307,.00298,.00289,.0028,.00272,.00264,.00256,.00248,.0024,.00233,.00226,.00219,.00212,.00205,.00199,.00193,.00187,.00181,.00175,.00169,.00164,.00159,.00154,.00149,.00144,.00139,.00135,.00131,.00126,.00122,.00118,.00114,.00111,.00107,.00104,.001,97e-5,94e-5,9e-4,87e-5,84e-5,82e-5,79e-5,76e-5,74e-5,71e-5,69e-5,66e-5,64e-5,62e-5,6e-4,58e-5,56e-5,54e-5,52e-5,5e-4,48e-5,47e-5,45e-5,43e-5,42e-5,4e-4,39e-5,38e-5,36e-5,35e-5,34e-5,32e-5,31e-5,3e-4,29e-5,28e-5,27e-5,26e-5,25e-5,24e-5,23e-5,22e-5,22e-5,21e-5,2e-4,19e-5,19e-5,18e-5,17e-5,17e-5,16e-5,15e-5,15e-5,14e-5,14e-5,13e-5,13e-5,12e-5,12e-5,11e-5,11e-5,1e-4,1e-4,1e-4,9e-5,9e-5,8e-5,8e-5,8e-5,8e-5,7e-5,7e-5,7e-5,6e-5,6e-5,6e-5,6e-5,5e-5,5e-5,5e-5,5e-5,5e-5,4e-5,4e-5,4e-5,4e-5,4e-5,4e-5,3e-5,3e-5,3e-5,3e-5,3e-5,3e-5,3e-5,3e-5,2e-5,2e-5,2e-5,2e-5]});var nr=c((wT,ef)=>{var{abs:Ll,assert:mN,dropNaNPairwise:dN,flatten:Et,isArray:Gl,isDataFrame:Wl,isEqual:pN,isSeries:Kl,mean:Hl,remap:gN,round:qN,shape:Ql,sqrt:yN,std:Xl}=x(),bN=J(),Zl=$l();function wN(t){return Ll(t)>4.1?0:Zl[qN(gN(Ll(t),0,4.1,0,Zl.length))]}function tr(t,e){if(Wl(t)||Kl(t))return tr(t.values,e);if(Wl(e)||Kl(e))return tr(t,e.values);mN(Gl(t)&&Gl(e)&&pN(Ql(t),Ql(e)),"You must pass two identically-shaped arrays, Series, or DataFrames into the `pValue` function!");let[n,r]=bN.shouldIgnoreNaNValues?dN(Et(t),Et(e)):[Et(t),Et(e)];if(n.length===0||r.length===0)return NaN;let s=Hl(n),o=Hl(r),i=Xl(n),u=Xl(r),a=n.length,l=r.length,f=(s-o)/yN(i*i/a+u*u/l);return 2*wN(f)}ef.exports=tr});var of=c((NT,sf)=>{var{assert:rr,clamp:NN,DataFrame:It,dropNaNPairwise:vN,isArray:tf,isDataFrame:Mt,isJagged:nf,isUndefined:SN,ndarray:xN}=x(),TN=J(),rf=nr();function sr(t){let e="@jrc03c/js-data-science-helpers/get-p-value-matrix";return Object.defineProperty(t,e,{configurable:!1,enumerable:!1,writable:!1,value:Symbol.for(e)}),t}function or(t,e){if(SN(e)&&(e=t),Mt(t)){let r=new It(or(t.values,e));return r.index=t.columns.slice(),r.columns=Mt(e)?e.columns.slice():new It(e).columns.slice(),sr(r)}if(Mt(e)){let r=new It(or(t,e.values));return r.index=Mt(t)?t.columns.slice():new It(t).columns.slice(),r.columns=e.columns.slice(),sr(r)}rr(tf(t)&&tf(e),"The `getPValueMatrix` function only works on 2-dimensional arrays and DataFrames!"),rr(!nf(t)&&!nf(e),"The `getPValueMatrix` function only works on non-jagged 2-dimensional arrays and DataFrames!"),rr(t.length===e.length,'The dimensions of the matrices you passed into the `getPValueMatrix` function aren\'t compatible! ([shape(a).join(", ")] vs. [shape(b).join(", ")]) The function expects that you\'ll be comparing the columns of two matrices where the columns are all of the same length, so please make sure that the matrices are oriented accordingly.');let n=xN([t[0].length,e[0].length]);for(let r=0;r<t[0].length;r++){let s=t.map(o=>o[r]);for(let o=0;o<e[0].length;o++){let i=e.map(u=>u[o]);TN.shouldIgnoreNaNValues?n[r][o]=rf(...vN(s,i)):n[r][o]=rf(s,i)}}return sr(NN(n,0,1))}sf.exports=or});var ff=c((vT,lf)=>{var{assert:At,intersect:_N,isDataFrame:uf,isSeries:af,isUndefined:cf}=x(),ge=class{constructor(e){let n=this;At(cf(e)||e===ge.DROP_NAN_MODE||e===ge.DROP_MISSING_MODE,"The `mode` value passed into the `IndexMatcher` constructor must be undefined or one of [IndexMatcher.DROP_NAN_MODE, IndexMatcher.DROP_MISSING_MODE]! (By default, the mode is `Indexer.DROP_MISSING_MODE`.)"),n.mode=cf(e)?ge.DROP_MISSING_MODE:e,n.index=null}fit(){let e=this,n=[];return Object.values(arguments).forEach(r=>{At(uf(r)||af(r),"The `IndexMatcher` only works on Series and DataFrames! To drop NaN values in a pair-wise fashion from regular arrays, use the `dropNaNPairwise` function from the @jrc03c/js-math-tools library."),e.mode===ge.DROP_MISSING_MODE?n.push(r.dropMissing().index):n.push(r.dropNaN().index)}),e.index=_N(...n),e}transform(){let e=this;At(!!e.index,"The IndexMatcher hasn't been fitted yet! Please call the `fit` method before calling the `transform` method.");let n=Object.values(arguments).map(r=>(At(uf(r)||af(r),"The `IndexMatcher` only works on Series and DataFrames! To drop NaN values in a pair-wise fashion from regular arrays, use the `dropNaNPairwise` function from the @jrc03c/js-math-tools library."),r.get(e.index,null)));return n.length===1?n[0]:n}fitAndTransform(){return this.fit(...arguments).transform(...arguments)}},ze=ge;Rt(ze,"DROP_NAN_MODE","DROP_NAN_MODE"),Rt(ze,"DROP_MISSING_MODE","DROP_MISSING_MODE");lf.exports=ze});var ar=c((ST,mf)=>{var{apply:ON,assert:FN,count:DN,flatten:EN,float:IN,isArray:ir,isDataFrame:MN,isNumber:AN,isSeries:jN,isString:CN}=x(),hf=["null","none","nan","na","n/a","","undefined"],kN=["true","false","yes","no"];function VN(t,e){if(t===void 0&&(t="undefined"),e==="null")return null;if(e==="number"){let n=IN(t);return isNaN(n)?NaN:n}if(e==="boolean"){try{let n=t.trim().toLowerCase();if(n==="true"||n==="yes")return!0;if(n==="false"||n==="no")return!1}catch{}return null}if(e==="date"){let n=new Date(t);return n.toString()==="Invalid Date"?null:n}if(e==="object")try{let n=JSON.parse(t);return ir(n)?null:n}catch{return null}if(e==="string"){try{if(hf.indexOf(t.trim().toLowerCase())>-1)return null}catch{return null}return t}}function ur(t){if(MN(t)){let s=t.copy(),o=ur(t.values);return s.values=o.values,{type:o.type,values:s}}if(jN(t)){let s=t.copy(),o=ur(t.values);return s.values=o.values,{type:o.type,values:s}}FN(ir(t),"The `inferType` function only works on arrays, Series, and DataFrames!");let e=EN(t).map(s=>{if(s===void 0)return"null";CN(s)||(s=JSON.stringify(s));let i=s.toLowerCase().trim();if(hf.indexOf(i)>-1)return"null";if(kN.indexOf(i)>-1)return"boolean";try{let u=JSON.parse(s);return AN(u)?"number":typeof u=="object"?ir(u)?"string":"object":"string"}catch{return new Date(s).toString()!=="Invalid Date"?"date":"string"}}),r=DN(e).sort((s,o)=>o.count-s.count)[0].item;return{type:r,values:ON(t,s=>VN(s,r))}}mf.exports=ur});var lr=c((xT,yf)=>{var{assert:cr,isArray:zN,isBoolean:UN,isDataFrame:df,isSeries:pf,int:RN,isNumber:PN,isUndefined:gf,range:qf,set:BN,shape:JN,shuffle:YN}=x();yf.exports=function(){let e=Array.from(arguments),n=e.find(g=>UN(g)),r=gf(n)?!0:n,s=e.find(g=>PN(g)),o=gf(s)?.1:s;cr(o>0&&o<1,"`testSize` must be a number between 0 and 1 (exclusive on both ends)!");let i=e.filter(g=>zN(g)||df(g)||pf(g));cr(i.length>0,"You must pass at least one dataset into the `trainTestSplit` function!");let u=i.map(g=>JN(g)[0]);cr(BN(u).length===1,`All datasets passed into the \`trainTestSplit\` function must be the same length at their shallowest dimension! The lengths of your datasets, though, are: ${u.join(", ")}`);let a=[],l=r?YN(qf(0,u[0])):qf(0,u[0]),f=RN((1-o)*l.length),h=l.slice(0,f),d=l.slice(f);return i.forEach(g=>{if(df(g))a.push(g.get(h,null)),a.push(g.get(d,null));else if(pf(g))a.push(g.get(h)),a.push(g.get(d));else{let N=[],v=[];g.forEach((A,O)=>{h.indexOf(O)>-1?N.push(A):v.push(A)}),a.push(N),a.push(v)}}),a}});var Ct=c((TT,xf)=>{var{add:$N,argmin:LN,assert:GN,flatten:bf,isArray:WN,isDataFrame:wf,isEqual:KN,int:HN,isNumber:QN,isSeries:Nf,normal:fr,pow:XN,random:ZN,range:ev,scale:tv,shape:jt,subtract:nv,sum:rv}=x(),sv=lr();function hr(t,e){(wf(t)||Nf(t))&&(t=t.values),(wf(e)||Nf(e))&&(e=e.values),GN(KN(jt(t),jt(e)),"`yPred` and `yTrue` must have the same shape!");let n=bf(t),r=bf(e),s=0;return n.forEach((o,i)=>{o===r[i]&&s++}),s/n.length}function ov(t){test(`tests that the \`${t.name}\` model works correctly`,()=>{let e=fr([5,10]).map(h=>h.map(d=>d*100+fr()*100)),n=[],r=ev(0,500).map(()=>{let h=HN(ZN()*e.length),d=e[h];return n.push(h),$N(d,tv(5,fr(jt(d))))}),[s,o,i,u]=sv(r,n),a=new t({k:e.length});a.fit(s),a.centroids=vf(e,a.centroids);let l=a.predict(s),f=a.predict(o);expect(hr(i,l)).toBeGreaterThan(.95),expect(hr(u,f)).toBeGreaterThan(.95)})}function iv(t){return WN(t)&&jt(t).length===2}function uv(t){return QN(t)&&parseInt(t)===t&&t>=0}function vf(t,e){return t.map(n=>e[LN(e.map(r=>Sf(n,r)))])}function Sf(t,e){return rv(XN(nv(t,e),2))}xf.exports={accuracy:hr,createGenericTest:ov,isMatrix:iv,isWholeNumber:uv,orderCentroids:vf,sse:Sf}});var pr=c((_T,Ff)=>{var{add:Tf,argmin:av,assert:ue,copy:cv,distance:_f,divide:lv,isDataFrame:fv,isFunction:hv,isUndefined:kt,normal:mv,random:dv,range:pv,scale:gv,shuffle:qv,zeros:Of}=x(),{isMatrix:yv,isWholeNumber:mr,sse:bv}=Ct(),dr=class{constructor(e){ue(typeof e=="object","`config` must be an object! See the documentation for more information about the properties that the `config` object can contain."),ue(mr(e.k),"`k` must be a whole number!"),ue(mr(e.maxIterations)||kt(e.maxIterations),"`maxIterations` must be a whole number or undefined!"),ue(mr(e.maxRestarts)||kt(e.maxRestarts),"`maxRestarts` must be a whole number or undefined!"),ue(typeof e.tolerance=="number"||kt(e.tolerance),"`tolerance` must be a number or undefined!");let n=this;n.k=e.k,n.maxRestarts=e.maxRestarts||25,n.maxIterations=e.maxIterations||100,n.tolerance=e.tolerance||1e-4,n.centroids=null,n._fitState=null}initializeCentroids(e){let n=this;return qv(e).slice(0,n.k)}fitStep(e,n){let r=this;if(ue(yv(e),"`x` must be a matrix!"),fv(e)&&(e=e.values),kt(n)||ue(hv(n),"If defined, `progress` must be a function!"),r._fitState){if(r._fitState.isFinished)return r}else{let a=r.initializeCentroids(e);r._fitState={currentRestart:0,currentIteration:0,currentCentroids:a,bestCentroids:a,bestScore:-1/0,isFinished:!1}}let s=r.predict(e,r._fitState.currentCentroids),o=[],i=Of(r.k);e.forEach((a,l)=>{let f=s[l];o[f]||(o[f]=Of(a.length)),o[f]=Tf(o[f],a),i[f]++});let u=pv(0,r.k).map(a=>i[a]===0?Tf(r._fitState.currentCentroids[parseInt(dv()*r._fitState.currentCentroids.length)],gv(.001,mv(r._fitState.currentCentroids[0].length))):lv(o[a],i[a]));if(_f(r._fitState.currentCentroids,u)<r.tolerance?r._fitState.currentIteration=r.maxIterations-1:r._fitState.currentCentroids=u,n&&n((r._fitState.currentRestart+r._fitState.currentIteration/r.maxIterations)/r.maxRestarts,r),r._fitState.currentIteration++,r._fitState.currentIteration>=r.maxIterations){let a=r.score(e,r._fitState.currentCentroids);if(a>r._fitState.bestScore&&(r._fitState.bestScore=a,r._fitState.bestCentroids=cv(r._fitState.currentCentroids)),r._fitState.currentIteration=0,r._fitState.currentRestart++,r._fitState.currentRestart>=r.maxRestarts)r._fitState.isFinished=!0,r.centroids=r._fitState.bestCentroids,n&&n(1,r);else{let l=r.initializeCentroids(e);r._fitState.currentCentroids=l}}return r}fit(e,n){let r=this;for(r._fitState&&(r._fitState=null);!r._fitState||!r._fitState.isFinished;)r.fitStep(e,n);return r}predict(e,n){if(n=n||this.centroids,!n)throw new Error("No centroids were provided to the `predict` method, and the K-Means model hasn't been fitted yet. Please either pass centroids as a second parameter to the `predict` method or run the `fit` method first!");return e.map(s=>av(n.map(o=>_f(s,o))))}score(e,n){let r=this;if(n=n||r.centroids,!n)throw new Error("No centroids were provided to the `score` method, and the K-Means model hasn't been fitted yet. Please either pass centroids as a second parameter to the `score` method or run the `fit` method first!");let o=r.predict(e,n).map(i=>n[i]);return-bv(e,o)}};Ff.exports=dr});var qr=c((OT,If)=>{var{argmin:wv,distance:Df,divide:Nv,max:vv,random:Ef}=x(),Sv=pr(),gr=class extends Sv{initializeCentroids(e){let n=this,r=[e[parseInt(Ef()*e.length)]];for(;r.length<n.k;){let s=e.map(i=>Df(i,r[wv(r.map(u=>Df(i,u)))])),o=Nv(s,vv(s));r.push(e[o.findIndex(i=>Ef()<i)])}return r}};If.exports=gr});var jf=c((FT,Af)=>{var{assert:L,isArray:xv,isDataFrame:Tv,isEqual:_v,isFunction:Ov,isUndefined:qe,range:Fv,shape:Mf}=x(),{isMatrix:Dv,isWholeNumber:yr}=Ct(),Ev=qr(),br=class{constructor(e){qe(e)&&(e={}),L(typeof e=="object","`config` must be an object! See the documentation for more information about the properties that the `config` object can contain."),qe(e.ks)&&(e.ks=Fv(1,16)),L(xv(e.ks),"`ks` must be an array of whole numbers!"),e.ks.forEach(r=>{L(yr(r),"`ks` must be an array of whole numbers!")}),L(yr(e.maxIterations)||qe(e.maxIterations),"`maxIterations` must be a whole number or undefined!"),L(yr(e.maxRestarts)||qe(e.maxRestarts),"`maxRestarts` must be a whole number or undefined!"),L(typeof e.tolerance=="number"||qe(e.tolerance),"`tolerance` must be a number or undefined!");let n=this;n.ks=e.ks,n.maxRestarts=e.maxRestarts||25,n.maxIterations=e.maxIterations||100,n.tolerance=e.tolerance||1e-4,n.scoreStopRatio=e.scoreStopRatio||.85,n.modelClass=e.modelClass||Ev,n.fittedModel=null,n._fitState=null}fitStep(e,n){let r=this;if(L(Dv(e),"`x` must be a matrix!"),Tv(e)&&(e=e.values),qe(n)||L(Ov(n),"If defined, `progress` must be a function!"),!r._fitState)r._fitState={isFinished:!1,lastScore:-1/0,currentIndex:0};else if(r._fitState.isFinished)return r;let s=r.ks[r._fitState.currentIndex],o=new r.modelClass({k:s,maxRestarts:10,maxIterations:20});o.fit(e,u=>n?n((r._fitState.currentIndex+u)/(r.ks.length+1)):null);let i=o.score(e);return i/r._fitState.lastScore>r.scoreStopRatio?(r._fitState.isFinished=!0,r._fitState.currentIndex--):(r._fitState.lastScore=i,r._fitState.currentIndex+1>=r.ks.length?r._fitState.isFinished=!0:r._fitState.currentIndex++),r._fitState.isFinished&&(r.fittedModel=new r.modelClass({k:r.ks[r._fitState.currentIndex],maxRestarts:r.maxRestarts,maxIterations:r.maxIterations}),r.fittedModel.fit(e,u=>n?n((r.ks.length+u)/(r.ks.length+1)):null),n&&n(1)),r}fit(e,n){let r=this;for(r._fitState=null;!r._fitState||!r._fitState.isFinished;)r.fitStep(e,n);return r}predict(e,n){return this.fittedModel.predict(e,n)}score(e,n){return this.fittedModel.score(e,n)}get k(){return this.fittedModel.k}set k(e){throw new Error("You can't set the k-value manually! It has to be set automatically via the `fit` method.")}get centroids(){return this.fittedModel.centroids}set centroids(e){let n=this;L(_v(Mf(e),Mf(n.fittedModel.centroids)),"When assigning a new value to the `centroids` property, the new centroids must have the same shape as the old centroids!"),n.fittedModel.centroids=e}};Af.exports=br});var kf=c((DT,Cf)=>{Cf.exports={KMeansMeta:jf(),KMeansNaive:pr(),KMeansPlusPlus:qr(),helpers:Ct()}});var wr=c((ET,Bf)=>{var{apply:Iv,assert:Mv,dropNaN:Vf,isArray:Av,isDataFrame:jv,isSeries:Cv,mean:zf,std:Uf}=x(),Rf=J();function Pf(t){if(jv(t)||Cv(t)){let r=t.copy();return r.values=Pf(r.values),r}Mv(Av(t),"The `normalize` function only works on arrays, Series, and DataFrames!");let e=(()=>Rf.shouldIgnoreNaNValues?zf(Vf(t)):zf(t))(),n=(()=>Rf.shouldIgnoreNaNValues?Uf(Vf(t)):Uf(t))();return n===0?t:Iv(t,r=>(r-e)/n)}Bf.exports=Pf});var vr=c((IT,Gf)=>{var{assert:ye,dot:Jf,isArray:Yf,isSeries:Nr,scale:kv,Series:Vv,shape:$f}=x(),Lf=pe();function Vt(t,e){if(Nr(t)){if(Nr(e))return new Vv(Vt(t.values,e.values));{let n=t.copy();return n.values=Vt(t.values,e),n}}if(Nr(e)){let n=e.copy();return n.values=Vt(t,e.values),n}return ye(Yf(t),"`project` only works on vectors!"),ye(Yf(e),"`project` only works on vectors!"),ye(Lf(t),"`project` only works on vectors of numbers!"),ye(Lf(e),"`project` only works on vectors of numbers!"),ye($f(t).length===1,"`project` only works on vectors!"),ye($f(e).length===1,"`project` only works on vectors!"),kv(Jf(e,t)/Jf(e,e),e)}Gf.exports=Vt});var Xf=c((MT,Qf)=>{var{assert:Wf,copy:zv,DataFrame:Uv,divide:Rv,isArray:Pv,isDataFrame:Bv,isJagged:Jv,shape:Yv,subtract:$v,transpose:Kf}=x(),Lv=pe(),Gv=Zn(),Wv=vr();function Hf(t){if(Bv(t)){let s=new Uv(Hf(t.values));return s.index=t.index.slice(),s.columns=t.columns.slice(),s}Wf(Pv(t)&&!Jv(t)&&Yv(t).length===2,"`orthonormalize` only works on matrices!"),Wf(Lv(t),"`orthonormalize` only works on matrices of numbers!");let e=Kf(t),n=[];e.forEach(s=>{let o=zv(s);n.forEach(i=>{o=$v(o,Wv(o,i))}),n.push(o)});let r=n.map(s=>Rv(s,Gv(s)));return Kf(r)}Qf.exports=Hf});var oh=c((CT,sh)=>{var{assert:be,copy:AT,correl:Kv,DataFrame:Zf,dropMissing:Hv,isArray:Qv,isDataFrame:Xv,isEqual:Zv,isFunction:eS,isJagged:tS,isNumber:Ue,isUndefined:nS,set:rS,shape:sS,transpose:jT}=x(),oS=Yn(),iS=er(),eh=(t,e)=>t.map(n=>n[e]),th=ar(),nh=t=>Ue(t)&&(parseInt(t)===t||t===1/0);function rh(t,e){e=e||{};let n=Ue(e.maxUniqueStrings)?e.maxUniqueStrings:7,r=Ue(e.minNonMissingValues)?e.minNonMissingValues:15,s=Ue(e.maxCorrelationThreshold)?e.maxCorrelationThreshold:1-1e-5,o=e.progress||null;if(Qv(t))return be(sS(t).length===2&&!tS(t),"The `preprocess` function only works on non-jagged 2-dimensional arrays and DataFrames!"),rh(new Zf(t));be(Xv(t),"You must pass a DataFrame into the `preprocess` function!"),be(nh(n),"`maxUniqueStrings` must be a whole number!"),be(nh(r),"`minNonMissingValues` must be a whole number!"),be(Ue(s),"`maxCorrelationThreshold` must be a number!"),nS(o)||be(eS(o),"If defined, `progress` must be a function!");let i={},u={},a={},l=t.values;t.columns.forEach((h,d)=>{if(u[h])return;let g=eh(l,d),N=(()=>{if(i[h])return i[h];{let O=th(g);return i[h]=O,O}})();if(N.type==="null"||N.type==="object"){u[h]=!0;return}let v=Hv(N.values);if(v.length<=r){u[h]=!0;return}let A=rS(v);if(A.length<2){u[h]=!0;return}if(N.type==="string"&&A.length<=n){let O=iS(h,N.values);Object.keys(O).forEach(E=>{a[E]=O[E]}),u[h]=!0;return}N.type==="number"&&(N.values=oS(N.values)),t.columns.slice(d+1).forEach((O,E)=>{if(u[O])return;let we=eh(l,d+E+1),Y=(()=>{if(i[O])return i[O];{let Ut=th(we);return i[O]=Ut,Ut}})();if(Y.type===N.type){if(Y.type==="number"&&Kv(Y.values,N.values)>s){u[O]=!0;return}if(Y.type==="string"&&Zv(Y.values,N.values)){u[O]=!0;return}}}),a[h]=N.values,o&&o(d/t.columns.length)});let f=new Zf(a);return f.index=t.index.slice(),f}sh.exports=rh});var ph=c((kT,dh)=>{var{abs:uS,add:aS,assert:Re,isArray:ih,isDataFrame:uh,isEqual:cS,isSeries:ah,mean:lS,pow:ch,scale:fS,shape:lh,sign:hS,sqrt:mS,sum:fh}=x(),hh=pe(),mh=(t,e)=>aS(t,fS(e,-1));function Sr(t,e){if(uh(t)||ah(t))return Sr(t.values,e);if(uh(e)||ah(e))return Sr(t,e.values);Re(ih(t),"You must pass two same-shaped numerical arrays into the `rScore` function!"),Re(ih(e),"You must pass two same-shaped numerical arrays into the `rScore` function!"),Re(cS(lh(t),lh(e)),"You must pass two same-shaped numerical arrays into the `rScore` function!"),Re(hh(t),"You must pass two same-shaped numerical arrays into the `rScore` function!"),Re(hh(e),"You must pass two same-shaped numerical arrays into the `rScore` function!");let n=fh(ch(mh(t,e),2)),r=fh(ch(mh(t,lS(t)),2));if(r===0)return NaN;let s=1-n/r;return hS(s)*mS(uS(s))}dh.exports=Sr});var wh=c((VT,bh)=>{var{argmax:gh,assert:Pe,copy:dS,DataFrame:pS,dot:gS,isArray:qS,isDataFrame:yS,isEqual:qh,isJagged:bS,max:wS,min:NS,reverse:vS,shape:SS,transpose:xS}=x();function yh(t){if(qS(t)){Pe(SS(t).length===2&&!bS(t),"The `sortCorrelationMatrix` function only works on 2-dimensional arrays and DataFrames!");let s=new pS(t);return s.index=s.columns.slice(),yh(s).values}Pe(yS(t),"You must pass a DataFrame into the `sortCorrelationMatrix` function!"),Pe(wS(t.values)<=1&&NS(t.values)>=-1,"The correlation matrix passed into the `sortCorrelationMatrix` function must not contain values less than -1 or greater than 1!"),Pe(qh(t.values,xS(t.values)),"The correlation matrix passed into the `sortCorrelationMatrix` function must be symmetrical!"),Pe(qh(t.index,t.columns),"The correlation matrix passed into the `sortCorrelationMatrix` function must be symmetrical! (In this case, although the values themselves are symmetrical, the row and column names differ.)");let e=dS(t.index),n=[];for(;e.length>0;)if(n.length===0){let s=gh(t.values.map(o=>gS(o,o)));n.push(e[s]),e.splice(s,1)}else{let s=t.index.indexOf(n.at(-1)),o=gh(e.map(u=>t.values[t.index.indexOf(u)][s])),i=e[o];n.push(i),e.splice(o,1)}let r=vS(n);return t.get(r,r)}bh.exports=yh});var vh=c((zT,Nh)=>{var TS=wr();function _S(){return TS(...arguments)}Nh.exports=_S});var Ih=c((UT,Eh)=>{var{assert:zt,DataFrame:Sh,dropNaN:OS,flatten:xh,isArray:FS,isDataFrame:xr,isSeries:Tr,mean:Th,range:DS,Series:_h,shape:Oh,stdev:Fh,transpose:Dh}=x(),ES=J(),_r=class{constructor(){let e=this;e.means=[],e.stdevs=[],e.wasFittedOnAVector=!1,e.hasBeenFitted=!1}_getDataArrayAndShape(e){if(xr(e))return[e.values,e.shape];if(Tr(e)){let r=Dh([e.values]);return[r,Oh(r)]}zt(FS(e),"`x` must be a 1- or 2-dimensional array, DataFrame, or Series!");let n=Oh(e);return zt(n.length<3,"`x` must be a 1- or 2-dimensional array, DataFrame, or Series!"),n.length===1&&(n.push(1),e=Dh([e])),[e,n]}fit(e){let n=this,r=n._getDataArrayAndShape(e);e=r[0];let s=r[1];return n.wasFittedOnAVector=s.indexOf(1)>-1,n.means=[],n.stdevs=[],DS(0,s[1]).forEach(o=>{let i=e.map(u=>u[o]);if(ES.shouldIgnoreNaNValues){let u=OS(i);n.means.push(Th(u)),n.stdevs.push(Fh(u))}else n.means.push(Th(i)),n.stdevs.push(Fh(i))}),n.hasBeenFitted=!0,n}transform(e){let n=this;if(!n.hasBeenFitted)throw new Error("This `StandardScaler` instance hasn't been trained on any data yet! Please use the `fit` method to train it before calling the `transform` method.");if(xr(e)){let i=new Sh(n.transform(e.values));return i.columns=e.columns,i.index=e.index,i}if(Tr(e)){let i=new _h(n.transform(e.values));return i.name=e.name,i.index=e.index,i}let r=n._getDataArrayAndShape(e);e=r[0];let s=r[1];zt(s[1]===n.means.length,"The data you passed into the `transform` function doesn't have the same number of columns as the data set on which this StandardScaler was fitted!");let o=e.map(i=>i.map((u,a)=>(u-n.means[a])/n.stdevs[a]));return n.wasFittedOnAVector?xh(o):o}untransform(e){let n=this;if(!n.hasBeenFitted)throw new Error("This `StandardScaler` instance hasn't been trained on any data yet! Please use the `fit` method to train it before calling the `transform` method.");if(xr(e)){let i=new Sh(n.untransform(e.values));return i.columns=e.columns,i.index=e.index,i}if(Tr(e)){let i=new _h(n.untransform(e.values));return i.name=e.name,i.index=e.index,i}let r=n._getDataArrayAndShape(e);e=r[0];let s=r[1];zt(s[1]===n.means.length,"The data you passed into the `untransform` function doesn't have the same number of columns as the data set on which this StandardScaler was fitted!");let o=e.map(i=>i.map((u,a)=>u*n.stdevs[a]+n.means[a]));return n.wasFittedOnAVector?xh(o):o}};Eh.exports=_r});var MS=c((RT,Ah)=>{var{MathError:IS}=x(),Mh={clipOutliers:Yn(),cohensD:Ln(),cohensd:Ln(),common:J(),containsOnlyNumbers:pe(),diagonalize:Fl(),getCorrelationMatrix:Hn(),getHighlyCorrelatedColumns:Vl(),getMagnitude:Zn(),getOneHotEncodings:er(),getPercentages:Yl(),getPValueMatrix:of(),IndexMatcher:ff(),inferType:ar(),isBinary:Jn(),isCorrelationMatrix:Qn(),KMeans:kf(),normalize:wr(),orthonormalize:Xf(),preprocess:oh(),project:vr(),pValue:nr(),rScore:ph(),sortCorrelationMatrix:wh(),standardize:vh(),StandardScaler:Ih(),trainTestSplit:lr(),dump(){let t=this,e=typeof global<"u"?global:typeof window<"u"?window:null;if(!e)throw new IS("Cannot dump functions into global scope because neither `global` nor `window` exist in the current context!");Object.keys(t).forEach(n=>{try{Object.defineProperty(e,n,{configurable:!1,enumerable:!0,writable:!1,value:t[n]})}catch{e[n]=t[n]}})}};try{window.JSDataScienceHelpers=Mh}catch{}try{Ah.exports=Mh}catch{}});MS();})();
