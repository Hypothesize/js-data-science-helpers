(()=>{var Ah=Object.defineProperty;var Mh=(t,e,n)=>e in t?Ah(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n;var ye=(t=>typeof require!="undefined"?require:typeof Proxy!="undefined"?new Proxy(t,{get:(e,n)=>(typeof require!="undefined"?require:e)[n]}):t)(function(t){if(typeof require!="undefined")return require.apply(this,arguments);throw new Error('Dynamic require of "'+t+'" is not supported')});var c=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports);var zt=(t,e,n)=>(Mh(t,typeof e!="symbol"?e+"":e,n),n);var P=c((ES,xr)=>{var Vt=class extends Error{constructor(e){typeof window<"u"?super(e):super(`

\x1B[31m`+e+`
\x1B[0m`)}};xr.exports=Vt});var m=c((AS,Tr)=>{var Ih=P();Tr.exports=function(t,e){if(!t)throw new Ih(e)}});var R=c((MS,Or)=>{function jh(t){try{return structuredClone(t)}catch{return t}}Or.exports=jh});var p=c((IS,Fr)=>{function kh(t){try{return t instanceof Array||typeof t.constructor<"u"&&t.constructor.name==="Array"}catch{return!1}}Fr.exports=kh});var b=c((jS,Dr)=>{function Ch(t){try{return!!t._symbol&&t._symbol===Symbol.for("@jrc03c/js-math-tools/dataframe")}catch{return!1}}Dr.exports=Ch});var y=c((kS,_r)=>{function zh(t){try{return!!t._symbol&&t._symbol===Symbol.for("@jrc03c/js-math-tools/series")}catch{return!1}}_r.exports=zh});var F=c((CS,Mr)=>{var Vh=m(),Ph=R(),Er=p(),Rh=b(),Uh=y();function Ar(t){if(Rh(t)||Uh(t))return Ar(t.values);Vh(Er(t),"The `flatten` function only works on arrays, Series, and DataFrames!");function e(n){let r=[];return Ph(n).forEach(s=>{Er(s)?r=r.concat(e(s)):r.push(s)}),r}return e(t)}Mr.exports=Ar});var M=c((zS,Ir)=>{function Bh(t){return typeof t=="function"}Ir.exports=Bh});var q=c((VS,jr)=>{function Jh(t){return typeof t=="number"&&!isNaN(t)}jr.exports=Jh});var w=c((PS,kr)=>{function Yh(t){return t===null||typeof t>"u"}kr.exports=Yh});var L=c((RS,Cr)=>{var $h=p(),Lh=w();function Gh(t){return typeof t=="object"&&!Lh(t)&&!$h(t)}Cr.exports=Gh});var be=c((US,Pr)=>{var Kh=m(),zr=p(),Wh=b(),Hh=M(),Pt=q(),Vr=L(),Qh=y();function Rt(t,e){if(Wh(t)){let o=Rt(t.values,e);return o.length>0&&Pt(o[0])&&o[0]>=0&&o[0]<t.index.length&&(o[0]=t.index[o[0]]),o.length>1&&Pt(o[1])&&o[1]>=0&&o[1]<t.columns.length&&(o[1]=t.columns[o[1]]),o}if(Qh(t)){let o=Rt(t.values,e);return o.length>0&&Pt(o[0])&&o[0]>=0&&o[0]<t.index.length&&(o[0]=t.index[o[0]]),o}if(Kh(Vr(t)||zr(t),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `indexOf` function!"),!Hh(e)){let o=e;e=i=>i===o}function n(o,i,u){if(u=u||[],u.indexOf(o)>-1)return null;if(Vr(o)){u.push(o);let a=Object.keys(o);for(let l=0;l<a.length;l++){let f=a[l],h=o[f];if(i(h))return[f];let d=n(h,i,u);if(d&&d.length>0)return[f].concat(d)}}else if(zr(o)){u.push(o);for(let a=0;a<o.length;a++){let l=o[a];if(i(l))return[a];let f=n(l,i,u);if(f&&f.length>0)return[a].concat(f)}}else if(i(o))return[];return null}function r(o){try{return e(o)}catch{return!1}}let s=n(t,r);return s&&s.length>0?s:null}Pr.exports=Rt});var U=c((BS,Br)=>{var Rr=R(),Xh=be(),Zh=p(),e0=b(),t0=y();function Ur(t){function e(r,s,o){if(e0(r)||t0(r))return r.copy();if(s=s||[],o=o||"",s.indexOf(r)>-1){let i=o.split("/").slice(o.startsWith("/")?1:0);if(i.some((a,l)=>{let f=i.slice(0,i.length-l-1),h=n;return f.forEach(d=>{h=h[d]}),h===r}))return`<reference to "${n===r?"/":"/"+Xh(n,r).join("/")}">`}if(typeof r=="object"){if(r===null)return null;if(s.push(r),Zh(r))return r.map((i,u)=>e(i,s,o+"/"+u));{let i={};return Object.keys(r).forEach(u=>{i[u]=e(r[u],s,o+"/"+u)}),i}}else return r}let n=t;return e(t)}function n0(t,e){function n(r,s){let o=typeof r;if(o!==typeof s)return!1;if(o==="undefined")return!0;if(o==="boolean"||o==="symbol")return r===s;if(o==="number"||o==="bigint")return r.toString()==="NaN"&&s.toString()==="NaN"?!0:r===s;if(o==="string"||o==="function")return r===s;if(o==="object"){if(r===null||s===null)return r===null&&s===null;{let u=Object.keys(r),a=Object.keys(s);if(u.length!==a.length)return!1;for(let l=0;l<u.length;l++){let f=u[l];if(!n(r[f],s[f]))return!1}return!0}}}try{return n(Rr(t),Rr(e))}catch{return n(Ur(t),Ur(e))}}Br.exports=n0});var V=c((JS,Lr)=>{var r0=m(),s0=F(),o0=p(),Jr=b(),i0=M(),Yr=y(),u0=w();function we(t){let e="abcdefg1234567890",n="";for(;n.length<t;)n+=e[parseInt(Math.random()*e.length)];return n}var a0=we(256),c0=we(256),l0=we(256),f0=we(256),h0=we(256);function $r(t){if(Jr(t)||Yr(t))return $r(t.values);r0(o0(t),"The `set` function only works on arrays, Series, and DataFrames!");let e=[],n={};return s0(t).forEach(r=>{let s=typeof r=="object"&&r===null?a0:u0(r)?c0:i0(r)?r.toString():typeof r=="symbol"?r.toString()+" - "+h0:r===1/0?l0:r===-1/0?f0:Jr(r)?r.toJSONString():Yr(r)?JSON.stringify(r.toObject()):JSON.stringify(r);n[s]||e.push(r),n[s]=!0}),e}Lr.exports=$r});var Pe=c((YS,Wr)=>{var m0=m(),Ut=F(),Gr=p(),d0=b(),Kr=U(),p0=M(),g0=y(),q0=V();function Ve(t,e){if(d0(t)||g0(t))return arguments.length>1?Ve(t.values,e):Ve(t.values,t.values);if(m0(Gr(t),"The first argument to the `count` function must be an array, Series, or DataFrame!"),p0(e))return Ut(t).filter(n=>e(n)).length;if(Gr(e)){let n=Ut(t);return q0(e).map(r=>({item:r,count:n.filter(s=>Kr(s,r)).length}))}else return arguments.length>1?Ut(t).filter(n=>Kr(n,e)).length:Ve(t,t)}Wr.exports=Ve});var Ne=c(($S,Qr)=>{var y0=m(),Hr=p(),b0=b(),w0=y();function Bt(t){if(b0(t)||w0(t))return Bt(t.values);y0(Hr(t),"The `isJagged` function only works on arrays, Series, and DataFrames!");let e=0,n=null;for(let r=0;r<t.length;r++)if(Hr(t[r])){if(e++,Bt(t[r]))return!0;if(n===null)n=t[r].length;else if(t[r].length!==n)return!0}return e>0&&e<t.length}Qr.exports=Bt});var Re=c((LS,es)=>{var N0=m(),Xr=p(),v0=b(),S0=y();function Zr(t){if(v0(t)||S0(t))return Zr(t.values);N0(Xr(t),"The `isNested` function only works on arrays, Series, and DataFrames!");for(let e=0;e<t.length;e++)if(Xr(t[e]))return!0;return!1}es.exports=Zr});var G=c((GS,ns)=>{var re=m(),x0=p(),T0=Re(),O0=q(),F0=w(),ue="You must pass a natural number or a one-dimensional array of natural numbers into the `ndarray` function!";function ts(t){re(!F0(t),ue),x0(t)||(t=[t]),re(!T0(t),ue),re(t.length>0,ue);let e=t[0];if(re(O0(e),ue),re(parseInt(e)===e,ue),re(e>=0,ue),re(e!==1/0,"We can't create an array containing an infinite number of values!"),t.length===1){let n=[];for(let r=0;r<e;r++)n.push(void 0);return n}else{let n=[];for(let r=0;r<e;r++)n.push(ts(t.slice(1)));return n}}ns.exports=ts});var ve=c((KS,rs)=>{var D0=m(),_0=p(),E0=b(),A0=y();function Jt(t){if(E0(t)||A0(t)){let n=t.copy();return n.values=Jt(n.values),n.index=Jt(n.index),n}D0(_0(t),"The `reverse` function only works on arrays, Series, and DataFrames!");let e=[];for(let n=t.length-1;n>=0;n--)e.push(t[n]);return e}rs.exports=Jt});var j=c((WS,ss)=>{var Yt=m(),$t=q(),Lt=w(),M0=ve();function I0(t,e,n=1){Yt(!Lt(t)&&!Lt(e)&&!Lt(n),"You must pass two numbers and optionally a step value to the `range` function!"),Yt($t(t)&&$t(e)&&$t(n),"You must pass two numbers and optionally a step value to the `range` function!"),Yt(n>0,"The step value must be greater than 0! (NOTE: The step value is a magnitude; it does not indicate direction.)");let r=!1;if(t>e){r=!0;let o=t;t=e+n,e=o+n}let s=[];for(let o=t;o<e;o+=n)s.push(o);return r&&(s=M0(s)),s}ss.exports=I0});var T=c((HS,as)=>{var j0=m(),os=p(),k0=b(),C0=U(),z0=y(),V0=w();function is(t){if(!os(t))return;let e=[t.length],n=0,r=t.map(s=>{let o=is(s);return V0(o)?o:(n++,o.length===1?o[0]:o)});return n>0?n===t.length&&r.slice(0,-1).every((o,i)=>C0(o,r[i+1]))?e.concat(r[0]):(e.push(r),e):e}function us(t){return k0(t)||z0(t)?us(t.values):(j0(os(t),"The `shape` function only works on arrays, Series, and DataFrames!"),is(t))}as.exports=us});var ds=c((QS,ms)=>{var cs=m(),P0=p(),R0=b(),U0=Ne(),B0=y(),J0=w(),ls=P(),Ue=G(),fs=j(),Y0=V(),$0=T();function hs(t,e,n){if(J0(n)&&(n=0),cs(n===0||n===1||n==="vertical"||n==="horizontal",'The only valid axis values for use when appending data to a DataFrame are 0, 1, "vertical", and "horizontal". Note that 0 == "horizontal" and 1 == "vertical".'),P0(e)){cs(!U0(e),"The array of data you're trying to append to this DataFrame is jagged!");let r=$0(e);if(r.length===1)if(n===0){let s=t.copy();s._values.push(e);let o=Math.max(t.shape[1],r[0]);for(s._values.forEach(i=>{for(;i.length<o;)i.push(void 0)});s._index.length<s._values.length;)s._index.push("row"+s._index.length);for(;s._columns.length<o;)s._columns.push("col"+s._columns.length);return s}else{let s=Math.max(t.shape[0],r[0]),o=t.copy();for(fs(0,s).forEach(i=>{i>=o._values.length&&o._values.push(Ue(t.shape[1])),o._values[i].push(e[i])});o._index.length<o._values.length;)o._index.push("row"+o._index.length);for(;o._columns.length<o._values[0].length;)o._columns.push("col"+o._columns.length);return o}else if(r.length===2)if(n===0){let s=Math.max(...e.map(i=>i.length).concat([t.shape[1]])),o=t.copy();for(o._values=o._values.concat(e).map(i=>{for(;i.length<s;)i.push(void 0);return i});o._index.length<o._values.length;)o._index.push("row"+o._index.length);for(;o._columns.length<s;)o._columns.push("col"+o._columns.length);return o}else{let s=Math.max(...e.map(u=>u.length))+t.shape[1],o=Math.max(t.shape[0],r[0]),i=t.copy();for(fs(0,o).forEach(u=>{for(u>=i._values.length&&i._values.push(Ue(t.shape[1])),i._values[u]=i._values[u].concat(e[u]);i._values[u].length<s;)i._values[u].push(void 0)});i._index.length<i._values.length;)i._index.push("row"+i._index.length);for(;i._columns.length<s;)i._columns.push("col"+i._columns.length);return i}else throw new ls("Only 1- and 2-dimensional arrays can be appended to a DataFrame!")}else if(B0(e)){let r=hs(t,e.values,n);return n===0?r.index[r.index.length-1]=r.index.indexOf(e.name)>-1?e.name+" (2)":e.name:r.columns[r.columns.length-1]=r.columns.indexOf(e.name)>-1?e.name+" (2)":e.name,r}else if(R0(e))if(n===0){let r=t.copy(),s=Y0(r._columns.concat(e._columns)).length;for(r._values.forEach(o=>{for(;o.length<s;)o.push(void 0)}),e.apply(o=>{let i=o.copy(),u=[];r._columns.forEach(a=>{let l=i._index.indexOf(a);l>-1?(u.push(i._values[l]),i._values.splice(l,1),i._index.splice(l,1)):u.push(void 0)}),r._values.push(u.concat(i._values))},1),r._columns=r._columns.concat(e._columns.filter(o=>r._columns.indexOf(o)<0));r._index.length<r._values.length;){let o="row"+r._index.length;r._index.push(o+(t._index.indexOf(o)>-1?" (2)":""))}return r}else{let r=t.copy();return r._index.forEach((s,o)=>{let i=e._index.indexOf(s);i>-1?r._values[o]=r._values[o].concat(e._values[i]):r._values[o]=r._values[o].concat(Ue(e.shape[1]))}),e._index.forEach((s,o)=>{r._index.indexOf(s)<0&&(r._index.push(s),r._values.push(Ue(r._columns.length).concat(e._values[o])))}),r._columns=r._columns.concat(e._columns.map(s=>s+(r._columns.indexOf(s)>-1?" (2)":""))),r}else throw new ls("Only 1- or 2-dimensional arrays, Series, and DataFrames can be appended to a DataFrame!")}ms.exports=hs});var bs=c((XS,ys)=>{var ps=m(),gs=p(),L0=M(),qs=w();function G0(t,e,n,r,s){if(s=s||0,ps(L0(r),"The first parameter to the `apply` method must be a function."),ps(s===0||s===1,"The second parameter to the `apply` method (the `axis`) must be 0 or 1."),s===0){let o={},i;if(n.columns.forEach((u,a)=>{let l=new e(n.values.map(h=>h[a]));l.name=u,l.index=n.index;let f=r(l,a,n);f instanceof e?o[u]=f.values:o[u]=f,qs(i)&&(i=f instanceof e||gs(f))}),i){let u=new t(o);return u.index=n.index,u}else{let u=new e(n.columns.map(a=>o[a]));return u.index=n.columns,u}}else if(s===1){let o,i=n.values.map((u,a)=>{let l=new e(u);l.name=n.index[a],l.index=n.columns;let f=r(l,a,n);return qs(o)&&(o=f instanceof e||gs(f)),f instanceof e?f.values:f});if(o){let u=new t(i);return u.index=n.index,u.columns=n.columns,u}else{let u=new e(i);return u.index=n.index,u}}}ys.exports=G0});var E=c((ZS,ws)=>{function K0(t){return typeof t=="string"}ws.exports=K0});var Ss=c((e2,vs)=>{var Ns=m(),W0=p(),H0=Ne(),Q0=L(),X0=E(),Z0=w(),em=P(),tm=T();function nm(t,e,n,r,s){let o=u=>u instanceof t,i=u=>u instanceof e;if(Z0(s)){if(o(r))return n.append(r,1);if(i(r))return n.append(r,1);if(Q0(r)){let u=Math.max(...Object.keys(r).map(a=>r[a].length));return Object.keys(r).forEach(a=>{for(;r[a].length<u;)r[a].push(void 0)}),n.append(new t(r),1)}else throw new em("You must pass a DataFrame, Series, or object into the `assign` method!")}else{Ns(X0(r),"If passing two arguments into the `assign` method, then the first argument must be a string name!"),Ns(W0(s)&&!H0(s)&&tm(s).length===1,"If passing two arguments into the `assign` method, then the second argument must be a 1-dimensional array!");let u=n.append(s,1);return u.columns[u.columns.length-1]=r,u}}vs.exports=nm});var Ts=c((t2,xs)=>{var rm=R();function sm(t,e){if(e.isEmpty)return new t;let n=new t(rm(e.values));return n.columns=e.columns.slice(),n.index=e.index.slice(),n}xs.exports=sm});var Ms=c((n2,As)=>{var Be=m(),Os=p(),Fs=q(),Ds=E(),_s=w(),Es=T();function om(t,e,n,r,s){_s(r)&&(r=[]),_s(s)&&(s=[]),(Ds(r)||Fs(r))&&(r=[r]),(Ds(s)||Fs(s))&&(s=[s]),Be(Os(r),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),Be(Os(s),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),Be(Es(r).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),Be(Es(s).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");let o,i;n.index.forEach((a,l)=>{r.indexOf(a)<0&&r.indexOf(l)<0&&(o||(o=[]),o.push(a))}),n.columns.forEach((a,l)=>{s.indexOf(a)<0&&s.indexOf(l)<0&&(i||(i=[]),i.push(a))});let u=n.get(o,i);if(u instanceof e){let a=new t;a=a.assign(u),n.index.indexOf(u.name)>-1&&(a=a.transpose()),u=a}return u}As.exports=om});var Se=c((r2,Is)=>{var im=q();function um(t){return im(t)&&parseInt(t)===t}function am(t){return um(t)&&t>=0}Is.exports=am});var ks=c((s2,js)=>{var Gt=m(),cm=E(),Je=w(),lm=Se(),fm=T();function hm(t,e,n,r,s,o){r=r||0,Gt(r===0||r===1,"The first parameter of the `dropMissing` method (the `axis`) must be 0 or 1."),o=o||0,Gt(lm(o),"The third parameter of the `dropMissing` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` null values)."),s=o>0?"none":s||"any",Gt(s==="any"||s==="all"||s==="none","The second parameter of the `dropMissing` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains null values, then it should be dropped; or that if 'all' of the data contains null values, then it should be dropped).");function i(l){if(o>0){let f=0;for(let h=0;h<l.length;h++){let d=l[h];if(Je(d)&&f++,f>=o)return[]}}else if(s==="any")for(let f=0;f<l.length;f++){let h=l[f];if(Je(h))return[]}else if(s==="all"){for(let f=0;f<l.length;f++){let h=l[f];if(!Je(h))return l}return[]}return l}let u=n.copy(),a=Math.random().toString();if(r===0){u=u.assign(a,u.index);let l=u.values.map(i).filter(h=>h.length>0);if(fm(l).length<2)return new t;u.values=l;let f=u.get(null,a);if(Je(f))return new t;cm(f)&&(f=[f]),f instanceof e&&(f=f.values),u.index=f,u=u.drop(null,a)}else if(r===1){let l={};if(u.columns.forEach((h,d)=>{let g=u.values.map(v=>v[d]),N=i(g);N.length>0&&(l[h]=N)}),Object.keys(l).length===0)return new t;let f=new t(l);return f.index=u.index,f}return u}js.exports=hm});var Kt=c((o2,zs)=>{var mm=m(),dm=p(),pm=b(),gm=q(),qm=y();function Cs(t){if(pm(t)||qm(t))return t.dropNaN(...Object.values(arguments).slice(1));mm(dm(t),"The `dropNaN` function only works on arrays, Series, and DataFrames!");let e=[];return t.forEach(n=>{try{return e.push(Cs(n))}catch{if(gm(n))return e.push(n)}}),e}zs.exports=Cs});var Ps=c((i2,Vs)=>{var Wt=m(),ym=Kt(),bm=Se();function wm(t,e,n,r,s){n=n||0,Wt(n===0||n===1,"The first parameter of the `dropNaN` method (the `axis`) must be 0 or 1."),s=s||0,Wt(bm(s),"The third parameter of the `dropNaN` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` NaN values)."),r=s>0?"none":r||"any",Wt(r==="any"||r==="all"||r==="none","The second parameter of the `dropNaN` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains NaN values, then it should be dropped; or that if 'all' of the data contains NaN values, then it should be dropped).");function o(u){let a=ym(u);return s>0?u.length-a.length<s:r==="any"?a.length===u.length:r==="all"?a.length>0:!0}let i=e.copy();if(n===0){let u=i.index.filter(a=>{let l=i.get(a,null).values;return o(l)});return u.length>0?i.get(u,null):new t}else if(n===1){let u=i.columns.filter(a=>{let l=i.get(null,a).values;return o(l)});return u.length>0?i.get(null,u):new t}return i}Vs.exports=wm});var Js=c((u2,Bs)=>{var Rs=m(),xe=F(),Nm=M(),vm=w();function Us(t){let e={};return xe(t).forEach((n,r)=>{e[n]=r}),e}function ae(t){return Object.keys(t).sort((e,n)=>t[e]-t[n])}function Sm(t,e,n,r,s){Rs(Nm(r),"The `filter` method takes a single parameter: a function that is used to filter the values."),vm(s)&&(s=0),Rs(s===0||s===1,"The `axis` parameter to the `filter` method must be 0 or 1.");let o=n.copy();if(o.isEmpty)return o;let i=Us(o.index),u=Us(o.columns);if(s===0){let a=o.values.filter((l,f)=>{let h=new e(l);h.name=n.index[f],h.index=n.columns;let d=r(h,f,n);return d||delete i[o.index[f]],d});if(xe(a).length===0)return new t;if(a.length===1){let l=new e(xe(a));return l.name=ae(i)[0],l.index=ae(u),l}o.values=a,o.index=ae(i)}else if(s===1){o=o.transpose();let a=o.values.filter((l,f)=>{let h=new e(l);h.name=n.columns[f],h.index=n.index;let d=r(h,f,n);return d||delete u[o.index[f]],d});if(xe(a).length===0)return new t;if(a.length===1){let l=new e(xe(a));return l.name=ae(u)[0],l.index=ae(i),l}o.values=a,o.index=ae(u),o=o.transpose()}return o}Bs.exports=Sm});var Te=c((a2,Ys)=>{function xm(t){return typeof t=="boolean"}Ys.exports=xm});var se=c((c2,Ls)=>{var Tm=m(),Om=F(),Fm=p(),Dm=b(),_m=y();function $s(t){if(Dm(t)||_m(t))return $s(t.values);Tm(Fm(t),"The `max` function only works on arrays, Series, and DataFrames!");try{return Math.max(...Om(t))}catch{return NaN}}Ls.exports=$s});var Ht=c((l2,Ws)=>{var Ye=P(),K=m(),W=p(),Gs=Te(),$e=E(),Le=w(),Em=se(),Ks=j();function Am(t,e,n,r,s,o){return n=(()=>{if(Le(n))return!1;if(Gs(n))return n;throw new Ye("The `hasHeaderRow` parameter of the `fromCSV` method must be a boolean!")})(),r=(()=>{if(Le(r))return!1;if(Gs(r))return r;throw new Ye("The `hasIndexColumn` parameter of the `fromCSV` method must be a boolean!")})(),s=(()=>{let u="The `fieldDelimiter` parameter of the `fromCSV` method must be one of:\n\n1) a single-character string (e.g., ',')\n2) an array containing two single-character strings, one each for a left delimiter and a right delimiter (e.g., ['<', '>'])";if(Le(s))return",";if($e(s))return K(s.length===1,u),s;if(W(s))return K(s.length===2,u),K(s[0].length===1,u),K(s[1].length===1,u),s;throw new Ye(u)})(),o=(()=>{let u="The `stringDelimiter` parameter of the `fromCSV` method must be one of:\n\n1) a single-character string (e.g., '\"')\n2) an array containing two single-character strings, one each for a left delimiter and a right delimiter (e.g., ['\u201C', '\u201D'])";if(Le(o))return'"';if($e(o))return K(o.length===1,u),o;if(W(o))return K(o.length===2,u),K(o[0].length===1,u),K(o[1].length===1,u),o;throw new Ye(u)})(),(()=>{let a=e.split(`
`).filter(g=>g.length>0).map(g=>{let N=[],v="",_=!1;for(let C=0;C<g.length;C++){let I=g[C];if(I.match(/\\/g))C++;else if(W(o)&&I===o[0])_=!0;else if(W(o)&&I===o[1])_=!1;else if($e(o)&&I===o)_=!_;else if(W(s)&&I===s[0]||W(s)&&I===s[1]||$e(s)&&I===s)if(_)v+=I;else{let kt=v;try{let Ct=JSON.parse(kt);W(Ct)?N.push(kt.trim()):N.push(Ct)}catch{N.push(kt.trim())}v=""}else v+=I}if(v.length>0){let C=v;try{let I=JSON.parse(C);W(I)?N.push(C.trim()):N.push(I)}catch{N.push(C.trim())}}return N}),l=(()=>{let g=n?a.shift():Ks(0,a[0].length).map(N=>"col"+N);return r&&g.shift(),g})(),f=(()=>r?a.map(N=>N.shift()):Ks(0,a.length).map(N=>"row"+N))(),h=Em(a.map(g=>g.length)),d=new t(a.map(g=>(g.length=h,g)));return n&&(d.columns=l),r&&(d.index=f),d})()}Ws.exports=Am});var Qs=c((f2,Hs)=>{var Mm=P(),Im=m(),jm=Ht(),km=E(),Cm=w();async function zm(t,e,n,r,s,o,i){n=(()=>Cm(n)?"utf8":(Im(km(n),"The `encoding` parameter of the `fromCSV` method must be a string (e.g., 'utf8')!"),n))();let u=await(async()=>{try{return ye("fs").readFileSync(e,n)}catch{}try{return await(await fetch(e)).text()}catch{}throw new Mm(`The path "${e}" could not be loaded!`)})();return jm(t,u,r,s,o,i)}Hs.exports=zm});var eo=c((h2,Zs)=>{var z=m(),Ge=q(),Ke=E(),Xs=w(),Vm=V();function Pm(t,e,n){(Ke(e)||Ge(e))&&(e=[e]),(Ke(n)||Ge(n))&&(n=[n]);let r=Vm((e||[]).concat(n||[]).map(s=>typeof s));return z(r.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===1&&z(r[0]==="string"||r[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===2&&(z(r.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),z(r.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),Xs(e)||(e=e.map(s=>{if(Ke(s))return z(t.index.indexOf(s)>-1,`Row "${s}" does not exist!`),s;if(Ge(s))return z(s>=0,`Index ${s} is out of bounds!`),z(parseInt(s)===s,"Row numbers must be integers!"),z(s<t.index.length,`Index ${s} is out of bounds!`),t.index[s]})),Xs(n)||(n=n.map(s=>{if(Ke(s))return z(t.columns.indexOf(s)>-1,`Column "${s}" does not exist!`),s;if(Ge(s))return z(s>=0,`Column ${s} is out of bounds!`),z(parseInt(s)===s,"Column numbers must be integers!"),z(s<t.columns.length,`Column ${s} is out of bounds!`),t.columns[s]})),t.getSubsetByNames(e,n)}Zs.exports=Pm});var H=c((m2,no)=>{var to=m(),Rm=p(),Um=b(),Bm=M(),Jm=y(),Ym=w();function $m(t,e){try{return t<e?-1:t>e?1:0}catch{return t=typeof t=="object"&&t!==null?JSON.stringify(t):t.toString(),e=typeof e=="object"&&e!==null?JSON.stringify(e):e.toString(),t<e?-1:t>e?1:0}}function Lm(t,e){if(Ym(e)&&(e=$m),Um(t)||Jm(t))return t.sort(...Object.values(arguments).slice(1));to(Rm(t),"The `sort` function only works on arrays, Series, and DataFrames!"),to(Bm(e),"The second parameter of the `sort` function must be a comparison function!");let n=t.slice();return n.sort(e),n}no.exports=Lm});var io=c((d2,oo)=>{var ro=m(),so=E(),Gm=w(),Km=V(),Wm=H();function Hm(t){let e=t.toLowerCase(),n="";for(let s=0;s<e.length;s++){let o=e[s];o.match(/[a-z0-9]/g)?n+=o:n+=" "}let r=n.split(" ").filter(s=>s.length>0);return r[0]+r.slice(1).map(s=>s[0].toUpperCase()+s.substring(1)).join("")}function Qm(t,e,n){Gm(n)?n=e.columns:so(n)&&(n=[n]);let r={};n.forEach(o=>{ro(so(o),"You must pass either a string or a one-dimensional array of strings into the `getDummies` (AKA `oneHotEncode`) method!");let i=e.columns.indexOf(o);ro(i>-1,`The given DataFrame does not have a column called "${o}"!`);let u=e.values.map(l=>l[i]),a=Wm(Km(u));u.forEach(l=>{a.forEach(f=>{let h=o+"_"+Hm(f.toString());r[h]||(r[h]=[]),l===f?r[h].push(1):r[h].push(0)})})});let s=new t(r);return s.index=e.index,s}oo.exports=Qm});var po=c((p2,mo)=>{var Q=m(),uo=p(),ao=q(),co=w(),lo=Se(),fo=j(),ho=T();function Xm(t,e,n){let r=t.shape;co(e)&&(e=fo(0,r[0])),co(n)&&(n=fo(0,r[1])),ao(e)&&(e=[e]),ao(n)&&(n=[n]),Q(uo(e)&&uo(n),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),Q(ho(e).length===1&&ho(n).length===1,"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),Q(e.length>0,"The `rowIndices` array must contain at least one index."),Q(n.length>0,"The `colIndices` array must contain at least one index."),e.forEach(i=>{Q(lo(i),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),Q(i<t.index.length,`The row index ${i} is out of bounds.`)}),n.forEach(i=>{Q(lo(i),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),Q(i<t.columns.length,`The column index ${i} is out of bounds.`)});let s=e.map(i=>t.index[i]),o=n.map(i=>t.columns[i]);return t.getSubsetByNames(s,o)}mo.exports=Xm});var wo=c((g2,bo)=>{var X=m(),Qt=F(),go=p(),We=E(),qo=w(),yo=T();function Zm(t,e,n,r,s){qo(r)&&(r=n.index),qo(s)&&(s=n.columns),We(r)&&(r=[r]),We(s)&&(s=[s]),X(go(r)&&go(s),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),X(yo(r).length===1&&yo(s).length===1,"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),X(r.length>0,"The `rows` array must contain at least one row name."),X(s.length>0,"The `cols` array must contain at least one column name."),r.forEach(u=>{X(We(u),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),X(n.index.indexOf(u)>-1,`The row name "${u}" does not exist in the list of rows.`)}),s.forEach(u=>{X(We(u),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),X(n.columns.indexOf(u)>-1,`The column name "${u}" does not exist in the list of columns.`)});let o=r.map(u=>s.map(a=>n.values[n.index.indexOf(u)][n.columns.indexOf(a)]));if(r.length===1&&s.length===1)return Qt(o)[0];if(r.length===1){let u=new e(Qt(o));return u.name=r[0],u.index=s,u}if(s.length===1){let u=new e(Qt(o));return u.name=s[0],u.index=r,u}let i=new t(o);return i.columns=s,i.index=r,i}bo.exports=Zm});var vo=c((q2,No)=>{var ed=E(),Oe=j();function td(t,e,n){function r(d,g){return ed(d)&&d.length>g?d.substring(0,g-3)+"...":d}if(n.isEmpty)return console.table({}),console.log("Shape:",[0,0],`
`),n;let s=typeof window>"u"?20:10,o=parseInt(s/2),i=typeof window>"u"?Math.floor(process.stdout.columns/24)-1:10,u=parseInt(i/2),a=s>n.index.length?null:Oe(0,o).concat(Oe(n.index.length-o,n.index.length)),l=i>n.columns.length?null:Oe(0,u).concat(Oe(n.columns.length-u,n.columns.length)),f=n.get(a,l);f instanceof e&&(n.shape[0]===1?(f=new t([f.values]),f.index=n.index,f.columns=new e(n.columns).get(l).values):n.shape[1]===1&&(f=new t([f.values]).transpose(),f.index=new e(n.index).get(a).values,f.columns=n.columns)),s<=n.index.length&&(f._index.splice(o,0,"..."),f._values.splice(o,0,Oe(0,f.columns.length).map(()=>"..."))),i<=n.columns.length&&(f._columns.splice(u,0,"..."),f._values=f._values.map(d=>(d.splice(u,0,"..."),d)));let h=28;return f instanceof e?(f.values=f.values.map(d=>r(d,h)),f.name=r(f.name,h),f.index=f.index.map(d=>r(d,h))):(f.values=f.values.map(d=>d.map(g=>r(g,h))),f.columns=f.columns.map(d=>r(d,h)),f.index=f.index.map(d=>r(d,h))),console.table(f.toObject()),console.log("Shape:",n.shape,`
`),n}No.exports=td});var He=c((y2,So)=>{var nd=m(),rd=q();function sd(t,e){nd(rd(t),"The `leftPad` function only works on numbers!");let n=t.toString();for(;n.length<e;)n="0"+n;return n}So.exports=sd});var To=c((b2,xo)=>{var od=He(),id=j();function ud(t,e){let n=e?t:t.copy();return n.index=id(0,t.shape[0]).map(r=>"row"+od(r,(n.index.length-1).toString().length)),n}xo.exports=ud});var Fe=c((w2,Fo)=>{var ad=m(),cd=F(),ld=p(),fd=b(),hd=y();function Oo(t){if(fd(t)||hd(t))return Oo(t.values);ad(ld(t),"The `product` function only works on arrays, Series, and DataFrames!");try{return t.length===0?NaN:cd(t).reduce((e,n)=>e*n,1)}catch{return NaN}}Fo.exports=Oo});var Qe=c((N2,Ao)=>{var De=m(),Do=F(),_o=p(),md=b(),Eo=q(),dd=y(),pd=Fe(),gd=T();function Xt(t,e){if(md(t)||dd(t))return Xt(t.values,e);if(De(_o(t),"The first argument passed into the `reshape` function must be an array!"),Eo(e)&&(e=[e]),De(_o(e),"The second argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),De(gd(e).length===1,"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),e.forEach(o=>{De(Eo(o)&&parseInt(o)===o&&o>0,"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!")}),e.length===0)return Do(t);let n=Do(t);if(e.length===1&&e[0]===n.length)return n;De(pd(e)===n.length,"The new shape doesn't match the number of values available in `x` (the first argument passed into the `reshape` function)!");let r=[],s=parseInt(n.length/e[0]);for(let o=0;o<e[0];o++){let i=n.slice(o*s,(o+1)*s);r.push(Xt(i,e.slice(1)))}return r}Ao.exports=Xt});var ce=c((v2,Vo)=>{var qd=m(),jo=R(),yd=p(),bd=q(),ko=w(),wd=G(),Nd=Fe(),vd=Qe(),Co=Math.pow(2,64),O=[];zo(parseInt(Math.random()*Co));function Sd(t,e){t=A(t);function n(){t+=A("0x9e3779b97f4a7c15");let s=jo(t);return s=(s^s>>30n)*A("0xbf58476d1ce4e5b9"),s=(s^s>>27n)*A("0x94d049bb133111eb"),s^s>>31n}let r=[];for(let s=0;s<e;s++)r.push(n());return r}function A(t){return BigInt.asUintN(64,BigInt(t))}function Mo(t,e){return t=A(t),e=BigInt(e),A(A(t<<e)|A(t>>A(64n-e)))}function zo(t){if(ko(t))return jo(O);{qd(bd(t),"If passing a value into the `seed` function, then that value must be an integer!");let e=Sd(parseInt(t),4);O[0]=e[0],O[1]=e[1],O[2]=e[2],O[3]=e[3]}}function Io(){let t=A(Mo(O[0]+O[3],23)+O[0]),e=A(O[1]<<17n);return O[2]=A(O[2]^O[0]),O[3]=A(O[3]^O[1]),O[1]=A(O[1]^O[2]),O[0]=A(O[0]^O[3]),O[2]=A(O[2]^e),O[3]=Mo(O[3],45),parseInt(t)/Co}function xd(t){return ko(t)?Io():(yd(t)||(t=[t]),vd(wd(Nd(t)).map(Io),t))}Vo.exports={random:xd,seed:zo}});var Xe=c((S2,Po)=>{var{random:Td}=ce(),Od=m(),Fd=p(),Dd=b(),_d=y();function Ed(t){if(Dd(t)||_d(t))return t.shuffle(...Object.values(arguments).slice(1));Od(Fd(t),"The `shuffle` function only works on arrays, Series, and DataFrames!");let e=[],n=t.slice();for(let r=0;r<t.length;r++){let s=parseInt(Td()*n.length);e.push(n.splice(s,1)[0])}return e}Po.exports=Ed});var Bo=c((x2,Uo)=>{var Ad=m(),Md=w(),Ro=Xe();function Id(t,e){return Md(e)&&(e=0),Ad(e===0||e===1,"The `axis` parameter to the `shuffle` must be 0, 1, or undefined."),t.get(e===0?Ro(t.index):null,e===1?Ro(t.columns):null)}Uo.exports=Id});var Go=c((T2,Lo)=>{var{random:jd}=ce(),k=m(),kd=F(),Jo=p(),Zt=Te(),$o=M(),Ze=q(),le=E(),en=w(),Cd=j(),Yo=T(),tn=H();function zd(t,e,n){return $o(e)?Vd(t,e,n):Pd(t,e,n)}function Vd(t,e,n){if(n=en(n)?0:n,k($o(e),"When sorting a DataFrame using a function, the first argument to the `sort` method must be a function!"),k(Ze(n),"When sorting a DataFrame using a function, the second argument to the `sort` method must be null, undefined, 0, or 1 to indicate the axis along which the data should be sorted! An axis of 0 means that the rows will be sorted relative to each other, whereas an axis of 1 means that the columns will be sorted relative to each other."),n===0){let r=tn(t.index,(s,o)=>e(t.get(s,null),t.get(o,null)));return t.get(r,null)}else{let r=tn(t.columns,(s,o)=>e(t.get(null,s),t.get(null,o)));return t.get(null,r)}}function Pd(t,e,n){let r=t.copy(),s=jd().toString();return r=r.assign(s,r.index),en(e)&&(e=[s],n=[!0]),(Ze(e)||le(e))&&(e=[e],(Zt(n)||le(n))&&(n=[n])),k(Jo(e),"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),k(Yo(e).length===1,"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),en(n)&&(n=Cd(0,e.length).map(()=>!0)),k(Jo(n),"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),k(Yo(n).length===1,"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),k(e.length===n.length,"The arrays passed into the `sort` method must be equal in length."),e=e.map(o=>{if(k(le(o)||Ze(o),"Column references can either be column names (as strings) or column indices (as whole numbers)."),le(o)){let i=r.columns.indexOf(o);return k(i>-1,`The column "${o}" does not exist!`),i}if(Ze(o))return k(parseInt(o)===o,"Column indices must be whole numbers!"),k(o>=0,`The column index ${o} is out of bounds!`),k(o<r.columns.length,`The index ${o} is out of bounds!`),o}),n=n.map(o=>{if(k(le(o)||Zt(o),"Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),le(o)){let i=o.trim().toLowerCase();return k(i==="ascending"||i==="descending","Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),i==="ascending"}if(Zt(o))return o}),r.values=tn(r.values,(o,i)=>{let u=0;for(;o[e[u]]===i[e[u]]&&u<e.length;)u++;let a=n[u];if(o[e[u]]===i[e[u]])return 0;if(o[e[u]]<i[e[u]])return a?-1:1;if(o[e[u]]>i[e[u]])return a?1:-1}),r.index=kd(r.get(null,s).values),r=r.dropColumns(s),r}Lo.exports=zd});var nn=c((O2,Wo)=>{var Rd=P(),Ud=Te(),Bd=L(),Jd=E(),Ko=w();function Yd(t,e){e=(()=>{if(Ko(e))return!0;if(Ud(e))return e;throw new Rd("The `shouldIncludeIndex` parameter of the `toCSVString` method must be a boolean!")})();let n=[""].concat(t.index);return[t.columns].concat(t.values).map((s,o)=>(e?[n[o]]:[]).concat(s).map(u=>Jd(u)?JSON.stringify(u):Bd(u)?JSON.stringify(JSON.stringify(u)):Ko(u)?"":u.toString()).join(",")).join(`
`)}Wo.exports=Yd});var Ho=c((F2,sn)=>{var rn=P(),$d=nn();function Ld(t,e,n){let r=$d(t,n),s=!1,o=!1,i,u;try{let a=e;if(e.includes("/")){let f=e.split("/");a=f[f.length-1]}let l=document.createElement("a");l.href=`data:text/csv;charset=utf-8,${encodeURIComponent(r)}`,l.download=a,l.dispatchEvent(new MouseEvent("click")),s=!0}catch(a){i=a}try{let a=ye("fs"),l=ye("path");a.writeFileSync(l.resolve(e),r,"utf8"),o=!0}catch(a){u=a}if(!s&&!o)throw typeof window<"u"?new rn(i):typeof sn<"u"?new rn(u):new rn("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");return t}sn.exports=Ld});var on=c((D2,Qo)=>{function Gd(t,e){return JSON.stringify(t.toObject(e))}Qo.exports=Gd});var Xo=c((_2,an)=>{var un=P(),Kd=on();function Wd(t,e,n){let r=Kd(t,n),s=!1,o=!1,i,u;try{let a=e;if(e.includes("/")){let f=e.split("/");a=f[f.length-1]}let l=document.createElement("a");l.href=`data:application/json;charset=utf-8,${encodeURIComponent(r)}`,l.download=a,l.dispatchEvent(new MouseEvent("click")),s=!0}catch(a){i=a}try{let a=ye("fs"),l=ye("path");a.writeFileSync(l.resolve(e),r,"utf8"),o=!0}catch(a){u=a}if(!s&&!o)throw typeof window<"u"?new un(i):typeof an<"u"?new un(u):new un("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");return t}an.exports=Wd});var ei=c((E2,Zo)=>{var Hd=m(),Qd=w();function Xd(t,e){Qd(e)?e=0:Hd(e===0||e===1,"The axis parameter of the `toObject` method must be undefined, 0, or 1. An axis of 0 indicates that the returned object should be organized first by rows and then by columns. An axis of 1 indicates that the returned object should be organized first by columns and then by rows.");let n={};return e===0?t.index.forEach((r,s)=>{let o={};t.columns.forEach((i,u)=>{o[i]=t.values[s][u]}),n[r]=o}):t.columns.forEach((r,s)=>{let o={};t.index.forEach((i,u)=>{o[i]=t.values[u][s]}),n[r]=o}),n}Zo.exports=Xd});var oe=c((A2,ri)=>{var ti=m(),Zd=p(),ep=b(),tp=y(),np=G(),ni=ve(),rp=T();function sp(t){if(ep(t)||tp(t))return t.transpose();ti(Zd(t),"The `transpose` function only works on arrays, Series, and DataFrames!");let e=rp(t);if(ti(e.length<=2,"I'm not smart enough to know how to transpose arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `transpose` function!"),e.length===1)return ni(t);if(e.length===2){let n=np(ni(e));for(let r=0;r<e[0];r++)for(let s=0;s<e[1];s++)n[s][r]=t[r][s];return n}}ri.exports=sp});var ui=c((M2,ii)=>{var si=m(),op=p(),ip=b(),up=Re(),ap=y(),cp=T();function oi(t,e,n){if(ap(n))return new t(e.values.concat(n.values));if(op(n)){let r=cp(n);si(r.length===1&&!up(r),"Only vectors can be appended to Series!");let s=e.copy();return n.forEach((o,i)=>{s._values.push(o),s._index.push("item"+(e.values.length+i))}),s}return si(!ip(n),"DataFrames cannot be appended to Series!"),oi(e,[n])}ii.exports=oi});var ci=c((I2,ai)=>{var lp=m(),fp=M();function hp(t,e){lp(fp(e),"The parameter to the `apply` method must be a function.");let n=t.copy();return n._values=n._values.map((r,s)=>e(r,s)),n}ai.exports=hp});var fi=c((j2,li)=>{var mp=w();function dp(t){let e=t.copy(),n=[];return e._values=e.values.filter((r,s)=>mp(r)?!1:(n.push(e.index[s]),!0)),e._index=n,e}li.exports=dp});var mi=c((k2,hi)=>{var pp=q();function gp(t,e){let n=[],r=[];e.values.forEach((o,i)=>{pp(o)&&(r.push(o),n.push(e.index[i]))});let s=new t(r);return s.name=e.name,s.index=n,s}hi.exports=gp});var pi=c((C2,di)=>{var qp=R();function yp(t,e,n){let r=e.copy(),s=qp(r.index),o=[],i=r.values.filter((u,a)=>{let l=n(u,a,r.values);return l||o.push(r.index[a]),l});return o.forEach(u=>{s.splice(s.indexOf(u),1)}),i.length===0?(r=new t,r.name=e.name,r):(r.values=i,r.index=s,r)}di.exports=yp});var qi=c((z2,gi)=>{var Z=m(),bp=q(),wp=E(),Np=w(),vp=V();function Sp(t,e){(wp(e)||bp(e))&&(e=[e]);let n=vp((e||[]).map(r=>typeof r));return Z(n.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===1&&Z(n[0]==="string"||n[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===2&&(Z(n.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),Z(n.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),Np(e)||(e=e.map(r=>{if(typeof r=="string")return Z(t.index.indexOf(r)>-1,`Index "${r}" does not exist!`),r;if(typeof r=="number")return Z(r>=0,`Index ${r} is out of bounds!`),Z(parseInt(r)===r,"Indices must be integers!"),Z(r<t.index.length,`Index ${r} is out of bounds!`),t.index[r]})),t.getSubsetByNames(e)}gi.exports=Sp});var bi=c((V2,yi)=>{var _e=m(),xp=p(),Tp=w(),Op=Se(),Fp=j(),Dp=T();function _p(t,e){let n=t.shape;Tp(e)&&(e=Fp(0,n[0])),_e(xp(e),"The `indices` array must be 1-dimensional array of whole numbers."),_e(Dp(e).length===1,"The `indices` array must be a 1-dimensional array of whole numbers."),_e(e.length>0,"The `indices` array must contain at least one index."),e.forEach(s=>{_e(Op(s),"The `indices` array must be a 1-dimensional array of whole numbers."),_e(s<t.index.length,`The row index ${s} is out of bounds.`)});let r=e.map(s=>t.index[s]);return t.getSubsetByNames(r)}yi.exports=_p});var Ni=c((P2,wi)=>{var Ee=m(),Ep=p(),Ap=E(),Mp=w(),Ip=T();function jp(t,e,n){Mp(n)&&(n=e.index),Ee(Ep(n),"The `indices` array must be a 1-dimensional array of strings."),Ee(Ip(n).length===1,"The `indices` array must be a 1-dimensional array of strings."),Ee(n.length>0,"The `indices` array must contain at least one index name."),n.forEach(o=>{Ee(Ap(o),"The `indices` array must contain only strings."),Ee(e.index.indexOf(o)>-1,`The name "${o}" does not exist in the index.`)});let r=n.map(o=>e.values[e.index.indexOf(o)]);if(r.length===1)return r[0];let s=new t(r);return s.index=n,s.name=e.name,s}wi.exports=jp});var xi=c((R2,Si)=>{var kp=R(),vi=j();function Cp(t){let e=t.copy(),n=typeof window>"u"?20:10;if(e.index.length>n){e=e.get(vi(0,n/2).concat(vi(e.index.length-n/2,e.index.length)));let s=kp(e.index);s.splice(parseInt(s.length/2),0,"..."),e.values.push("..."),e.index.push("..."),e=e.get(s)}let r={};return e.values.forEach((s,o)=>{let i={};i[e.name]=s,r[e.index[o]]=i}),console.table(r),console.log("Shape:",t.shape,`
`),t}Si.exports=Cp});var Oi=c((U2,Ti)=>{var zp=Xe();function Vp(t){let e=t.copy();return e.get(zp(e.index))}Ti.exports=Vp});var Di=c((B2,Fi)=>{var Pp=m(),Rp=M(),Up=w(),Bp=H(),Jp=oe();function Yp(t,e,n){n=n||((a,l)=>a<l?-1:1),Pp(Up(n)||Rp(n),"You must pass undefined, null, or a comparison function as the second argument to the `sort` method!");let r=Jp([e.values,e.index]),s=Bp(r,(a,l)=>n(a[0],l[0])),o=[],i=[];s.forEach(a=>{o.push(a[0]),i.push(a[1])});let u=new t;return u._values=o,u._index=i,u.name=e.name,u}Fi.exports=Yp});var Ai=c((J2,Ei)=>{var $p=H(),_i=oe();function Lp(t,e){let n=_i([e.values,e.index]);n=_i($p(n,(s,o)=>{if(s[1]===o[1])return 0;if(s[1]<o[1])return-1;if(s[1]>o[1])return 1}));let r=new t(n[0]);return r.index=n[1],r.name=e.name,r}Ei.exports=Lp});var Ii=c((Y2,Mi)=>{function Gp(t){let e={};return e[t.name]={},t.index.forEach((n,r)=>{e[t.name][n]=t.values[r]}),e}Mi.exports=Gp});var Vi=c(($2,zi)=>{var Y=m(),et=R(),cn=p(),Kp=E(),Wp=w(),ji=He(),ki=j(),tt=ve(),Hp=ui(),Qp=ci(),Xp=fi(),Zp=mi(),eg=pi(),tg=qi(),ng=bi(),rg=Ni(),sg=xi(),og=Oi(),ig=Di(),ug=Ai(),ag=Ii(),Ae=T(),cg=oe(),Ci=Symbol.for("@jrc03c/js-math-tools/series");zi.exports=function(t){class e{static[Symbol.hasInstance](r){try{return!!r._symbol&&r._symbol===Ci}catch{return!1}}constructor(r){let s=this;if(s.name="data",Object.defineProperty(s,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:Ci}),Object.defineProperty(s,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(s,"values",{configurable:!0,enumerable:!0,get(){return s._values},set(o){Y(cn(o),"The new values must be a 1-dimensional array!");let i=Ae(o);Y(i.length===1,"The new array of values must be 1-dimensional!"),i[0]<s._index.length?s._index=s._index.slice(0,i[0]):i[0]>s._index.length&&(s._index=s._index.concat(ki(s._index.length,i[0]).map(u=>"item"+ji(u,(o.length-1).toString().length)))),s._values=o}}),Object.defineProperty(s,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(s,"index",{configurable:!0,enumerable:!0,get(){return s._index},set(o){Y(cn(o),"The new index must be a 1-dimensional array of strings!"),Y(o.length===s.shape[0],"The new index must be the same length as the old index!"),Y(Ae(o).length===1,"The new index must be a 1-dimensional array of strings!"),o.forEach(i=>{Y(Kp(i),"All of the row names must be strings!")}),s._index=o}}),r){if(r instanceof e)s.name=r.name,s.values=et(r.values),s.index=et(r.index);else if(cn(r)){let o=Ae(r);Y(o.length===1,"When passing an array into the constructor of a Series, the array must be 1-dimensional!"),s.values=r}else if(r instanceof Object){let o=Object.keys(r);Y(o.length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");let i=o[0],u=r[i];Y(Ae(u).length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!"),s.name=i,s.values=u.slice()}}}get shape(){return Ae(this.values)}get length(){return this.shape[0]}get isEmpty(){return this.values.filter(s=>!Wp(s)).length===0}clear(){let s=this.copy();return s.values.forEach((o,i)=>{s.values[i]=void 0}),s}get(r){return tg(this,r)}getSubsetByNames(r){return rg(e,this,r)}getSubsetByIndices(r){return ng(this,r)}loc(r){return this.getSubsetByNames(r)}iloc(r){return this.getSubsetByIndices(r)}reverse(){let r=this,s=new e(tt(r.values));return s.index=tt(r.index),s.name=r.name,s}resetIndex(){let r=this,s=r.copy();return s.index=ki(0,r.shape[0]).map(o=>"item"+ji(o,(s.index.length-1).toString().length)),s}copy(){let r=this,s=new e;return s._values=et(r.values),s._index=et(r.index),s.name=r.name,s}append(r){return Hp(e,this,r)}apply(r){return Qp(this,r)}concat(r){return this.append(r)}dropMissing(r,s){return Xp(this,r,s)}dropNaN(){return Zp(e,this)}toObject(){return ag(this)}print(){return sg(this)}shuffle(){return og(this)}sort(r){return ig(e,this,r)}sortByIndex(){return ug(e,this)}filter(r){return eg(e,this,r)}toDataFrame(){let r=this,s=new t(cg([r.values]));return s.columns=[r.name],s.index=r.index,s}transpose(){let s=this.copy();return s.values=tt(s.values),s.index=tt(s.index),s}getDummies(){return this.toDataFrame().getDummies()}oneHotEncode(){return this.getDummies()}}return e}});var Ie=c((L2,Yi)=>{var B=m(),ln=R(),Pi=Pe(),lg=ds(),fg=bs(),hg=Ss(),mg=Ts(),dg=Ms(),pg=ks(),gg=Ps(),qg=Js(),yg=Qs(),bg=Ht(),wg=eo(),Ri=io(),Ng=po(),vg=wo(),Sg=vo(),xg=To(),Tg=Bo(),Og=Go(),Fg=Ho(),Dg=nn(),_g=Xo(),Eg=on(),Ag=ei(),Mg=F(),Me=p(),Ig=L(),Ui=w(),fn=He(),jg=G(),hn=j(),fe=T(),Bi=oe(),Ji=Symbol.for("@jrc03c/js-math-tools/dataframe");function nt(t){let e="abcdefghijklmnopqrstuvwxyz1234567890",n="";for(let r=0;r<t;r++)n+=e[parseInt(Math.random()*e.length)];return n}var D=class{static[Symbol.hasInstance](e){try{return!!e._symbol&&e._symbol===Ji}catch{return!1}}constructor(e){let n=this;if(Object.defineProperty(n,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:Ji}),Object.defineProperty(n,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(n,"values",{configurable:!0,enumerable:!0,get(){return n._values.length===0||!Ui(n._values[0])&&n._values[0].length===0?[[]]:n._values},set(r){B(Me(r),"The new values must be a 2-dimensional array!");let s=fe(r);B(s.length===2,"The new array of values must be 2-dimensional!"),s[0]<n._index.length?n._index=n._index.slice(0,s[0]):s[0]>n._index.length&&(n._index=n._index.concat(hn(n._index.length,s[0]).map(o=>"row"+fn(o,(s[0]-1).toString().length)))),s[1]<n._columns.length?n._columns=n._columns.slice(0,s[1]):s[1]>n._columns.length&&(n._columns=n._columns.concat(hn(n._columns.length,s[1]).map(o=>"col"+fn(o,(s[1]-1).toString().length)))),n._values=r}}),Object.defineProperty(n,"_columns",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(n,"columns",{configurable:!0,enumerable:!0,get(){return n._columns},set(r){B(Me(r),"The new columns list must be a 1-dimensional array of strings!"),B(n.isEmpty||r.length===n.shape[1],"The new columns list must be the same length as the old columns list!"),B(fe(r).length===1,"The new columns list must be a 1-dimensional array of strings!"),r=r.map(o=>(typeof o!="string"&&(o=JSON.stringify(o)||o.toString()),o.trim().length===0?"untitled_"+nt(8):o.trim()));let s=(()=>{let o=Pi(r),i={};return o.forEach(u=>{i[u.item]=u.count}),i})();r=r.map(o=>s[o]>1?o+"_"+nt(8):o),n._columns=r}}),Object.defineProperty(n,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(n,"index",{configurable:!0,enumerable:!0,get(){return n._index},set(r){B(Me(r),"The new index must be a 1-dimensional array of strings!"),B(n.isEmpty||r.length===n.shape[0],"The new index must be the same length as the old index!"),B(fe(r).length===1,"The new index must be a 1-dimensional array of strings!"),r=r.map(o=>(typeof o!="string"&&(o=JSON.stringify(o)||o.toString()),o.trim().length===0?"untitled_"+nt(8):o.trim()));let s=(()=>{let o=Pi(r),i={};return o.forEach(u=>{i[u.item]=u.count}),i})();r=r.map(o=>s[o]>1?o+"_"+nt(8):o),n._index=r}}),B(Ui(e)||Ig(e)||Me(e),"The `data` passed into the constructor of a DataFrame must be either (1) an object where the key-value pairs are (respectively) column names and 1-dimensional arrays of values, or (2) a 2-dimensional array of values."),e)if(e instanceof D)n.values=ln(e.values),n.columns=ln(e.columns),n.index=ln(e.index);else if(Me(e)){let r=fe(e);B(r.length===2,"The `data` array passed into the constructor of a DataFrame must be 2-dimensional!"),n.values=e}else{n._columns=Object.keys(e);let r=[];n._columns.forEach(o=>{let i=e[o];r.push(i)}),n._values=Bi(r);let s=fe(n.values);n._index=hn(0,s[0]).map(o=>"row"+fn(o,(s[0]-1).toString().length))}}get shape(){return fe(this.values)}get length(){return this.shape[0]}get width(){return this.shape[1]}get rows(){return this.index}set rows(e){let n=this;n.index=e}get isEmpty(){return Mg(this.values).length===0}clear(){let e=this,n=new D(jg(e.shape));return n.columns=e.columns.slice(),n.index=e.index.slice(),n}get(e,n){let r=this;if(arguments.length===0)return r;if(arguments.length===1)try{return r.get(null,e)}catch{return r.get(e,null)}return wg(r,e,n)}getSubsetByNames(e,n){return vg(D,ee,this,e,n)}getSubsetByIndices(e,n){return Ng(this,e,n)}getDummies(e){return Ri(D,this,e)}oneHotEncode(e){return Ri(D,this,e)}transpose(){let e=this,n=new D(Bi(e.values));return n.columns=e.index.slice(),n.index=e.columns.slice(),n}get T(){return this.transpose()}resetIndex(e){return xg(this,e)}copy(){return mg(D,this)}assign(e,n){return hg(D,ee,this,e,n)}apply(e,n){return fg(D,ee,this,e,n)}dropMissing(e,n,r){return pg(D,ee,this,e,n,r)}dropNaN(e,n,r){return gg(D,this,e,n,r)}drop(e,n){return dg(D,ee,this,e,n)}dropColumns(e){return this.drop(null,e)}dropRows(e){return this.drop(e,null)}toObject(e){return Ag(this,e)}toCSVString(e){return Dg(this,e)}saveAsCSV(e,n){return Fg(this,e,n)}toJSONString(e){return Eg(this,e)}saveAsJSON(e,n){return _g(this,e,n)}print(){return Sg(D,ee,this)}sort(e,n){return Og(this,e,n)}sortByIndex(){return this.sort()}filter(e,n){return qg(D,ee,this,e,n)}shuffle(e){return Tg(this,e)}append(e,n){return lg(this,e,n)}concat(e,n){return this.append(e,n)}join(e,n){return this.append(e,n)}toString(){let e=this;return JSON.stringify(e)}};D.fromCSV=function(){return yg(D,...arguments)};D.fromCSVString=function(){return bg(D,...arguments)};var ee=Vi()(D);Yi.exports={DataFrame:D,Series:ee}});var S=c((G2,Wi)=>{var{DataFrame:$i,Series:Li}=Ie(),Gi=m(),je=p(),mn=b(),Ki=U(),kg=M(),dn=y(),Cg=se(),zg=j(),rt=T();function Vg(t){return je(t)||dn(t)||mn(t)}function Pg(t){return Gi(kg(t),"You must pass a function into the `vectorize` function!"),function e(){let n,r,s=[],o=[],i=Object.keys(arguments).filter(u=>{let a=arguments[u];return je(a)?!0:dn(a)?(n=!0,s.push(a),!0):mn(a)?(r=!0,o.push(a),!0):!1}).map(u=>arguments[u]);if(i.slice(0,-1).forEach((u,a)=>{Gi(Ki(je(u)?rt(u):u.shape,je(i[a+1])?rt(i[a+1]):i[a+1].shape),`When passing multiple arrays into the \`${t.name}\` function, all of the arrays must have the same shape!`)}),i.length>0){let u=Cg(i.map(l=>l.length?l.length:l.values.length)),a=zg(0,u).map(l=>{let f=Object.keys(arguments).map(h=>{if(Vg(arguments[h])){if(je(arguments[h]))return arguments[h][l];if(dn(arguments[h]))return arguments[h].values[l];if(mn(arguments[h]))return arguments[h].values[l]}else return arguments[h]});return e(...f)});if(r)try{if(o.length===1&&Ki(rt(o[0]),rt(a))){let l=new $i(a);return l.index=o[0].index.slice(),l.columns=o[0].columns.slice(),l}else return new $i(a)}catch{return a}if(n)try{if(s.length===1&&s[0].length===a.length){let l=new Li(a);return l.name=s[0].name,l.index=s[0].index.slice(),l}else return new Li(a)}catch{return a}return a}else return t(...arguments)}}Wi.exports=Pg});var st=c((K2,Hi)=>{var Rg=q(),Ug=S();function Bg(t){try{return Rg(t)?Math.abs(t):NaN}catch{return NaN}}Hi.exports=Ug(Bg)});var ot=c((W2,Qi)=>{var Jg=q(),Yg=S();function $g(){try{let t=0,e=Object.values(arguments);for(let n=0;n<e.length;n++){if(!Jg(e[n]))return NaN;t+=e[n]}return t}catch{return NaN}}Qi.exports=Yg($g)});var it=c((H2,Xi)=>{var Lg=S();function Gg(t,e){try{return e(t)}catch{return NaN}}Xi.exports=Lg(Gg)});var eu=c((Q2,Zi)=>{var Kg=q(),Wg=S();function Hg(t){try{return Kg(t)?Math.acos(t):NaN}catch{return NaN}}Zi.exports=Wg(Hg)});var nu=c((X2,tu)=>{var Qg=q(),Xg=S();function Zg(t){try{return Qg(t)?Math.asin(t):NaN}catch{return NaN}}tu.exports=Xg(Zg)});var su=c((Z2,ru)=>{var eq=q(),tq=S();function nq(t){try{return eq(t)?Math.atan(t):NaN}catch{return NaN}}ru.exports=tq(nq)});var iu=c((ex,ou)=>{var rq=m(),sq=be(),oq=p(),iq=b(),uq=y(),aq=se();function pn(t){if(iq(t)){let e=pn(t.values);return[t.index[e[0]],t.columns[e[1]]]}if(uq(t)){let e=pn(t.values);return[t.index[e]]}rq(oq(t),"The `argmax` function only works on arrays, Series, and DataFrames!");try{let e=sq(t,aq(t));return e?e.length===0?void 0:e.length===1?e[0]:e:void 0}catch{return}}ou.exports=pn});var ut=c((tx,au)=>{var cq=m(),lq=F(),fq=p(),hq=b(),mq=y();function uu(t){if(hq(t)||mq(t))return uu(t.values);cq(fq(t),"The `min` function only works on arrays, Series, and DataFrames!");try{return Math.min(...lq(t))}catch{return NaN}}au.exports=uu});var lu=c((nx,cu)=>{var dq=m(),pq=be(),gq=p(),qq=b(),yq=y(),bq=ut();function gn(t){if(qq(t)){let e=gn(t.values);return[t.index[e[0]],t.columns[e[1]]]}if(yq(t)){let e=gn(t.values);return[t.index[e]]}dq(gq(t),"The `argmin` function only works on arrays, Series, and DataFrames!");try{let e=pq(t,bq(t));return e?e.length===0?void 0:e.length===1?e[0]:e:void 0}catch{return}}cu.exports=gn});var hu=c((rx,fu)=>{var wq=q(),Nq=S();function vq(t){try{return wq(t)?Math.ceil(t):NaN}catch{return NaN}}fu.exports=Nq(vq)});var pu=c((sx,du)=>{var Sq=st(),mu=q(),xq=w(),Tq=S();function Oq(t,e){try{if(!mu(t))return NaN;if(xq(e))e=1e-10;else if(!mu(e))return NaN;return Sq(t)<e?0:t}catch{return NaN}}du.exports=Tq(Oq)});var qu=c((ox,gu)=>{var qn=q(),Fq=S();function Dq(t,e,n){try{return qn(t)?qn(e)?qn(n)?t<e?e:t>n?n:t:NaN:NaN:NaN}catch{return NaN}}gu.exports=Fq(Dq)});var bu=c((ix,yu)=>{var yn=m(),_q=F(),Eq=p(),Aq=b(),Mq=q(),Iq=y();function bn(t,e){if(Aq(t)||Iq(t))return bn(t.values,e);if(yn(Eq(t),"The `combinations` function only works on arrays, Series, and DataFrames!"),yn(Mq(e),"`r` must be a whole number!"),t=_q(t),e>t.length)return[t];if(e<=0)return[[]];if(yn(e===parseInt(e),"`r` must be a whole number!"),t.length<2)return t;let n=[];return t.forEach((r,s)=>{let o=t.slice(s+1);if(o.length<e-1)return;bn(o,e-1).forEach(u=>{n.push([r].concat(u))})}),n}yu.exports=bn});var at=c((ux,Nu)=>{var jq=m(),kq=F(),Cq=p(),zq=b(),Vq=y();function wu(t){if(zq(t)||Vq(t))return wu(t.values);jq(Cq(t),"The `mean` function only works on arrays, Series, and DataFrames!");try{let e=kq(t),n=0;return e.forEach(r=>{n+=r}),n/e.length}catch{return NaN}}Nu.exports=wu});var Nn=c((ax,Fu)=>{var vu=m(),Su=p(),ct=q(),xu=y(),Tu=at(),Ou=T();function wn(t,e){if(xu(t))return wn(t.values,e);if(xu(e))return wn(t,e.values);vu(Su(t)&&Su(e)&&Ou(t).length===1&&Ou(e).length===1,"The `covariance` function only works on 1-dimensional arrays and Series!"),vu(t.length===e.length,"The two arrays or Series passed into the `covariance` function must have the same length!");try{let n=Tu(t),r=Tu(e);if(!ct(n)||!ct(r))return NaN;let s=Math.max(t.length,e.length),o=0;for(let i=0;i<s;i++){if(!ct(t[i]))return NaN;if(!ct(e[i]))return NaN;o+=(t[i]-n)*(e[i]-r)}return o/t.length}catch{return NaN}}Fu.exports=wn});var lt=c((cx,Du)=>{var Pq=q(),Rq=S();function Uq(t){try{return Pq(t)?Math.sqrt(t):NaN}catch{return NaN}}Du.exports=Rq(Uq)});var vn=c((lx,Eu)=>{var Bq=m(),Jq=F(),Yq=p(),$q=b(),Lq=q(),Gq=y(),Kq=at();function _u(t){if($q(t)||Gq(t))return _u(t.values);Bq(Yq(t),"The `variance` function only works on arrays, Series, and DataFrames!");try{let e=Jq(t),n=Kq(e),r=0;for(let s=0;s<e.length;s++){if(!Lq(e[s]))return NaN;r+=(e[s]-n)*(e[s]-n)}return r/e.length}catch{return NaN}}Eu.exports=_u});var ft=c((fx,Mu)=>{var Wq=m(),Hq=p(),Qq=b(),Xq=y(),Zq=lt(),ey=vn();function Au(t){if(Qq(t)||Xq(t))return Au(t.values);Wq(Hq(t),"The `std` function only works on arrays, Series, and DataFrames!");try{return Zq(ey(t))}catch{return NaN}}Mu.exports=Au});var Pu=c((hx,Vu)=>{var Iu=m(),ty=Nn(),ju=p(),ku=y(),Cu=T(),zu=ft();function Sn(t,e){if(ku(t))return Sn(t.values,e);if(ku(e))return Sn(t,e.values);Iu(ju(t)&&ju(e)&&Cu(t).length===1&&Cu(e).length===1,"The `correl` function only works on 1-dimensional arrays and Series!"),Iu(t.length===e.length,"The two arrays or Series passed into the `correl` function must have the same length!");try{return ty(t,e)/(zu(t)*zu(e))}catch{return NaN}}Vu.exports=Sn});var Uu=c((mx,Ru)=>{var ny=q(),ry=S();function sy(t){try{return ny(t)?Math.cos(t):NaN}catch{return NaN}}Ru.exports=ry(sy)});var Gu=c((dx,Lu)=>{var oy=m(),Bu=p(),Ju=b(),iy=U(),Yu=y(),$u=V();function xn(t,e){if(Ju(t)||Yu(t))return xn(t.values,e);if(Ju(e)||Yu(e))return xn(t,e.values);oy(Bu(t)&&Bu(e),"The `diff` function only works on arrays, Series, and DataFrames!");let n=$u(t),r=$u(e),s=[];return n.forEach(o=>{r.findIndex(i=>iy(i,o))<0&&s.push(o)}),s}Lu.exports=xn});var ht=c((px,Wu)=>{var Ku=q(),uy=S();function ay(t,e){try{return Ku(t)?Ku(e)?Math.pow(t,e):NaN:NaN}catch{return NaN}}Wu.exports=uy(ay)});var Tn=c((gx,Hu)=>{var cy=q(),ly=S();function fy(){try{let t=Object.values(arguments);if(t.length===0)return NaN;let e=1;for(let n=0;n<t.length;n++){if(!cy(t[n]))return NaN;e*=t[n]}return e}catch{return NaN}}Hu.exports=ly(fy)});var he=c((qx,Qu)=>{var hy=Tn();function my(){return hy(...arguments)}Qu.exports=my});var On=c((yx,Xu)=>{var dy=ot(),py=he();function gy(t,e){return dy(t,py(e,-1))}Xu.exports=gy});var mt=c((bx,ea)=>{var qy=m(),yy=F(),by=p(),wy=b(),Ny=y();function Zu(t){if(wy(t)||Ny(t))return Zu(t.values);qy(by(t),"The `sum` function only works on arrays, Series, and DataFrames!");try{return t.length===0?NaN:yy(t).reduce((e,n)=>e+n,0)}catch{return NaN}}ea.exports=Zu});var ua=c((wx,ia)=>{var vy=st(),Sy=m(),ta=p(),na=b(),xy=U(),ra=q(),sa=y(),Ty=ht(),oa=T(),Oy=lt(),Fy=On(),Dy=mt();function Fn(t,e){if(ra(t)&&ra(e))return vy(t-e);if(na(t)||sa(t))return Fn(t.values,e);if(na(e)||sa(e))return Fn(t,e.values);ta(t)&&ta(e)&&Sy(xy(oa(t),oa(e)),"If passing two arrays, Series, or DataFrames into the `distance` function, then those objects must have the same shape!");try{return Oy(Dy(Ty(Fy(t,e),2)))}catch{return NaN}}ia.exports=Fn});var ca=c((Nx,aa)=>{var _y=ht(),Ey=he();function Ay(t,e){return Ey(t,_y(e,-1))}aa.exports=Ay});var _n=c((vx,pa)=>{var{DataFrame:la,Series:fa}=Ie(),dt=m(),ha=F(),ma=p(),Dn=b(),My=q(),pt=y(),Iy=he(),gt=T(),jy=mt(),da=oe();function te(t,e){if(Dn(t)){let s=te(t.values,e);if(gt(s).length===1){let o=new fa(s);return o.name=pt(e)?e.name:o.name,o.index=t.index.slice(),o}else{let o=new la(s);return o.index=t.index.slice(),Dn(e)&&(o.columns=e.columns.slice()),o}}if(Dn(e)){let s=te(t,e.values);if(gt(s).length===1){let o=new fa(s);return o.name=pt(t)?t.name:o.name,o.index=e.columns.slice(),o}else{let o=new la(s);return o.columns=e.columns.slice(),o}}if(pt(t))return te(t.values,e);if(pt(e))return te(t,e.values);dt(ma(t)&&ma(e),"The `dot` function only works on arrays, Series, and DataFrames!"),ha(t).concat(ha(e)).forEach(s=>{dt(My(s),"One of the arrays you passed into the `dot` function contains non-numerical values!")});let n=gt(t),r=gt(e);if(dt(n.length<=2&&r.length<=2,"I'm not smart enough to know how to get the dot-product of arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `dot` function!"),dt(n[n.length-1]===r[0],`There's a dimension misalignment in the two arrays you passed into the \`dot\` function. (${n[n.length-1]} !== ${r[0]})`),n.length===1&&r.length===1)return jy(Iy(t,e));if(n.length===1&&r.length===2)return da(e).map(s=>te(t,s));if(n.length===2&&r.length===1)return t.map(s=>te(s,e));if(n.length===2&&r.length===2){let s=da(e),o=[];for(let i=0;i<t.length;i++){let u=[];for(let a=0;a<s.length;a++)u.push(te(t[i],s[a]));o.push(u)}return o}}pa.exports=te});var En=c((Sx,qa)=>{var ky=m(),Cy=p(),zy=b(),Vy=y(),Py=w();function ga(t){if(zy(t)||Vy(t))return t.dropMissing(...Object.values(arguments).slice(1));ky(Cy(t),"The `dropMissing` function only works on arrays, Series, and DataFrames!");let e=[];return t.forEach(n=>{try{return e.push(ga(n))}catch{Py(n)||e.push(n)}}),e}qa.exports=ga});var Ta=c((xx,xa)=>{var ya=m(),ba=p(),wa=b(),Ry=U(),Na=y(),va=w(),Sa=T();function qt(t,e){if(wa(t)||Na(t))return qt(t.values,e);if(wa(e)||Na(e))return qt(t,e.values);ya(ba(t)&&ba(e),"The `dropMissingPairwise` function only works on arrays, Series, and DataFrames!"),ya(Ry(Sa(t),Sa(e)),"The two arrays, Series, and/or DataFrames passed into the `dropMissingPairwise` function must have the same shape!");let n=[],r=[];for(let s=0;s<t.length;s++)try{let[o,i]=qt(t[s],e[s]);n.push(o),r.push(i)}catch{!va(t[s])&&!va(e[s])&&(n.push(t[s]),r.push(e[s]))}return[n,r]}xa.exports=qt});var Ia=c((Tx,Ma)=>{var Oa=m(),Fa=p(),Da=b(),Uy=U(),_a=q(),Ea=y(),Aa=T();function yt(t,e){if(Da(t)||Ea(t))return yt(t.values,e);if(Da(e)||Ea(e))return yt(t,e.values);Oa(Fa(t)&&Fa(e),"The `dropNaNPairwise` only works on arrays, Series, and DataFrames!"),Oa(Uy(Aa(t),Aa(e)),"The two arrays, Series, and/or DataFrames passed into the `dropNaNPairwise` must have the same shape!");let n=[],r=[];for(let s=0;s<t.length;s++)try{let[o,i]=yt(t[s],e[s]);n.push(o),r.push(i)}catch{_a(t[s])&&_a(e[s])&&(n.push(t[s]),r.push(e[s]))}return[n,r]}Ma.exports=yt});var ka=c((Ox,ja)=>{var By=En();function Jy(t){return By(t)}ja.exports=Jy});var za=c((Fx,Ca)=>{var Yy=q(),$y=S();function Ly(t){try{return Yy(t)?Math.exp(t):NaN}catch{return NaN}}Ca.exports=$y(Ly)});var Ra=c((Dx,Pa)=>{var Gy=S();function Va(t){try{return t!==parseInt(t)?NaN:t<=1?1:t*Va(t-1)}catch{return NaN}}Pa.exports=Gy(Va)});var Ya=c((_x,Ja)=>{var Ky=m(),Wy=F(),Ua=p(),Hy=b(),Qy=M(),Ba=L(),Xy=y();function An(t,e){if(Hy(t))return An(Wy(t.values),e);if(Xy(t))return An(t.values,e);if(Ky(Ba(t)||Ua(t),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `find` function!"),!Qy(e)){let s=e;e=o=>o===s}function n(s,o,i){if(i=i||[],i.indexOf(s)>-1)return null;if(Ba(s)){i.push(s);let u=Object.keys(s);for(let a=0;a<u.length;a++){let l=u[a],f=s[l];if(o(f))return f;let h=n(f,o,i);if(h)return h}}else if(Ua(s)){i.push(s);for(let u=0;u<s.length;u++){let a=s[u];if(o(a))return a;let l=n(a,o,i);if(l)return l}}else if(o(s))return s;return null}function r(s){try{return e(s)}catch{return!1}}return n(t,r)}Ja.exports=An});var Ka=c((Ex,Ga)=>{var Zy=m(),e1=F(),$a=p(),t1=b(),n1=M(),La=L(),r1=y();function Mn(t,e){if(t1(t))return Mn(e1(t.values),e);if(r1(t))return Mn(t.values,e);if(Zy(La(t)||$a(t),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `findAll` function!"),!n1(e)){let o=e;e=i=>i===o}function n(o,i,u){if(u=u||[],u.indexOf(o)>-1)return null;if(La(o)){u.push(o);let a=Object.keys(o),l=[];for(let f=0;f<a.length;f++){let h=a[f],d=o[h],g=!1;i(d)&&(l.push(d),g=!0);let N=n(d,i,u);N&&N.length>0&&N.slice(g?1:0).forEach(v=>l.push(v))}return l}else if($a(o)){u.push(o);let a=[];for(let l=0;l<o.length;l++){let f=o[l],h=!1;i(f)&&(a.push(f),h=!0);let d=n(f,i,u);d&&d.length>0&&d.slice(h?1:0).forEach(g=>a.push(g))}return a}else if(i(o))return[o];return null}function r(o){try{return e(o)}catch{return!1}}let s=n(t,r);return s&&s.length>0?s:null}Ga.exports=Mn});var Ha=c((Ax,Wa)=>{var s1=q(),o1=S();function i1(t){try{if(t==="Infinity")return 1/0;if(t==="-Infinity")return-1/0;let e=JSON.parse(t);return s1(e)?e:NaN}catch{return NaN}}Wa.exports=o1(i1)});var Xa=c((Mx,Qa)=>{var u1=q(),a1=S();function c1(t){try{return u1(t)?Math.floor(t):NaN}catch{return NaN}}Qa.exports=a1(c1)});var In=c((Ix,Za)=>{var l1=q(),f1=Fe(),h1=Qe();function m1(t){l1(t)&&(t=[t]);let e=[],n=f1(t);for(let r=0;r<n;r++)e.push(0);return h1(e,t)}Za.exports=m1});var tc=c((jx,ec)=>{var bt=m(),d1=q(),p1=w(),g1=In();function q1(t){bt(!p1(t),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),bt(d1(t),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),bt(parseInt(t)===t,"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),bt(t>0,"You must pass an integer greater than 0 (representing the size) into the `identity` function!");let e=g1([t,t]);for(let n=0;n<t;n++)e[n][n]=1;return e}ec.exports=q1});var rc=c((kx,nc)=>{var y1=q(),b1=S();function w1(t){try{let e=JSON.parse(t);return y1(e)?parseInt(e):NaN}catch{return NaN}}nc.exports=b1(w1)});var oc=c((Cx,sc)=>{var N1=m(),v1=p(),S1=b(),x1=U(),T1=y(),jn=V();function O1(){let t=Object.values(arguments).map(n=>S1(n)||T1(n)?jn(n.values):(N1(v1(n),"The `intersect` function only works on arrays, Series, and DataFrames!"),jn(n)));return jn(t).filter(n=>t.every(r=>r.findIndex(s=>x1(s,n))>-1))}sc.exports=O1});var cc=c((zx,ac)=>{var ic=ot(),ne=m(),F1=_n(),D1=F(),_1=p(),E1=b(),kn=q(),uc=he(),A1=T();function wt(t){if(E1(t)){let n=t.copy();return n.values=wt(n.values),n}ne(_1(t),"The `inverse` function only works on square 2-dimensional arrays or DataFrames!"),D1(t).forEach(n=>ne(kn(n),"The array passed into the `inverse` function must contain only numbers!"));let e=A1(t);if(ne(e.length===2,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),ne(e[0]===e[1],"The array passed into the `inverse` function must be exactly two-dimensional and square!"),ne(e[0]>=0,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),e[0]===0)return t;if(e[0]===1)return ne(t[0][0]!==0,"This matrix cannot be inverted!"),1/t[0][0];if(e[0]===2){let n=t[0][0],r=t[0][1],s=t[1][0],o=t[1][1],i=n*o-r*s;ne(i!==0,"This matrix cannot be inverted!");let u=[[o,-r],[-s,n]];return uc(u,1/i)}else if(e[0]>1){let n=(r,s)=>kn(r)||kn(s)?uc(r,s):F1(r,s);for(let r=1;r<e[0]-1;r++)try{let s=t.slice(0,r).map(v=>v.slice(0,r)),o=t.slice(0,r).map(v=>v.slice(r,e[0])),i=t.slice(r,e[0]).map(v=>v.slice(0,r)),u=t.slice(r,e[0]).map(v=>v.slice(r,e[0])),a=wt(s),l=wt(ic(u,n(-1,n(n(i,a),o)))),f=ic(a,n(n(n(n(a,o),l),i),a)),h=n(-1,n(n(a,o),l)),d=n(-1,n(n(l,i),a)),g=l;return f.map((v,_)=>v.concat(h[_])).concat(d.map((v,_)=>v.concat(g[_])))}catch{}ne(!1,"This matrix cannot be inverted!")}}ac.exports=wt});var fc=c((Vx,lc)=>{var Cn=q(),M1=S();function I1(t,e,n){try{return Cn(t)?Cn(e)?Cn(n)?n*(e-t)+t:NaN:NaN:NaN}catch{return NaN}}lc.exports=M1(I1)});var dc=c((Px,mc)=>{var hc=q(),j1=w(),k1=S();function C1(t,e){try{return e=j1(e)?Math.E:e,hc(t)?hc(e)?Math.log(t)/Math.log(e):NaN:NaN}catch{return NaN}}mc.exports=k1(C1)});var qc=c((Rx,gc)=>{var z1=m(),V1=F(),P1=p(),R1=b(),U1=y(),B1=H();function pc(t){if(R1(t)||U1(t))return pc(t.values);z1(P1(t),"The `median` function only works on arrays, Series, and DataFrames!");try{let e=B1(V1(t));return e.length===0?NaN:e.length%2===0?(e[e.length/2-1]+e[e.length/2])/2:e[parseInt(e.length/2)]}catch{return NaN}}gc.exports=pc});var wc=c((Ux,bc)=>{var yc=q(),J1=S();function Y1(t,e){try{return yc(t)?yc(e)?t%e:NaN:NaN}catch{return NaN}}bc.exports=J1(Y1)});var xc=c((Bx,Sc)=>{var $1=m(),L1=Pe(),G1=F(),K1=p(),W1=b(),H1=y(),Q1=V(),Nc=H();function vc(t){if(W1(t)||H1(t))return vc(t.values);$1(K1(t),"The `mode` function only works on arrays, Series, and DataFrames!");try{if(t.length===0)return NaN;let e=G1(t);if(e.length===0)return NaN;let n={},r=Q1(e);r.forEach(u=>{n[u]=L1(e,u)});let s=Nc(r,(u,a)=>n[a]-n[u]),o=s[0];return Nc(s.filter(u=>n[u]===n[o]))}catch{return NaN}}Sc.exports=vc});var Dc=c((Jx,Fc)=>{var{random:Tc}=ce(),X1=it(),Z1=w(),eb=G();function Oc(){let t=Tc(),e=Tc();return Math.sqrt(-2*Math.log(t))*Math.cos(2*Math.PI*e)}function tb(t){return Z1(t)?Oc():X1(eb(t),Oc)}Fc.exports=tb});var Ec=c((Yx,_c)=>{var nb=it(),rb=G();function sb(t){return nb(rb(t),()=>1)}_c.exports=sb});var Mc=c(($x,Ac)=>{var zn=m(),ob=F(),ib=p(),ub=b(),ab=q(),cb=y(),lb=w();function Nt(t,e){if(ub(t)||cb(t))return Nt(t.values,e);if(zn(ib(t),"The `permutations` function only works on arrays, Series, and DataFrames!"),lb(e)&&(e=t.length),zn(ab(e),"`r` must be a whole number!"),t=ob(t),e>t.length)return Nt(t);if(e<=0)return[[]];if(zn(e===parseInt(e),"`r` must be a whole number!"),t.length<2)return t;let n=[];return t.forEach((r,s)=>{let o=t.slice(0,s),i=t.slice(s+1),u=o.concat(i);Nt(u,e-1).forEach(l=>{n.push([r].concat(l))})}),n}Ac.exports=Nt});var jc=c((Lx,Ic)=>{var{DataFrame:fb,Series:hb}=Ie(),mb=p(),db=b(),pb=Ne(),gb=y(),qb=T();function yb(){Object.keys(arguments).forEach(t=>{let e=arguments[t];if(mb(e))if(pb(e))console.log(e);else{let n=qb(e);n.length===1?new hb(e).print():n.length==2?new fb(e).print():console.log(e)}else db(e)||gb(e)?e.print():console.log(e)})}Ic.exports=yb});var zc=c((Gx,Cc)=>{var bb=p(),wb=q(),kc=w(),Nb=se(),vb=ut(),Sb=S(),xb=Sb(function(t,e,n,r,s){try{return[t,e,n,r,s].every(o=>wb(o))?n-e===0?NaN:(s-r)*(t-e)/(n-e)+r:NaN}catch{return NaN}});function Tb(t,e,n,r,s){return bb(t)&&kc(r)&&kc(s)&&(r=e,s=n,e=vb(t),n=Nb(t)),xb(t,e,n,r,s)}Cc.exports=Tb});var Pc=c((Kx,Vc)=>{var Ob=q(),Fb=S();function Db(t){try{return Ob(t)?Math.round(t):NaN}catch{return NaN}}Vc.exports=Fb(Db)});var Uc=c((Wx,Rc)=>{var _b=q(),Eb=S();function Ab(t){try{return _b(t)?t<0?-1:t>0?1:0:NaN}catch{return NaN}}Rc.exports=Eb(Ab)});var Jc=c((Hx,Bc)=>{var Mb=q(),Ib=S();function jb(t){try{return Mb(t)?Math.sin(t):NaN}catch{return NaN}}Bc.exports=Ib(jb)});var $c=c((Qx,Yc)=>{var kb=ft();function Cb(t){return kb(t)}Yc.exports=Cb});var Gc=c((Xx,Lc)=>{var zb=q(),Vb=S();function Pb(t){try{return zb(t)?Math.tan(t):NaN}catch{return NaN}}Lc.exports=Vb(Pb)});var vt=c((Zx,Hc)=>{var Kc=m(),Wc=M();function Rb(t,e){Kc(Wc(t),"`fn` must be a function!");let n=new Date;return e?t(...e):t(),new Date-n}async function Ub(t,e){Kc(Wc(t),"`fn` must be a function!");let n=new Date;return e?await t(...e):await t(),new Date-n}Hc.exports={timeSync:Rb,timeAsync:Ub}});var Xc=c((eT,Qc)=>{var Bb=p(),Jb=b(),Yb=y(),$b=V();function Lb(){return $b([...arguments].map(t=>Bb(t)?t:Jb(t)||Yb(t)?t.values:[t]))}Qc.exports=Lb});var el=c((tT,Zc)=>{var Gb=m(),Kb=p(),Wb=b(),Hb=y(),Qb=w(),Xb=se(),Zb=j();function ew(){let t=[],e=Object.values(arguments).map(n=>((Wb(n)||Hb(n))&&(n=n.values),Gb(Kb(n),"The `zip` function only works on arrays, Series, and DataFrames!"),n));return Zb(0,Xb(e.map(n=>n.length))).forEach(n=>{let r=[];e.forEach(s=>{let o=s[n];r.push(Qb(o)?void 0:o)}),t.push(r)}),t}Zc.exports=ew});var x=c((nT,Vn)=>{var{DataFrame:tw,Series:nw}=Ie(),me={abs:st(),add:ot(),apply:it(),arccos:eu(),arcsin:nu(),arctan:su(),argmax:iu(),argmin:lu(),assert:m(),ceil:hu(),chop:pu(),clamp:qu(),combinations:bu(),copy:R(),correl:Pu(),cos:Uu(),count:Pe(),covariance:Nn(),DataFrame:tw,diff:Gu(),distance:ua(),divide:ca(),dot:_n(),dropMissing:En(),dropMissingPairwise:Ta(),dropNaN:Kt(),dropNaNPairwise:Ia(),dropUndefined:ka(),exp:za(),factorial:Ra(),find:Ya(),findAll:Ka(),flatten:F(),float:Ha(),floor:Xa(),identity:tc(),indexOf:be(),int:rc(),intersect:oc(),inverse:cc(),isArray:p(),isBoolean:Te(),isDataFrame:b(),isEqual:U(),isFunction:M(),isJagged:Ne(),isNested:Re(),isNumber:q(),isObject:L(),isSeries:y(),isString:E(),isUndefined:w(),lerp:fc(),log:dc(),MathError:P(),max:se(),mean:at(),median:qc(),min:ut(),mod:wc(),mode:xc(),multiply:Tn(),ndarray:G(),normal:Dc(),ones:Ec(),permutations:Mc(),pow:ht(),print:jc(),product:Fe(),random:ce().random,range:j(),remap:zc(),reshape:Qe(),reverse:ve(),round:Pc(),scale:he(),seed:ce().seed,Series:nw,set:V(),shape:T(),shuffle:Xe(),sign:Uc(),sin:Jc(),sort:H(),sqrt:lt(),std:ft(),stdev:$c(),subtract:On(),sum:mt(),tan:Gc(),time:vt().timeSync,timeSync:vt().timeSync,timeAsync:vt().timeAsync,transpose:oe(),union:Xc(),variance:vn(),vectorize:S(),zeros:In(),zip:el(),dump:function(){let t=typeof global<"u"?global:window;if(!t)throw new me.MathError("Cannot dump functions into global scope because neither `global` nor `window` exist in the current context!");Object.keys(me).forEach(e=>{try{Object.defineProperty(t,e,{configurable:!1,enumerable:!0,writable:!1,value:me[e]})}catch{t[e]=me[e]}})}};typeof Vn<"u"&&(Vn.exports=me);typeof window<"u"&&(window.JSMathTools=me)});var J=c((rT,tl)=>{tl.exports={shouldIgnoreNaNValues:!0}});var de=c((sT,rl)=>{var{assert:rw,flatten:sw,isArray:ow,isDataFrame:iw,isNumber:uw,isSeries:aw}=x();function nl(t){if(iw(t)||aw(t))return nl(t.values);rw(ow(t),"The `containsOnlyNumbers` function only works on arrays, Series, and DataFrames!");let e=sw(t);for(let n=0;n<e.length;n++)if(!uw(e[n]))return!1;return!0}rl.exports=nl});var Rn=c((oT,sl)=>{var{dropMissing:cw,flatten:lw,isArray:fw,isDataFrame:hw,isSeries:mw}=x();function Pn(t){return typeof t=="number"?t===0||t===1:hw(t)||mw(t)?Pn(t.values):fw(t)?t.length===0?!1:cw(lw(t)).every(n=>Pn(n)):!1}sl.exports=Pn});var Un=c((iT,ml)=>{var{abs:ol,apply:il,assert:ul,clamp:dw,copy:pw,divide:gw,dropNaN:qw,flatten:yw,isArray:bw,isDataFrame:ww,isNumber:al,isSeries:Nw,max:cl,median:ll,min:vw,sort:Sw,subtract:fl}=x(),xw=J(),Tw=de(),Ow=Rn();function hl(t,e){if(ww(t)||Nw(t)){let a=t.copy();return a._values=hl(a._values,e),a}if(ul(bw(t),"The `clipOutliers` function only works on arrays, Series, and DataFrames!"),e=e||5,ul(al(e),"Any `maxScore` value passed into the `clipOutliers` function must be a number!"),!xw.shouldIgnoreNaNValues&&!Tw(t))return il(t,()=>NaN);let n=yw(t),r=qw(n);if(Ow(r)||r.length===0)return t;let s=ll(r),o=ll(ol(fl(r,s))),i=!1;if(o===0){let a=Sw(pw(r)),l=a.filter(g=>g<s),f=a.filter(g=>g>s),h=s,d=s;if(l.length>0&&(h=cl(l)),f.length>0&&(d=vw(f)),o=(d-h)/2,o===0)return t;i=(s-h)/o>e||(d-s)/o>e}return cl(gw(ol(fl(r,s)),o))>e||i?il(t,a=>al(a)?dw(a,s-e*o,s+e*o):a):t}ml.exports=hl});var Jn=c((uT,Nl)=>{var{assert:dl,dropNaN:pl,isArray:gl,isSeries:ql,mean:yl,shape:bl,variance:wl}=x(),Fw=J();function Bn(t,e){if(ql(t))return Bn(t.values,e);if(ql(e))return Bn(t,e.values);dl(gl(t)&&gl(e)&&bl(t).length===1&&bl(e).length===1,"The `cohensd` function only works on 1-dimensional arrays and Series!"),dl(t.length===e.length,"Two arrays or Series passed into the `cohensd` function must have the same length!"),Fw.shouldIgnoreNaNValues&&(t=pl(t),e=pl(e));try{let n=yl(t),r=yl(e),s=Math.sqrt((wl(t)+wl(e))/2);return(n-r)/s}catch{return NaN}}Nl.exports=Bn});var Tl=c((aT,xl)=>{var{assert:vl,DataFrame:Dw,isArray:_w,isSeries:Ew,shape:Aw,zeros:Mw}=x();function Sl(t){if(Ew(t)){let r=new Dw(Sl(t.values));return r.index=t.index.slice(),r.columns=t.index.slice(),r}vl(_w(t),"The `diagonalize` function only works on 1-dimensional arrays and Series!");let e=Aw(t);vl(e.length===1,"The `diagonalize` function only works on 1-dimensional arrays and Series!");let n=Mw([e[0],e[0]]);return t.forEach((r,s)=>n[s][s]=r),n}xl.exports=Sl});var Gn=c((cT,_l)=>{var{assert:Yn,clamp:Iw,correl:Ol,DataFrame:St,dropNaNPairwise:jw,isArray:Fl,isDataFrame:xt,isJagged:Dl,isUndefined:kw,ndarray:Cw}=x(),zw=J();function $n(t){let e="@jrc03c/js-data-science-helpers/get-correlation-matrix";return Object.defineProperty(t,e,{configurable:!1,enumerable:!1,writable:!1,value:Symbol.for(e)}),t}function Ln(t,e){if(kw(e)&&(e=t),xt(t)){let r=new St(Ln(t.values,e));return r.index=t.columns.slice(),r.columns=xt(e)?e.columns.slice():new St(e).columns.slice(),$n(r)}if(xt(e)){let r=new St(Ln(t,e.values));return r.index=xt(t)?t.columns.slice():new St(t).columns.slice(),r.columns=e.columns.slice(),$n(r)}Yn(Fl(t)&&Fl(e),"The `getCorrelationMatrix` function only works on 2-dimensional arrays and DataFrames!"),Yn(!Dl(t)&&!Dl(e),"The `getCorrelationMatrix` function only works on non-jagged 2-dimensional arrays and DataFrames!"),Yn(t.length===e.length,'The dimensions of the matrices you passed into the `getCorrelationMatrix` function aren\'t compatible! ([shape(a).join(", ")] vs. [shape(b).join(", ")]) The function expects that you\'ll be comparing the columns of two matrices where the columns are all of the same length, so please make sure that the matrices are oriented accordingly.');let n=Cw([t[0].length,e[0].length]);for(let r=0;r<t[0].length;r++){let s=t.map(o=>o[r]);for(let o=0;o<e[0].length;o++){let i=e.map(u=>u[o]);zw.shouldIgnoreNaNValues?n[r][o]=Ol(...jw(s,i)):n[r][o]=Ol(s,i)}}return $n(Iw(n,-1,1))}_l.exports=Ln});var Kn=c((lT,El)=>{function Vw(t){try{let e="@jrc03c/js-data-science-helpers/get-correlation-matrix";return t[e]===Symbol.for(e)}catch{return!1}}El.exports=Vw});var jl=c((fT,Il)=>{var{DataFrame:Wn,isArray:Pw,isDataFrame:Tt,isNumber:Al,MathError:Rw,sort:Uw}=x(),Ml=Gn(),Bw=Kn();function Jw(t,e,n){n=Object.values(arguments).find(o=>Al(o))||1-1e-5;let r=(()=>{let o=Object.values(arguments).filter(i=>Pw(i)||Tt(i));if(o.length===1){let i=o[0];if(Bw(i))return Tt(i)?i:new Wn(i);{let u=Ml(i,null);return Tt(u)?u:new Wn(u)}}if(o.length===2){let i=Ml(o[0],o[1]);return Tt(i)?i:new Wn(i)}throw new Rw("You must pass 1 or 2 2-dimensional arrays or DataFrames into the `getHighlyCorrelatedColumns` function!")})(),s={};return r.values.forEach((o,i)=>{o.forEach((u,a)=>{if(Al(u)&&u>n){let l=r.index[i],f=r.columns[a];s[l]||(s[l]=[]),s[l].indexOf(f)<0&&s[l].push(f),s[f]||(s[f]=[]),s[f].indexOf(l)<0&&s[f].push(l)}})}),Object.keys(s).forEach(o=>{s[o]=Uw(s[o])}),s}Il.exports=Jw});var Hn=c((hT,Cl)=>{var{dropNaN:Yw,isArray:$w,isDataFrame:Lw,isNumber:Gw,isSeries:Kw,pow:Ww,sqrt:Hw,sum:Qw}=x(),Xw=J();function kl(t){return Lw(t)||Kw(t)?kl(t.values):Gw(t)?Math.abs(t):$w(t)?(Xw.shouldIgnoreNaNValues&&(t=Yw(t)),Hw(Qw(Ww(t,2)))):NaN}Cl.exports=kl});var Qn=c((mT,Pl)=>{var{assert:zl,DataFrame:Zw,isArray:eN,isSeries:tN,isString:nN,isUndefined:rN,set:sN,shape:oN,sort:iN}=x();function Vl(){if(arguments.length===1&&tN(arguments[0])){let{name:o,values:i}=arguments[0],u=Vl(o,i),a=new Zw(u);return a.index=arguments[0].index.slice(),a}let[t,e]=arguments;zl(nN(t),"When passing two arguments into the `getOneHotEncodings` function, the first argument must be a string representing the name of the variable being encoded!"),zl(eN(e)&&oN(e).length===1,"When passing two arguments into the `getOneHotEncodings` function, the second argument must be a 1-dimensional array!");let n={},r=t+"_"+e[0];return iN(sN(e)).filter(o=>!rN(o)).map(o=>t+"_"+o).filter(o=>o!==r).forEach(o=>{n[o]=e.map(i=>o===t+"_"+i?1:0)}),n}Pl.exports=Vl});var Ul=c((dT,Rl)=>{var{count:uN}=x();function aN(t){return uN(t).map(n=>(n.percentage=n.count/t.length,n))}Rl.exports=aN});var Bl=c((pT,cN)=>{cN.exports=[.5,.49601,.49202,.48803,.48405,.48006,.47608,.4721,.46812,.46414,.46017,.4562,.45224,.44828,.44433,.44038,.4364,.43251,.42858,.42465,.42074,.41683,.41294,.40905,.40517,.40129,.39743,.39358,.38974,.38591,.38209,.37828,.37448,.3707,.36693,.36317,.35942,.35569,.35197,.34827,.34458,.3409,.33724,.3336,.32997,.32636,.32276,.31918,.31561,.31207,.30854,.30503,.30153,.29806,.2946,.29116,.28774,.28434,.28096,.2776,.27425,.27093,.26763,.26435,.26109,.25785,.25463,.25143,.24825,.2451,.24196,.23885,.23576,.2327,.22965,.22663,.22363,.22065,.2177,.21476,.21186,.20897,.20611,.20327,.20045,.19766,.19489,.19215,.18943,.18673,.18406,.18141,.17879,.17619,.17361,.17106,.16853,.16602,.16354,.16109,.15866,.15625,.15386,.15151,.14917,.14686,.14457,.14231,.14007,.13786,.13567,.1335,.13136,.12924,.12714,.12507,.12302,.121,.119,.11702,.11507,.11314,.11123,.10935,.10749,.10565,.10383,.10204,.10027,.09853,.0968,.0951,.09342,.09176,.09012,.08851,.08692,.08534,.08379,.08226,.08076,.07927,.0778,.07636,.07493,.07353,.07215,.07078,.06944,.06811,.06681,.06552,.06426,.06301,.06178,.06057,.05938,.05821,.05705,.05592,.0548,.0537,.05262,.05155,.0505,.04947,.04846,.04746,.04648,.04551,.04457,.04363,.04272,.04182,.04093,.04006,.0392,.03836,.03754,.03673,.03593,.03515,.03438,.03362,.03288,.03216,.03144,.03074,.03005,.02938,.02872,.02807,.02743,.0268,.02619,.02559,.025,.02442,.02385,.0233,.02275,.02222,.02169,.02118,.02068,.02018,.0197,.01923,.01876,.01831,.01786,.01743,.017,.01659,.01618,.01578,.01539,.015,.01463,.01426,.0139,.01355,.01321,.01287,.01255,.01222,.01191,.0116,.0113,.01101,.01072,.01044,.01017,.0099,.00964,.00939,.00914,.00889,.00866,.00842,.0082,.00798,.00776,.00755,.00734,.00714,.00695,.00676,.00657,.00639,.00621,.00604,.00587,.0057,.00554,.00539,.00523,.00508,.00494,.0048,.00466,.00453,.0044,.00427,.00415,.00402,.00391,.00379,.00368,.00357,.00347,.00336,.00326,.00317,.00307,.00298,.00289,.0028,.00272,.00264,.00256,.00248,.0024,.00233,.00226,.00219,.00212,.00205,.00199,.00193,.00187,.00181,.00175,.00169,.00164,.00159,.00154,.00149,.00144,.00139,.00135,.00131,.00126,.00122,.00118,.00114,.00111,.00107,.00104,.001,97e-5,94e-5,9e-4,87e-5,84e-5,82e-5,79e-5,76e-5,74e-5,71e-5,69e-5,66e-5,64e-5,62e-5,6e-4,58e-5,56e-5,54e-5,52e-5,5e-4,48e-5,47e-5,45e-5,43e-5,42e-5,4e-4,39e-5,38e-5,36e-5,35e-5,34e-5,32e-5,31e-5,3e-4,29e-5,28e-5,27e-5,26e-5,25e-5,24e-5,23e-5,22e-5,22e-5,21e-5,2e-4,19e-5,19e-5,18e-5,17e-5,17e-5,16e-5,15e-5,15e-5,14e-5,14e-5,13e-5,13e-5,12e-5,12e-5,11e-5,11e-5,1e-4,1e-4,1e-4,9e-5,9e-5,8e-5,8e-5,8e-5,8e-5,7e-5,7e-5,7e-5,6e-5,6e-5,6e-5,6e-5,5e-5,5e-5,5e-5,5e-5,5e-5,4e-5,4e-5,4e-5,4e-5,4e-5,4e-5,3e-5,3e-5,3e-5,3e-5,3e-5,3e-5,3e-5,3e-5,2e-5,2e-5,2e-5,2e-5]});var Zn=c((gT,Ql)=>{var{abs:Jl,assert:lN,dropNaNPairwise:fN,flatten:Ot,isArray:Yl,isDataFrame:$l,isEqual:hN,isSeries:Ll,mean:Gl,remap:mN,round:dN,shape:Kl,sqrt:pN,std:Wl}=x(),gN=J(),Hl=Bl();function qN(t){return Jl(t)>4.1?0:Hl[dN(mN(Jl(t),0,4.1,0,Hl.length))]}function Xn(t,e){if($l(t)||Ll(t))return Xn(t.values,e);if($l(e)||Ll(e))return Xn(t,e.values);lN(Yl(t)&&Yl(e)&&hN(Kl(t),Kl(e)),"You must pass two identically-shaped arrays, Series, or DataFrames into the `pValue` function!");let[n,r]=gN.shouldIgnoreNaNValues?fN(Ot(t),Ot(e)):[Ot(t),Ot(e)];if(n.length===0||r.length===0)return NaN;let s=Gl(n),o=Gl(r),i=Wl(n),u=Wl(r),a=n.length,l=r.length,f=(s-o)/pN(i*i/a+u*u/l);return 2*qN(f)}Ql.exports=Xn});var nf=c((qT,tf)=>{var{assert:er,clamp:yN,DataFrame:Ft,dropNaNPairwise:bN,isArray:Xl,isDataFrame:Dt,isJagged:Zl,isUndefined:wN,ndarray:NN}=x(),vN=J(),ef=Zn();function tr(t){let e="@jrc03c/js-data-science-helpers/get-p-value-matrix";return Object.defineProperty(t,e,{configurable:!1,enumerable:!1,writable:!1,value:Symbol.for(e)}),t}function nr(t,e){if(wN(e)&&(e=t),Dt(t)){let r=new Ft(nr(t.values,e));return r.index=t.columns.slice(),r.columns=Dt(e)?e.columns.slice():new Ft(e).columns.slice(),tr(r)}if(Dt(e)){let r=new Ft(nr(t,e.values));return r.index=Dt(t)?t.columns.slice():new Ft(t).columns.slice(),r.columns=e.columns.slice(),tr(r)}er(Xl(t)&&Xl(e),"The `getPValueMatrix` function only works on 2-dimensional arrays and DataFrames!"),er(!Zl(t)&&!Zl(e),"The `getPValueMatrix` function only works on non-jagged 2-dimensional arrays and DataFrames!"),er(t.length===e.length,'The dimensions of the matrices you passed into the `getPValueMatrix` function aren\'t compatible! ([shape(a).join(", ")] vs. [shape(b).join(", ")]) The function expects that you\'ll be comparing the columns of two matrices where the columns are all of the same length, so please make sure that the matrices are oriented accordingly.');let n=NN([t[0].length,e[0].length]);for(let r=0;r<t[0].length;r++){let s=t.map(o=>o[r]);for(let o=0;o<e[0].length;o++){let i=e.map(u=>u[o]);vN.shouldIgnoreNaNValues?n[r][o]=ef(...bN(s,i)):n[r][o]=ef(s,i)}}return tr(yN(n,0,1))}tf.exports=nr});var af=c((yT,uf)=>{var{assert:_t,intersect:SN,isDataFrame:rf,isSeries:sf,isUndefined:of}=x(),pe=class{constructor(e){let n=this;_t(of(e)||e===pe.DROP_NAN_MODE||e===pe.DROP_MISSING_MODE,"The `mode` value passed into the `IndexMatcher` constructor must be undefined or one of [IndexMatcher.DROP_NAN_MODE, IndexMatcher.DROP_MISSING_MODE]! (By default, the mode is `Indexer.DROP_MISSING_MODE`.)"),n.mode=of(e)?pe.DROP_MISSING_MODE:e,n.index=null}fit(){let e=this,n=[];return Object.values(arguments).forEach(r=>{_t(rf(r)||sf(r),"The `IndexMatcher` only works on Series and DataFrames! To drop NaN values in a pair-wise fashion from regular arrays, use the `dropNaNPairwise` function from the @jrc03c/js-math-tools library."),e.mode===pe.DROP_MISSING_MODE?n.push(r.dropMissing().index):n.push(r.dropNaN().index)}),e.index=SN(...n),e}transform(){let e=this;_t(!!e.index,"The IndexMatcher hasn't been fitted yet! Please call the `fit` method before calling the `transform` method.");let n=Object.values(arguments).map(r=>(_t(rf(r)||sf(r),"The `IndexMatcher` only works on Series and DataFrames! To drop NaN values in a pair-wise fashion from regular arrays, use the `dropNaNPairwise` function from the @jrc03c/js-math-tools library."),r.get(e.index,null)));return n.length===1?n[0]:n}fitAndTransform(){return this.fit(...arguments).transform(...arguments)}},ke=pe;zt(ke,"DROP_NAN_MODE","DROP_NAN_MODE"),zt(ke,"DROP_MISSING_MODE","DROP_MISSING_MODE");uf.exports=ke});var or=c((bT,lf)=>{var{apply:xN,assert:TN,count:ON,flatten:FN,float:DN,isArray:rr,isDataFrame:_N,isNumber:EN,isSeries:AN,isString:MN}=x(),cf=["null","none","nan","na","n/a","","undefined"],IN=["true","false","yes","no"];function jN(t,e){if(t===void 0&&(t="undefined"),e==="null")return null;if(e==="number"){let n=DN(t);return isNaN(n)?NaN:n}if(e==="boolean"){try{let n=t.trim().toLowerCase();if(n==="true"||n==="yes")return!0;if(n==="false"||n==="no")return!1}catch{}return null}if(e==="date"){let n=new Date(t);return n.toString()==="Invalid Date"?null:n}if(e==="object")try{let n=JSON.parse(t);return rr(n)?null:n}catch{return null}if(e==="string"){try{if(cf.indexOf(t.trim().toLowerCase())>-1)return null}catch{return null}return t}}function sr(t){if(_N(t)){let s=t.copy(),o=sr(t.values);return s.values=o.values,{type:o.type,values:s}}if(AN(t)){let s=t.copy(),o=sr(t.values);return s.values=o.values,{type:o.type,values:s}}TN(rr(t),"The `inferType` function only works on arrays, Series, and DataFrames!");let e=FN(t).map(s=>{if(s===void 0)return"null";MN(s)||(s=JSON.stringify(s));let i=s.toLowerCase().trim();if(cf.indexOf(i)>-1)return"null";if(IN.indexOf(i)>-1)return"boolean";try{let u=JSON.parse(s);return EN(u)?"number":typeof u=="object"?rr(u)?"string":"object":"string"}catch{return new Date(s).toString()!=="Invalid Date"?"date":"string"}}),r=ON(e).sort((s,o)=>o.count-s.count)[0].item;return{type:r,values:xN(t,s=>jN(s,r))}}lf.exports=sr});var ur=c((wT,pf)=>{var{assert:ir,isArray:kN,isBoolean:CN,isDataFrame:ff,isSeries:hf,int:zN,isNumber:VN,isUndefined:mf,range:df,set:PN,shape:RN,shuffle:UN}=x();pf.exports=function(){let e=Array.from(arguments),n=e.find(g=>CN(g)),r=mf(n)?!0:n,s=e.find(g=>VN(g)),o=mf(s)?.1:s;ir(o>0&&o<1,"`testSize` must be a number between 0 and 1 (exclusive on both ends)!");let i=e.filter(g=>kN(g)||ff(g)||hf(g));ir(i.length>0,"You must pass at least one dataset into the `trainTestSplit` function!");let u=i.map(g=>RN(g)[0]);ir(PN(u).length===1,`All datasets passed into the \`trainTestSplit\` function must be the same length at their shallowest dimension! The lengths of your datasets, though, are: ${u.join(", ")}`);let a=[],l=r?UN(df(0,u[0])):df(0,u[0]),f=zN((1-o)*l.length),h=l.slice(0,f),d=l.slice(f);return i.forEach(g=>{if(ff(g))a.push(g.get(h,null)),a.push(g.get(d,null));else if(hf(g))a.push(g.get(h)),a.push(g.get(d));else{let N=[],v=[];g.forEach((_,C)=>{h.indexOf(C)>-1?N.push(_):v.push(_)}),a.push(N),a.push(v)}}),a}});var At=c((NT,Nf)=>{var{add:BN,argmin:JN,assert:YN,flatten:gf,isArray:$N,isDataFrame:qf,isEqual:LN,int:GN,isNumber:KN,isSeries:yf,normal:ar,pow:WN,random:HN,range:QN,scale:XN,shape:Et,subtract:ZN,sum:ev}=x(),tv=ur();function cr(t,e){(qf(t)||yf(t))&&(t=t.values),(qf(e)||yf(e))&&(e=e.values),YN(LN(Et(t),Et(e)),"`yPred` and `yTrue` must have the same shape!");let n=gf(t),r=gf(e),s=0;return n.forEach((o,i)=>{o===r[i]&&s++}),s/n.length}function nv(t){test(`tests that the \`${t.name}\` model works correctly`,()=>{let e=ar([5,10]).map(h=>h.map(d=>d*100+ar()*100)),n=[],r=QN(0,500).map(()=>{let h=GN(HN()*e.length),d=e[h];return n.push(h),BN(d,XN(5,ar(Et(d))))}),[s,o,i,u]=tv(r,n),a=new t({k:e.length});a.fit(s),a.centroids=bf(e,a.centroids);let l=a.predict(s),f=a.predict(o);expect(cr(i,l)).toBeGreaterThan(.95),expect(cr(u,f)).toBeGreaterThan(.95)})}function rv(t){return $N(t)&&Et(t).length===2}function sv(t){return KN(t)&&parseInt(t)===t&&t>=0}function bf(t,e){return t.map(n=>e[JN(e.map(r=>wf(n,r)))])}function wf(t,e){return ev(WN(ZN(t,e),2))}Nf.exports={accuracy:cr,createGenericTest:nv,isMatrix:rv,isWholeNumber:sv,orderCentroids:bf,sse:wf}});var hr=c((vT,Tf)=>{var{add:vf,argmin:ov,assert:ie,distance:Sf,divide:iv,isDataFrame:uv,isFunction:av,isUndefined:Mt,normal:cv,random:lv,range:fv,scale:hv,shuffle:mv,zeros:xf}=x(),{isMatrix:dv,isWholeNumber:lr,sse:pv}=At(),fr=class{constructor(e){ie(typeof e=="object","`config` must be an object! See the documentation for more information about the properties that the `config` object can contain."),ie(lr(e.k),"`k` must be a whole number!"),ie(lr(e.maxIterations)||Mt(e.maxIterations),"`maxIterations` must be a whole number or undefined!"),ie(lr(e.maxRestarts)||Mt(e.maxRestarts),"`maxRestarts` must be a whole number or undefined!"),ie(typeof e.tolerance=="number"||Mt(e.tolerance),"`tolerance` must be a number or undefined!");let n=this;n.k=e.k,n.maxRestarts=e.maxRestarts||25,n.maxIterations=e.maxIterations||100,n.tolerance=e.tolerance||1e-4,n.centroids=null}initializeCentroids(e){let n=this;return mv(e).slice(0,n.k)}fit(e,n){let r=this;ie(dv(e),"`x` must be a matrix!"),uv(e)&&(e=e.values),Mt(n)||ie(av(n),"If defined, `progress` must be a function!");let s,o=-1/0;for(let i=0;i<r.maxRestarts;i++){let u=r.initializeCentroids(e);for(let l=0;l<r.maxIterations;l++){n&&n((i+l/r.maxIterations)/r.maxRestarts);let f=r.predict(e,u),h=[],d=xf(r.k);e.forEach((N,v)=>{let _=f[v];h[_]||(h[_]=xf(N.length)),h[_]=vf(h[_],N),d[_]++});let g=fv(0,r.k).map(N=>d[N]===0?vf(u[parseInt(lv()*u.length)],hv(.001,cv(u[0].length))):iv(h[N],d[N]));try{if(Sf(u,g)<r.tolerance)break}catch{break}u=g}let a=r.score(e,u);a>o&&(o=a,s=u)}return n&&n(1),r.centroids=s,r}predict(e,n){if(n=n||this.centroids,!n)throw new Error("No centroids were provided to the `predict` method, and the K-Means model hasn't been fitted yet. Please either pass centroids as a second parameter to the `predict` method or run the `fit` method first!");return e.map(s=>ov(n.map(o=>Sf(s,o))))}score(e,n){let r=this;if(n=n||r.centroids,!n)throw new Error("No centroids were provided to the `score` method, and the K-Means model hasn't been fitted yet. Please either pass centroids as a second parameter to the `score` method or run the `fit` method first!");let o=r.predict(e,n).map(i=>n[i]);return-pv(e,o)}};Tf.exports=fr});var dr=c((ST,Df)=>{var{argmin:gv,distance:Of,divide:qv,max:yv,random:Ff}=x(),bv=hr(),mr=class extends bv{initializeCentroids(e){let n=this,r=[e[parseInt(Ff()*e.length)]];for(;r.length<n.k;){let s=e.map(i=>Of(i,r[gv(r.map(u=>Of(i,u)))])),o=qv(s,yv(s));r.push(e[o.findIndex(i=>Ff()<i)])}return r}};Df.exports=mr});var Af=c((xT,Ef)=>{var{assert:$,isArray:wv,isDataFrame:Nv,isEqual:vv,isFunction:Sv,isUndefined:ge,range:xv,shape:_f}=x(),{isMatrix:Tv,isWholeNumber:pr}=At(),Ov=dr(),gr=class{constructor(e){ge(e)&&(e={}),$(typeof e=="object","`config` must be an object! See the documentation for more information about the properties that the `config` object can contain."),ge(e.ks)&&(e.ks=xv(1,16)),$(wv(e.ks),"`ks` must be an array of whole numbers!"),e.ks.forEach(r=>{$(pr(r),"`ks` must be an array of whole numbers!")}),$(pr(e.maxIterations)||ge(e.maxIterations),"`maxIterations` must be a whole number or undefined!"),$(pr(e.maxRestarts)||ge(e.maxRestarts),"`maxRestarts` must be a whole number or undefined!"),$(typeof e.tolerance=="number"||ge(e.tolerance),"`tolerance` must be a number or undefined!");let n=this;n.ks=e.ks,n.maxRestarts=e.maxRestarts||25,n.maxIterations=e.maxIterations||100,n.tolerance=e.tolerance||1e-4,n.scoreStopRatio=.85,n.modelClass=e.modelClass||Ov,n.fittedModel=null}fit(e,n){let r=this;$(Tv(e),"`x` must be a matrix!"),Nv(e)&&(e=e.values),ge(n)||$(Sv(n),"If defined, `progress` must be a function!");let s=r.ks[0],o=-1/0;for(let i=0;i<r.ks.length;i++){let u=r.ks[i],a=new r.modelClass({k:u,maxRestarts:10,maxIterations:25});a.fit(e,f=>n?n((i+f)/r.ks.length):null);let l=a.score(e);if(l/o>r.scoreStopRatio)break;s=u,o=l}return r.fittedModel=new r.modelClass({k:s,maxRestarts:r.maxRestarts,maxIterations:r.maxIterations,tolerance:r.tolerance}),r.fittedModel.fit(e),n&&n(1),r}predict(e,n){return this.fittedModel.predict(e,n)}score(e,n){return this.fittedModel.score(e,n)}get k(){return this.fittedModel.k}set k(e){throw new Error("You can't set the k-value manually! It has to be set automatically via the `fit` method.")}get centroids(){return this.fittedModel.centroids}set centroids(e){let n=this;$(vv(_f(e),_f(n.fittedModel.centroids)),"When assigning a new value to the `centroids` property, the new centroids must have the same shape as the old centroids!"),n.fittedModel.centroids=e}};Ef.exports=gr});var If=c((TT,Mf)=>{Mf.exports={KMeansMeta:Af(),KMeansNaive:hr(),KMeansPlusPlus:dr(),helpers:At()}});var qr=c((OT,Pf)=>{var{apply:Fv,assert:Dv,dropNaN:jf,isArray:_v,isDataFrame:Ev,isSeries:Av,mean:kf,std:Cf}=x(),zf=J();function Vf(t){if(Ev(t)||Av(t)){let r=t.copy();return r.values=Vf(r.values),r}Dv(_v(t),"The `normalize` function only works on arrays, Series, and DataFrames!");let e=(()=>zf.shouldIgnoreNaNValues?kf(jf(t)):kf(t))(),n=(()=>zf.shouldIgnoreNaNValues?Cf(jf(t)):Cf(t))();return n===0?t:Fv(t,r=>(r-e)/n)}Pf.exports=Vf});var br=c((FT,Yf)=>{var{assert:qe,dot:Rf,isArray:Uf,isSeries:yr,scale:Mv,Series:Iv,shape:Bf}=x(),Jf=de();function It(t,e){if(yr(t)){if(yr(e))return new Iv(It(t.values,e.values));{let n=t.copy();return n.values=It(t.values,e),n}}if(yr(e)){let n=e.copy();return n.values=It(t,e.values),n}return qe(Uf(t),"`project` only works on vectors!"),qe(Uf(e),"`project` only works on vectors!"),qe(Jf(t),"`project` only works on vectors of numbers!"),qe(Jf(e),"`project` only works on vectors of numbers!"),qe(Bf(t).length===1,"`project` only works on vectors!"),qe(Bf(e).length===1,"`project` only works on vectors!"),Mv(Rf(e,t)/Rf(e,e),e)}Yf.exports=It});var Wf=c((DT,Kf)=>{var{assert:$f,copy:jv,DataFrame:kv,divide:Cv,isArray:zv,isDataFrame:Vv,isJagged:Pv,shape:Rv,subtract:Uv,transpose:Lf}=x(),Bv=de(),Jv=Hn(),Yv=br();function Gf(t){if(Vv(t)){let s=new kv(Gf(t.values));return s.index=t.index.slice(),s.columns=t.columns.slice(),s}$f(zv(t)&&!Pv(t)&&Rv(t).length===2,"`orthonormalize` only works on matrices!"),$f(Bv(t),"`orthonormalize` only works on matrices of numbers!");let e=Lf(t),n=[];e.forEach(s=>{let o=jv(s);n.forEach(i=>{o=Uv(o,Yv(o,i))}),n.push(o)});let r=n.map(s=>Cv(s,Jv(s)));return Lf(r)}Kf.exports=Gf});var nh=c((_T,th)=>{var{assert:Hf,copy:$v,correl:Lv,DataFrame:Qf,dropMissing:Gv,isArray:Kv,isDataFrame:Wv,isEqual:Hv,isJagged:Qv,isNumber:Xf,set:Xv,shape:Zv,transpose:Zf}=x(),eS=Un(),tS=Qn(),nS=or();function eh(t,e,n){if(e=Xf(e)?e:7,n=Xf(n)?n:1-1e-5,Kv(t))return Hf(Zv(t).length===2&&!Qv(t),"The `preprocess` function only works on non-jagged 2-dimensional arrays and DataFrames!"),eh(new Qf(t));Hf(Wv(t),"You must pass a DataFrame into the `preprocess` function!");let r={};t=t.apply(l=>{let f=nS(l.values);return r[l.name]=f.type,f.values});let s=$v(t.columns),o=Zf(t.values),i=0,u=!1;for(;!u;){let l=o[i];for(let f=i+1;f<o.length;f++){let h=o[f];Hv(l,h)&&(s.splice(f,1),o.splice(f,1))}i++,u=i>=s.length-1}for(i=0,u=!1;!u;){let l=s[i],f=o[i];if(!f)break;let h=Gv(f);if(h.length<15){s.splice(i,1),o.splice(i,1);continue}let d=Xv(h);if(d.length===1){s.splice(i,1),o.splice(i,1);continue}let g=r[l];if(g==="string"){if(d.length<=e){let N=tS(l,f);Object.keys(N).forEach(v=>{s.push(v),o.push(N[v]),r[v]="number"}),s.splice(i,1),o.splice(i,1);continue}}else if(g==="number"){let N=eS(f);o[i]=N;let v=!1;for(let _=0;_<i;_++){let C=o[_];if(Lv(f,C)>n){s.splice(i,1),o.splice(i,1),v=!0;break}}if(v)continue}else{o.splice(i,1),s.splice(i,1);continue}i++,u=i>=s.length}let a=new Qf(Zf(o));return a.columns=s,a}th.exports=eh});var hh=c((ET,fh)=>{var{abs:rS,add:sS,assert:Ce,isArray:rh,isDataFrame:sh,isEqual:oS,isSeries:oh,mean:iS,pow:ih,scale:uS,shape:uh,sign:aS,sqrt:cS,sum:ah}=x(),ch=de(),lh=(t,e)=>sS(t,uS(e,-1));function wr(t,e){if(sh(t)||oh(t))return wr(t.values,e);if(sh(e)||oh(e))return wr(t,e.values);Ce(rh(t),"You must pass two same-shaped numerical arrays into the `rScore` function!"),Ce(rh(e),"You must pass two same-shaped numerical arrays into the `rScore` function!"),Ce(oS(uh(t),uh(e)),"You must pass two same-shaped numerical arrays into the `rScore` function!"),Ce(ch(t),"You must pass two same-shaped numerical arrays into the `rScore` function!"),Ce(ch(e),"You must pass two same-shaped numerical arrays into the `rScore` function!");let n=ah(ih(lh(t,e),2)),r=ah(ih(lh(t,iS(t)),2));if(r===0)return NaN;let s=1-n/r;return aS(s)*cS(rS(s))}fh.exports=wr});var qh=c((AT,gh)=>{var{argmax:mh,assert:ze,copy:lS,DataFrame:fS,dot:hS,isArray:mS,isDataFrame:dS,isEqual:dh,isJagged:pS,max:gS,min:qS,reverse:yS,shape:bS,transpose:wS}=x();function ph(t){if(mS(t)){ze(bS(t).length===2&&!pS(t),"The `sortCorrelationMatrix` function only works on 2-dimensional arrays and DataFrames!");let s=new fS(t);return s.index=s.columns.slice(),ph(s).values}ze(dS(t),"You must pass a DataFrame into the `sortCorrelationMatrix` function!"),ze(gS(t.values)<=1&&qS(t.values)>=-1,"The correlation matrix passed into the `sortCorrelationMatrix` function must not contain values less than -1 or greater than 1!"),ze(dh(t.values,wS(t.values)),"The correlation matrix passed into the `sortCorrelationMatrix` function must be symmetrical!"),ze(dh(t.index,t.columns),"The correlation matrix passed into the `sortCorrelationMatrix` function must be symmetrical! (In this case, although the values themselves are symmetrical, the row and column names differ.)");let e=lS(t.index),n=[];for(;e.length>0;)if(n.length===0){let s=mh(t.values.map(o=>hS(o,o)));n.push(e[s]),e.splice(s,1)}else{let s=t.index.indexOf(n.at(-1)),o=mh(e.map(u=>t.values[t.index.indexOf(u)][s])),i=e[o];n.push(i),e.splice(o,1)}let r=yS(n);return t.get(r,r)}gh.exports=ph});var bh=c((MT,yh)=>{var NS=qr();function vS(){return NS(...arguments)}yh.exports=vS});var Dh=c((IT,Fh)=>{var{assert:jt,DataFrame:wh,dropNaN:SS,flatten:Nh,isArray:xS,isDataFrame:Nr,isSeries:vr,mean:vh,range:TS,Series:Sh,shape:xh,stdev:Th,transpose:Oh}=x(),OS=J(),Sr=class{constructor(){let e=this;e.means=[],e.stdevs=[],e.wasFittedOnAVector=!1,e.hasBeenFitted=!1}_getDataArrayAndShape(e){if(Nr(e))return[e.values,e.shape];if(vr(e)){let r=Oh([e.values]);return[r,xh(r)]}jt(xS(e),"`x` must be a 1- or 2-dimensional array, DataFrame, or Series!");let n=xh(e);return jt(n.length<3,"`x` must be a 1- or 2-dimensional array, DataFrame, or Series!"),n.length===1&&(n.push(1),e=Oh([e])),[e,n]}fit(e){let n=this,r=n._getDataArrayAndShape(e);e=r[0];let s=r[1];return n.wasFittedOnAVector=s.indexOf(1)>-1,n.means=[],n.stdevs=[],TS(0,s[1]).forEach(o=>{let i=e.map(u=>u[o]);if(OS.shouldIgnoreNaNValues){let u=SS(i);n.means.push(vh(u)),n.stdevs.push(Th(u))}else n.means.push(vh(i)),n.stdevs.push(Th(i))}),n.hasBeenFitted=!0,n}transform(e){let n=this;if(!n.hasBeenFitted)throw new Error("This `StandardScaler` instance hasn't been trained on any data yet! Please use the `fit` method to train it before calling the `transform` method.");if(Nr(e)){let i=new wh(n.transform(e.values));return i.columns=e.columns,i.index=e.index,i}if(vr(e)){let i=new Sh(n.transform(e.values));return i.name=e.name,i.index=e.index,i}let r=n._getDataArrayAndShape(e);e=r[0];let s=r[1];jt(s[1]===n.means.length,"The data you passed into the `transform` function doesn't have the same number of columns as the data set on which this StandardScaler was fitted!");let o=e.map(i=>i.map((u,a)=>(u-n.means[a])/n.stdevs[a]));return n.wasFittedOnAVector?Nh(o):o}untransform(e){let n=this;if(!n.hasBeenFitted)throw new Error("This `StandardScaler` instance hasn't been trained on any data yet! Please use the `fit` method to train it before calling the `transform` method.");if(Nr(e)){let i=new wh(n.untransform(e.values));return i.columns=e.columns,i.index=e.index,i}if(vr(e)){let i=new Sh(n.untransform(e.values));return i.name=e.name,i.index=e.index,i}let r=n._getDataArrayAndShape(e);e=r[0];let s=r[1];jt(s[1]===n.means.length,"The data you passed into the `untransform` function doesn't have the same number of columns as the data set on which this StandardScaler was fitted!");let o=e.map(i=>i.map((u,a)=>u*n.stdevs[a]+n.means[a]));return n.wasFittedOnAVector?Nh(o):o}};Fh.exports=Sr});var DS=c((jT,Eh)=>{var{MathError:FS}=x(),_h={clipOutliers:Un(),cohensD:Jn(),cohensd:Jn(),common:J(),containsOnlyNumbers:de(),diagonalize:Tl(),getCorrelationMatrix:Gn(),getHighlyCorrelatedColumns:jl(),getMagnitude:Hn(),getOneHotEncodings:Qn(),getPercentages:Ul(),getPValueMatrix:nf(),IndexMatcher:af(),inferType:or(),isBinary:Rn(),isCorrelationMatrix:Kn(),KMeans:If(),normalize:qr(),orthonormalize:Wf(),preprocess:nh(),project:br(),pValue:Zn(),rScore:hh(),sortCorrelationMatrix:qh(),standardize:bh(),StandardScaler:Dh(),trainTestSplit:ur(),dump(){let t=this,e=typeof global<"u"?global:typeof window<"u"?window:null;if(!e)throw new FS("Cannot dump functions into global scope because neither `global` nor `window` exist in the current context!");Object.keys(t).forEach(n=>{try{Object.defineProperty(e,n,{configurable:!1,enumerable:!0,writable:!1,value:t[n]})}catch{e[n]=t[n]}})}};try{window.JSDataScienceHelpers=_h}catch{}try{Eh.exports=_h}catch{}});DS();})();
