(()=>{var Vf=Object.defineProperty;var Uf=(e,t,n)=>t in e?Vf(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n;var de=(e=>typeof require!="undefined"?require:typeof Proxy!="undefined"?new Proxy(e,{get:(t,n)=>(typeof require!="undefined"?require:t)[n]}):e)(function(e){if(typeof require!="undefined")return require.apply(this,arguments);throw new Error('Dynamic require of "'+e+'" is not supported')});var c=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports);var Et=(e,t,n)=>(Uf(e,typeof t!="symbol"?t+"":t,n),n);var U=c((Kb,sr)=>{var At=class extends Error{constructor(t){typeof window<"u"?super(t):super(`

\x1B[31m`+t+`
\x1B[0m`)}};sr.exports=At});var m=c((Wb,or)=>{var Pf=U();or.exports=function(e,t){if(!e)throw new Pf(t)}});var p=c((Hb,ir)=>{function Bf(e){try{return e instanceof Array||typeof e.constructor<"u"&&e.constructor.name==="Array"}catch{return!1}}ir.exports=Bf});var N=c((Qb,ur)=>{function Jf(e){try{return!!e._symbol&&e._symbol===Symbol.for("@jrc03c/js-math-tools/dataframe")}catch{return!1}}ur.exports=Jf});var M=c((Xb,ar)=>{function Rf(e){return typeof e=="function"}ar.exports=Rf});var q=c((Zb,cr)=>{function Yf(e){return typeof e=="number"&&!isNaN(e)}cr.exports=Yf});var w=c((ev,lr)=>{function $f(e){return e===null||typeof e>"u"}lr.exports=$f});var $=c((tv,fr)=>{var Lf=p(),Gf=w();function Kf(e){return typeof e=="object"&&!Gf(e)&&!Lf(e)}fr.exports=Kf});var y=c((nv,hr)=>{function Wf(e){try{return!!e._symbol&&e._symbol===Symbol.for("@jrc03c/js-math-tools/series")}catch{return!1}}hr.exports=Wf});var ge=c((rv,dr)=>{var Hf=m(),mr=p(),Qf=N(),Xf=M(),Mt=q(),pr=$(),Zf=y();function jt(e,t){if(Qf(e)){let o=jt(e.values,t);return o.length>0&&Mt(o[0])&&o[0]>=0&&o[0]<e.index.length&&(o[0]=e.index[o[0]]),o.length>1&&Mt(o[1])&&o[1]>=0&&o[1]<e.columns.length&&(o[1]=e.columns[o[1]]),o}if(Zf(e)){let o=jt(e.values,t);return o.length>0&&Mt(o[0])&&o[0]>=0&&o[0]<e.index.length&&(o[0]=e.index[o[0]]),o}if(Hf(pr(e)||mr(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `indexOf` function!"),!Xf(t)){let o=t;t=i=>i===o}function n(o,i,u){if(u=u||[],u.indexOf(o)>-1)return null;if(pr(o)){u.push(o);let a=Object.keys(o);for(let l=0;l<a.length;l++){let f=a[l],h=o[f];if(i(h))return[f];let d=n(h,i,u);if(d&&d.length>0)return[f].concat(d)}}else if(mr(o)){u.push(o);for(let a=0;a<o.length;a++){let l=o[a];if(i(l))return[a];let f=n(l,i,u);if(f&&f.length>0)return[a].concat(f)}}else if(i(o))return[];return null}function r(o){try{return t(o)}catch{return!1}}let s=n(e,r);return s&&s.length>0?s:null}dr.exports=jt});var P=c((sv,gr)=>{var e0=ge(),t0=p(),n0=N(),r0=y();function s0(e){function t(r,s,o){if(n0(r)||r0(r))return r.copy();if(s=s||[],o=o||"",s.indexOf(r)>-1){let i=o.split("/").slice(o.startsWith("/")?1:0);if(i.some((a,l)=>{let f=i.slice(0,i.length-l-1),h=n;return f.forEach(d=>{h=h[d]}),h===r}))return`<reference to "${n===r?"/":"/"+e0(n,r).join("/")}">`}if(typeof r=="object"){if(r===null)return null;if(s.push(r),t0(r))return r.map((i,u)=>t(i,s,o+"/"+u));{let i={};return Object.keys(r).forEach(u=>{i[u]=t(r[u],s,o+"/"+u)}),i}}else return r}let n=e;return t(e)}gr.exports=s0});var T=c((ov,Nr)=>{var o0=m(),i0=P(),qr=p(),u0=N(),a0=y();function yr(e){if(u0(e)||a0(e))return yr(e.values);o0(qr(e),"The `flatten` function only works on arrays, Series, and DataFrames!");function t(n){let r=[];return i0(n).forEach(s=>{qr(s)?r=r.concat(t(s)):r.push(s)}),r}return t(e)}Nr.exports=yr});var B=c((iv,br)=>{var wr=P();function c0(e,t){function n(r,s){let o=typeof r;if(o!==typeof s)return!1;if(o==="undefined")return!0;if(o==="boolean"||o==="symbol")return r===s;if(o==="number"||o==="bigint")return r.toString()==="NaN"&&s.toString()==="NaN"?!0:r===s;if(o==="string"||o==="function")return r===s;if(o==="object"){if(r===null||s===null)return r===null&&s===null;{let u=Object.keys(r),a=Object.keys(s);if(u.length!==a.length)return!1;for(let l=0;l<u.length;l++){let f=u[l];if(!n(r[f],s[f]))return!1}return!0}}}return n(wr(e),wr(t))}br.exports=c0});var V=c((uv,Or)=>{var l0=m(),f0=T(),h0=p(),vr=N(),m0=M(),Sr=y(),p0=w();function qe(e){let t="abcdefg1234567890",n="";for(;n.length<e;)n+=t[parseInt(Math.random()*t.length)];return n}var d0=qe(256),g0=qe(256),q0=qe(256),y0=qe(256),N0=qe(256);function xr(e){if(vr(e)||Sr(e))return xr(e.values);l0(h0(e),"The `set` function only works on arrays, Series, and DataFrames!");let t=[],n={};return f0(e).forEach(r=>{let s=typeof r=="object"&&r===null?d0:p0(r)?g0:m0(r)?r.toString():typeof r=="symbol"?r.toString()+" - "+N0:r===1/0?q0:r===-1/0?y0:vr(r)?r.toJSONString():Sr(r)?JSON.stringify(r.toObject()):JSON.stringify(r);n[s]||t.push(r),n[s]=!0}),t}Or.exports=xr});var ke=c((av,_r)=>{var w0=m(),It=T(),Tr=p(),b0=N(),Fr=B(),v0=M(),S0=y(),x0=V();function Ce(e,t){if(b0(e)||S0(e))return arguments.length>1?Ce(e.values,t):Ce(e.values,e.values);if(w0(Tr(e),"The first argument to the `count` function must be an array, Series, or DataFrame!"),v0(t))return It(e).filter(n=>t(n)).length;if(Tr(t)){let n=It(e);return x0(t).map(r=>({item:r,count:n.filter(s=>Fr(s,r)).length}))}else return arguments.length>1?It(e).filter(n=>Fr(n,t)).length:Ce(e,e)}_r.exports=Ce});var ye=c((cv,Er)=>{var O0=m(),Dr=p(),T0=N(),F0=y();function Ct(e){if(T0(e)||F0(e))return Ct(e.values);O0(Dr(e),"The `isJagged` function only works on arrays, Series, and DataFrames!");let t=0,n=null;for(let r=0;r<e.length;r++)if(Dr(e[r])){if(t++,Ct(e[r]))return!0;if(n===null)n=e[r].length;else if(e[r].length!==n)return!0}return t>0&&t<e.length}Er.exports=Ct});var ze=c((lv,jr)=>{var _0=m(),Ar=p(),D0=N(),E0=y();function Mr(e){if(D0(e)||E0(e))return Mr(e.values);_0(Ar(e),"The `isNested` function only works on arrays, Series, and DataFrames!");for(let t=0;t<e.length;t++)if(Ar(e[t]))return!0;return!1}jr.exports=Mr});var L=c((fv,Cr)=>{var ne=m(),A0=p(),M0=ze(),j0=q(),I0=w(),oe="You must pass a natural number or a one-dimensional array of natural numbers into the `ndarray` function!";function Ir(e){ne(!I0(e),oe),A0(e)||(e=[e]),ne(!M0(e),oe),ne(e.length>0,oe);let t=e[0];if(ne(j0(t),oe),ne(parseInt(t)===t,oe),ne(t>=0,oe),ne(t!==1/0,"We can't create an array containing an infinite number of values!"),e.length===1){let n=[];for(let r=0;r<t;r++)n.push(void 0);return n}else{let n=[];for(let r=0;r<t;r++)n.push(Ir(e.slice(1)));return n}}Cr.exports=Ir});var Ne=c((hv,kr)=>{var C0=m(),k0=p(),z0=N(),V0=y();function kt(e){if(z0(e)||V0(e)){let n=e.copy();return n.values=kt(n.values),n.index=kt(n.index),n}C0(k0(e),"The `reverse` function only works on arrays, Series, and DataFrames!");let t=[];for(let n=e.length-1;n>=0;n--)t.push(e[n]);return t}kr.exports=kt});var I=c((mv,zr)=>{var zt=m(),Vt=q(),Ut=w(),U0=Ne();function P0(e,t,n=1){zt(!Ut(e)&&!Ut(t)&&!Ut(n),"You must pass two numbers and optionally a step value to the `range` function!"),zt(Vt(e)&&Vt(t)&&Vt(n),"You must pass two numbers and optionally a step value to the `range` function!"),zt(n>0,"The step value must be greater than 0! (NOTE: The step value is a magnitude; it does not indicate direction.)");let r=!1;if(e>t){r=!0;let o=e;e=t+n,t=o+n}let s=[];for(let o=e;o<t;o+=n)s.push(o);return r&&(s=U0(s)),s}zr.exports=P0});var x=c((pv,Br)=>{var B0=m(),Vr=p(),J0=N(),R0=B(),Y0=y(),$0=w();function Ur(e){if(!Vr(e))return;let t=[e.length],n=0,r=e.map(s=>{let o=Ur(s);return $0(o)?o:(n++,o.length===1?o[0]:o)});return n>0?n===e.length&&r.slice(0,-1).every((o,i)=>R0(o,r[i+1]))?t.concat(r[0]):(t.push(r),t):t}function Pr(e){return J0(e)||Y0(e)?Pr(e.values):(B0(Vr(e),"The `shape` function only works on arrays, Series, and DataFrames!"),Ur(e))}Br.exports=Pr});var Gr=c((dv,Lr)=>{var Jr=m(),L0=p(),G0=N(),K0=ye(),W0=y(),H0=w(),Rr=U(),Ve=L(),Yr=I(),Q0=V(),X0=x();function $r(e,t,n){if(H0(n)&&(n=0),Jr(n===0||n===1||n==="vertical"||n==="horizontal",'The only valid axis values for use when appending data to a DataFrame are 0, 1, "vertical", and "horizontal". Note that 0 == "horizontal" and 1 == "vertical".'),L0(t)){Jr(!K0(t),"The array of data you're trying to append to this DataFrame is jagged!");let r=X0(t);if(r.length===1)if(n===0){let s=e.copy();s._values.push(t);let o=Math.max(e.shape[1],r[0]);for(s._values.forEach(i=>{for(;i.length<o;)i.push(void 0)});s._index.length<s._values.length;)s._index.push("row"+s._index.length);for(;s._columns.length<o;)s._columns.push("col"+s._columns.length);return s}else{let s=Math.max(e.shape[0],r[0]),o=e.copy();for(Yr(0,s).forEach(i=>{i>=o._values.length&&o._values.push(Ve(e.shape[1])),o._values[i].push(t[i])});o._index.length<o._values.length;)o._index.push("row"+o._index.length);for(;o._columns.length<o._values[0].length;)o._columns.push("col"+o._columns.length);return o}else if(r.length===2)if(n===0){let s=Math.max(...t.map(i=>i.length).concat([e.shape[1]])),o=e.copy();for(o._values=o._values.concat(t).map(i=>{for(;i.length<s;)i.push(void 0);return i});o._index.length<o._values.length;)o._index.push("row"+o._index.length);for(;o._columns.length<s;)o._columns.push("col"+o._columns.length);return o}else{let s=Math.max(...t.map(u=>u.length))+e.shape[1],o=Math.max(e.shape[0],r[0]),i=e.copy();for(Yr(0,o).forEach(u=>{for(u>=i._values.length&&i._values.push(Ve(e.shape[1])),i._values[u]=i._values[u].concat(t[u]);i._values[u].length<s;)i._values[u].push(void 0)});i._index.length<i._values.length;)i._index.push("row"+i._index.length);for(;i._columns.length<s;)i._columns.push("col"+i._columns.length);return i}else throw new Rr("Only 1- and 2-dimensional arrays can be appended to a DataFrame!")}else if(W0(t)){let r=$r(e,t.values,n);return n===0?r.index[r.index.length-1]=r.index.indexOf(t.name)>-1?t.name+" (2)":t.name:r.columns[r.columns.length-1]=r.columns.indexOf(t.name)>-1?t.name+" (2)":t.name,r}else if(G0(t))if(n===0){let r=e.copy(),s=Q0(r._columns.concat(t._columns)).length;for(r._values.forEach(o=>{for(;o.length<s;)o.push(void 0)}),t.apply(o=>{let i=o.copy(),u=[];r._columns.forEach(a=>{let l=i._index.indexOf(a);l>-1?(u.push(i._values[l]),i._values.splice(l,1),i._index.splice(l,1)):u.push(void 0)}),r._values.push(u.concat(i._values))},1),r._columns=r._columns.concat(t._columns.filter(o=>r._columns.indexOf(o)<0));r._index.length<r._values.length;){let o="row"+r._index.length;r._index.push(o+(e._index.indexOf(o)>-1?" (2)":""))}return r}else{let r=e.copy();return r._index.forEach((s,o)=>{let i=t._index.indexOf(s);i>-1?r._values[o]=r._values[o].concat(t._values[i]):r._values[o]=r._values[o].concat(Ve(t.shape[1]))}),t._index.forEach((s,o)=>{r._index.indexOf(s)<0&&(r._index.push(s),r._values.push(Ve(r._columns.length).concat(t._values[o])))}),r._columns=r._columns.concat(t._columns.map(s=>s+(r._columns.indexOf(s)>-1?" (2)":""))),r}else throw new Rr("Only 1- or 2-dimensional arrays, Series, and DataFrames can be appended to a DataFrame!")}Lr.exports=$r});var Xr=c((gv,Qr)=>{var Kr=m(),Wr=p(),Z0=M(),Hr=w();function eh(e,t,n,r,s){if(s=s||0,Kr(Z0(r),"The first parameter to the `apply` method must be a function."),Kr(s===0||s===1,"The second parameter to the `apply` method (the `axis`) must be 0 or 1."),s===0){let o={},i;if(n.columns.forEach((u,a)=>{let l=new t(n.values.map(h=>h[a]));l.name=u,l.index=n.index;let f=r(l,a,n);f instanceof t?o[u]=f.values:o[u]=f,Hr(i)&&(i=f instanceof t||Wr(f))}),i){let u=new e(o);return u.index=n.index,u}else{let u=new t(n.columns.map(a=>o[a]));return u.index=n.columns,u}}else if(s===1){let o,i=n.values.map((u,a)=>{let l=new t(u);l.name=n.index[a],l.index=n.columns;let f=r(l,a,n);return Hr(o)&&(o=f instanceof t||Wr(f)),f instanceof t?f.values:f});if(o){let u=new e(i);return u.index=n.index,u.columns=n.columns,u}else{let u=new t(i);return u.index=n.index,u}}}Qr.exports=eh});var E=c((qv,Zr)=>{function th(e){return typeof e=="string"}Zr.exports=th});var ns=c((yv,ts)=>{var es=m(),nh=p(),rh=ye(),sh=$(),oh=E(),ih=w(),uh=U(),ah=x();function ch(e,t,n,r,s){let o=u=>u instanceof e,i=u=>u instanceof t;if(ih(s)){if(o(r))return n.append(r,1);if(i(r))return n.append(r,1);if(sh(r)){let u=Math.max(...Object.keys(r).map(a=>r[a].length));return Object.keys(r).forEach(a=>{for(;r[a].length<u;)r[a].push(void 0)}),n.append(new e(r),1)}else throw new uh("You must pass a DataFrame, Series, or object into the `assign` method!")}else{es(oh(r),"If passing two arguments into the `assign` method, then the first argument must be a string name!"),es(nh(s)&&!rh(s)&&ah(s).length===1,"If passing two arguments into the `assign` method, then the second argument must be a 1-dimensional array!");let u=n.append(s,1);return u.columns[u.columns.length-1]=r,u}}ts.exports=ch});var ss=c((Nv,rs)=>{var lh=P();function fh(e,t){if(t.isEmpty)return new e;let n=new e(lh(t.values));return n.columns=t.columns.slice(),n.index=t.index.slice(),n}rs.exports=fh});var fs=c((wv,ls)=>{var Ue=m(),os=p(),is=q(),us=E(),as=w(),cs=x();function hh(e,t,n,r,s){as(r)&&(r=[]),as(s)&&(s=[]),(us(r)||is(r))&&(r=[r]),(us(s)||is(s))&&(s=[s]),Ue(os(r),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),Ue(os(s),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),Ue(cs(r).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),Ue(cs(s).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");let o,i;n.index.forEach((a,l)=>{r.indexOf(a)<0&&r.indexOf(l)<0&&(o||(o=[]),o.push(a))}),n.columns.forEach((a,l)=>{s.indexOf(a)<0&&s.indexOf(l)<0&&(i||(i=[]),i.push(a))});let u=n.get(o,i);if(u instanceof t){let a=new e;a=a.assign(u),n.index.indexOf(u.name)>-1&&(a=a.transpose()),u=a}return u}ls.exports=hh});var we=c((bv,hs)=>{var mh=q();function ph(e){return mh(e)&&parseInt(e)===e}function dh(e){return ph(e)&&e>=0}hs.exports=dh});var ps=c((vv,ms)=>{var Pt=m(),gh=E(),Pe=w(),qh=we(),yh=x();function Nh(e,t,n,r,s,o){r=r||0,Pt(r===0||r===1,"The first parameter of the `dropMissing` method (the `axis`) must be 0 or 1."),o=o||0,Pt(qh(o),"The third parameter of the `dropMissing` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` null values)."),s=o>0?"none":s||"any",Pt(s==="any"||s==="all"||s==="none","The second parameter of the `dropMissing` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains null values, then it should be dropped; or that if 'all' of the data contains null values, then it should be dropped).");function i(l){if(o>0){let f=0;for(let h=0;h<l.length;h++){let d=l[h];if(Pe(d)&&f++,f>=o)return[]}}else if(s==="any")for(let f=0;f<l.length;f++){let h=l[f];if(Pe(h))return[]}else if(s==="all"){for(let f=0;f<l.length;f++){let h=l[f];if(!Pe(h))return l}return[]}return l}let u=n.copy(),a=Math.random().toString();if(r===0){u=u.assign(a,u.index);let l=u.values.map(i).filter(h=>h.length>0);if(yh(l).length<2)return new e;u.values=l;let f=u.get(null,a);if(Pe(f))return new e;gh(f)&&(f=[f]),f instanceof t&&(f=f.values),u.index=f,u=u.drop(null,a)}else if(r===1){let l={};if(u.columns.forEach((h,d)=>{let g=u.values.map(b=>b[d]),v=i(g);v.length>0&&(l[h]=v)}),Object.keys(l).length===0)return new e;let f=new e(l);return f.index=u.index,f}return u}ms.exports=Nh});var Bt=c((Sv,gs)=>{var wh=m(),bh=p(),vh=N(),Sh=q(),xh=y();function ds(e){if(vh(e)||xh(e))return e.dropNaN(...Object.values(arguments).slice(1));wh(bh(e),"The `dropNaN` function only works on arrays, Series, and DataFrames!");let t=[];return e.forEach(n=>{try{return t.push(ds(n))}catch{if(Sh(n))return t.push(n)}}),t}gs.exports=ds});var ys=c((xv,qs)=>{var Jt=m(),Oh=Bt(),Th=we();function Fh(e,t,n,r,s){n=n||0,Jt(n===0||n===1,"The first parameter of the `dropNaN` method (the `axis`) must be 0 or 1."),s=s||0,Jt(Th(s),"The third parameter of the `dropNaN` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` NaN values)."),r=s>0?"none":r||"any",Jt(r==="any"||r==="all"||r==="none","The second parameter of the `dropNaN` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains NaN values, then it should be dropped; or that if 'all' of the data contains NaN values, then it should be dropped).");function o(u){let a=Oh(u);return s>0?u.length-a.length<s:r==="any"?a.length===u.length:r==="all"?a.length>0:!0}let i=t.copy();if(n===0){let u=i.index.filter(a=>{let l=i.get(a,null).values;return o(l)});return u.length>0?i.get(u,null):new e}else if(n===1){let u=i.columns.filter(a=>{let l=i.get(null,a).values;return o(l)});return u.length>0?i.get(null,u):new e}return i}qs.exports=Fh});var vs=c((Ov,bs)=>{var Ns=m(),be=T(),_h=M(),Dh=w();function ws(e){let t={};return be(e).forEach((n,r)=>{t[n]=r}),t}function ie(e){return Object.keys(e).sort((t,n)=>e[t]-e[n])}function Eh(e,t,n,r,s){Ns(_h(r),"The `filter` method takes a single parameter: a function that is used to filter the values."),Dh(s)&&(s=0),Ns(s===0||s===1,"The `axis` parameter to the `filter` method must be 0 or 1.");let o=n.copy();if(o.isEmpty)return o;let i=ws(o.index),u=ws(o.columns);if(s===0){let a=o.values.filter((l,f)=>{let h=new t(l);h.name=n.index[f],h.index=n.columns;let d=r(h,f,n);return d||delete i[o.index[f]],d});if(be(a).length===0)return new e;if(a.length===1){let l=new t(be(a));return l.name=ie(i)[0],l.index=ie(u),l}o.values=a,o.index=ie(i)}else if(s===1){o=o.transpose();let a=o.values.filter((l,f)=>{let h=new t(l);h.name=n.columns[f],h.index=n.index;let d=r(h,f,n);return d||delete u[o.index[f]],d});if(be(a).length===0)return new e;if(a.length===1){let l=new t(be(a));return l.name=ie(u)[0],l.index=ie(i),l}o.values=a,o.index=ie(u),o=o.transpose()}return o}bs.exports=Eh});var ve=c((Tv,Ss)=>{function Ah(e){return typeof e=="boolean"}Ss.exports=Ah});var re=c((Fv,Os)=>{var Mh=m(),jh=T(),Ih=p(),Ch=N(),kh=y();function xs(e){if(Ch(e)||kh(e))return xs(e.values);Mh(Ih(e),"The `max` function only works on arrays, Series, and DataFrames!");try{return Math.max(...jh(e))}catch{return NaN}}Os.exports=xs});var Rt=c((_v,_s)=>{var Be=U(),G=m(),K=p(),Ts=ve(),Je=E(),Re=w(),zh=re(),Fs=I();function Vh(e,t,n,r,s,o){return n=(()=>{if(Re(n))return!1;if(Ts(n))return n;throw new Be("The `hasHeaderRow` parameter of the `fromCSV` method must be a boolean!")})(),r=(()=>{if(Re(r))return!1;if(Ts(r))return r;throw new Be("The `hasIndexColumn` parameter of the `fromCSV` method must be a boolean!")})(),s=(()=>{let u="The `fieldDelimiter` parameter of the `fromCSV` method must be one of:\n\n1) a single-character string (e.g., ',')\n2) an array containing two single-character strings, one each for a left delimiter and a right delimiter (e.g., ['<', '>'])";if(Re(s))return",";if(Je(s))return G(s.length===1,u),s;if(K(s))return G(s.length===2,u),G(s[0].length===1,u),G(s[1].length===1,u),s;throw new Be(u)})(),o=(()=>{let u="The `stringDelimiter` parameter of the `fromCSV` method must be one of:\n\n1) a single-character string (e.g., '\"')\n2) an array containing two single-character strings, one each for a left delimiter and a right delimiter (e.g., ['\u201C', '\u201D'])";if(Re(o))return'"';if(Je(o))return G(o.length===1,u),o;if(K(o))return G(o.length===2,u),G(o[0].length===1,u),G(o[1].length===1,u),o;throw new Be(u)})(),(()=>{let a=t.split(`
`).filter(g=>g.length>0).map(g=>{let v=[],b="",D=!1;for(let k=0;k<g.length;k++){let j=g[k];if(j.match(/\\/g))k++;else if(K(o)&&j===o[0])D=!0;else if(K(o)&&j===o[1])D=!1;else if(Je(o)&&j===o)D=!D;else if(K(s)&&j===s[0]||K(s)&&j===s[1]||Je(s)&&j===s)if(D)b+=j;else{let _t=b;try{let Dt=JSON.parse(_t);K(Dt)?v.push(_t.trim()):v.push(Dt)}catch{v.push(_t.trim())}b=""}else b+=j}if(b.length>0){let k=b;try{let j=JSON.parse(k);K(j)?v.push(k.trim()):v.push(j)}catch{v.push(k.trim())}}return v}),l=(()=>{let g=n?a.shift():Fs(0,a[0].length).map(v=>"col"+v);return r&&g.shift(),g})(),f=(()=>r?a.map(v=>v.shift()):Fs(0,a.length).map(v=>"row"+v))(),h=zh(a.map(g=>g.length)),d=new e(a.map(g=>(g.length=h,g)));return n&&(d.columns=l),r&&(d.index=f),d})()}_s.exports=Vh});var Es=c((Dv,Ds)=>{var Uh=U(),Ph=m(),Bh=Rt(),Jh=E(),Rh=w();async function Yh(e,t,n,r,s,o,i){n=(()=>Rh(n)?"utf8":(Ph(Jh(n),"The `encoding` parameter of the `fromCSV` method must be a string (e.g., 'utf8')!"),n))();let u=await(async()=>{try{return de("fs").readFileSync(t,n)}catch{}try{return await(await fetch(t)).text()}catch{}throw new Uh(`The path "${t}" could not be loaded!`)})();return Bh(e,u,r,s,o,i)}Ds.exports=Yh});var js=c((Ev,Ms)=>{var z=m(),Ye=q(),$e=E(),As=w(),$h=V();function Lh(e,t,n){($e(t)||Ye(t))&&(t=[t]),($e(n)||Ye(n))&&(n=[n]);let r=$h((t||[]).concat(n||[]).map(s=>typeof s));return z(r.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===1&&z(r[0]==="string"||r[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===2&&(z(r.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),z(r.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),As(t)||(t=t.map(s=>{if($e(s))return z(e.index.indexOf(s)>-1,`Row "${s}" does not exist!`),s;if(Ye(s))return z(s>=0,`Index ${s} is out of bounds!`),z(parseInt(s)===s,"Row numbers must be integers!"),z(s<e.index.length,`Index ${s} is out of bounds!`),e.index[s]})),As(n)||(n=n.map(s=>{if($e(s))return z(e.columns.indexOf(s)>-1,`Column "${s}" does not exist!`),s;if(Ye(s))return z(s>=0,`Column ${s} is out of bounds!`),z(parseInt(s)===s,"Column numbers must be integers!"),z(s<e.columns.length,`Column ${s} is out of bounds!`),e.columns[s]})),e.getSubsetByNames(t,n)}Ms.exports=Lh});var W=c((Av,Cs)=>{var Is=m(),Gh=p(),Kh=N(),Wh=M(),Hh=y(),Qh=w();function Xh(e,t){try{return e<t?-1:e>t?1:0}catch{return e=typeof e=="object"&&e!==null?JSON.stringify(e):e.toString(),t=typeof t=="object"&&t!==null?JSON.stringify(t):t.toString(),e<t?-1:e>t?1:0}}function Zh(e,t){if(Qh(t)&&(t=Xh),Kh(e)||Hh(e))return e.sort(...Object.values(arguments).slice(1));Is(Gh(e),"The `sort` function only works on arrays, Series, and DataFrames!"),Is(Wh(t),"The second parameter of the `sort` function must be a comparison function!");let n=e.slice();return n.sort(t),n}Cs.exports=Zh});var Us=c((Mv,Vs)=>{var ks=m(),zs=E(),em=w(),tm=V(),nm=W();function rm(e){let t=e.toLowerCase(),n="";for(let s=0;s<t.length;s++){let o=t[s];o.match(/[a-z0-9]/g)?n+=o:n+=" "}let r=n.split(" ").filter(s=>s.length>0);return r[0]+r.slice(1).map(s=>s[0].toUpperCase()+s.substring(1)).join("")}function sm(e,t,n){em(n)?n=t.columns:zs(n)&&(n=[n]);let r={};n.forEach(o=>{ks(zs(o),"You must pass either a string or a one-dimensional array of strings into the `getDummies` (AKA `oneHotEncode`) method!");let i=t.columns.indexOf(o);ks(i>-1,`The given DataFrame does not have a column called "${o}"!`);let u=t.values.map(l=>l[i]),a=nm(tm(u));u.forEach(l=>{a.forEach(f=>{let h=o+"_"+rm(f.toString());r[h]||(r[h]=[]),l===f?r[h].push(1):r[h].push(0)})})});let s=new e(r);return s.index=t.index,s}Vs.exports=sm});var Gs=c((jv,Ls)=>{var H=m(),Ps=p(),Bs=q(),Js=w(),Rs=we(),Ys=I(),$s=x();function om(e,t,n){let r=e.shape;Js(t)&&(t=Ys(0,r[0])),Js(n)&&(n=Ys(0,r[1])),Bs(t)&&(t=[t]),Bs(n)&&(n=[n]),H(Ps(t)&&Ps(n),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),H($s(t).length===1&&$s(n).length===1,"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),H(t.length>0,"The `rowIndices` array must contain at least one index."),H(n.length>0,"The `colIndices` array must contain at least one index."),t.forEach(i=>{H(Rs(i),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),H(i<e.index.length,`The row index ${i} is out of bounds.`)}),n.forEach(i=>{H(Rs(i),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),H(i<e.columns.length,`The column index ${i} is out of bounds.`)});let s=t.map(i=>e.index[i]),o=n.map(i=>e.columns[i]);return e.getSubsetByNames(s,o)}Ls.exports=om});var Xs=c((Iv,Qs)=>{var Q=m(),Yt=T(),Ks=p(),Le=E(),Ws=w(),Hs=x();function im(e,t,n,r,s){Ws(r)&&(r=n.index),Ws(s)&&(s=n.columns),Le(r)&&(r=[r]),Le(s)&&(s=[s]),Q(Ks(r)&&Ks(s),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),Q(Hs(r).length===1&&Hs(s).length===1,"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),Q(r.length>0,"The `rows` array must contain at least one row name."),Q(s.length>0,"The `cols` array must contain at least one column name."),r.forEach(u=>{Q(Le(u),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),Q(n.index.indexOf(u)>-1,`The row name "${u}" does not exist in the list of rows.`)}),s.forEach(u=>{Q(Le(u),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),Q(n.columns.indexOf(u)>-1,`The column name "${u}" does not exist in the list of columns.`)});let o=r.map(u=>s.map(a=>n.values[n.index.indexOf(u)][n.columns.indexOf(a)]));if(r.length===1&&s.length===1)return Yt(o)[0];if(r.length===1){let u=new t(Yt(o));return u.name=r[0],u.index=s,u}if(s.length===1){let u=new t(Yt(o));return u.name=s[0],u.index=r,u}let i=new e(o);return i.columns=s,i.index=r,i}Qs.exports=im});var eo=c((Cv,Zs)=>{var um=E(),Se=I();function am(e,t,n){function r(d,g){return um(d)&&d.length>g?d.substring(0,g-3)+"...":d}if(n.isEmpty)return console.table({}),console.log("Shape:",[0,0],`
`),n;let s=typeof window>"u"?20:10,o=parseInt(s/2),i=typeof window>"u"?Math.floor(process.stdout.columns/24)-1:10,u=parseInt(i/2),a=s>n.index.length?null:Se(0,o).concat(Se(n.index.length-o,n.index.length)),l=i>n.columns.length?null:Se(0,u).concat(Se(n.columns.length-u,n.columns.length)),f=n.get(a,l);f instanceof t&&(n.shape[0]===1?(f=new e([f.values]),f.index=n.index,f.columns=new t(n.columns).get(l).values):n.shape[1]===1&&(f=new e([f.values]).transpose(),f.index=new t(n.index).get(a).values,f.columns=n.columns)),s<=n.index.length&&(f._index.splice(o,0,"..."),f._values.splice(o,0,Se(0,f.columns.length).map(()=>"..."))),i<=n.columns.length&&(f._columns.splice(u,0,"..."),f._values=f._values.map(d=>(d.splice(u,0,"..."),d)));let h=28;return f instanceof t?(f.values=f.values.map(d=>r(d,h)),f.name=r(f.name,h),f.index=f.index.map(d=>r(d,h))):(f.values=f.values.map(d=>d.map(g=>r(g,h))),f.columns=f.columns.map(d=>r(d,h)),f.index=f.index.map(d=>r(d,h))),console.table(f.toObject()),console.log("Shape:",n.shape,`
`),n}Zs.exports=am});var Ge=c((kv,to)=>{var cm=m(),lm=q();function fm(e,t){cm(lm(e),"The `leftPad` function only works on numbers!");let n=e.toString();for(;n.length<t;)n="0"+n;return n}to.exports=fm});var ro=c((zv,no)=>{var hm=Ge(),mm=I();function pm(e,t){let n=t?e:e.copy();return n.index=mm(0,e.shape[0]).map(r=>"row"+hm(r,(n.index.length-1).toString().length)),n}no.exports=pm});var xe=c((Vv,oo)=>{var dm=m(),gm=T(),qm=p(),ym=N(),Nm=y();function so(e){if(ym(e)||Nm(e))return so(e.values);dm(qm(e),"The `product` function only works on arrays, Series, and DataFrames!");try{return e.length===0?NaN:gm(e).reduce((t,n)=>t*n,1)}catch{return NaN}}oo.exports=so});var Ke=c((Uv,co)=>{var Oe=m(),io=T(),uo=p(),wm=N(),ao=q(),bm=y(),vm=xe(),Sm=x();function $t(e,t){if(wm(e)||bm(e))return $t(e.values,t);if(Oe(uo(e),"The first argument passed into the `reshape` function must be an array!"),ao(t)&&(t=[t]),Oe(uo(t),"The second argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),Oe(Sm(t).length===1,"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),t.forEach(o=>{Oe(ao(o)&&parseInt(o)===o&&o>0,"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!")}),t.length===0)return io(e);let n=io(e);if(t.length===1&&t[0]===n.length)return n;Oe(vm(t)===n.length,"The new shape doesn't match the number of values available in `x` (the first argument passed into the `reshape` function)!");let r=[],s=parseInt(n.length/t[0]);for(let o=0;o<t[0];o++){let i=n.slice(o*s,(o+1)*s);r.push($t(i,t.slice(1)))}return r}co.exports=$t});var ue=c((Pv,qo)=>{var xm=m(),ho=P(),Om=p(),Tm=q(),mo=w(),Fm=L(),_m=xe(),Dm=Ke(),po=Math.pow(2,64),O=[];go(parseInt(Math.random()*po));function Em(e,t){e=A(e);function n(){e+=A("0x9e3779b97f4a7c15");let s=ho(e);return s=(s^s>>30n)*A("0xbf58476d1ce4e5b9"),s=(s^s>>27n)*A("0x94d049bb133111eb"),s^s>>31n}let r=[];for(let s=0;s<t;s++)r.push(n());return r}function A(e){return BigInt.asUintN(64,BigInt(e))}function lo(e,t){return e=A(e),t=BigInt(t),A(A(e<<t)|A(e>>A(64n-t)))}function go(e){if(mo(e))return ho(O);{xm(Tm(e),"If passing a value into the `seed` function, then that value must be an integer!");let t=Em(parseInt(e),4);O[0]=t[0],O[1]=t[1],O[2]=t[2],O[3]=t[3]}}function fo(){let e=A(lo(O[0]+O[3],23)+O[0]),t=A(O[1]<<17n);return O[2]=A(O[2]^O[0]),O[3]=A(O[3]^O[1]),O[1]=A(O[1]^O[2]),O[0]=A(O[0]^O[3]),O[2]=A(O[2]^t),O[3]=lo(O[3],45),parseInt(e)/po}function Am(e){return mo(e)?fo():(Om(e)||(e=[e]),Dm(Fm(_m(e)).map(fo),e))}qo.exports={random:Am,seed:go}});var We=c((Bv,yo)=>{var{random:Mm}=ue(),jm=m(),Im=p(),Cm=N(),km=y();function zm(e){if(Cm(e)||km(e))return e.shuffle(...Object.values(arguments).slice(1));jm(Im(e),"The `shuffle` function only works on arrays, Series, and DataFrames!");let t=[],n=e.slice();for(let r=0;r<e.length;r++){let s=parseInt(Mm()*n.length);t.push(n.splice(s,1)[0])}return t}yo.exports=zm});var bo=c((Jv,wo)=>{var Vm=m(),Um=w(),No=We();function Pm(e,t){return Um(t)&&(t=0),Vm(t===0||t===1,"The `axis` parameter to the `shuffle` must be 0, 1, or undefined."),e.get(t===0?No(e.index):null,t===1?No(e.columns):null)}wo.exports=Pm});var To=c((Rv,Oo)=>{var{random:Bm}=ue(),C=m(),Jm=T(),vo=p(),Lt=ve(),xo=M(),He=q(),ae=E(),Gt=w(),Rm=I(),So=x(),Kt=W();function Ym(e,t,n){return xo(t)?$m(e,t,n):Lm(e,t,n)}function $m(e,t,n){if(n=Gt(n)?0:n,C(xo(t),"When sorting a DataFrame using a function, the first argument to the `sort` method must be a function!"),C(He(n),"When sorting a DataFrame using a function, the second argument to the `sort` method must be null, undefined, 0, or 1 to indicate the axis along which the data should be sorted! An axis of 0 means that the rows will be sorted relative to each other, whereas an axis of 1 means that the columns will be sorted relative to each other."),n===0){let r=Kt(e.index,(s,o)=>t(e.get(s,null),e.get(o,null)));return e.get(r,null)}else{let r=Kt(e.columns,(s,o)=>t(e.get(null,s),e.get(null,o)));return e.get(null,r)}}function Lm(e,t,n){let r=e.copy(),s=Bm().toString();return r=r.assign(s,r.index),Gt(t)&&(t=[s],n=[!0]),(He(t)||ae(t))&&(t=[t],(Lt(n)||ae(n))&&(n=[n])),C(vo(t),"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),C(So(t).length===1,"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),Gt(n)&&(n=Rm(0,t.length).map(()=>!0)),C(vo(n),"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),C(So(n).length===1,"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),C(t.length===n.length,"The arrays passed into the `sort` method must be equal in length."),t=t.map(o=>{if(C(ae(o)||He(o),"Column references can either be column names (as strings) or column indices (as whole numbers)."),ae(o)){let i=r.columns.indexOf(o);return C(i>-1,`The column "${o}" does not exist!`),i}if(He(o))return C(parseInt(o)===o,"Column indices must be whole numbers!"),C(o>=0,`The column index ${o} is out of bounds!`),C(o<r.columns.length,`The index ${o} is out of bounds!`),o}),n=n.map(o=>{if(C(ae(o)||Lt(o),"Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),ae(o)){let i=o.trim().toLowerCase();return C(i==="ascending"||i==="descending","Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),i==="ascending"}if(Lt(o))return o}),r.values=Kt(r.values,(o,i)=>{let u=0;for(;o[t[u]]===i[t[u]]&&u<t.length;)u++;let a=n[u];if(o[t[u]]===i[t[u]])return 0;if(o[t[u]]<i[t[u]])return a?-1:1;if(o[t[u]]>i[t[u]])return a?1:-1}),r.index=Jm(r.get(null,s).values),r=r.dropColumns(s),r}Oo.exports=Ym});var Wt=c((Yv,_o)=>{var Gm=U(),Km=ve(),Wm=$(),Hm=E(),Fo=w();function Qm(e,t){t=(()=>{if(Fo(t))return!0;if(Km(t))return t;throw new Gm("The `shouldIncludeIndex` parameter of the `toCSVString` method must be a boolean!")})();let n=[""].concat(e.index);return[e.columns].concat(e.values).map((s,o)=>(t?[n[o]]:[]).concat(s).map(u=>Hm(u)?JSON.stringify(u):Wm(u)?JSON.stringify(JSON.stringify(u)):Fo(u)?"":u.toString()).join(",")).join(`
`)}_o.exports=Qm});var Do=c(($v,Qt)=>{var Ht=U(),Xm=Wt();function Zm(e,t,n){let r=Xm(e,n),s=!1,o=!1,i,u;try{let a=t;if(t.includes("/")){let f=t.split("/");a=f[f.length-1]}let l=document.createElement("a");l.href=`data:text/csv;charset=utf-8,${encodeURIComponent(r)}`,l.download=a,l.dispatchEvent(new MouseEvent("click")),s=!0}catch(a){i=a}try{let a=de("fs"),l=de("path");a.writeFileSync(l.resolve(t),r,"utf8"),o=!0}catch(a){u=a}if(!s&&!o)throw typeof window<"u"?new Ht(i):typeof Qt<"u"?new Ht(u):new Ht("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");return e}Qt.exports=Zm});var Xt=c((Lv,Eo)=>{function ep(e,t){return JSON.stringify(e.toObject(t))}Eo.exports=ep});var Ao=c((Gv,en)=>{var Zt=U(),tp=Xt();function np(e,t,n){let r=tp(e,n),s=!1,o=!1,i,u;try{let a=t;if(t.includes("/")){let f=t.split("/");a=f[f.length-1]}let l=document.createElement("a");l.href=`data:application/json;charset=utf-8,${encodeURIComponent(r)}`,l.download=a,l.dispatchEvent(new MouseEvent("click")),s=!0}catch(a){i=a}try{let a=de("fs"),l=de("path");a.writeFileSync(l.resolve(t),r,"utf8"),o=!0}catch(a){u=a}if(!s&&!o)throw typeof window<"u"?new Zt(i):typeof en<"u"?new Zt(u):new Zt("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");return e}en.exports=np});var jo=c((Kv,Mo)=>{var rp=m(),sp=w();function op(e,t){sp(t)?t=0:rp(t===0||t===1,"The axis parameter of the `toObject` method must be undefined, 0, or 1. An axis of 0 indicates that the returned object should be organized first by rows and then by columns. An axis of 1 indicates that the returned object should be organized first by columns and then by rows.");let n={};return t===0?e.index.forEach((r,s)=>{let o={};e.columns.forEach((i,u)=>{o[i]=e.values[s][u]}),n[r]=o}):e.columns.forEach((r,s)=>{let o={};e.index.forEach((i,u)=>{o[i]=e.values[u][s]}),n[r]=o}),n}Mo.exports=op});var se=c((Wv,ko)=>{var Io=m(),ip=p(),up=N(),ap=y(),cp=L(),Co=Ne(),lp=x();function fp(e){if(up(e)||ap(e))return e.transpose();Io(ip(e),"The `transpose` function only works on arrays, Series, and DataFrames!");let t=lp(e);if(Io(t.length<=2,"I'm not smart enough to know how to transpose arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `transpose` function!"),t.length===1)return Co(e);if(t.length===2){let n=cp(Co(t));for(let r=0;r<t[0];r++)for(let s=0;s<t[1];s++)n[s][r]=e[r][s];return n}}ko.exports=fp});var Po=c((Hv,Uo)=>{var zo=m(),hp=p(),mp=N(),pp=ze(),dp=y(),gp=x();function Vo(e,t,n){if(dp(n))return new e(t.values.concat(n.values));if(hp(n)){let r=gp(n);zo(r.length===1&&!pp(r),"Only vectors can be appended to Series!");let s=t.copy();return n.forEach((o,i)=>{s._values.push(o),s._index.push("item"+(t.values.length+i))}),s}return zo(!mp(n),"DataFrames cannot be appended to Series!"),Vo(t,[n])}Uo.exports=Vo});var Jo=c((Qv,Bo)=>{var qp=m(),yp=M();function Np(e,t){qp(yp(t),"The parameter to the `apply` method must be a function.");let n=e.copy();return n._values=n._values.map((r,s)=>t(r,s)),n}Bo.exports=Np});var Yo=c((Xv,Ro)=>{var wp=w();function bp(e){let t=e.copy(),n=[];return t._values=t.values.filter((r,s)=>wp(r)?!1:(n.push(t.index[s]),!0)),t._index=n,t}Ro.exports=bp});var Lo=c((Zv,$o)=>{var vp=q();function Sp(e,t){let n=[],r=[];t.values.forEach((o,i)=>{vp(o)&&(r.push(o),n.push(t.index[i]))});let s=new e(r);return s.name=t.name,s.index=n,s}$o.exports=Sp});var Ko=c((eS,Go)=>{var xp=P();function Op(e,t,n){let r=t.copy(),s=xp(r.index),o=[],i=r.values.filter((u,a)=>{let l=n(u,a,r.values);return l||o.push(r.index[a]),l});return o.forEach(u=>{s.splice(s.indexOf(u),1)}),i.length===0?(r=new e,r.name=t.name,r):(r.values=i,r.index=s,r)}Go.exports=Op});var Ho=c((tS,Wo)=>{var X=m(),Tp=q(),Fp=E(),_p=w(),Dp=V();function Ep(e,t){(Fp(t)||Tp(t))&&(t=[t]);let n=Dp((t||[]).map(r=>typeof r));return X(n.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===1&&X(n[0]==="string"||n[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===2&&(X(n.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),X(n.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),_p(t)||(t=t.map(r=>{if(typeof r=="string")return X(e.index.indexOf(r)>-1,`Index "${r}" does not exist!`),r;if(typeof r=="number")return X(r>=0,`Index ${r} is out of bounds!`),X(parseInt(r)===r,"Indices must be integers!"),X(r<e.index.length,`Index ${r} is out of bounds!`),e.index[r]})),e.getSubsetByNames(t)}Wo.exports=Ep});var Xo=c((nS,Qo)=>{var Te=m(),Ap=p(),Mp=w(),jp=we(),Ip=I(),Cp=x();function kp(e,t){let n=e.shape;Mp(t)&&(t=Ip(0,n[0])),Te(Ap(t),"The `indices` array must be 1-dimensional array of whole numbers."),Te(Cp(t).length===1,"The `indices` array must be a 1-dimensional array of whole numbers."),Te(t.length>0,"The `indices` array must contain at least one index."),t.forEach(s=>{Te(jp(s),"The `indices` array must be a 1-dimensional array of whole numbers."),Te(s<e.index.length,`The row index ${s} is out of bounds.`)});let r=t.map(s=>e.index[s]);return e.getSubsetByNames(r)}Qo.exports=kp});var ei=c((rS,Zo)=>{var Fe=m(),zp=p(),Vp=E(),Up=w(),Pp=x();function Bp(e,t,n){Up(n)&&(n=t.index),Fe(zp(n),"The `indices` array must be a 1-dimensional array of strings."),Fe(Pp(n).length===1,"The `indices` array must be a 1-dimensional array of strings."),Fe(n.length>0,"The `indices` array must contain at least one index name."),n.forEach(o=>{Fe(Vp(o),"The `indices` array must contain only strings."),Fe(t.index.indexOf(o)>-1,`The name "${o}" does not exist in the index.`)});let r=n.map(o=>t.values[t.index.indexOf(o)]);if(r.length===1)return r[0];let s=new e(r);return s.index=n,s.name=t.name,s}Zo.exports=Bp});var ri=c((sS,ni)=>{var Jp=P(),ti=I();function Rp(e){let t=e.copy(),n=typeof window>"u"?20:10;if(t.index.length>n){t=t.get(ti(0,n/2).concat(ti(t.index.length-n/2,t.index.length)));let s=Jp(t.index);s.splice(parseInt(s.length/2),0,"..."),t.values.push("..."),t.index.push("..."),t=t.get(s)}let r={};return t.values.forEach((s,o)=>{let i={};i[t.name]=s,r[t.index[o]]=i}),console.table(r),console.log("Shape:",e.shape,`
`),e}ni.exports=Rp});var oi=c((oS,si)=>{var Yp=We();function $p(e){let t=e.copy();return t.get(Yp(t.index))}si.exports=$p});var ui=c((iS,ii)=>{var Lp=m(),Gp=M(),Kp=w(),Wp=W(),Hp=se();function Qp(e,t,n){n=n||((a,l)=>a<l?-1:1),Lp(Kp(n)||Gp(n),"You must pass undefined, null, or a comparison function as the second argument to the `sort` method!");let r=Hp([t.values,t.index]),s=Wp(r,(a,l)=>n(a[0],l[0])),o=[],i=[];s.forEach(a=>{o.push(a[0]),i.push(a[1])});let u=new e;return u._values=o,u._index=i,u.name=t.name,u}ii.exports=Qp});var li=c((uS,ci)=>{var Xp=W(),ai=se();function Zp(e,t){let n=ai([t.values,t.index]);n=ai(Xp(n,(s,o)=>{if(s[1]===o[1])return 0;if(s[1]<o[1])return-1;if(s[1]>o[1])return 1}));let r=new e(n[0]);return r.index=n[1],r.name=t.name,r}ci.exports=Zp});var hi=c((aS,fi)=>{function ed(e){let t={};return t[e.name]={},e.index.forEach((n,r)=>{t[e.name][n]=e.values[r]}),t}fi.exports=ed});var qi=c((cS,gi)=>{var R=m(),Qe=P(),tn=p(),td=E(),nd=w(),mi=Ge(),pi=I(),Xe=Ne(),rd=Po(),sd=Jo(),od=Yo(),id=Lo(),ud=Ko(),ad=Ho(),cd=Xo(),ld=ei(),fd=ri(),hd=oi(),md=ui(),pd=li(),dd=hi(),_e=x(),gd=se(),di=Symbol.for("@jrc03c/js-math-tools/series");gi.exports=function(e){class t{static[Symbol.hasInstance](r){try{return!!r._symbol&&r._symbol===di}catch{return!1}}constructor(r){let s=this;if(s.name="data",Object.defineProperty(s,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:di}),Object.defineProperty(s,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(s,"values",{configurable:!0,enumerable:!0,get(){return s._values},set(o){R(tn(o),"The new values must be a 1-dimensional array!");let i=_e(o);R(i.length===1,"The new array of values must be 1-dimensional!"),i[0]<s._index.length?s._index=s._index.slice(0,i[0]):i[0]>s._index.length&&(s._index=s._index.concat(pi(s._index.length,i[0]).map(u=>"item"+mi(u,(o.length-1).toString().length)))),s._values=o}}),Object.defineProperty(s,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(s,"index",{configurable:!0,enumerable:!0,get(){return s._index},set(o){R(tn(o),"The new index must be a 1-dimensional array of strings!"),R(o.length===s.shape[0],"The new index must be the same length as the old index!"),R(_e(o).length===1,"The new index must be a 1-dimensional array of strings!"),o.forEach(i=>{R(td(i),"All of the row names must be strings!")}),s._index=o}}),r){if(r instanceof t)s.name=r.name,s.values=Qe(r.values),s.index=Qe(r.index);else if(tn(r)){let o=_e(r);R(o.length===1,"When passing an array into the constructor of a Series, the array must be 1-dimensional!"),s.values=r}else if(r instanceof Object){let o=Object.keys(r);R(o.length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");let i=o[0],u=r[i];R(_e(u).length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!"),s.name=i,s.values=u.slice()}}}get shape(){return _e(this.values)}get length(){return this.shape[0]}get isEmpty(){return this.values.filter(s=>!nd(s)).length===0}clear(){let s=this.copy();return s.values.forEach((o,i)=>{s.values[i]=void 0}),s}get(r){return ad(this,r)}getSubsetByNames(r){return ld(t,this,r)}getSubsetByIndices(r){return cd(this,r)}loc(r){return this.getSubsetByNames(r)}iloc(r){return this.getSubsetByIndices(r)}reverse(){let r=this,s=new t(Xe(r.values));return s.index=Xe(r.index),s.name=r.name,s}resetIndex(){let r=this,s=r.copy();return s.index=pi(0,r.shape[0]).map(o=>"item"+mi(o,(s.index.length-1).toString().length)),s}copy(){let r=this,s=new t;return s._values=Qe(r.values),s._index=Qe(r.index),s.name=r.name,s}append(r){return rd(t,this,r)}apply(r){return sd(this,r)}concat(r){return this.append(r)}dropMissing(r,s){return od(this,r,s)}dropNaN(){return id(t,this)}toObject(){return dd(this)}print(){return fd(this)}shuffle(){return hd(this)}sort(r){return md(t,this,r)}sortByIndex(){return pd(t,this)}filter(r){return ud(t,this,r)}toDataFrame(){let r=this,s=new e(gd([r.values]));return s.columns=[r.name],s.index=r.index,s}transpose(){let s=this.copy();return s.values=Xe(s.values),s.index=Xe(s.index),s}getDummies(){return this.toDataFrame().getDummies()}oneHotEncode(){return this.getDummies()}}return t}});var Ee=c((lS,Si)=>{var J=m(),nn=P(),yi=ke(),qd=Gr(),yd=Xr(),Nd=ns(),wd=ss(),bd=fs(),vd=ps(),Sd=ys(),xd=vs(),Od=Es(),Td=Rt(),Fd=js(),Ni=Us(),_d=Gs(),Dd=Xs(),Ed=eo(),Ad=ro(),Md=bo(),jd=To(),Id=Do(),Cd=Wt(),kd=Ao(),zd=Xt(),Vd=jo(),Ud=T(),De=p(),Pd=$(),wi=w(),rn=Ge(),Bd=L(),sn=I(),ce=x(),bi=se(),vi=Symbol.for("@jrc03c/js-math-tools/dataframe");function Ze(e){let t="abcdefghijklmnopqrstuvwxyz1234567890",n="";for(let r=0;r<e;r++)n+=t[parseInt(Math.random()*t.length)];return n}var F=class{static[Symbol.hasInstance](t){try{return!!t._symbol&&t._symbol===vi}catch{return!1}}constructor(t){let n=this;if(Object.defineProperty(n,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:vi}),Object.defineProperty(n,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(n,"values",{configurable:!0,enumerable:!0,get(){return n._values.length===0||!wi(n._values[0])&&n._values[0].length===0?[[]]:n._values},set(r){J(De(r),"The new values must be a 2-dimensional array!");let s=ce(r);J(s.length===2,"The new array of values must be 2-dimensional!"),s[0]<n._index.length?n._index=n._index.slice(0,s[0]):s[0]>n._index.length&&(n._index=n._index.concat(sn(n._index.length,s[0]).map(o=>"row"+rn(o,(s[0]-1).toString().length)))),s[1]<n._columns.length?n._columns=n._columns.slice(0,s[1]):s[1]>n._columns.length&&(n._columns=n._columns.concat(sn(n._columns.length,s[1]).map(o=>"col"+rn(o,(s[1]-1).toString().length)))),n._values=r}}),Object.defineProperty(n,"_columns",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(n,"columns",{configurable:!0,enumerable:!0,get(){return n._columns},set(r){J(De(r),"The new columns list must be a 1-dimensional array of strings!"),J(n.isEmpty||r.length===n.shape[1],"The new columns list must be the same length as the old columns list!"),J(ce(r).length===1,"The new columns list must be a 1-dimensional array of strings!"),r=r.map(o=>(typeof o!="string"&&(o=JSON.stringify(o)||o.toString()),o.trim().length===0?"untitled_"+Ze(8):o.trim()));let s=(()=>{let o=yi(r),i={};return o.forEach(u=>{i[u.item]=u.count}),i})();r=r.map(o=>s[o]>1?o+"_"+Ze(8):o),n._columns=r}}),Object.defineProperty(n,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(n,"index",{configurable:!0,enumerable:!0,get(){return n._index},set(r){J(De(r),"The new index must be a 1-dimensional array of strings!"),J(n.isEmpty||r.length===n.shape[0],"The new index must be the same length as the old index!"),J(ce(r).length===1,"The new index must be a 1-dimensional array of strings!"),r=r.map(o=>(typeof o!="string"&&(o=JSON.stringify(o)||o.toString()),o.trim().length===0?"untitled_"+Ze(8):o.trim()));let s=(()=>{let o=yi(r),i={};return o.forEach(u=>{i[u.item]=u.count}),i})();r=r.map(o=>s[o]>1?o+"_"+Ze(8):o),n._index=r}}),J(wi(t)||Pd(t)||De(t),"The `data` passed into the constructor of a DataFrame must be either (1) an object where the key-value pairs are (respectively) column names and 1-dimensional arrays of values, or (2) a 2-dimensional array of values."),t)if(t instanceof F)n.values=nn(t.values),n.columns=nn(t.columns),n.index=nn(t.index);else if(De(t)){let r=ce(t);J(r.length===2,"The `data` array passed into the constructor of a DataFrame must be 2-dimensional!"),n.values=t}else{n._columns=Object.keys(t);let r=[];n._columns.forEach(o=>{let i=t[o];r.push(i)}),n._values=bi(r);let s=ce(n.values);n._index=sn(0,s[0]).map(o=>"row"+rn(o,(s[0]-1).toString().length))}}get shape(){return ce(this.values)}get length(){return this.shape[0]}get width(){return this.shape[1]}get rows(){return this.index}set rows(t){let n=this;n.index=t}get isEmpty(){return Ud(this.values).length===0}clear(){let t=this,n=new F(Bd(t.shape));return n.columns=t.columns.slice(),n.index=t.index.slice(),n}get(t,n){let r=this;if(arguments.length===0)return r;if(arguments.length===1)try{return r.get(null,t)}catch{return r.get(t,null)}return Fd(r,t,n)}getSubsetByNames(t,n){return Dd(F,Z,this,t,n)}getSubsetByIndices(t,n){return _d(this,t,n)}getDummies(t){return Ni(F,this,t)}oneHotEncode(t){return Ni(F,this,t)}transpose(){let t=this,n=new F(bi(t.values));return n.columns=t.index.slice(),n.index=t.columns.slice(),n}get T(){return this.transpose()}resetIndex(t){return Ad(this,t)}copy(){return wd(F,this)}assign(t,n){return Nd(F,Z,this,t,n)}apply(t,n){return yd(F,Z,this,t,n)}dropMissing(t,n,r){return vd(F,Z,this,t,n,r)}dropNaN(t,n,r){return Sd(F,this,t,n,r)}drop(t,n){return bd(F,Z,this,t,n)}dropColumns(t){return this.drop(null,t)}dropRows(t){return this.drop(t,null)}toObject(t){return Vd(this,t)}toCSVString(t){return Cd(this,t)}saveAsCSV(t,n){return Id(this,t,n)}toJSONString(t){return zd(this,t)}saveAsJSON(t,n){return kd(this,t,n)}print(){return Ed(F,Z,this)}sort(t,n){return jd(this,t,n)}sortByIndex(){return this.sort()}filter(t,n){return xd(F,Z,this,t,n)}shuffle(t){return Md(this,t)}append(t,n){return qd(this,t,n)}concat(t,n){return this.append(t,n)}join(t,n){return this.append(t,n)}toString(){let t=this;return JSON.stringify(t)}};F.fromCSV=function(){return Od(F,...arguments)};F.fromCSVString=function(){return Td(F,...arguments)};var Z=qi()(F);Si.exports={DataFrame:F,Series:Z}});var S=c((fS,_i)=>{var{DataFrame:xi,Series:Oi}=Ee(),Ti=m(),Ae=p(),on=N(),Fi=B(),Jd=M(),un=y(),Rd=re(),Yd=I(),et=x();function $d(e){return Ae(e)||un(e)||on(e)}function Ld(e){return Ti(Jd(e),"You must pass a function into the `vectorize` function!"),function t(){let n,r,s=[],o=[],i=Object.keys(arguments).filter(u=>{let a=arguments[u];return Ae(a)?!0:un(a)?(n=!0,s.push(a),!0):on(a)?(r=!0,o.push(a),!0):!1}).map(u=>arguments[u]);if(i.slice(0,-1).forEach((u,a)=>{Ti(Fi(Ae(u)?et(u):u.shape,Ae(i[a+1])?et(i[a+1]):i[a+1].shape),`When passing multiple arrays into the \`${e.name}\` function, all of the arrays must have the same shape!`)}),i.length>0){let u=Rd(i.map(l=>l.length?l.length:l.values.length)),a=Yd(0,u).map(l=>{let f=Object.keys(arguments).map(h=>{if($d(arguments[h])){if(Ae(arguments[h]))return arguments[h][l];if(un(arguments[h]))return arguments[h].values[l];if(on(arguments[h]))return arguments[h].values[l]}else return arguments[h]});return t(...f)});if(r)try{if(o.length===1&&Fi(et(o[0]),et(a))){let l=new xi(a);return l.index=o[0].index.slice(),l.columns=o[0].columns.slice(),l}else return new xi(a)}catch{return a}if(n)try{if(s.length===1&&s[0].length===a.length){let l=new Oi(a);return l.name=s[0].name,l.index=s[0].index.slice(),l}else return new Oi(a)}catch{return a}return a}else return e(...arguments)}}_i.exports=Ld});var tt=c((hS,Di)=>{var Gd=q(),Kd=S();function Wd(e){try{return Gd(e)?Math.abs(e):NaN}catch{return NaN}}Di.exports=Kd(Wd)});var nt=c((mS,Ei)=>{var Hd=q(),Qd=S();function Xd(){try{let e=0,t=Object.values(arguments);for(let n=0;n<t.length;n++){if(!Hd(t[n]))return NaN;e+=t[n]}return e}catch{return NaN}}Ei.exports=Qd(Xd)});var rt=c((pS,Ai)=>{var Zd=S();function eg(e,t){try{return t(e)}catch{return NaN}}Ai.exports=Zd(eg)});var ji=c((dS,Mi)=>{var tg=q(),ng=S();function rg(e){try{return tg(e)?Math.acos(e):NaN}catch{return NaN}}Mi.exports=ng(rg)});var Ci=c((gS,Ii)=>{var sg=q(),og=S();function ig(e){try{return sg(e)?Math.asin(e):NaN}catch{return NaN}}Ii.exports=og(ig)});var zi=c((qS,ki)=>{var ug=q(),ag=S();function cg(e){try{return ug(e)?Math.atan(e):NaN}catch{return NaN}}ki.exports=ag(cg)});var Ui=c((yS,Vi)=>{var lg=m(),fg=ge(),hg=p(),mg=N(),pg=y(),dg=re();function an(e){if(mg(e)){let t=an(e.values);return[e.index[t[0]],e.columns[t[1]]]}if(pg(e)){let t=an(e.values);return[e.index[t]]}lg(hg(e),"The `argmax` function only works on arrays, Series, and DataFrames!");try{let t=fg(e,dg(e));return t?t.length===0?void 0:t.length===1?t[0]:t:void 0}catch{return}}Vi.exports=an});var st=c((NS,Bi)=>{var gg=m(),qg=T(),yg=p(),Ng=N(),wg=y();function Pi(e){if(Ng(e)||wg(e))return Pi(e.values);gg(yg(e),"The `min` function only works on arrays, Series, and DataFrames!");try{return Math.min(...qg(e))}catch{return NaN}}Bi.exports=Pi});var Ri=c((wS,Ji)=>{var bg=m(),vg=ge(),Sg=p(),xg=N(),Og=y(),Tg=st();function cn(e){if(xg(e)){let t=cn(e.values);return[e.index[t[0]],e.columns[t[1]]]}if(Og(e)){let t=cn(e.values);return[e.index[t]]}bg(Sg(e),"The `argmin` function only works on arrays, Series, and DataFrames!");try{let t=vg(e,Tg(e));return t?t.length===0?void 0:t.length===1?t[0]:t:void 0}catch{return}}Ji.exports=cn});var $i=c((bS,Yi)=>{var Fg=q(),_g=S();function Dg(e){try{return Fg(e)?Math.ceil(e):NaN}catch{return NaN}}Yi.exports=_g(Dg)});var Ki=c((vS,Gi)=>{var Eg=tt(),Li=q(),Ag=w(),Mg=S();function jg(e,t){try{if(!Li(e))return NaN;if(Ag(t))t=1e-10;else if(!Li(t))return NaN;return Eg(e)<t?0:e}catch{return NaN}}Gi.exports=Mg(jg)});var Hi=c((SS,Wi)=>{var ln=q(),Ig=S();function Cg(e,t,n){try{return ln(e)?ln(t)?ln(n)?e<t?t:e>n?n:e:NaN:NaN:NaN}catch{return NaN}}Wi.exports=Ig(Cg)});var Xi=c((xS,Qi)=>{var fn=m(),kg=T(),zg=p(),Vg=N(),Ug=q(),Pg=y();function hn(e,t){if(Vg(e)||Pg(e))return hn(e.values,t);if(fn(zg(e),"The `combinations` function only works on arrays, Series, and DataFrames!"),fn(Ug(t),"`r` must be a whole number!"),e=kg(e),t>e.length)return[e];if(t<=0)return[[]];if(fn(t===parseInt(t),"`r` must be a whole number!"),e.length<2)return e;let n=[];return e.forEach((r,s)=>{let o=e.slice(s+1);if(o.length<t-1)return;hn(o,t-1).forEach(u=>{n.push([r].concat(u))})}),n}Qi.exports=hn});var ot=c((OS,eu)=>{var Bg=m(),Jg=T(),Rg=p(),Yg=N(),$g=y();function Zi(e){if(Yg(e)||$g(e))return Zi(e.values);Bg(Rg(e),"The `mean` function only works on arrays, Series, and DataFrames!");try{let t=Jg(e),n=0;return t.forEach(r=>{n+=r}),n/t.length}catch{return NaN}}eu.exports=Zi});var pn=c((TS,iu)=>{var tu=m(),nu=p(),it=q(),ru=y(),su=ot(),ou=x();function mn(e,t){if(ru(e))return mn(e.values,t);if(ru(t))return mn(e,t.values);tu(nu(e)&&nu(t)&&ou(e).length===1&&ou(t).length===1,"The `covariance` function only works on 1-dimensional arrays and Series!"),tu(e.length===t.length,"The two arrays or Series passed into the `covariance` function must have the same length!");try{let n=su(e),r=su(t);if(!it(n)||!it(r))return NaN;let s=Math.max(e.length,t.length),o=0;for(let i=0;i<s;i++){if(!it(e[i]))return NaN;if(!it(t[i]))return NaN;o+=(e[i]-n)*(t[i]-r)}return o/e.length}catch{return NaN}}iu.exports=mn});var ut=c((FS,uu)=>{var Lg=q(),Gg=S();function Kg(e){try{return Lg(e)?Math.sqrt(e):NaN}catch{return NaN}}uu.exports=Gg(Kg)});var dn=c((_S,cu)=>{var Wg=m(),Hg=T(),Qg=p(),Xg=N(),Zg=q(),eq=y(),tq=ot();function au(e){if(Xg(e)||eq(e))return au(e.values);Wg(Qg(e),"The `variance` function only works on arrays, Series, and DataFrames!");try{let t=Hg(e),n=tq(t),r=0;for(let s=0;s<t.length;s++){if(!Zg(t[s]))return NaN;r+=(t[s]-n)*(t[s]-n)}return r/t.length}catch{return NaN}}cu.exports=au});var at=c((DS,fu)=>{var nq=m(),rq=p(),sq=N(),oq=y(),iq=ut(),uq=dn();function lu(e){if(sq(e)||oq(e))return lu(e.values);nq(rq(e),"The `std` function only works on arrays, Series, and DataFrames!");try{return iq(uq(e))}catch{return NaN}}fu.exports=lu});var yu=c((ES,qu)=>{var hu=m(),aq=pn(),mu=p(),pu=y(),du=x(),gu=at();function gn(e,t){if(pu(e))return gn(e.values,t);if(pu(t))return gn(e,t.values);hu(mu(e)&&mu(t)&&du(e).length===1&&du(t).length===1,"The `correl` function only works on 1-dimensional arrays and Series!"),hu(e.length===t.length,"The two arrays or Series passed into the `correl` function must have the same length!");try{return aq(e,t)/(gu(e)*gu(t))}catch{return NaN}}qu.exports=gn});var wu=c((AS,Nu)=>{var cq=q(),lq=S();function fq(e){try{return cq(e)?Math.cos(e):NaN}catch{return NaN}}Nu.exports=lq(fq)});var Tu=c((MS,Ou)=>{var hq=m(),bu=p(),vu=N(),mq=B(),Su=y(),xu=V();function qn(e,t){if(vu(e)||Su(e))return qn(e.values,t);if(vu(t)||Su(t))return qn(e,t.values);hq(bu(e)&&bu(t),"The `diff` function only works on arrays, Series, and DataFrames!");let n=xu(e),r=xu(t),s=[];return n.forEach(o=>{r.findIndex(i=>mq(i,o))<0&&s.push(o)}),s}Ou.exports=qn});var ct=c((jS,_u)=>{var Fu=q(),pq=S();function dq(e,t){try{return Fu(e)?Fu(t)?Math.pow(e,t):NaN:NaN}catch{return NaN}}_u.exports=pq(dq)});var yn=c((IS,Du)=>{var gq=q(),qq=S();function yq(){try{let e=Object.values(arguments);if(e.length===0)return NaN;let t=1;for(let n=0;n<e.length;n++){if(!gq(e[n]))return NaN;t*=e[n]}return t}catch{return NaN}}Du.exports=qq(yq)});var le=c((CS,Eu)=>{var Nq=yn();function wq(){return Nq(...arguments)}Eu.exports=wq});var Nn=c((kS,Au)=>{var bq=nt(),vq=le();function Sq(e,t){return bq(e,vq(t,-1))}Au.exports=Sq});var lt=c((zS,ju)=>{var xq=m(),Oq=T(),Tq=p(),Fq=N(),_q=y();function Mu(e){if(Fq(e)||_q(e))return Mu(e.values);xq(Tq(e),"The `sum` function only works on arrays, Series, and DataFrames!");try{return e.length===0?NaN:Oq(e).reduce((t,n)=>t+n,0)}catch{return NaN}}ju.exports=Mu});var Pu=c((VS,Uu)=>{var Dq=tt(),Eq=m(),Iu=p(),Cu=N(),Aq=B(),ku=q(),zu=y(),Mq=ct(),Vu=x(),jq=ut(),Iq=Nn(),Cq=lt();function wn(e,t){if(ku(e)&&ku(t))return Dq(e-t);if(Cu(e)||zu(e))return wn(e.values,t);if(Cu(t)||zu(t))return wn(e,t.values);Iu(e)&&Iu(t)&&Eq(Aq(Vu(e),Vu(t)),"If passing two arrays, Series, or DataFrames into the `distance` function, then those objects must have the same shape!");try{return jq(Cq(Mq(Iq(e,t),2)))}catch{return NaN}}Uu.exports=wn});var Ju=c((US,Bu)=>{var kq=ct(),zq=le();function Vq(e,t){return zq(e,kq(t,-1))}Bu.exports=Vq});var vn=c((PS,Ku)=>{var{DataFrame:Ru,Series:Yu}=Ee(),ft=m(),$u=T(),Lu=p(),bn=N(),Uq=q(),ht=y(),Pq=le(),mt=x(),Bq=lt(),Gu=se();function ee(e,t){if(bn(e)){let s=ee(e.values,t);if(mt(s).length===1){let o=new Yu(s);return o.name=ht(t)?t.name:o.name,o.index=e.index.slice(),o}else{let o=new Ru(s);return o.index=e.index.slice(),bn(t)&&(o.columns=t.columns.slice()),o}}if(bn(t)){let s=ee(e,t.values);if(mt(s).length===1){let o=new Yu(s);return o.name=ht(e)?e.name:o.name,o.index=t.columns.slice(),o}else{let o=new Ru(s);return o.columns=t.columns.slice(),o}}if(ht(e))return ee(e.values,t);if(ht(t))return ee(e,t.values);ft(Lu(e)&&Lu(t),"The `dot` function only works on arrays, Series, and DataFrames!"),$u(e).concat($u(t)).forEach(s=>{ft(Uq(s),"One of the arrays you passed into the `dot` function contains non-numerical values!")});let n=mt(e),r=mt(t);if(ft(n.length<=2&&r.length<=2,"I'm not smart enough to know how to get the dot-product of arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `dot` function!"),ft(n[n.length-1]===r[0],`There's a dimension misalignment in the two arrays you passed into the \`dot\` function. (${n[n.length-1]} !== ${r[0]})`),n.length===1&&r.length===1)return Bq(Pq(e,t));if(n.length===1&&r.length===2)return Gu(t).map(s=>ee(e,s));if(n.length===2&&r.length===1)return e.map(s=>ee(s,t));if(n.length===2&&r.length===2){let s=Gu(t),o=[];for(let i=0;i<e.length;i++){let u=[];for(let a=0;a<s.length;a++)u.push(ee(e[i],s[a]));o.push(u)}return o}}Ku.exports=ee});var Sn=c((BS,Hu)=>{var Jq=m(),Rq=p(),Yq=N(),$q=y(),Lq=w();function Wu(e){if(Yq(e)||$q(e))return e.dropMissing(...Object.values(arguments).slice(1));Jq(Rq(e),"The `dropMissing` function only works on arrays, Series, and DataFrames!");let t=[];return e.forEach(n=>{try{return t.push(Wu(n))}catch{Lq(n)||t.push(n)}}),t}Hu.exports=Wu});var sa=c((JS,ra)=>{var Qu=m(),Xu=p(),Zu=N(),Gq=B(),ea=y(),ta=w(),na=x();function pt(e,t){if(Zu(e)||ea(e))return pt(e.values,t);if(Zu(t)||ea(t))return pt(e,t.values);Qu(Xu(e)&&Xu(t),"The `dropMissingPairwise` function only works on arrays, Series, and DataFrames!"),Qu(Gq(na(e),na(t)),"The two arrays, Series, and/or DataFrames passed into the `dropMissingPairwise` function must have the same shape!");let n=[],r=[];for(let s=0;s<e.length;s++)try{let[o,i]=pt(e[s],t[s]);n.push(o),r.push(i)}catch{!ta(e[s])&&!ta(t[s])&&(n.push(e[s]),r.push(t[s]))}return[n,r]}ra.exports=pt});var ha=c((RS,fa)=>{var oa=m(),ia=p(),ua=N(),Kq=B(),aa=q(),ca=y(),la=x();function dt(e,t){if(ua(e)||ca(e))return dt(e.values,t);if(ua(t)||ca(t))return dt(e,t.values);oa(ia(e)&&ia(t),"The `dropNaNPairwise` only works on arrays, Series, and DataFrames!"),oa(Kq(la(e),la(t)),"The two arrays, Series, and/or DataFrames passed into the `dropNaNPairwise` must have the same shape!");let n=[],r=[];for(let s=0;s<e.length;s++)try{let[o,i]=dt(e[s],t[s]);n.push(o),r.push(i)}catch{aa(e[s])&&aa(t[s])&&(n.push(e[s]),r.push(t[s]))}return[n,r]}fa.exports=dt});var pa=c((YS,ma)=>{var Wq=Sn();function Hq(e){return Wq(e)}ma.exports=Hq});var ga=c(($S,da)=>{var Qq=q(),Xq=S();function Zq(e){try{return Qq(e)?Math.exp(e):NaN}catch{return NaN}}da.exports=Xq(Zq)});var Na=c((LS,ya)=>{var ey=S();function qa(e){try{return e!==parseInt(e)?NaN:e<=1?1:e*qa(e-1)}catch{return NaN}}ya.exports=ey(qa)});var Sa=c((GS,va)=>{var ty=m(),ny=T(),wa=p(),ry=N(),sy=M(),ba=$(),oy=y();function xn(e,t){if(ry(e))return xn(ny(e.values),t);if(oy(e))return xn(e.values,t);if(ty(ba(e)||wa(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `find` function!"),!sy(t)){let s=t;t=o=>o===s}function n(s,o,i){if(i=i||[],i.indexOf(s)>-1)return null;if(ba(s)){i.push(s);let u=Object.keys(s);for(let a=0;a<u.length;a++){let l=u[a],f=s[l];if(o(f))return f;let h=n(f,o,i);if(h)return h}}else if(wa(s)){i.push(s);for(let u=0;u<s.length;u++){let a=s[u];if(o(a))return a;let l=n(a,o,i);if(l)return l}}else if(o(s))return s;return null}function r(s){try{return t(s)}catch{return!1}}return n(e,r)}va.exports=xn});var Fa=c((KS,Ta)=>{var iy=m(),uy=T(),xa=p(),ay=N(),cy=M(),Oa=$(),ly=y();function On(e,t){if(ay(e))return On(uy(e.values),t);if(ly(e))return On(e.values,t);if(iy(Oa(e)||xa(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `findAll` function!"),!cy(t)){let o=t;t=i=>i===o}function n(o,i,u){if(u=u||[],u.indexOf(o)>-1)return null;if(Oa(o)){u.push(o);let a=Object.keys(o),l=[];for(let f=0;f<a.length;f++){let h=a[f],d=o[h],g=!1;i(d)&&(l.push(d),g=!0);let v=n(d,i,u);v&&v.length>0&&v.slice(g?1:0).forEach(b=>l.push(b))}return l}else if(xa(o)){u.push(o);let a=[];for(let l=0;l<o.length;l++){let f=o[l],h=!1;i(f)&&(a.push(f),h=!0);let d=n(f,i,u);d&&d.length>0&&d.slice(h?1:0).forEach(g=>a.push(g))}return a}else if(i(o))return[o];return null}function r(o){try{return t(o)}catch{return!1}}let s=n(e,r);return s&&s.length>0?s:null}Ta.exports=On});var Da=c((WS,_a)=>{var fy=q(),hy=S();function my(e){try{if(e==="Infinity")return 1/0;if(e==="-Infinity")return-1/0;let t=JSON.parse(e);return fy(t)?t:NaN}catch{return NaN}}_a.exports=hy(my)});var Aa=c((HS,Ea)=>{var py=q(),dy=S();function gy(e){try{return py(e)?Math.floor(e):NaN}catch{return NaN}}Ea.exports=dy(gy)});var Tn=c((QS,Ma)=>{var qy=q(),yy=xe(),Ny=Ke();function wy(e){qy(e)&&(e=[e]);let t=[],n=yy(e);for(let r=0;r<n;r++)t.push(0);return Ny(t,e)}Ma.exports=wy});var Ia=c((XS,ja)=>{var gt=m(),by=q(),vy=w(),Sy=Tn();function xy(e){gt(!vy(e),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),gt(by(e),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),gt(parseInt(e)===e,"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),gt(e>0,"You must pass an integer greater than 0 (representing the size) into the `identity` function!");let t=Sy([e,e]);for(let n=0;n<e;n++)t[n][n]=1;return t}ja.exports=xy});var ka=c((ZS,Ca)=>{var Oy=q(),Ty=S();function Fy(e){try{let t=JSON.parse(e);return Oy(t)?parseInt(t):NaN}catch{return NaN}}Ca.exports=Ty(Fy)});var Va=c((e2,za)=>{var _y=m(),Dy=p(),Ey=N(),Ay=B(),My=y(),Fn=V();function jy(){let e=Object.values(arguments).map(n=>Ey(n)||My(n)?Fn(n.values):(_y(Dy(n),"The `intersect` function only works on arrays, Series, and DataFrames!"),Fn(n)));return Fn(e).filter(n=>e.every(r=>r.findIndex(s=>Ay(s,n))>-1))}za.exports=jy});var Ja=c((t2,Ba)=>{var Ua=nt(),te=m(),Iy=vn(),Cy=T(),ky=p(),zy=N(),_n=q(),Pa=le(),Vy=x();function qt(e){if(zy(e)){let n=e.copy();return n.values=qt(n.values),n}te(ky(e),"The `inverse` function only works on square 2-dimensional arrays or DataFrames!"),Cy(e).forEach(n=>te(_n(n),"The array passed into the `inverse` function must contain only numbers!"));let t=Vy(e);if(te(t.length===2,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),te(t[0]===t[1],"The array passed into the `inverse` function must be exactly two-dimensional and square!"),te(t[0]>=0,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),t[0]===0)return e;if(t[0]===1)return te(e[0][0]!==0,"This matrix cannot be inverted!"),1/e[0][0];if(t[0]===2){let n=e[0][0],r=e[0][1],s=e[1][0],o=e[1][1],i=n*o-r*s;te(i!==0,"This matrix cannot be inverted!");let u=[[o,-r],[-s,n]];return Pa(u,1/i)}else if(t[0]>1){let n=(r,s)=>_n(r)||_n(s)?Pa(r,s):Iy(r,s);for(let r=1;r<t[0]-1;r++)try{let s=e.slice(0,r).map(b=>b.slice(0,r)),o=e.slice(0,r).map(b=>b.slice(r,t[0])),i=e.slice(r,t[0]).map(b=>b.slice(0,r)),u=e.slice(r,t[0]).map(b=>b.slice(r,t[0])),a=qt(s),l=qt(Ua(u,n(-1,n(n(i,a),o)))),f=Ua(a,n(n(n(n(a,o),l),i),a)),h=n(-1,n(n(a,o),l)),d=n(-1,n(n(l,i),a)),g=l;return f.map((b,D)=>b.concat(h[D])).concat(d.map((b,D)=>b.concat(g[D])))}catch{}te(!1,"This matrix cannot be inverted!")}}Ba.exports=qt});var Ya=c((n2,Ra)=>{var Dn=q(),Uy=S();function Py(e,t,n){try{return Dn(e)?Dn(t)?Dn(n)?n*(t-e)+e:NaN:NaN:NaN}catch{return NaN}}Ra.exports=Uy(Py)});var Ga=c((r2,La)=>{var $a=q(),By=w(),Jy=S();function Ry(e,t){try{return t=By(t)?Math.E:t,$a(e)?$a(t)?Math.log(e)/Math.log(t):NaN:NaN}catch{return NaN}}La.exports=Jy(Ry)});var Ha=c((s2,Wa)=>{var Yy=m(),$y=T(),Ly=p(),Gy=N(),Ky=y(),Wy=W();function Ka(e){if(Gy(e)||Ky(e))return Ka(e.values);Yy(Ly(e),"The `median` function only works on arrays, Series, and DataFrames!");try{let t=Wy($y(e));return t.length===0?NaN:t.length%2===0?(t[t.length/2-1]+t[t.length/2])/2:t[parseInt(t.length/2)]}catch{return NaN}}Wa.exports=Ka});var Za=c((o2,Xa)=>{var Qa=q(),Hy=S();function Qy(e,t){try{return Qa(e)?Qa(t)?e%t:NaN:NaN}catch{return NaN}}Xa.exports=Hy(Qy)});var rc=c((i2,nc)=>{var Xy=m(),Zy=ke(),e1=T(),t1=p(),n1=N(),r1=y(),s1=V(),ec=W();function tc(e){if(n1(e)||r1(e))return tc(e.values);Xy(t1(e),"The `mode` function only works on arrays, Series, and DataFrames!");try{if(e.length===0)return NaN;let t=e1(e);if(t.length===0)return NaN;let n={},r=s1(t);r.forEach(u=>{n[u]=Zy(t,u)});let s=ec(r,(u,a)=>n[a]-n[u]),o=s[0];return ec(s.filter(u=>n[u]===n[o]))}catch{return NaN}}nc.exports=tc});var uc=c((u2,ic)=>{var{random:sc}=ue(),o1=rt(),i1=w(),u1=L();function oc(){let e=sc(),t=sc();return Math.sqrt(-2*Math.log(e))*Math.cos(2*Math.PI*t)}function a1(e){return i1(e)?oc():o1(u1(e),oc)}ic.exports=a1});var cc=c((a2,ac)=>{var c1=rt(),l1=L();function f1(e){return c1(l1(e),()=>1)}ac.exports=f1});var fc=c((c2,lc)=>{var En=m(),h1=T(),m1=p(),p1=N(),d1=q(),g1=y(),q1=w();function yt(e,t){if(p1(e)||g1(e))return yt(e.values,t);if(En(m1(e),"The `permutations` function only works on arrays, Series, and DataFrames!"),q1(t)&&(t=e.length),En(d1(t),"`r` must be a whole number!"),e=h1(e),t>e.length)return yt(e);if(t<=0)return[[]];if(En(t===parseInt(t),"`r` must be a whole number!"),e.length<2)return e;let n=[];return e.forEach((r,s)=>{let o=e.slice(0,s),i=e.slice(s+1),u=o.concat(i);yt(u,t-1).forEach(l=>{n.push([r].concat(l))})}),n}lc.exports=yt});var mc=c((l2,hc)=>{var{DataFrame:y1,Series:N1}=Ee(),w1=p(),b1=N(),v1=ye(),S1=y(),x1=x();function O1(){Object.keys(arguments).forEach(e=>{let t=arguments[e];if(w1(t))if(v1(t))console.log(t);else{let n=x1(t);n.length===1?new N1(t).print():n.length==2?new y1(t).print():console.log(t)}else b1(t)||S1(t)?t.print():console.log(t)})}hc.exports=O1});var gc=c((f2,dc)=>{var T1=p(),F1=q(),pc=w(),_1=re(),D1=st(),E1=S(),A1=E1(function(e,t,n,r,s){try{return[e,t,n,r,s].every(o=>F1(o))?n-t===0?NaN:(s-r)*(e-t)/(n-t)+r:NaN}catch{return NaN}});function M1(e,t,n,r,s){return T1(e)&&pc(r)&&pc(s)&&(r=t,s=n,t=D1(e),n=_1(e)),A1(e,t,n,r,s)}dc.exports=M1});var yc=c((h2,qc)=>{var j1=q(),I1=S();function C1(e){try{return j1(e)?Math.round(e):NaN}catch{return NaN}}qc.exports=I1(C1)});var wc=c((m2,Nc)=>{var k1=q(),z1=S();function V1(e){try{return k1(e)?e<0?-1:e>0?1:0:NaN}catch{return NaN}}Nc.exports=z1(V1)});var vc=c((p2,bc)=>{var U1=q(),P1=S();function B1(e){try{return U1(e)?Math.sin(e):NaN}catch{return NaN}}bc.exports=P1(B1)});var xc=c((d2,Sc)=>{var J1=at();function R1(e){return J1(e)}Sc.exports=R1});var Tc=c((g2,Oc)=>{var Y1=q(),$1=S();function L1(e){try{return Y1(e)?Math.tan(e):NaN}catch{return NaN}}Oc.exports=$1(L1)});var Nt=c((q2,Dc)=>{var Fc=m(),_c=M();function G1(e,t){Fc(_c(e),"`fn` must be a function!");let n=new Date;return t?e(...t):e(),new Date-n}async function K1(e,t){Fc(_c(e),"`fn` must be a function!");let n=new Date;return t?await e(...t):await e(),new Date-n}Dc.exports={timeSync:G1,timeAsync:K1}});var Ac=c((y2,Ec)=>{var W1=p(),H1=N(),Q1=y(),X1=V();function Z1(){return X1([...arguments].map(e=>W1(e)?e:H1(e)||Q1(e)?e.values:[e]))}Ec.exports=Z1});var jc=c((N2,Mc)=>{var eN=m(),tN=p(),nN=N(),rN=y(),sN=w(),oN=re(),iN=I();function uN(){let e=[],t=Object.values(arguments).map(n=>((nN(n)||rN(n))&&(n=n.values),eN(tN(n),"The `zip` function only works on arrays, Series, and DataFrames!"),n));return iN(0,oN(t.map(n=>n.length))).forEach(n=>{let r=[];t.forEach(s=>{let o=s[n];r.push(sN(o)?void 0:o)}),e.push(r)}),e}Mc.exports=uN});var _=c((w2,An)=>{var{DataFrame:aN,Series:cN}=Ee(),fe={abs:tt(),add:nt(),apply:rt(),arccos:ji(),arcsin:Ci(),arctan:zi(),argmax:Ui(),argmin:Ri(),assert:m(),ceil:$i(),chop:Ki(),clamp:Hi(),combinations:Xi(),copy:P(),correl:yu(),cos:wu(),count:ke(),covariance:pn(),DataFrame:aN,diff:Tu(),distance:Pu(),divide:Ju(),dot:vn(),dropMissing:Sn(),dropMissingPairwise:sa(),dropNaN:Bt(),dropNaNPairwise:ha(),dropUndefined:pa(),exp:ga(),factorial:Na(),find:Sa(),findAll:Fa(),flatten:T(),float:Da(),floor:Aa(),identity:Ia(),indexOf:ge(),int:ka(),intersect:Va(),inverse:Ja(),isArray:p(),isBoolean:ve(),isDataFrame:N(),isEqual:B(),isFunction:M(),isJagged:ye(),isNested:ze(),isNumber:q(),isObject:$(),isSeries:y(),isString:E(),isUndefined:w(),lerp:Ya(),log:Ga(),MathError:U(),max:re(),mean:ot(),median:Ha(),min:st(),mod:Za(),mode:rc(),multiply:yn(),ndarray:L(),normal:uc(),ones:cc(),permutations:fc(),pow:ct(),print:mc(),product:xe(),random:ue().random,range:I(),remap:gc(),reshape:Ke(),reverse:Ne(),round:yc(),scale:le(),seed:ue().seed,Series:cN,set:V(),shape:x(),shuffle:We(),sign:wc(),sin:vc(),sort:W(),sqrt:ut(),std:at(),stdev:xc(),subtract:Nn(),sum:lt(),tan:Tc(),time:Nt().timeSync,timeSync:Nt().timeSync,timeAsync:Nt().timeAsync,transpose:se(),union:Ac(),variance:dn(),vectorize:S(),zeros:Tn(),zip:jc(),dump:function(){let e=typeof global<"u"?global:window;if(!e)throw new fe.MathError("Cannot dump functions into global scope because neither `global` nor `window` exist in the current context!");Object.keys(fe).forEach(t=>{try{Object.defineProperty(e,t,{configurable:!1,enumerable:!0,writable:!1,value:fe[t]})}catch{e[t]=fe[t]}})}};typeof An<"u"&&(An.exports=fe);typeof window<"u"&&(window.JSMathTools=fe)});var Y=c((b2,Ic)=>{Ic.exports={shouldIgnoreNaNValues:!0}});var he=c((v2,kc)=>{var{assert:lN,flatten:fN,isArray:hN,isDataFrame:mN,isNumber:pN,isSeries:dN}=_();function Cc(e){if(mN(e)||dN(e))return Cc(e.values);lN(hN(e),"The `containsOnlyNumbers` function only works on arrays, Series, and DataFrames!");let t=fN(e);for(let n=0;n<t.length;n++)if(!pN(t[n]))return!1;return!0}kc.exports=Cc});var jn=c((S2,zc)=>{var{dropMissing:gN,flatten:qN,isArray:yN,isDataFrame:NN,isSeries:wN}=_();function Mn(e){return typeof e=="number"?e===0||e===1:NN(e)||wN(e)?Mn(e.values):yN(e)?e.length===0?!1:gN(qN(e)).every(n=>Mn(n)):!1}zc.exports=Mn});var In=c((x2,Lc)=>{var{abs:Vc,apply:Uc,assert:Pc,clamp:bN,copy:vN,divide:SN,dropNaN:xN,flatten:ON,isArray:TN,isDataFrame:FN,isNumber:Bc,isSeries:_N,max:Jc,median:Rc,min:DN,sort:EN,subtract:Yc}=_(),AN=Y(),MN=he(),jN=jn();function $c(e,t){if(FN(e)||_N(e)){let a=e.copy();return a._values=$c(a._values,t),a}if(Pc(TN(e),"The `clipOutliers` function only works on arrays, Series, and DataFrames!"),t=t||5,Pc(Bc(t),"Any `maxScore` value passed into the `clipOutliers` function must be a number!"),!AN.shouldIgnoreNaNValues&&!MN(e))return Uc(e,()=>NaN);let n=ON(e),r=xN(n);if(jN(r)||r.length===0)return e;let s=Rc(r),o=Rc(Vc(Yc(r,s))),i=!1;if(o===0){let a=EN(vN(r)),l=a.filter(g=>g<s),f=a.filter(g=>g>s),h=s,d=s;if(l.length>0&&(h=Jc(l)),f.length>0&&(d=DN(f)),o=(d-h)/2,o===0)return e;i=(s-h)/o>t||(d-s)/o>t}return Jc(SN(Vc(Yc(r,s)),o))>t||i?Uc(e,a=>Bc(a)?bN(a,s-t*o,s+t*o):a):e}Lc.exports=$c});var kn=c((O2,el)=>{var{assert:Gc,dropNaN:Kc,isArray:Wc,isSeries:Hc,mean:Qc,shape:Xc,variance:Zc}=_(),IN=Y();function Cn(e,t){if(Hc(e))return Cn(e.values,t);if(Hc(t))return Cn(e,t.values);Gc(Wc(e)&&Wc(t)&&Xc(e).length===1&&Xc(t).length===1,"The `cohensd` function only works on 1-dimensional arrays and Series!"),Gc(e.length===t.length,"Two arrays or Series passed into the `cohensd` function must have the same length!"),IN.shouldIgnoreNaNValues&&(e=Kc(e),t=Kc(t));try{let n=Qc(e),r=Qc(t),s=Math.sqrt((Zc(e)+Zc(t))/2);return(n-r)/s}catch{return NaN}}el.exports=Cn});var sl=c((T2,rl)=>{var{assert:tl,DataFrame:CN,isArray:kN,isSeries:zN,shape:VN,zeros:UN}=_();function nl(e){if(zN(e)){let r=new CN(nl(e.values));return r.index=e.index.slice(),r.columns=e.index.slice(),r}tl(kN(e),"The `diagonalize` function only works on 1-dimensional arrays and Series!");let t=VN(e);tl(t.length===1,"The `diagonalize` function only works on 1-dimensional arrays and Series!");let n=UN([t[0],t[0]]);return e.forEach((r,s)=>n[s][s]=r),n}rl.exports=nl});var Pn=c((F2,al)=>{var{assert:zn,clamp:PN,correl:ol,DataFrame:wt,dropNaNPairwise:BN,isArray:il,isDataFrame:bt,isJagged:ul,isUndefined:JN,ndarray:RN}=_(),YN=Y();function Vn(e){let t="@jrc03c/js-data-science-helpers/get-correlation-matrix";return Object.defineProperty(e,t,{configurable:!1,enumerable:!1,writable:!1,value:Symbol.for(t)}),e}function Un(e,t){if(JN(t)&&(t=e),bt(e)){let r=new wt(Un(e.values,t));return r.index=e.columns.slice(),r.columns=bt(t)?t.columns.slice():new wt(t).columns.slice(),Vn(r)}if(bt(t)){let r=new wt(Un(e,t.values));return r.index=bt(e)?e.columns.slice():new wt(e).columns.slice(),r.columns=t.columns.slice(),Vn(r)}zn(il(e)&&il(t),"The `getCorrelationMatrix` function only works on 2-dimensional arrays and DataFrames!"),zn(!ul(e)&&!ul(t),"The `getCorrelationMatrix` function only works on non-jagged 2-dimensional arrays and DataFrames!"),zn(e.length===t.length,'The dimensions of the matrices you passed into the `getCorrelationMatrix` function aren\'t compatible! ([shape(a).join(", ")] vs. [shape(b).join(", ")]) The function expects that you\'ll be comparing the columns of two matrices where the columns are all of the same length, so please make sure that the matrices are oriented accordingly.');let n=RN([e[0].length,t[0].length]);for(let r=0;r<e[0].length;r++){let s=e.map(o=>o[r]);for(let o=0;o<t[0].length;o++){let i=t.map(u=>u[o]);YN.shouldIgnoreNaNValues?n[r][o]=ol(...BN(s,i)):n[r][o]=ol(s,i)}}return Vn(PN(n,-1,1))}al.exports=Un});var Bn=c((_2,cl)=>{function $N(e){try{let t="@jrc03c/js-data-science-helpers/get-correlation-matrix";return e[t]===Symbol.for(t)}catch{return!1}}cl.exports=$N});var ml=c((D2,hl)=>{var{DataFrame:Jn,isArray:LN,isDataFrame:vt,isNumber:ll,MathError:GN,sort:KN}=_(),fl=Pn(),WN=Bn();function HN(e,t,n){n=Object.values(arguments).find(o=>ll(o))||1-1e-5;let r=(()=>{let o=Object.values(arguments).filter(i=>LN(i)||vt(i));if(o.length===1){let i=o[0];if(WN(i))return vt(i)?i:new Jn(i);{let u=fl(i,null);return vt(u)?u:new Jn(u)}}if(o.length===2){let i=fl(o[0],o[1]);return vt(i)?i:new Jn(i)}throw new GN("You must pass 1 or 2 2-dimensional arrays or DataFrames into the `getHighlyCorrelatedColumns` function!")})(),s={};return r.values.forEach((o,i)=>{o.forEach((u,a)=>{if(ll(u)&&u>n){let l=r.index[i],f=r.columns[a];s[l]||(s[l]=[]),s[l].indexOf(f)<0&&s[l].push(f),s[f]||(s[f]=[]),s[f].indexOf(l)<0&&s[f].push(l)}})}),Object.keys(s).forEach(o=>{s[o]=KN(s[o])}),s}hl.exports=HN});var Rn=c((E2,dl)=>{var{dropNaN:QN,isArray:XN,isDataFrame:ZN,isNumber:ew,isSeries:tw,pow:nw,sqrt:rw,sum:sw}=_(),ow=Y();function pl(e){return ZN(e)||tw(e)?pl(e.values):ew(e)?Math.abs(e):XN(e)?(ow.shouldIgnoreNaNValues&&(e=QN(e)),rw(sw(nw(e,2)))):NaN}dl.exports=pl});var Yn=c((A2,yl)=>{var{assert:gl,DataFrame:iw,isArray:uw,isSeries:aw,isString:cw,isUndefined:lw,set:fw,shape:hw,sort:mw}=_();function ql(){if(arguments.length===1&&aw(arguments[0])){let{name:o,values:i}=arguments[0],u=ql(o,i),a=new iw(u);return a.index=arguments[0].index.slice(),a}let[e,t]=arguments;gl(cw(e),"When passing two arguments into the `getOneHotEncodings` function, the first argument must be a string representing the name of the variable being encoded!"),gl(uw(t)&&hw(t).length===1,"When passing two arguments into the `getOneHotEncodings` function, the second argument must be a 1-dimensional array!");let n={},r=e+"_"+t[0];return mw(fw(t)).filter(o=>!lw(o)).map(o=>e+"_"+o).filter(o=>o!==r).forEach(o=>{n[o]=t.map(i=>o===e+"_"+i?1:0)}),n}yl.exports=ql});var wl=c((M2,Nl)=>{var{count:pw}=_();function dw(e){return pw(e).map(n=>(n.percentage=n.count/e.length,n))}Nl.exports=dw});var bl=c((j2,gw)=>{gw.exports=[.5,.49601,.49202,.48803,.48405,.48006,.47608,.4721,.46812,.46414,.46017,.4562,.45224,.44828,.44433,.44038,.4364,.43251,.42858,.42465,.42074,.41683,.41294,.40905,.40517,.40129,.39743,.39358,.38974,.38591,.38209,.37828,.37448,.3707,.36693,.36317,.35942,.35569,.35197,.34827,.34458,.3409,.33724,.3336,.32997,.32636,.32276,.31918,.31561,.31207,.30854,.30503,.30153,.29806,.2946,.29116,.28774,.28434,.28096,.2776,.27425,.27093,.26763,.26435,.26109,.25785,.25463,.25143,.24825,.2451,.24196,.23885,.23576,.2327,.22965,.22663,.22363,.22065,.2177,.21476,.21186,.20897,.20611,.20327,.20045,.19766,.19489,.19215,.18943,.18673,.18406,.18141,.17879,.17619,.17361,.17106,.16853,.16602,.16354,.16109,.15866,.15625,.15386,.15151,.14917,.14686,.14457,.14231,.14007,.13786,.13567,.1335,.13136,.12924,.12714,.12507,.12302,.121,.119,.11702,.11507,.11314,.11123,.10935,.10749,.10565,.10383,.10204,.10027,.09853,.0968,.0951,.09342,.09176,.09012,.08851,.08692,.08534,.08379,.08226,.08076,.07927,.0778,.07636,.07493,.07353,.07215,.07078,.06944,.06811,.06681,.06552,.06426,.06301,.06178,.06057,.05938,.05821,.05705,.05592,.0548,.0537,.05262,.05155,.0505,.04947,.04846,.04746,.04648,.04551,.04457,.04363,.04272,.04182,.04093,.04006,.0392,.03836,.03754,.03673,.03593,.03515,.03438,.03362,.03288,.03216,.03144,.03074,.03005,.02938,.02872,.02807,.02743,.0268,.02619,.02559,.025,.02442,.02385,.0233,.02275,.02222,.02169,.02118,.02068,.02018,.0197,.01923,.01876,.01831,.01786,.01743,.017,.01659,.01618,.01578,.01539,.015,.01463,.01426,.0139,.01355,.01321,.01287,.01255,.01222,.01191,.0116,.0113,.01101,.01072,.01044,.01017,.0099,.00964,.00939,.00914,.00889,.00866,.00842,.0082,.00798,.00776,.00755,.00734,.00714,.00695,.00676,.00657,.00639,.00621,.00604,.00587,.0057,.00554,.00539,.00523,.00508,.00494,.0048,.00466,.00453,.0044,.00427,.00415,.00402,.00391,.00379,.00368,.00357,.00347,.00336,.00326,.00317,.00307,.00298,.00289,.0028,.00272,.00264,.00256,.00248,.0024,.00233,.00226,.00219,.00212,.00205,.00199,.00193,.00187,.00181,.00175,.00169,.00164,.00159,.00154,.00149,.00144,.00139,.00135,.00131,.00126,.00122,.00118,.00114,.00111,.00107,.00104,.001,97e-5,94e-5,9e-4,87e-5,84e-5,82e-5,79e-5,76e-5,74e-5,71e-5,69e-5,66e-5,64e-5,62e-5,6e-4,58e-5,56e-5,54e-5,52e-5,5e-4,48e-5,47e-5,45e-5,43e-5,42e-5,4e-4,39e-5,38e-5,36e-5,35e-5,34e-5,32e-5,31e-5,3e-4,29e-5,28e-5,27e-5,26e-5,25e-5,24e-5,23e-5,22e-5,22e-5,21e-5,2e-4,19e-5,19e-5,18e-5,17e-5,17e-5,16e-5,15e-5,15e-5,14e-5,14e-5,13e-5,13e-5,12e-5,12e-5,11e-5,11e-5,1e-4,1e-4,1e-4,9e-5,9e-5,8e-5,8e-5,8e-5,8e-5,7e-5,7e-5,7e-5,6e-5,6e-5,6e-5,6e-5,5e-5,5e-5,5e-5,5e-5,5e-5,4e-5,4e-5,4e-5,4e-5,4e-5,4e-5,3e-5,3e-5,3e-5,3e-5,3e-5,3e-5,3e-5,3e-5,2e-5,2e-5,2e-5,2e-5]});var Ln=c((I2,El)=>{var{abs:vl,assert:qw,dropNaNPairwise:yw,flatten:St,isArray:Sl,isDataFrame:xl,isEqual:Nw,isSeries:Ol,mean:Tl,remap:ww,round:bw,shape:Fl,sqrt:vw,std:_l}=_(),Sw=Y(),Dl=bl();function xw(e){return vl(e)>4.1?0:Dl[bw(ww(vl(e),0,4.1,0,Dl.length))]}function $n(e,t){if(xl(e)||Ol(e))return $n(e.values,t);if(xl(t)||Ol(t))return $n(e,t.values);qw(Sl(e)&&Sl(t)&&Nw(Fl(e),Fl(t)),"You must pass two identically-shaped arrays, Series, or DataFrames into the `pValue` function!");let[n,r]=Sw.shouldIgnoreNaNValues?yw(St(e),St(t)):[St(e),St(t)];if(n.length===0||r.length===0)return NaN;let s=Tl(n),o=Tl(r),i=_l(n),u=_l(r),a=n.length,l=r.length,f=(s-o)/vw(i*i/a+u*u/l);return 2*xw(f)}El.exports=$n});var Cl=c((C2,Il)=>{var{assert:Gn,clamp:Ow,DataFrame:xt,dropNaNPairwise:Tw,isArray:Al,isDataFrame:Ot,isJagged:Ml,isUndefined:Fw,ndarray:_w}=_(),Dw=Y(),jl=Ln();function Kn(e){let t="@jrc03c/js-data-science-helpers/get-p-value-matrix";return Object.defineProperty(e,t,{configurable:!1,enumerable:!1,writable:!1,value:Symbol.for(t)}),e}function Wn(e,t){if(Fw(t)&&(t=e),Ot(e)){let r=new xt(Wn(e.values,t));return r.index=e.columns.slice(),r.columns=Ot(t)?t.columns.slice():new xt(t).columns.slice(),Kn(r)}if(Ot(t)){let r=new xt(Wn(e,t.values));return r.index=Ot(e)?e.columns.slice():new xt(e).columns.slice(),r.columns=t.columns.slice(),Kn(r)}Gn(Al(e)&&Al(t),"The `getPValueMatrix` function only works on 2-dimensional arrays and DataFrames!"),Gn(!Ml(e)&&!Ml(t),"The `getPValueMatrix` function only works on non-jagged 2-dimensional arrays and DataFrames!"),Gn(e.length===t.length,'The dimensions of the matrices you passed into the `getPValueMatrix` function aren\'t compatible! ([shape(a).join(", ")] vs. [shape(b).join(", ")]) The function expects that you\'ll be comparing the columns of two matrices where the columns are all of the same length, so please make sure that the matrices are oriented accordingly.');let n=_w([e[0].length,t[0].length]);for(let r=0;r<e[0].length;r++){let s=e.map(o=>o[r]);for(let o=0;o<t[0].length;o++){let i=t.map(u=>u[o]);Dw.shouldIgnoreNaNValues?n[r][o]=jl(...Tw(s,i)):n[r][o]=jl(s,i)}}return Kn(Ow(n,0,1))}Il.exports=Wn});var Pl=c((k2,Ul)=>{var{assert:Tt,intersect:Ew,isDataFrame:kl,isSeries:zl,isUndefined:Vl}=_(),me=class{constructor(t){let n=this;Tt(Vl(t)||t===me.DROP_NAN_MODE||t===me.DROP_MISSING_MODE,"The `mode` value passed into the `IndexMatcher` constructor must be undefined or one of [IndexMatcher.DROP_NAN_MODE, IndexMatcher.DROP_MISSING_MODE]! (By default, the mode is `Indexer.DROP_MISSING_MODE`.)"),n.mode=Vl(t)?me.DROP_MISSING_MODE:t,n.index=null}fit(){let t=this,n=[];return Object.values(arguments).forEach(r=>{Tt(kl(r)||zl(r),"The `IndexMatcher` only works on Series and DataFrames! To drop NaN values in a pair-wise fashion from regular arrays, use the `dropNaNPairwise` function from the @jrc03c/js-math-tools library."),t.mode===me.DROP_MISSING_MODE?n.push(r.dropMissing().index):n.push(r.dropNaN().index)}),t.index=Ew(...n),t}transform(){let t=this;Tt(!!t.index,"The IndexMatcher hasn't been fitted yet! Please call the `fit` method before calling the `transform` method.");let n=Object.values(arguments).map(r=>(Tt(kl(r)||zl(r),"The `IndexMatcher` only works on Series and DataFrames! To drop NaN values in a pair-wise fashion from regular arrays, use the `dropNaNPairwise` function from the @jrc03c/js-math-tools library."),r.get(t.index,null)));return n.length===1?n[0]:n}fitAndTransform(){return this.fit(...arguments).transform(...arguments)}},Me=me;Et(Me,"DROP_NAN_MODE","DROP_NAN_MODE"),Et(Me,"DROP_MISSING_MODE","DROP_MISSING_MODE");Ul.exports=Me});var Xn=c((z2,Jl)=>{var{apply:Aw,assert:Mw,count:jw,flatten:Iw,float:Cw,isArray:Hn,isDataFrame:kw,isNumber:zw,isSeries:Vw,isString:Uw}=_(),Bl=["null","none","nan","na","n/a","","undefined"],Pw=["true","false","yes","no"];function Bw(e,t){if(e===void 0&&(e="undefined"),t==="null")return null;if(t==="number"){let n=Cw(e);return isNaN(n)?NaN:n}if(t==="boolean"){try{let n=e.trim().toLowerCase();if(n==="true"||n==="yes")return!0;if(n==="false"||n==="no")return!1}catch{}return null}if(t==="date"){let n=new Date(e);return n.toString()==="Invalid Date"?null:n}if(t==="object")try{let n=JSON.parse(e);return Hn(n)?null:n}catch{return null}if(t==="string"){try{if(Bl.indexOf(e.trim().toLowerCase())>-1)return null}catch{return null}return e}}function Qn(e){if(kw(e)){let s=e.copy(),o=Qn(e.values);return s.values=o.values,{type:o.type,values:s}}if(Vw(e)){let s=e.copy(),o=Qn(e.values);return s.values=o.values,{type:o.type,values:s}}Mw(Hn(e),"The `inferType` function only works on arrays, Series, and DataFrames!");let t=Iw(e).map(s=>{if(s===void 0)return"null";Uw(s)||(s=JSON.stringify(s));let i=s.toLowerCase().trim();if(Bl.indexOf(i)>-1)return"null";if(Pw.indexOf(i)>-1)return"boolean";try{let u=JSON.parse(s);return zw(u)?"number":typeof u=="object"?Hn(u)?"string":"object":"string"}catch{return new Date(s).toString()!=="Invalid Date"?"date":"string"}}),r=jw(t).sort((s,o)=>o.count-s.count)[0].item;return{type:r,values:Aw(e,s=>Bw(s,r))}}Jl.exports=Qn});var Zn=c((V2,Kl)=>{var{apply:Jw,assert:Rw,dropNaN:Rl,isArray:Yw,isDataFrame:$w,isSeries:Lw,mean:Yl,std:$l}=_(),Ll=Y();function Gl(e){if($w(e)||Lw(e)){let r=e.copy();return r.values=Gl(r.values),r}Rw(Yw(e),"The `normalize` function only works on arrays, Series, and DataFrames!");let t=(()=>Ll.shouldIgnoreNaNValues?Yl(Rl(e)):Yl(e))(),n=(()=>Ll.shouldIgnoreNaNValues?$l(Rl(e)):$l(e))();return n===0?e:Jw(e,r=>(r-t)/n)}Kl.exports=Gl});var tr=c((U2,Zl)=>{var{assert:pe,dot:Wl,isArray:Hl,isSeries:er,scale:Gw,Series:Kw,shape:Ql}=_(),Xl=he();function Ft(e,t){if(er(e)){if(er(t))return new Kw(Ft(e.values,t.values));{let n=e.copy();return n.values=Ft(e.values,t),n}}if(er(t)){let n=t.copy();return n.values=Ft(e,t.values),n}return pe(Hl(e),"`project` only works on vectors!"),pe(Hl(t),"`project` only works on vectors!"),pe(Xl(e),"`project` only works on vectors of numbers!"),pe(Xl(t),"`project` only works on vectors of numbers!"),pe(Ql(e).length===1,"`project` only works on vectors!"),pe(Ql(t).length===1,"`project` only works on vectors!"),Gw(Wl(t,e)/Wl(t,t),t)}Zl.exports=Ft});var sf=c((P2,rf)=>{var{assert:ef,copy:Ww,DataFrame:Hw,divide:Qw,isArray:Xw,isDataFrame:Zw,isJagged:eb,shape:tb,subtract:nb,transpose:tf}=_(),rb=he(),sb=Rn(),ob=tr();function nf(e){if(Zw(e)){let s=new Hw(nf(e.values));return s.index=e.index.slice(),s.columns=e.columns.slice(),s}ef(Xw(e)&&!eb(e)&&tb(e).length===2,"`orthonormalize` only works on matrices!"),ef(rb(e),"`orthonormalize` only works on matrices of numbers!");let t=tf(e),n=[];t.forEach(s=>{let o=Ww(s);n.forEach(i=>{o=nb(o,ob(o,i))}),n.push(o)});let r=n.map(s=>Qw(s,sb(s)));return tf(r)}rf.exports=nf});var hf=c((B2,ff)=>{var{assert:of,copy:ib,correl:ub,DataFrame:uf,dropMissing:ab,isArray:cb,isDataFrame:lb,isEqual:fb,isJagged:hb,isNumber:af,set:mb,shape:pb,transpose:cf}=_(),db=In(),gb=Yn(),qb=Xn();function lf(e,t,n){if(t=af(t)?t:7,n=af(n)?n:1-1e-5,cb(e))return of(pb(e).length===2&&!hb(e),"The `preprocess` function only works on non-jagged 2-dimensional arrays and DataFrames!"),lf(new uf(e));of(lb(e),"You must pass a DataFrame into the `preprocess` function!");let r={};e=e.apply(l=>{let f=qb(l.values);return r[l.name]=f.type,f.values});let s=ib(e.columns),o=cf(e.values),i=0,u=!1;for(;!u;){let l=o[i];for(let f=i+1;f<o.length;f++){let h=o[f];fb(l,h)&&(s.splice(f,1),o.splice(f,1))}i++,u=i>=s.length-1}for(i=0,u=!1;!u;){let l=s[i],f=o[i];if(!f)break;let h=ab(f);if(h.length<15){s.splice(i,1),o.splice(i,1);continue}let d=mb(h);if(d.length===1){s.splice(i,1),o.splice(i,1);continue}let g=r[l];if(g==="string"){if(d.length<=t){let v=gb(l,f);Object.keys(v).forEach(b=>{s.push(b),o.push(v[b]),r[b]="number"}),s.splice(i,1),o.splice(i,1);continue}}else if(g==="number"){let v=db(f);o[i]=v;let b=!1;for(let D=0;D<i;D++){let k=o[D];if(ub(f,k)>n){s.splice(i,1),o.splice(i,1),b=!0;break}}if(b)continue}else{o.splice(i,1),s.splice(i,1);continue}i++,u=i>=s.length}let a=new uf(cf(o));return a.columns=s,a}ff.exports=lf});var vf=c((J2,bf)=>{var{abs:yb,add:Nb,assert:je,isArray:mf,isDataFrame:pf,isEqual:wb,isSeries:df,mean:bb,pow:gf,scale:vb,shape:qf,sign:Sb,sqrt:xb,sum:yf}=_(),Nf=he(),wf=(e,t)=>Nb(e,vb(t,-1));function nr(e,t){if(pf(e)||df(e))return nr(e.values,t);if(pf(t)||df(t))return nr(e,t.values);je(mf(e),"You must pass two same-shaped numerical arrays into the `rScore` function!"),je(mf(t),"You must pass two same-shaped numerical arrays into the `rScore` function!"),je(wb(qf(e),qf(t)),"You must pass two same-shaped numerical arrays into the `rScore` function!"),je(Nf(e),"You must pass two same-shaped numerical arrays into the `rScore` function!"),je(Nf(t),"You must pass two same-shaped numerical arrays into the `rScore` function!");let n=yf(gf(wf(e,t),2)),r=yf(gf(wf(e,bb(e)),2));if(r===0)return NaN;let s=1-n/r;return Sb(s)*xb(yb(s))}bf.exports=nr});var Ff=c((R2,Tf)=>{var{argmax:Sf,assert:Ie,copy:Ob,DataFrame:Tb,dot:Fb,isArray:_b,isDataFrame:Db,isEqual:xf,isJagged:Eb,max:Ab,min:Mb,reverse:jb,shape:Ib,transpose:Cb}=_();function Of(e){if(_b(e)){Ie(Ib(e).length===2&&!Eb(e),"The `sortCorrelationMatrix` function only works on 2-dimensional arrays and DataFrames!");let s=new Tb(e);return s.index=s.columns.slice(),Of(s).values}Ie(Db(e),"You must pass a DataFrame into the `sortCorrelationMatrix` function!"),Ie(Ab(e.values)<=1&&Mb(e.values)>=-1,"The correlation matrix passed into the `sortCorrelationMatrix` function must not contain values less than -1 or greater than 1!"),Ie(xf(e.values,Cb(e.values)),"The correlation matrix passed into the `sortCorrelationMatrix` function must be symmetrical!"),Ie(xf(e.index,e.columns),"The correlation matrix passed into the `sortCorrelationMatrix` function must be symmetrical! (In this case, although the values themselves are symmetrical, the row and column names differ.)");let t=Ob(e.index),n=[];for(;t.length>0;)if(n.length===0){let s=Sf(e.values.map(o=>Fb(o,o)));n.push(t[s]),t.splice(s,1)}else{let s=e.index.indexOf(n.at(-1)),o=Sf(t.map(u=>e.values[e.index.indexOf(u)][s])),i=t[o];n.push(i),t.splice(o,1)}let r=jb(n);return e.get(r,r)}Tf.exports=Of});var Df=c((Y2,_f)=>{var kb=Zn();function zb(){return kb(...arguments)}_f.exports=zb});var Cf=c(($2,If)=>{var{assert:rr,isArray:Vb,isBoolean:Ub,isDataFrame:Ef,isSeries:Af,int:Pb,isNumber:Bb,isUndefined:Mf,range:jf,set:Jb,shape:Rb,shuffle:Yb}=_();If.exports=function(){let t=Array.from(arguments),n=t.find(g=>Ub(g)),r=Mf(n)?!0:n,s=t.find(g=>Bb(g)),o=Mf(s)?.1:s;rr(o>0&&o<1,"`testSize` must be a number between 0 and 1 (exclusive on both ends)!");let i=t.filter(g=>Vb(g)||Ef(g)||Af(g));rr(i.length>0,"You must pass at least one dataset into the `trainTestSplit` function!");let u=i.map(g=>Rb(g)[0]);rr(Jb(u).length===1,`All datasets passed into the \`trainTestSplit\` function must be the same length at their shallowest dimension! The lengths of your datasets, though, are: ${u.join(", ")}`);let a=[],l=r?Yb(jf(0,u[0])):jf(0,u[0]),f=Pb((1-o)*l.length),h=l.slice(0,f),d=l.slice(f);return i.forEach(g=>{if(Ef(g))a.push(g.get(h,null)),a.push(g.get(d,null));else if(Af(g))a.push(g.get(h)),a.push(g.get(d));else{let v=[],b=[];g.forEach((D,k)=>{h.indexOf(k)>-1?v.push(D):b.push(D)}),a.push(v),a.push(b)}}),a}});var Lb=c((L2,zf)=>{var{MathError:$b}=_(),kf={clipOutliers:In(),cohensD:kn(),cohensd:kn(),common:Y(),containsOnlyNumbers:he(),diagonalize:sl(),getCorrelationMatrix:Pn(),getHighlyCorrelatedColumns:ml(),getMagnitude:Rn(),getOneHotEncodings:Yn(),getPercentages:wl(),getPValueMatrix:Cl(),IndexMatcher:Pl(),inferType:Xn(),isBinary:jn(),isCorrelationMatrix:Bn(),normalize:Zn(),orthonormalize:sf(),preprocess:hf(),project:tr(),pValue:Ln(),rScore:vf(),sortCorrelationMatrix:Ff(),standardize:Df(),trainTestSplit:Cf(),dump:function(){let e=this,t=global||window;if(!t)throw new $b("Cannot dump functions into global scope because neither `global` nor `window` exist in the current context!");Object.keys(e).forEach(n=>{try{Object.defineProperty(t,n,{configurable:!1,enumerable:!0,writable:!1,value:e[n]})}catch{t[n]=e[n]}})}};try{window.JSDataScienceHelpers=kf}catch{}try{zf.exports=kf}catch{}});Lb();})();
