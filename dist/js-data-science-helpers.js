(()=>{var Oh=Object.defineProperty;var Dh=(t,e,n)=>e in t?Oh(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n;var gr=(t=>typeof require!="undefined"?require:typeof Proxy!="undefined"?new Proxy(t,{get:(e,n)=>(typeof require!="undefined"?require:e)[n]}):t)(function(t){if(typeof require!="undefined")return require.apply(this,arguments);throw new Error('Dynamic require of "'+t+'" is not supported')});var c=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports);var Et=(t,e,n)=>(Dh(t,typeof e!="symbol"?e+"":e,n),n);var se=c((mS,qr)=>{var Fh=new Function(`
  try {
    return this === window
  } catch(e) {}

  try {
    return typeof importScripts !== "undefined"
  } catch(e) {}

  return false
`),Mt=class extends Error{constructor(e){Fh()?super(e):super(`

\x1B[31m`+e+`
\x1B[0m`)}};qr.exports=Mt});var m=c((dS,yr)=>{var Ih=se();yr.exports=function(t,e){if(!t)throw new Ih(e)}});var C=c((pS,br)=>{function Ah(t){try{return structuredClone(t)}catch{return t}}br.exports=Ah});var d=c((gS,vr)=>{function Eh(t){try{return t instanceof Array||typeof t.constructor<"u"&&t.constructor.name==="Array"}catch{return!1}}vr.exports=Eh});var y=c((qS,Nr)=>{function Mh(t){try{return!!t._symbol&&t._symbol===Symbol.for("@jrc03c/js-math-tools/dataframe")}catch{return!1}}Nr.exports=Mh});var q=c((yS,wr)=>{function jh(t){try{return!!t._symbol&&t._symbol===Symbol.for("@jrc03c/js-math-tools/series")}catch{return!1}}wr.exports=jh});var T=c((bS,_r)=>{var kh=m(),Ch=C(),Sr=d(),zh=y(),Rh=q();function xr(t){if(zh(t)||Rh(t))return xr(t.values);kh(Sr(t),"The `flatten` function only works on arrays, Series, and DataFrames!");function e(n){let r=[];return Ch(n).forEach(s=>{Sr(s)?r=r.concat(e(s)):r.push(s)}),r}return e(t)}_r.exports=xr});var A=c((vS,Tr)=>{function Uh(t){return typeof t=="function"}Tr.exports=Uh});var g=c((NS,Or)=>{function Ph(t){return typeof t=="number"&&!isNaN(t)}Or.exports=Ph});var v=c((wS,Dr)=>{function Bh(t){return t===null||typeof t>"u"}Dr.exports=Bh});var Q=c((SS,Fr)=>{var Vh=d(),Yh=v();function Jh(t){return typeof t=="object"&&!Yh(t)&&!Vh(t)}Fr.exports=Jh});var be=c((xS,Er)=>{var $h=m(),Ir=d(),Gh=y(),Lh=A(),jt=g(),Ar=Q(),Wh=q();function kt(t,e){if(Gh(t)){let i=kt(t.values,e);return i.length>0&&jt(i[0])&&i[0]>=0&&i[0]<t.index.length&&(i[0]=t.index[i[0]]),i.length>1&&jt(i[1])&&i[1]>=0&&i[1]<t.columns.length&&(i[1]=t.columns[i[1]]),i}if(Wh(t)){let i=kt(t.values,e);return i.length>0&&jt(i[0])&&i[0]>=0&&i[0]<t.index.length&&(i[0]=t.index[i[0]]),i}if($h(Ar(t)||Ir(t),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `indexOf` function!"),!Lh(e)){let i=e;e=o=>o===i}function n(i,o,u){if(u=u||[],u.indexOf(i)>-1)return null;if(Ar(i)){u.push(i);let a=Object.keys(i);for(let l=0;l<a.length;l++){let f=a[l],h=i[f];if(o(h))return[f];let p=n(h,o,u);if(p&&p.length>0)return[f].concat(p)}}else if(Ir(i)){u.push(i);for(let a=0;a<i.length;a++){let l=i[a];if(o(l))return[a];let f=n(l,o,u);if(f&&f.length>0)return[a].concat(f)}}else if(o(i))return[];return null}function r(i){try{return e(i)}catch{return!1}}let s=n(t,r);return s&&s.length>0?s:null}Er.exports=kt});var Ct=c((_S,Mr)=>{var Kh=C(),Hh=be(),Xh=d(),Qh=y(),Zh=q();Mr.exports=function(e){function n(i,o,u){if(o=o||[],u=u||"",o.indexOf(i)>-1){let a=u.split("/").slice(u.startsWith("/")?1:0);if(a.some((f,h)=>{let p=a.slice(0,a.length-h-1),b=r;return p.forEach(S=>{b=b[S]}),b===i}))return`<reference to "${r===i?"/":"/"+Hh(r,i).join("/")}">`}return typeof i=="object"?i===null?null:(o.push(i),Xh(i)?i.map((a,l)=>n(a,o,u+"/"+l)):(Object.keys(i).forEach(a=>{i[a]=n(i[a],o,u+"/"+a)}),i)):i}let r=Kh(e),s=n(r);if(Qh(e)){let i=e.copy();i._values=s.values,i._columns=s.columns,i._index=s.index,s=i}if(Zh(e)){let i=e.copy();i.name=s.name,i._values=s.values,i._index=s.index,s=i}return s}});var R=c((TS,Cr)=>{var jr=C(),kr=Ct();function e0(t,e){function n(r,s){let i=typeof r;if(i!==typeof s)return!1;if(i==="undefined")return!0;if(i==="boolean"||i==="symbol")return r===s;if(i==="number"||i==="bigint")return r.toString()==="NaN"&&s.toString()==="NaN"?!0:r===s;if(i==="string"||i==="function")return r===s;if(i==="object"){if(r===null||s===null)return r===null&&s===null;{let u=Object.keys(r),a=Object.keys(s);if(u.length!==a.length)return!1;for(let l=0;l<u.length;l++){let f=u[l];if(!n(r[f],s[f]))return!1}return!0}}}try{return n(jr(t),jr(e))}catch{return n(kr(t),kr(e))}}Cr.exports=e0});var z=c((OS,Pr)=>{var t0=m(),n0=T(),r0=d(),zr=y(),s0=A(),Rr=q(),i0=v();function ve(t){let e="abcdefg1234567890",n="";for(;n.length<t;)n+=e[parseInt(Math.random()*e.length)];return n}var o0=ve(256),u0=ve(256),a0=ve(256),c0=ve(256),l0=ve(256);function Ur(t){if(zr(t)||Rr(t))return Ur(t.values);t0(r0(t),"The `set` function only works on arrays, Series, and DataFrames!");let e=[],n={};return n0(t).forEach(r=>{let s=typeof r=="object"&&r===null?o0:i0(r)?u0:s0(r)?r.toString():typeof r=="symbol"?r.toString()+" - "+l0:r===1/0?a0:r===-1/0?c0:zr(r)?r.toJSONString():Rr(r)?JSON.stringify(r.toObject()):JSON.stringify(r);n[s]||e.push(r),n[s]=!0}),e}Pr.exports=Ur});var Ne=c((DS,Yr)=>{var f0=m(),zt=T(),Br=d(),h0=y(),Vr=R(),m0=A(),d0=q(),p0=z();function Pe(t,e){if(h0(t)||d0(t))return arguments.length>1?Pe(t.values,e):Pe(t.values,t.values);if(f0(Br(t),"The first argument to the `count` function must be an array, Series, or DataFrame!"),m0(e))return zt(t).filter(n=>e(n)).length;if(Br(e)){let n=zt(t);return p0(e).map(r=>({item:r,count:n.filter(s=>Vr(s,r)).length}))}else return arguments.length>1?zt(t).filter(n=>Vr(n,e)).length:Pe(t,t)}Yr.exports=Pe});var we=c((FS,$r)=>{var g0=m(),Jr=d(),q0=y(),y0=q();function Rt(t){if(q0(t)||y0(t))return Rt(t.values);g0(Jr(t),"The `isJagged` function only works on arrays, Series, and DataFrames!");let e=0,n=null;for(let r=0;r<t.length;r++)if(Jr(t[r])){if(e++,Rt(t[r]))return!0;if(n===null)n=t[r].length;else if(t[r].length!==n)return!0}return e>0&&e<t.length}$r.exports=Rt});var Be=c((IS,Wr)=>{var b0=m(),Gr=d(),v0=y(),N0=q();function Lr(t){if(v0(t)||N0(t))return Lr(t.values);b0(Gr(t),"The `isNested` function only works on arrays, Series, and DataFrames!");for(let e=0;e<t.length;e++)if(Gr(t[e]))return!0;return!1}Wr.exports=Lr});var J=c((AS,Hr)=>{var Z=m(),w0=d(),S0=Be(),x0=g(),_0=v(),ie="You must pass a natural number or a one-dimensional array of natural numbers into the `ndarray` function!";function Kr(t){Z(!_0(t),ie),w0(t)||(t=[t]),Z(!S0(t),ie),Z(t.length>0,ie);let e=t[0];if(Z(x0(e),ie),Z(parseInt(e)===e,ie),Z(e>=0,ie),Z(e!==1/0,"We can't create an array containing an infinite number of values!"),t.length===1){let n=[];for(let r=0;r<e;r++)n.push(void 0);return n}else{let n=[];for(let r=0;r<e;r++)n.push(Kr(t.slice(1)));return n}}Hr.exports=Kr});var Se=c((ES,Xr)=>{var T0=m(),O0=d(),D0=y(),F0=q();function Ut(t){if(D0(t)||F0(t)){let n=t.copy();return n.values=Ut(n.values),n.index=Ut(n.index),n}T0(O0(t),"The `reverse` function only works on arrays, Series, and DataFrames!");let e=[];for(let n=t.length-1;n>=0;n--)e.push(t[n]);return e}Xr.exports=Ut});var j=c((MS,Qr)=>{var Pt=m(),Bt=g(),Vt=v(),I0=Se();function A0(t,e,n=1){Pt(!Vt(t)&&!Vt(e)&&!Vt(n),"You must pass two numbers and optionally a step value to the `range` function!"),Pt(Bt(t)&&Bt(e)&&Bt(n),"You must pass two numbers and optionally a step value to the `range` function!"),Pt(n>0,"The step value must be greater than 0! (NOTE: The step value is a magnitude; it does not indicate direction.)");let r=!1;if(t>e){r=!0;let i=t;t=e+n,e=i+n}let s=[];for(let i=t;i<e;i+=n)s.push(i);return r&&(s=I0(s)),s}Qr.exports=A0});var x=c((jS,ns)=>{var E0=m(),Zr=d(),M0=y(),j0=R(),k0=q(),C0=v();function es(t){if(!Zr(t))return;let e=[t.length],n=0,r=t.map(s=>{let i=es(s);return C0(i)?i:(n++,i.length===1?i[0]:i)});return n>0?n===t.length&&r.slice(0,-1).every((i,o)=>j0(i,r[o+1]))?e.concat(r[0]):(e.push(r),e):e}function ts(t){return M0(t)||k0(t)?ts(t.values):(E0(Zr(t),"The `shape` function only works on arrays, Series, and DataFrames!"),es(t))}ns.exports=ts});var as=c((kS,us)=>{var rs=m(),z0=d(),R0=y(),U0=we(),P0=q(),B0=v(),ss=se(),Ve=J(),is=j(),V0=z(),Y0=x();function os(t,e,n){if(B0(n)&&(n=0),rs(n===0||n===1||n==="vertical"||n==="horizontal",'The only valid axis values for use when appending data to a DataFrame are 0, 1, "vertical", and "horizontal". Note that 0 == "horizontal" and 1 == "vertical".'),z0(e)){rs(!U0(e),"The array of data you're trying to append to this DataFrame is jagged!");let r=Y0(e);if(r.length===1)if(n===0){let s=t.copy();s._values.push(e);let i=Math.max(t.shape[1],r[0]);for(s._values.forEach(o=>{for(;o.length<i;)o.push(void 0)});s._index.length<s._values.length;)s._index.push("row"+s._index.length);for(;s._columns.length<i;)s._columns.push("col"+s._columns.length);return s}else{let s=Math.max(t.shape[0],r[0]),i=t.copy();for(is(0,s).forEach(o=>{o>=i._values.length&&i._values.push(Ve(t.shape[1])),i._values[o].push(e[o])});i._index.length<i._values.length;)i._index.push("row"+i._index.length);for(;i._columns.length<i._values[0].length;)i._columns.push("col"+i._columns.length);return i}else if(r.length===2)if(n===0){let s=Math.max(...e.map(o=>o.length).concat([t.shape[1]])),i=t.copy();for(i._values=i._values.concat(e).map(o=>{for(;o.length<s;)o.push(void 0);return o});i._index.length<i._values.length;)i._index.push("row"+i._index.length);for(;i._columns.length<s;)i._columns.push("col"+i._columns.length);return i}else{let s=Math.max(...e.map(u=>u.length))+t.shape[1],i=Math.max(t.shape[0],r[0]),o=t.copy();for(is(0,i).forEach(u=>{for(u>=o._values.length&&o._values.push(Ve(t.shape[1])),o._values[u]=o._values[u].concat(e[u]);o._values[u].length<s;)o._values[u].push(void 0)});o._index.length<o._values.length;)o._index.push("row"+o._index.length);for(;o._columns.length<s;)o._columns.push("col"+o._columns.length);return o}else throw new ss("Only 1- and 2-dimensional arrays can be appended to a DataFrame!")}else if(P0(e)){let r=os(t,e.values,n);return n===0?r.index[r.index.length-1]=r.index.indexOf(e.name)>-1?e.name+" (2)":e.name:r.columns[r.columns.length-1]=r.columns.indexOf(e.name)>-1?e.name+" (2)":e.name,r}else if(R0(e))if(n===0){let r=t.copy(),s=V0(r._columns.concat(e._columns)).length;for(r._values.forEach(i=>{for(;i.length<s;)i.push(void 0)}),e.apply(i=>{let o=i.copy(),u=[];r._columns.forEach(a=>{let l=o._index.indexOf(a);l>-1?(u.push(o._values[l]),o._values.splice(l,1),o._index.splice(l,1)):u.push(void 0)}),r._values.push(u.concat(o._values))},1),r._columns=r._columns.concat(e._columns.filter(i=>r._columns.indexOf(i)<0));r._index.length<r._values.length;){let i="row"+r._index.length;r._index.push(i+(t._index.indexOf(i)>-1?" (2)":""))}return r}else{let r=t.copy();return r._index.forEach((s,i)=>{let o=e._index.indexOf(s);o>-1?r._values[i]=r._values[i].concat(e._values[o]):r._values[i]=r._values[i].concat(Ve(e.shape[1]))}),e._index.forEach((s,i)=>{r._index.indexOf(s)<0&&(r._index.push(s),r._values.push(Ve(r._columns.length).concat(e._values[i])))}),r._columns=r._columns.concat(e._columns.map(s=>s+(r._columns.indexOf(s)>-1?" (2)":""))),r}else throw new ss("Only 1- or 2-dimensional arrays, Series, and DataFrames can be appended to a DataFrame!")}us.exports=os});var ms=c((CS,hs)=>{var cs=m(),ls=d(),J0=A(),fs=v();function $0(t,e,n,r,s){if(s=s||0,cs(J0(r),"The first parameter to the `apply` method must be a function."),cs(s===0||s===1,"The second parameter to the `apply` method (the `axis`) must be 0 or 1."),s===0){let i={},o;if(n.columns.forEach((u,a)=>{let l=new e(n.values.map(h=>h[a]));l.name=u,l.index=n.index;let f=r(l,a,n);f instanceof e?i[u]=f.values:i[u]=f,fs(o)&&(o=f instanceof e||ls(f))}),o){let u=new t(i);return u.index=n.index,u}else{let u=new e(n.columns.map(a=>i[a]));return u.index=n.columns,u}}else if(s===1){let i,o=n.values.map((u,a)=>{let l=new e(u);l.name=n.index[a],l.index=n.columns;let f=r(l,a,n);return fs(i)&&(i=f instanceof e||ls(f)),f instanceof e?f.values:f});if(i){let u=new t(o);return u.index=n.index,u.columns=n.columns,u}else{let u=new e(o);return u.index=n.index,u}}}hs.exports=$0});var E=c((zS,ds)=>{function G0(t){return typeof t=="string"}ds.exports=G0});var qs=c((RS,gs)=>{var ps=m(),L0=d(),W0=we(),K0=Q(),H0=E(),X0=v(),Q0=se(),Z0=x();function em(t,e,n,r,s){let i=u=>u instanceof t,o=u=>u instanceof e;if(X0(s)){if(i(r))return n.append(r,1);if(o(r))return n.append(r,1);if(K0(r)){let u=Math.max(...Object.keys(r).map(a=>r[a].length));return Object.keys(r).forEach(a=>{for(;r[a].length<u;)r[a].push(void 0)}),n.append(new t(r),1)}else throw new Q0("You must pass a DataFrame, Series, or object into the `assign` method!")}else{ps(H0(r),"If passing two arguments into the `assign` method, then the first argument must be a string name!"),ps(L0(s)&&!W0(s)&&Z0(s).length===1,"If passing two arguments into the `assign` method, then the second argument must be a 1-dimensional array!");let u=n.append(s,1);return u.columns[u.columns.length-1]=r,u}}gs.exports=em});var bs=c((US,ys)=>{var tm=C();function nm(t,e){if(e.isEmpty)return new t;let n=new t(tm(e.values));return n.columns=e.columns.slice(),n.index=e.index.slice(),n}ys.exports=nm});var Ts=c((PS,_s)=>{var Ye=m(),vs=d(),Ns=g(),ws=E(),Ss=v(),xs=x();function rm(t,e,n,r,s){Ss(r)&&(r=[]),Ss(s)&&(s=[]),(ws(r)||Ns(r))&&(r=[r]),(ws(s)||Ns(s))&&(s=[s]),Ye(vs(r),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),Ye(vs(s),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),Ye(xs(r).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),Ye(xs(s).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");let i,o;n.index.forEach((a,l)=>{r.indexOf(a)<0&&r.indexOf(l)<0&&(i||(i=[]),i.push(a))}),n.columns.forEach((a,l)=>{s.indexOf(a)<0&&s.indexOf(l)<0&&(o||(o=[]),o.push(a))});let u=n.get(i,o);if(u instanceof e){let a=new t;a=a.assign(u),n.index.indexOf(u.name)>-1&&(a=a.transpose()),u=a}return u}_s.exports=rm});var xe=c((BS,Os)=>{var sm=g();function im(t){return sm(t)&&parseInt(t)===t}function om(t){return im(t)&&t>=0}Os.exports=om});var Fs=c((VS,Ds)=>{var Yt=m(),um=E(),Je=v(),am=xe(),cm=x();function lm(t,e,n,r,s,i){r=r||0,Yt(r===0||r===1,"The first parameter of the `dropMissing` method (the `axis`) must be 0 or 1."),i=i||0,Yt(am(i),"The third parameter of the `dropMissing` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` null values)."),s=i>0?"none":s||"any",Yt(s==="any"||s==="all"||s==="none","The second parameter of the `dropMissing` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains null values, then it should be dropped; or that if 'all' of the data contains null values, then it should be dropped).");function o(l){if(i>0){let f=0;for(let h=0;h<l.length;h++){let p=l[h];if(Je(p)&&f++,f>=i)return[]}}else if(s==="any")for(let f=0;f<l.length;f++){let h=l[f];if(Je(h))return[]}else if(s==="all"){for(let f=0;f<l.length;f++){let h=l[f];if(!Je(h))return l}return[]}return l}let u=n.copy(),a=Math.random().toString();if(r===0){u=u.assign(a,u.index);let l=u.values.map(o).filter(h=>h.length>0);if(cm(l).length<2)return new t;u.values=l;let f=u.get(null,a);if(Je(f))return new t;um(f)&&(f=[f]),f instanceof e&&(f=f.values),u.index=f,u=u.drop(null,a)}else if(r===1){let l={};if(u.columns.forEach((h,p)=>{let b=u.values.map(O=>O[p]),S=o(b);S.length>0&&(l[h]=S)}),Object.keys(l).length===0)return new t;let f=new t(l);return f.index=u.index,f}return u}Ds.exports=lm});var Jt=c((YS,As)=>{var fm=m(),hm=d(),mm=y(),dm=g(),pm=q();function Is(t){if(mm(t)||pm(t))return t.dropNaN(...Object.values(arguments).slice(1));fm(hm(t),"The `dropNaN` function only works on arrays, Series, and DataFrames!");let e=[];return t.forEach(n=>{try{return e.push(Is(n))}catch{if(dm(n))return e.push(n)}}),e}As.exports=Is});var Ms=c((JS,Es)=>{var $t=m(),gm=Jt(),qm=xe();function ym(t,e,n,r,s){n=n||0,$t(n===0||n===1,"The first parameter of the `dropNaN` method (the `axis`) must be 0 or 1."),s=s||0,$t(qm(s),"The third parameter of the `dropNaN` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` NaN values)."),r=s>0?"none":r||"any",$t(r==="any"||r==="all"||r==="none","The second parameter of the `dropNaN` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains NaN values, then it should be dropped; or that if 'all' of the data contains NaN values, then it should be dropped).");function i(u){let a=gm(u);return s>0?u.length-a.length<s:r==="any"?a.length===u.length:r==="all"?a.length>0:!0}let o=e.copy();if(n===0){let u=o.index.filter(a=>{let l=o.get(a,null).values;return i(l)});return u.length>0?o.get(u,null):new t}else if(n===1){let u=o.columns.filter(a=>{let l=o.get(null,a).values;return i(l)});return u.length>0?o.get(null,u):new t}return o}Es.exports=ym});var zs=c(($S,Cs)=>{var js=m(),_e=T(),bm=A(),vm=v();function ks(t){let e={};return _e(t).forEach((n,r)=>{e[n]=r}),e}function oe(t){return Object.keys(t).sort((e,n)=>t[e]-t[n])}function Nm(t,e,n,r,s){js(bm(r),"The `filter` method takes a single parameter: a function that is used to filter the values."),vm(s)&&(s=0),js(s===0||s===1,"The `axis` parameter to the `filter` method must be 0 or 1.");let i=n.copy();if(i.isEmpty)return i;let o=ks(i.index),u=ks(i.columns);if(s===0){let a=i.values.filter((l,f)=>{let h=new e(l);h.name=n.index[f],h.index=n.columns;let p=r(h,f,n);return p||delete o[i.index[f]],p});if(_e(a).length===0)return new t;if(a.length===1){let l=new e(_e(a));return l.name=oe(o)[0],l.index=oe(u),l}i.values=a,i.index=oe(o)}else if(s===1){i=i.transpose();let a=i.values.filter((l,f)=>{let h=new e(l);h.name=n.columns[f],h.index=n.index;let p=r(h,f,n);return p||delete u[i.index[f]],p});if(_e(a).length===0)return new t;if(a.length===1){let l=new e(_e(a));return l.name=oe(u)[0],l.index=oe(o),l}i.values=a,i.index=oe(u),i=i.transpose()}return i}Cs.exports=Nm});var Ps=c((GS,Us)=>{var k=m(),$e=g(),Ge=E(),Rs=v(),wm=z();function Sm(t,e,n){(Ge(e)||$e(e))&&(e=[e]),(Ge(n)||$e(n))&&(n=[n]);let r=wm((e||[]).concat(n||[]).map(s=>typeof s));return k(r.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===1&&k(r[0]==="string"||r[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===2&&(k(r.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),k(r.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),Rs(e)||(e=e.map(s=>{if(Ge(s))return k(t.index.indexOf(s)>-1,`Row "${s}" does not exist!`),s;if($e(s))return k(s>=0,`Index ${s} is out of bounds!`),k(parseInt(s)===s,"Row numbers must be integers!"),k(s<t.index.length,`Index ${s} is out of bounds!`),t.index[s]})),Rs(n)||(n=n.map(s=>{if(Ge(s))return k(t.columns.indexOf(s)>-1,`Column "${s}" does not exist!`),s;if($e(s))return k(s>=0,`Column ${s} is out of bounds!`),k(parseInt(s)===s,"Column numbers must be integers!"),k(s<t.columns.length,`Column ${s} is out of bounds!`),t.columns[s]})),t.getSubsetByNames(e,n)}Us.exports=Sm});var $=c((LS,Vs)=>{var Bs=m(),xm=d(),_m=y(),Tm=A(),Om=q(),Dm=v();function Fm(t,e){try{return t<e?-1:t>e?1:0}catch{return t=typeof t=="object"&&t!==null?JSON.stringify(t):t.toString(),e=typeof e=="object"&&e!==null?JSON.stringify(e):e.toString(),t<e?-1:t>e?1:0}}function Im(t,e){if(Dm(e)&&(e=Fm),_m(t)||Om(t))return t.sort(...Object.values(arguments).slice(1));Bs(xm(t),"The `sort` function only works on arrays, Series, and DataFrames!"),Bs(Tm(e),"The second parameter of the `sort` function must be a comparison function!");let n=t.slice();return n.sort(e),n}Vs.exports=Im});var Gs=c((WS,$s)=>{var Ys=m(),Js=E(),Am=v(),Em=z(),Mm=$();function jm(t){let e=t.toLowerCase(),n="";for(let s=0;s<e.length;s++){let i=e[s];i.match(/[a-z0-9]/g)?n+=i:n+=" "}let r=n.split(" ").filter(s=>s.length>0);return r[0]+r.slice(1).map(s=>s[0].toUpperCase()+s.substring(1)).join("")}function km(t,e,n){Am(n)?n=e.columns:Js(n)&&(n=[n]);let r={};n.forEach(i=>{Ys(Js(i),"You must pass either a string or a one-dimensional array of strings into the `getDummies` (AKA `oneHotEncode`) method!");let o=e.columns.indexOf(i);Ys(o>-1,`The given DataFrame does not have a column called "${i}"!`);let u=e.values.map(l=>l[o]),a=Mm(Em(u));u.forEach(l=>{a.forEach(f=>{let h=i+"_"+jm(f.toString());r[h]||(r[h]=[]),l===f?r[h].push(1):r[h].push(0)})})});let s=new t(r);return s.index=e.index,s}$s.exports=km});var ei=c((KS,Zs)=>{var G=m(),Ls=d(),Ws=g(),Ks=v(),Hs=xe(),Xs=j(),Qs=x();function Cm(t,e,n){let r=t.shape;Ks(e)&&(e=Xs(0,r[0])),Ks(n)&&(n=Xs(0,r[1])),Ws(e)&&(e=[e]),Ws(n)&&(n=[n]),G(Ls(e)&&Ls(n),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),G(Qs(e).length===1&&Qs(n).length===1,"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),G(e.length>0,"The `rowIndices` array must contain at least one index."),G(n.length>0,"The `colIndices` array must contain at least one index."),e.forEach(o=>{G(Hs(o),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),G(o<t.index.length,`The row index ${o} is out of bounds.`)}),n.forEach(o=>{G(Hs(o),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),G(o<t.columns.length,`The column index ${o} is out of bounds.`)});let s=e.map(o=>t.index[o]),i=n.map(o=>t.columns[o]);return t.getSubsetByNames(s,i)}Zs.exports=Cm});var ii=c((HS,si)=>{var L=m(),Gt=T(),ti=d(),Le=E(),ni=v(),ri=x();function zm(t,e,n,r,s){ni(r)&&(r=n.index),ni(s)&&(s=n.columns),Le(r)&&(r=[r]),Le(s)&&(s=[s]),L(ti(r)&&ti(s),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),L(ri(r).length===1&&ri(s).length===1,"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),L(r.length>0,"The `rows` array must contain at least one row name."),L(s.length>0,"The `cols` array must contain at least one column name."),r.forEach(u=>{L(Le(u),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),L(n.index.indexOf(u)>-1,`The row name "${u}" does not exist in the list of rows.`)}),s.forEach(u=>{L(Le(u),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),L(n.columns.indexOf(u)>-1,`The column name "${u}" does not exist in the list of columns.`)});let i=r.map(u=>s.map(a=>n.values[n.index.indexOf(u)][n.columns.indexOf(a)]));if(r.length===1&&s.length===1)return Gt(i)[0];if(r.length===1){let u=new e(Gt(i));return u.name=r[0],u.index=s,u}if(s.length===1){let u=new e(Gt(i));return u.name=s[0],u.index=r,u}let o=new t(i);return o.columns=s,o.index=r,o}si.exports=zm});var ui=c((XS,oi)=>{var Rm=E(),Te=j();function Um(t,e,n){function r(p,b){return Rm(p)&&p.length>b?p.substring(0,b-3)+"...":p}if(n.isEmpty)return console.table({}),console.log("Shape:",[0,0],`
`),n;let s=typeof window>"u"?20:10,i=parseInt(s/2),o=typeof process>"u"?10:Math.floor(process.stdout.columns/24)-1,u=parseInt(o/2),a=s>n.index.length?null:Te(0,i).concat(Te(n.index.length-i,n.index.length)),l=o>n.columns.length?null:Te(0,u).concat(Te(n.columns.length-u,n.columns.length)),f=n.get(a,l);f instanceof e&&(n.shape[0]===1?(f=new t([f.values]),f.index=n.index,f.columns=new e(n.columns).get(l).values):n.shape[1]===1&&(f=new t([f.values]).transpose(),f.index=new e(n.index).get(a).values,f.columns=n.columns)),s<=n.index.length&&(f._index.splice(i,0,"..."),f._values.splice(i,0,Te(0,f.columns.length).map(()=>"..."))),o<=n.columns.length&&(f._columns.splice(u,0,"..."),f._values=f._values.map(p=>(p.splice(u,0,"..."),p)));let h=28;return f instanceof e?(f.values=f.values.map(p=>r(p,h)),f.name=r(f.name,h),f.index=f.index.map(p=>r(p,h))):(f.values=f.values.map(p=>p.map(b=>r(b,h))),f.columns=f.columns.map(p=>r(p,h)),f.index=f.index.map(p=>r(p,h))),console.table(f.toObject()),console.log("Shape:",n.shape,`
`),n}oi.exports=Um});var We=c((QS,ai)=>{var Pm=m(),Bm=g();function Vm(t,e){Pm(Bm(t),"The `leftPad` function only works on numbers!");let n=t.toString();for(;n.length<e;)n="0"+n;return n}ai.exports=Vm});var li=c((ZS,ci)=>{var Ym=We(),Jm=j();function $m(t,e){let n=e?t:t.copy();return n.index=Jm(0,t.shape[0]).map(r=>"row"+Ym(r,(n.index.length-1).toString().length)),n}ci.exports=$m});var Oe=c((e2,hi)=>{var Gm=m(),Lm=T(),Wm=d(),Km=y(),Hm=q();function fi(t){if(Km(t)||Hm(t))return fi(t.values);Gm(Wm(t),"The `product` function only works on arrays, Series, and DataFrames!");try{return t.length===0?NaN:Lm(t).reduce((e,n)=>e*n,1)}catch{return NaN}}hi.exports=fi});var Ke=c((t2,gi)=>{var De=m(),mi=T(),di=d(),Xm=y(),pi=g(),Qm=q(),Zm=Oe(),ed=x();function Lt(t,e){if(Xm(t)||Qm(t))return Lt(t.values,e);if(De(di(t),"The first argument passed into the `reshape` function must be an array!"),pi(e)&&(e=[e]),De(di(e),"The second argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),De(ed(e).length===1,"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),e.forEach(i=>{De(pi(i)&&parseInt(i)===i&&i>0,"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!")}),e.length===0)return mi(t);let n=mi(t);if(e.length===1&&e[0]===n.length)return n;De(Zm(e)===n.length,"The new shape doesn't match the number of values available in `x` (the first argument passed into the `reshape` function)!");let r=[],s=parseInt(n.length/e[0]);for(let i=0;i<e[0];i++){let o=n.slice(i*s,(i+1)*s);r.push(Lt(o,e.slice(1)))}return r}gi.exports=Lt});var ue=c((n2,Si)=>{var td=m(),bi=C(),nd=d(),rd=g(),vi=v(),sd=J(),id=Oe(),od=Ke(),Ni=Math.pow(2,64),_=[];wi(parseInt(Math.random()*Ni));function ud(t,e){t=I(t);function n(){t+=I("0x9e3779b97f4a7c15");let s=bi(t);return s=(s^s>>30n)*I("0xbf58476d1ce4e5b9"),s=(s^s>>27n)*I("0x94d049bb133111eb"),s^s>>31n}let r=[];for(let s=0;s<e;s++)r.push(n());return r}function I(t){return BigInt.asUintN(64,BigInt(t))}function qi(t,e){return t=I(t),e=BigInt(e),I(I(t<<e)|I(t>>I(64n-e)))}function wi(t){if(vi(t))return bi(_);{td(rd(t),"If passing a value into the `seed` function, then that value must be an integer!");let e=ud(parseInt(t),4);_[0]=e[0],_[1]=e[1],_[2]=e[2],_[3]=e[3]}}function yi(){let t=I(qi(_[0]+_[3],23)+_[0]),e=I(_[1]<<17n);return _[2]=I(_[2]^_[0]),_[3]=I(_[3]^_[1]),_[1]=I(_[1]^_[2]),_[0]=I(_[0]^_[3]),_[2]=I(_[2]^e),_[3]=qi(_[3],45),parseInt(t)/Ni}function ad(t){return vi(t)?yi():(nd(t)||(t=[t]),od(sd(id(t)).map(yi),t))}Si.exports={random:ad,seed:wi}});var He=c((r2,xi)=>{var{random:cd}=ue(),ld=m(),fd=d(),hd=y(),md=q();function dd(t){if(hd(t)||md(t))return t.shuffle(...Object.values(arguments).slice(1));ld(fd(t),"The `shuffle` function only works on arrays, Series, and DataFrames!");let e=[],n=t.slice();for(let r=0;r<t.length;r++){let s=parseInt(cd()*n.length);e.push(n.splice(s,1)[0])}return e}xi.exports=dd});var Oi=c((s2,Ti)=>{var pd=m(),gd=v(),_i=He();function qd(t,e){return gd(e)&&(e=0),pd(e===0||e===1,"The `axis` parameter to the `shuffle` must be 0, 1, or undefined."),t.get(e===0?_i(t.index):null,e===1?_i(t.columns):null)}Ti.exports=qd});var Wt=c((i2,Di)=>{function yd(t){return typeof t=="boolean"}Di.exports=yd});var Mi=c((o2,Ei)=>{var{random:bd}=ue(),M=m(),vd=T(),Fi=d(),Kt=Wt(),Ai=A(),Xe=g(),ae=E(),Ht=v(),Nd=j(),Ii=x(),Xt=$();function wd(t,e,n){return Ai(e)?Sd(t,e,n):xd(t,e,n)}function Sd(t,e,n){if(n=Ht(n)?0:n,M(Ai(e),"When sorting a DataFrame using a function, the first argument to the `sort` method must be a function!"),M(Xe(n),"When sorting a DataFrame using a function, the second argument to the `sort` method must be null, undefined, 0, or 1 to indicate the axis along which the data should be sorted! An axis of 0 means that the rows will be sorted relative to each other, whereas an axis of 1 means that the columns will be sorted relative to each other."),n===0){let r=Xt(t.index,(s,i)=>e(t.get(s,null),t.get(i,null)));return t.get(r,null)}else{let r=Xt(t.columns,(s,i)=>e(t.get(null,s),t.get(null,i)));return t.get(null,r)}}function xd(t,e,n){let r=t.copy(),s=bd().toString();return r=r.assign(s,r.index),Ht(e)&&(e=[s],n=[!0]),(Xe(e)||ae(e))&&(e=[e],(Kt(n)||ae(n))&&(n=[n])),M(Fi(e),"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),M(Ii(e).length===1,"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),Ht(n)&&(n=Nd(0,e.length).map(()=>!0)),M(Fi(n),"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),M(Ii(n).length===1,"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),M(e.length===n.length,"The arrays passed into the `sort` method must be equal in length."),e=e.map(i=>{if(M(ae(i)||Xe(i),"Column references can either be column names (as strings) or column indices (as whole numbers)."),ae(i)){let o=r.columns.indexOf(i);return M(o>-1,`The column "${i}" does not exist!`),o}if(Xe(i))return M(parseInt(i)===i,"Column indices must be whole numbers!"),M(i>=0,`The column index ${i} is out of bounds!`),M(i<r.columns.length,`The index ${i} is out of bounds!`),i}),n=n.map(i=>{if(M(ae(i)||Kt(i),"Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),ae(i)){let o=i.trim().toLowerCase();return M(o==="ascending"||o==="descending","Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),o==="ascending"}if(Kt(i))return i}),r.values=Xt(r.values,(i,o)=>{let u=0;for(;i[e[u]]===o[e[u]]&&u<e.length;)u++;let a=n[u];if(i[e[u]]===o[e[u]])return 0;if(i[e[u]]<o[e[u]])return a?-1:1;if(i[e[u]]>o[e[u]])return a?1:-1}),r.index=vd(r.get(null,s).values),r=r.dropColumns(s),r}Ei.exports=wd});var Qt=c((u2,ji)=>{function _d(t,e){return JSON.stringify(t.toObject(e))}ji.exports=_d});var ki=c((a2,en)=>{var Zt=se(),Td=Qt();function Od(t,e,n){let r=Td(t,n),s=!1,i=!1,o,u;try{let a=e;if(e.includes("/")){let f=e.split("/");a=f[f.length-1]}let l=document.createElement("a");l.href=`data:application/json;charset=utf-8,${encodeURIComponent(r)}`,l.download=a,l.dispatchEvent(new MouseEvent("click")),s=!0}catch(a){o=a}try{let a=gr("fs"),l=gr("path");a.writeFileSync(l.resolve(e),r,"utf8"),i=!0}catch(a){u=a}if(!s&&!i)throw typeof window<"u"?new Zt(o):typeof en<"u"?new Zt(u):new Zt("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");return t}en.exports=Od});var zi=c((c2,Ci)=>{var Dd=m(),Fd=v();function Id(t,e){Fd(e)?e=0:Dd(e===0||e===1,"The axis parameter of the `toObject` method must be undefined, 0, or 1. An axis of 0 indicates that the returned object should be organized first by rows and then by columns. An axis of 1 indicates that the returned object should be organized first by columns and then by rows.");let n={};return e===0?t.index.forEach((r,s)=>{let i={};t.columns.forEach((o,u)=>{i[o]=t.values[s][u]}),n[r]=i}):t.columns.forEach((r,s)=>{let i={};t.index.forEach((o,u)=>{i[o]=t.values[u][s]}),n[r]=i}),n}Ci.exports=Id});var ee=c((l2,Pi)=>{var Ri=m(),Ad=d(),Ed=y(),Md=q(),jd=J(),Ui=Se(),kd=x();function Cd(t){if(Ed(t)||Md(t))return t.transpose();Ri(Ad(t),"The `transpose` function only works on arrays, Series, and DataFrames!");let e=kd(t);if(Ri(e.length<=2,"I'm not smart enough to know how to transpose arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `transpose` function!"),e.length===1)return Ui(t);if(e.length===2){let n=jd(Ui(e));for(let r=0;r<e[0];r++)for(let s=0;s<e[1];s++)n[s][r]=t[r][s];return n}}Pi.exports=Cd});var Ji=c((f2,Yi)=>{var Bi=m(),zd=d(),Rd=y(),Ud=Be(),Pd=q(),Bd=x();function Vi(t,e,n){if(Pd(n))return new t(e.values.concat(n.values));if(zd(n)){let r=Bd(n);Bi(r.length===1&&!Ud(r),"Only vectors can be appended to Series!");let s=e.copy();return n.forEach((i,o)=>{s._values.push(i),s._index.push("item"+(e.values.length+o))}),s}return Bi(!Rd(n),"DataFrames cannot be appended to Series!"),Vi(e,[n])}Yi.exports=Vi});var Gi=c((h2,$i)=>{var Vd=m(),Yd=A();function Jd(t,e){Vd(Yd(e),"The parameter to the `apply` method must be a function.");let n=t.copy();return n._values=n._values.map((r,s)=>e(r,s)),n}$i.exports=Jd});var Wi=c((m2,Li)=>{var $d=v();function Gd(t){let e=t.copy(),n=[];return e._values=e.values.filter((r,s)=>$d(r)?!1:(n.push(e.index[s]),!0)),e._index=n,e}Li.exports=Gd});var Hi=c((d2,Ki)=>{var Ld=g();function Wd(t,e){let n=[],r=[];e.values.forEach((i,o)=>{Ld(i)&&(r.push(i),n.push(e.index[o]))});let s=new t(r);return s.name=e.name,s.index=n,s}Ki.exports=Wd});var Qi=c((p2,Xi)=>{var Kd=C();function Hd(t,e,n){let r=e.copy(),s=Kd(r.index),i=[],o=r.values.filter((u,a)=>{let l=n(u,a,r.values);return l||i.push(r.index[a]),l});return i.forEach(u=>{s.splice(s.indexOf(u),1)}),o.length===0?(r=new t,r.name=e.name,r):(r.values=o,r.index=s,r)}Xi.exports=Hd});var eo=c((g2,Zi)=>{var W=m(),Xd=g(),Qd=E(),Zd=v(),ep=z();function tp(t,e){(Qd(e)||Xd(e))&&(e=[e]);let n=ep((e||[]).map(r=>typeof r));return W(n.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===1&&W(n[0]==="string"||n[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===2&&(W(n.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),W(n.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),Zd(e)||(e=e.map(r=>{if(typeof r=="string")return W(t.index.indexOf(r)>-1,`Index "${r}" does not exist!`),r;if(typeof r=="number")return W(r>=0,`Index ${r} is out of bounds!`),W(parseInt(r)===r,"Indices must be integers!"),W(r<t.index.length,`Index ${r} is out of bounds!`),t.index[r]})),t.getSubsetByNames(e)}Zi.exports=tp});var no=c((q2,to)=>{var Fe=m(),np=d(),rp=v(),sp=xe(),ip=j(),op=x();function up(t,e){let n=t.shape;rp(e)&&(e=ip(0,n[0])),Fe(np(e),"The `indices` array must be 1-dimensional array of whole numbers."),Fe(op(e).length===1,"The `indices` array must be a 1-dimensional array of whole numbers."),Fe(e.length>0,"The `indices` array must contain at least one index."),e.forEach(s=>{Fe(sp(s),"The `indices` array must be a 1-dimensional array of whole numbers."),Fe(s<t.index.length,`The row index ${s} is out of bounds.`)});let r=e.map(s=>t.index[s]);return t.getSubsetByNames(r)}to.exports=up});var so=c((y2,ro)=>{var Ie=m(),ap=d(),cp=E(),lp=v(),fp=x();function hp(t,e,n){lp(n)&&(n=e.index),Ie(ap(n),"The `indices` array must be a 1-dimensional array of strings."),Ie(fp(n).length===1,"The `indices` array must be a 1-dimensional array of strings."),Ie(n.length>0,"The `indices` array must contain at least one index name."),n.forEach(i=>{Ie(cp(i),"The `indices` array must contain only strings."),Ie(e.index.indexOf(i)>-1,`The name "${i}" does not exist in the index.`)});let r=n.map(i=>e.values[e.index.indexOf(i)]);if(r.length===1)return r[0];let s=new t(r);return s.index=n,s.name=e.name,s}ro.exports=hp});var uo=c((b2,oo)=>{var mp=C(),io=j();function dp(t){let e=t.copy(),n=typeof window>"u"?20:10;if(e.index.length>n){e=e.get(io(0,n/2).concat(io(e.index.length-n/2,e.index.length)));let s=mp(e.index);s.splice(parseInt(s.length/2),0,"..."),e.values.push("..."),e.index.push("..."),e=e.get(s)}let r={};return e.values.forEach((s,i)=>{let o={};o[e.name]=s,r[e.index[i]]=o}),console.table(r),console.log("Shape:",t.shape,`
`),t}oo.exports=dp});var co=c((v2,ao)=>{var pp=He();function gp(t){let e=t.copy();return e.get(pp(e.index))}ao.exports=gp});var fo=c((N2,lo)=>{var qp=m(),yp=A(),bp=v(),vp=$(),Np=ee();function wp(t,e,n){n=n||((a,l)=>a<l?-1:1),qp(bp(n)||yp(n),"You must pass undefined, null, or a comparison function as the second argument to the `sort` method!");let r=Np([e.values,e.index]),s=vp(r,(a,l)=>n(a[0],l[0])),i=[],o=[];s.forEach(a=>{i.push(a[0]),o.push(a[1])});let u=new t;return u._values=i,u._index=o,u.name=e.name,u}lo.exports=wp});var po=c((w2,mo)=>{var Sp=$(),ho=ee();function xp(t,e){let n=ho([e.values,e.index]);n=ho(Sp(n,(s,i)=>{if(s[1]===i[1])return 0;if(s[1]<i[1])return-1;if(s[1]>i[1])return 1}));let r=new t(n[0]);return r.index=n[1],r.name=e.name,r}mo.exports=xp});var qo=c((S2,go)=>{function _p(t){let e={};return e[t.name]={},t.index.forEach((n,r)=>{e[t.name][n]=t.values[r]}),e}go.exports=_p});var wo=c((x2,No)=>{var V=m(),Qe=C(),tn=d(),Tp=E(),Op=v(),yo=We(),bo=j(),Ze=Se(),Dp=Ji(),Fp=Gi(),Ip=Wi(),Ap=Hi(),Ep=Qi(),Mp=eo(),jp=no(),kp=so(),Cp=uo(),zp=co(),Rp=fo(),Up=po(),Pp=qo(),Ae=x(),Bp=ee(),vo=Symbol.for("@jrc03c/js-math-tools/series");No.exports=function(t){class e{static[Symbol.hasInstance](r){try{return!!r._symbol&&r._symbol===vo}catch{return!1}}constructor(r){let s=this;if(s.name="data",Object.defineProperty(s,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:vo}),Object.defineProperty(s,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(s,"values",{configurable:!0,enumerable:!0,get(){return s._values},set(i){V(tn(i),"The new values must be a 1-dimensional array!");let o=Ae(i);V(o.length===1,"The new array of values must be 1-dimensional!"),o[0]<s._index.length?s._index=s._index.slice(0,o[0]):o[0]>s._index.length&&(s._index=s._index.concat(bo(s._index.length,o[0]).map(u=>"item"+yo(u,(i.length-1).toString().length)))),s._values=i}}),Object.defineProperty(s,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(s,"index",{configurable:!0,enumerable:!0,get(){return s._index},set(i){V(tn(i),"The new index must be a 1-dimensional array of strings!"),V(i.length===s.shape[0],"The new index must be the same length as the old index!"),V(Ae(i).length===1,"The new index must be a 1-dimensional array of strings!"),i.forEach(o=>{V(Tp(o),"All of the row names must be strings!")}),s._index=i}}),r){if(r instanceof e)s.name=r.name,s.values=Qe(r.values),s.index=Qe(r.index);else if(tn(r)){let i=Ae(r);V(i.length===1,"When passing an array into the constructor of a Series, the array must be 1-dimensional!"),s.values=r}else if(r instanceof Object){let i=Object.keys(r);V(i.length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");let o=i[0],u=r[o];V(Ae(u).length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!"),s.name=o,s.values=u.slice()}}}get shape(){return Ae(this.values)}get length(){return this.shape[0]}get isEmpty(){return this.values.filter(s=>!Op(s)).length===0}clear(){let s=this.copy();return s.values.forEach((i,o)=>{s.values[o]=void 0}),s}get(r){return Mp(this,r)}getSubsetByNames(r){return kp(e,this,r)}getSubsetByIndices(r){return jp(this,r)}loc(r){return this.getSubsetByNames(r)}iloc(r){return this.getSubsetByIndices(r)}reverse(){let r=this,s=new e(Ze(r.values));return s.index=Ze(r.index),s.name=r.name,s}resetIndex(){let r=this,s=r.copy();return s.index=bo(0,r.shape[0]).map(i=>"item"+yo(i,(s.index.length-1).toString().length)),s}copy(){let r=this,s=new e;return s._values=Qe(r.values),s._index=Qe(r.index),s.name=r.name,s}append(r){return Dp(e,this,r)}apply(r){return Fp(this,r)}concat(r){return this.append(r)}dropMissing(r,s){return Ip(this,r,s)}dropNaN(){return Ap(e,this)}toObject(){return Pp(this)}print(){return Cp(this)}shuffle(){return zp(this)}sort(r){return Rp(e,this,r)}sortByIndex(){return Up(e,this)}filter(r){return Ep(e,this,r)}toDataFrame(){let r=this,s=new t(Bp([r.values]));return s.columns=[r.name],s.index=r.index,s}transpose(){let s=this.copy();return s.values=Ze(s.values),s.index=Ze(s.index),s}getDummies(){return this.toDataFrame().getDummies()}oneHotEncode(){return this.getDummies()}}return e}});var Me=c((_2,Do)=>{var U=m(),nn=C(),So=Ne(),Vp=as(),Yp=ms(),Jp=qs(),$p=bs(),Gp=Ts(),Lp=Fs(),Wp=Ms(),Kp=zs(),Hp=Ps(),xo=Gs(),Xp=ei(),Qp=ii(),Zp=ui(),eg=li(),tg=Oi(),ng=Mi(),rg=ki(),sg=Qt(),ig=zi(),og=T(),Ee=d(),ug=Q(),_o=v(),rn=We(),ag=J(),sn=j(),ce=x(),To=ee(),Oo=Symbol.for("@jrc03c/js-math-tools/dataframe");function et(t){let e="abcdefghijklmnopqrstuvwxyz1234567890",n="";for(let r=0;r<t;r++)n+=e[parseInt(Math.random()*e.length)];return n}var D=class{static[Symbol.hasInstance](e){try{return!!e._symbol&&e._symbol===Oo}catch{return!1}}constructor(e){let n=this;if(Object.defineProperty(n,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:Oo}),Object.defineProperty(n,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(n,"values",{configurable:!0,enumerable:!0,get(){return n._values.length===0||!_o(n._values[0])&&n._values[0].length===0?[[]]:n._values},set(r){U(Ee(r),"The new values must be a 2-dimensional array!");let s=ce(r);U(s.length===2,"The new array of values must be 2-dimensional!"),s[0]<n._index.length?n._index=n._index.slice(0,s[0]):s[0]>n._index.length&&(n._index=n._index.concat(sn(n._index.length,s[0]).map(i=>"row"+rn(i,(s[0]-1).toString().length)))),s[1]<n._columns.length?n._columns=n._columns.slice(0,s[1]):s[1]>n._columns.length&&(n._columns=n._columns.concat(sn(n._columns.length,s[1]).map(i=>"col"+rn(i,(s[1]-1).toString().length)))),n._values=r}}),Object.defineProperty(n,"_columns",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(n,"columns",{configurable:!0,enumerable:!0,get(){return n._columns},set(r){U(Ee(r),"The new columns list must be a 1-dimensional array of strings!"),U(n.isEmpty||r.length===n.shape[1],"The new columns list must be the same length as the old columns list!"),U(ce(r).length===1,"The new columns list must be a 1-dimensional array of strings!"),r=r.map(i=>(typeof i!="string"&&(i=JSON.stringify(i)||i.toString()),i.trim().length===0?"untitled_"+et(8):i.trim()));let s=(()=>{let i=So(r),o={};return i.forEach(u=>{o[u.item]=u.count}),o})();r=r.map(i=>s[i]>1?i+"_"+et(8):i),n._columns=r}}),Object.defineProperty(n,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(n,"index",{configurable:!0,enumerable:!0,get(){return n._index},set(r){U(Ee(r),"The new index must be a 1-dimensional array of strings!"),U(n.isEmpty||r.length===n.shape[0],"The new index must be the same length as the old index!"),U(ce(r).length===1,"The new index must be a 1-dimensional array of strings!"),r=r.map(i=>(typeof i!="string"&&(i=JSON.stringify(i)||i.toString()),i.trim().length===0?"untitled_"+et(8):i.trim()));let s=(()=>{let i=So(r),o={};return i.forEach(u=>{o[u.item]=u.count}),o})();r=r.map(i=>s[i]>1?i+"_"+et(8):i),n._index=r}}),U(_o(e)||ug(e)||Ee(e),"The `data` passed into the constructor of a DataFrame must be either (1) an object where the key-value pairs are (respectively) column names and 1-dimensional arrays of values, or (2) a 2-dimensional array of values."),e)if(e instanceof D)n.values=nn(e.values),n.columns=nn(e.columns),n.index=nn(e.index);else if(Ee(e)){let r=ce(e);U(r.length===2,"The `data` array passed into the constructor of a DataFrame must be 2-dimensional!"),n.values=e}else{n._columns=Object.keys(e);let r=[];n._columns.forEach(i=>{let o=e[i];r.push(o)}),n._values=To(r);let s=ce(n.values);n._index=sn(0,s[0]).map(i=>"row"+rn(i,(s[0]-1).toString().length))}}get shape(){return ce(this.values)}get length(){return this.shape[0]}get width(){return this.shape[1]}get rows(){return this.index}set rows(e){let n=this;n.index=e}get isEmpty(){return og(this.values).length===0}clear(){let e=this,n=new D(ag(e.shape));return n.columns=e.columns.slice(),n.index=e.index.slice(),n}get(e,n){let r=this;if(arguments.length===0)return r;if(arguments.length===1)try{return r.get(null,e)}catch{return r.get(e,null)}return Hp(r,e,n)}getSubsetByNames(e,n){return Qp(D,K,this,e,n)}getSubsetByIndices(e,n){return Xp(this,e,n)}getDummies(e){return xo(D,this,e)}oneHotEncode(e){return xo(D,this,e)}transpose(){let e=this,n=new D(To(e.values));return n.columns=e.index.slice(),n.index=e.columns.slice(),n}get T(){return this.transpose()}resetIndex(e){return eg(this,e)}copy(){return $p(D,this)}assign(e,n){return Jp(D,K,this,e,n)}apply(e,n){return Yp(D,K,this,e,n)}dropMissing(e,n,r){return Lp(D,K,this,e,n,r)}dropNaN(e,n,r){return Wp(D,this,e,n,r)}drop(e,n){return Gp(D,K,this,e,n)}dropColumns(e){return this.drop(null,e)}dropRows(e){return this.drop(e,null)}toObject(e){return ig(this,e)}toJSONString(e){return sg(this,e)}saveAsJSON(e,n){return rg(this,e,n)}print(){return Zp(D,K,this)}sort(e,n){return ng(this,e,n)}sortByIndex(){return this.sort()}filter(e,n){return Kp(D,K,this,e,n)}shuffle(e){return tg(this,e)}append(e,n){return Vp(this,e,n)}concat(e,n){return this.append(e,n)}join(e,n){return this.append(e,n)}toString(){let e=this;return JSON.stringify(e)}},K=wo()(D);Do.exports={DataFrame:D,Series:K}});var le=c((T2,Io)=>{var cg=m(),lg=T(),fg=d(),hg=y(),mg=q();function Fo(t){if(hg(t)||mg(t))return Fo(t.values);cg(fg(t),"The `max` function only works on arrays, Series, and DataFrames!");try{return Math.max(...lg(t))}catch{return NaN}}Io.exports=Fo});var N=c((O2,ko)=>{var{DataFrame:Ao,Series:Eo}=Me(),Mo=m(),je=d(),on=y(),jo=R(),dg=A(),un=q(),pg=le(),gg=j(),tt=x();function qg(t){return je(t)||un(t)||on(t)}function yg(t){return Mo(dg(t),"You must pass a function into the `vectorize` function!"),function e(){let n,r,s=[],i=[],o=Object.keys(arguments).filter(u=>{let a=arguments[u];return je(a)?!0:un(a)?(n=!0,s.push(a),!0):on(a)?(r=!0,i.push(a),!0):!1}).map(u=>arguments[u]);if(o.slice(0,-1).forEach((u,a)=>{Mo(jo(je(u)?tt(u):u.shape,je(o[a+1])?tt(o[a+1]):o[a+1].shape),`When passing multiple arrays into the \`${t.name}\` function, all of the arrays must have the same shape!`)}),o.length>0){let u=pg(o.map(l=>l.length?l.length:l.values.length)),a=gg(0,u).map(l=>{let f=Object.keys(arguments).map(h=>{if(qg(arguments[h])){if(je(arguments[h]))return arguments[h][l];if(un(arguments[h]))return arguments[h].values[l];if(on(arguments[h]))return arguments[h].values[l]}else return arguments[h]});return e(...f)});if(r)try{if(i.length===1&&jo(tt(i[0]),tt(a))){let l=new Ao(a);return l.index=i[0].index.slice(),l.columns=i[0].columns.slice(),l}else return new Ao(a)}catch{return a}if(n)try{if(s.length===1&&s[0].length===a.length){let l=new Eo(a);return l.name=s[0].name,l.index=s[0].index.slice(),l}else return new Eo(a)}catch{return a}return a}else return t(...arguments)}}ko.exports=yg});var nt=c((D2,Co)=>{var bg=g(),vg=N();function Ng(t){try{return bg(t)?Math.abs(t):NaN}catch{return NaN}}Co.exports=vg(Ng)});var rt=c((F2,zo)=>{var wg=g(),Sg=N();function xg(){try{let t=0,e=Object.values(arguments);for(let n=0;n<e.length;n++){if(!wg(e[n]))return NaN;t+=e[n]}return t}catch{return NaN}}zo.exports=Sg(xg)});var ke=c((I2,Ro)=>{var _g=N();function Tg(t,e){try{return e(t)}catch{return NaN}}Ro.exports=_g(Tg)});var Po=c((A2,Uo)=>{var Og=g(),Dg=N();function Fg(t){try{return Og(t)?Math.acos(t):NaN}catch{return NaN}}Uo.exports=Dg(Fg)});var Vo=c((E2,Bo)=>{var Ig=g(),Ag=N();function Eg(t){try{return Ig(t)?Math.asin(t):NaN}catch{return NaN}}Bo.exports=Ag(Eg)});var Jo=c((M2,Yo)=>{var Mg=g(),jg=N();function kg(t){try{return Mg(t)?Math.atan(t):NaN}catch{return NaN}}Yo.exports=jg(kg)});var Go=c((j2,$o)=>{var Cg=m(),zg=be(),Rg=d(),Ug=y(),Pg=q(),Bg=le();function an(t){if(Ug(t)){let e=an(t.values);return[t.index[e[0]],t.columns[e[1]]]}if(Pg(t)){let e=an(t.values);return[t.index[e]]}Cg(Rg(t),"The `argmax` function only works on arrays, Series, and DataFrames!");try{let e=zg(t,Bg(t));return e?e.length===0?void 0:e.length===1?e[0]:e:void 0}catch{return}}$o.exports=an});var st=c((k2,Wo)=>{var Vg=m(),Yg=T(),Jg=d(),$g=y(),Gg=q();function Lo(t){if($g(t)||Gg(t))return Lo(t.values);Vg(Jg(t),"The `min` function only works on arrays, Series, and DataFrames!");try{return Math.min(...Yg(t))}catch{return NaN}}Wo.exports=Lo});var Ho=c((C2,Ko)=>{var Lg=m(),Wg=be(),Kg=d(),Hg=y(),Xg=q(),Qg=st();function cn(t){if(Hg(t)){let e=cn(t.values);return[t.index[e[0]],t.columns[e[1]]]}if(Xg(t)){let e=cn(t.values);return[t.index[e]]}Lg(Kg(t),"The `argmin` function only works on arrays, Series, and DataFrames!");try{let e=Wg(t,Qg(t));return e?e.length===0?void 0:e.length===1?e[0]:e:void 0}catch{return}}Ko.exports=cn});var Qo=c((z2,Xo)=>{var Zg=g(),eq=N();function tq(t){try{return Zg(t)?Math.ceil(t):NaN}catch{return NaN}}Xo.exports=eq(tq)});var tu=c((R2,eu)=>{var nq=nt(),Zo=g(),rq=v(),sq=N();function iq(t,e){try{if(!Zo(t))return NaN;if(rq(e))e=1e-10;else if(!Zo(e))return NaN;return nq(t)<e?0:t}catch{return NaN}}eu.exports=sq(iq)});var ru=c((U2,nu)=>{var ln=g(),oq=N();function uq(t,e,n){try{return ln(t)?ln(e)?ln(n)?t<e?e:t>n?n:t:NaN:NaN:NaN}catch{return NaN}}nu.exports=oq(uq)});var iu=c((P2,su)=>{var fn=m(),aq=T(),cq=d(),lq=y(),fq=g(),hq=q();function hn(t,e){if(lq(t)||hq(t))return hn(t.values,e);if(fn(cq(t),"The `combinations` function only works on arrays, Series, and DataFrames!"),fn(fq(e),"`r` must be a whole number!"),t=aq(t),e>t.length)return[t];if(e<=0)return[[]];if(fn(e===parseInt(e),"`r` must be a whole number!"),t.length<2)return t;let n=[];return t.forEach((r,s)=>{let i=t.slice(s+1);if(i.length<e-1)return;hn(i,e-1).forEach(u=>{n.push([r].concat(u))})}),n}su.exports=hn});var it=c((B2,uu)=>{var mq=m(),dq=T(),pq=d(),gq=y(),qq=q();function ou(t){if(gq(t)||qq(t))return ou(t.values);mq(pq(t),"The `mean` function only works on arrays, Series, and DataFrames!");try{let e=dq(t),n=0;return e.forEach(r=>{n+=r}),n/e.length}catch{return NaN}}uu.exports=ou});var dn=c((V2,mu)=>{var au=m(),cu=d(),ot=g(),lu=q(),fu=it(),hu=x();function mn(t,e){if(lu(t))return mn(t.values,e);if(lu(e))return mn(t,e.values);au(cu(t)&&cu(e)&&hu(t).length===1&&hu(e).length===1,"The `covariance` function only works on 1-dimensional arrays and Series!"),au(t.length===e.length,"The two arrays or Series passed into the `covariance` function must have the same length!");try{let n=fu(t),r=fu(e);if(!ot(n)||!ot(r))return NaN;let s=Math.max(t.length,e.length),i=0;for(let o=0;o<s;o++){if(!ot(t[o]))return NaN;if(!ot(e[o]))return NaN;i+=(t[o]-n)*(e[o]-r)}return i/t.length}catch{return NaN}}mu.exports=mn});var ut=c((Y2,du)=>{var yq=g(),bq=N();function vq(t){try{return yq(t)?Math.sqrt(t):NaN}catch{return NaN}}du.exports=bq(vq)});var pn=c((J2,gu)=>{var Nq=m(),wq=T(),Sq=d(),xq=y(),_q=g(),Tq=q(),Oq=it();function pu(t){if(xq(t)||Tq(t))return pu(t.values);Nq(Sq(t),"The `variance` function only works on arrays, Series, and DataFrames!");try{let e=wq(t),n=Oq(e),r=0;for(let s=0;s<e.length;s++){if(!_q(e[s]))return NaN;r+=(e[s]-n)*(e[s]-n)}return r/e.length}catch{return NaN}}gu.exports=pu});var at=c(($2,yu)=>{var Dq=m(),Fq=d(),Iq=y(),Aq=q(),Eq=ut(),Mq=pn();function qu(t){if(Iq(t)||Aq(t))return qu(t.values);Dq(Fq(t),"The `std` function only works on arrays, Series, and DataFrames!");try{return Eq(Mq(t))}catch{return NaN}}yu.exports=qu});var _u=c((G2,xu)=>{var bu=m(),jq=dn(),vu=d(),Nu=q(),wu=x(),Su=at();function gn(t,e){if(Nu(t))return gn(t.values,e);if(Nu(e))return gn(t,e.values);bu(vu(t)&&vu(e)&&wu(t).length===1&&wu(e).length===1,"The `correl` function only works on 1-dimensional arrays and Series!"),bu(t.length===e.length,"The two arrays or Series passed into the `correl` function must have the same length!");try{return jq(t,e)/(Su(t)*Su(e))}catch{return NaN}}xu.exports=gn});var Ou=c((L2,Tu)=>{var kq=g(),Cq=N();function zq(t){try{return kq(t)?Math.cos(t):NaN}catch{return NaN}}Tu.exports=Cq(zq)});var Fu=c((W2,Du)=>{Du.exports=Object.freeze({boolean:"boolean",date:"date",null:"null",number:"number",object:"object",string:"string"})});var ku=c((K2,ju)=>{var Rq=m(),Iu=d(),Au=y(),Uq=R(),Eu=q(),Mu=z();function qn(t,e){if(Au(t)||Eu(t))return qn(t.values,e);if(Au(e)||Eu(e))return qn(t,e.values);Rq(Iu(t)&&Iu(e),"The `diff` function only works on arrays, Series, and DataFrames!");let n=Mu(t),r=Mu(e),s=[];return n.forEach(i=>{r.findIndex(o=>Uq(o,i))<0&&s.push(i)}),s}ju.exports=qn});var ct=c((H2,zu)=>{var Cu=g(),Pq=N();function Bq(t,e){try{return Cu(t)?Cu(e)?Math.pow(t,e):NaN:NaN}catch{return NaN}}zu.exports=Pq(Bq)});var yn=c((X2,Ru)=>{var Vq=g(),Yq=N();function Jq(){try{let t=Object.values(arguments);if(t.length===0)return NaN;let e=1;for(let n=0;n<t.length;n++){if(!Vq(t[n]))return NaN;e*=t[n]}return e}catch{return NaN}}Ru.exports=Yq(Jq)});var fe=c((Q2,Uu)=>{var $q=yn();function Gq(){return $q(...arguments)}Uu.exports=Gq});var bn=c((Z2,Pu)=>{var Lq=rt(),Wq=fe();function Kq(t,e){return Lq(t,Wq(e,-1))}Pu.exports=Kq});var lt=c((ex,Vu)=>{var Hq=m(),Xq=T(),Qq=d(),Zq=y(),ey=q();function Bu(t){if(Zq(t)||ey(t))return Bu(t.values);Hq(Qq(t),"The `sum` function only works on arrays, Series, and DataFrames!");try{return t.length===0?NaN:Xq(t).reduce((e,n)=>e+n,0)}catch{return NaN}}Vu.exports=Bu});var Ku=c((tx,Wu)=>{var ty=nt(),ny=m(),Yu=d(),Ju=y(),ry=R(),$u=g(),Gu=q(),sy=ct(),Lu=x(),iy=ut(),oy=bn(),uy=lt();function vn(t,e){if($u(t)&&$u(e))return ty(t-e);if(Ju(t)||Gu(t))return vn(t.values,e);if(Ju(e)||Gu(e))return vn(t,e.values);Yu(t)&&Yu(e)&&ny(ry(Lu(t),Lu(e)),"If passing two arrays, Series, or DataFrames into the `distance` function, then those objects must have the same shape!");try{return iy(uy(sy(oy(t,e),2)))}catch{return NaN}}Wu.exports=vn});var Xu=c((nx,Hu)=>{var ay=ct(),cy=fe();function ly(t,e){return cy(t,ay(e,-1))}Hu.exports=ly});var wn=c((rx,ra)=>{var{DataFrame:Qu,Series:Zu}=Me(),ft=m(),ea=T(),ta=d(),Nn=y(),fy=g(),ht=q(),hy=fe(),mt=x(),my=lt(),na=ee();function H(t,e){if(Nn(t)){let s=H(t.values,e);if(mt(s).length===1){let i=new Zu(s);return i.name=ht(e)?e.name:i.name,i.index=t.index.slice(),i}else{let i=new Qu(s);return i.index=t.index.slice(),Nn(e)&&(i.columns=e.columns.slice()),i}}if(Nn(e)){let s=H(t,e.values);if(mt(s).length===1){let i=new Zu(s);return i.name=ht(t)?t.name:i.name,i.index=e.columns.slice(),i}else{let i=new Qu(s);return i.columns=e.columns.slice(),i}}if(ht(t))return H(t.values,e);if(ht(e))return H(t,e.values);ft(ta(t)&&ta(e),"The `dot` function only works on arrays, Series, and DataFrames!"),ea(t).concat(ea(e)).forEach(s=>{ft(fy(s),"One of the arrays you passed into the `dot` function contains non-numerical values!")});let n=mt(t),r=mt(e);if(ft(n.length<=2&&r.length<=2,"I'm not smart enough to know how to get the dot-product of arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `dot` function!"),ft(n[n.length-1]===r[0],`There's a dimension misalignment in the two arrays you passed into the \`dot\` function. (${n[n.length-1]} !== ${r[0]})`),n.length===1&&r.length===1)return my(hy(t,e));if(n.length===1&&r.length===2)return na(e).map(s=>H(t,s));if(n.length===2&&r.length===1)return t.map(s=>H(s,e));if(n.length===2&&r.length===2){let s=na(e),i=[];for(let o=0;o<t.length;o++){let u=[];for(let a=0;a<s.length;a++)u.push(H(t[o],s[a]));i.push(u)}return i}}ra.exports=H});var Sn=c((sx,ia)=>{var dy=m(),py=d(),gy=y(),qy=q(),yy=v();function sa(t){if(gy(t)||qy(t))return t.dropMissing(...Object.values(arguments).slice(1));dy(py(t),"The `dropMissing` function only works on arrays, Series, and DataFrames!");let e=[];return t.forEach(n=>{try{return e.push(sa(n))}catch{yy(n)||e.push(n)}}),e}ia.exports=sa});var ma=c((ix,ha)=>{var oa=m(),ua=d(),aa=y(),by=R(),ca=q(),la=v(),fa=x();function dt(t,e){if(aa(t)||ca(t))return dt(t.values,e);if(aa(e)||ca(e))return dt(t,e.values);oa(ua(t)&&ua(e),"The `dropMissingPairwise` function only works on arrays, Series, and DataFrames!"),oa(by(fa(t),fa(e)),"The two arrays, Series, and/or DataFrames passed into the `dropMissingPairwise` function must have the same shape!");let n=[],r=[];for(let s=0;s<t.length;s++)try{let[i,o]=dt(t[s],e[s]);n.push(i),r.push(o)}catch{!la(t[s])&&!la(e[s])&&(n.push(t[s]),r.push(e[s]))}return[n,r]}ha.exports=dt});var Na=c((ox,va)=>{var da=m(),pa=d(),ga=y(),vy=R(),qa=g(),ya=q(),ba=x();function pt(t,e){if(ga(t)||ya(t))return pt(t.values,e);if(ga(e)||ya(e))return pt(t,e.values);da(pa(t)&&pa(e),"The `dropNaNPairwise` only works on arrays, Series, and DataFrames!"),da(vy(ba(t),ba(e)),"The two arrays, Series, and/or DataFrames passed into the `dropNaNPairwise` must have the same shape!");let n=[],r=[];for(let s=0;s<t.length;s++)try{let[i,o]=pt(t[s],e[s]);n.push(i),r.push(o)}catch{qa(t[s])&&qa(e[s])&&(n.push(t[s]),r.push(e[s]))}return[n,r]}va.exports=pt});var Sa=c((ux,wa)=>{var Ny=Sn();function wy(t){return Ny(t)}wa.exports=wy});var _a=c((ax,xa)=>{var Sy=g(),xy=N();function _y(t){try{return Sy(t)?Math.exp(t):NaN}catch{return NaN}}xa.exports=xy(_y)});var Da=c((cx,Oa)=>{var Ty=N();function Ta(t){try{return t!==parseInt(t)?NaN:t<=1?1:t*Ta(t-1)}catch{return NaN}}Oa.exports=Ty(Ta)});var Ea=c((lx,Aa)=>{var Oy=m(),Dy=T(),Fa=d(),Fy=y(),Iy=A(),Ia=Q(),Ay=q();function xn(t,e){if(Fy(t))return xn(Dy(t.values),e);if(Ay(t))return xn(t.values,e);if(Oy(Ia(t)||Fa(t),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `find` function!"),!Iy(e)){let s=e;e=i=>i===s}function n(s,i,o){if(o=o||[],o.indexOf(s)>-1)return null;if(Ia(s)){o.push(s);let u=Object.keys(s);for(let a=0;a<u.length;a++){let l=u[a],f=s[l];if(i(f))return f;let h=n(f,i,o);if(h)return h}}else if(Fa(s)){o.push(s);for(let u=0;u<s.length;u++){let a=s[u];if(i(a))return a;let l=n(a,i,o);if(l)return l}}else if(i(s))return s;return null}function r(s){try{return e(s)}catch{return!1}}return n(t,r)}Aa.exports=xn});var Ca=c((fx,ka)=>{var Ey=m(),My=T(),Ma=d(),jy=y(),ky=A(),ja=Q(),Cy=q();function _n(t,e){if(jy(t))return _n(My(t.values),e);if(Cy(t))return _n(t.values,e);if(Ey(ja(t)||Ma(t),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `findAll` function!"),!ky(e)){let i=e;e=o=>o===i}function n(i,o,u){if(u=u||[],u.indexOf(i)>-1)return null;if(ja(i)){u.push(i);let a=Object.keys(i),l=[];for(let f=0;f<a.length;f++){let h=a[f],p=i[h],b=!1;o(p)&&(l.push(p),b=!0);let S=n(p,o,u);S&&S.length>0&&S.slice(b?1:0).forEach(O=>l.push(O))}return l}else if(Ma(i)){u.push(i);let a=[];for(let l=0;l<i.length;l++){let f=i[l],h=!1;o(f)&&(a.push(f),h=!0);let p=n(f,o,u);p&&p.length>0&&p.slice(h?1:0).forEach(b=>a.push(b))}return a}else if(o(i))return[i];return null}function r(i){try{return e(i)}catch{return!1}}let s=n(t,r);return s&&s.length>0?s:null}ka.exports=_n});var Ra=c((hx,za)=>{var zy=g(),Ry=N();function Uy(t){try{if(t==="Infinity")return 1/0;if(t==="-Infinity")return-1/0;let e=JSON.parse(t);return zy(e)?e:NaN}catch{return NaN}}za.exports=Ry(Uy)});var Pa=c((mx,Ua)=>{var Py=g(),By=N();function Vy(t){try{return Py(t)?Math.floor(t):NaN}catch{return NaN}}Ua.exports=By(Vy)});var Tn=c((dx,Ba)=>{var Yy=g(),Jy=Oe(),$y=Ke();function Gy(t){Yy(t)&&(t=[t]);let e=[],n=Jy(t);for(let r=0;r<n;r++)e.push(0);return $y(e,t)}Ba.exports=Gy});var Ya=c((px,Va)=>{var gt=m(),Ly=g(),Wy=v(),Ky=Tn();function Hy(t){gt(!Wy(t),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),gt(Ly(t),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),gt(parseInt(t)===t,"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),gt(t>0,"You must pass an integer greater than 0 (representing the size) into the `identity` function!");let e=Ky([t,t]);for(let n=0;n<t;n++)e[n][n]=1;return e}Va.exports=Hy});var $a=c((gx,Ja)=>{Ja.exports=["true","false","yes","no"]});var On=c((qx,Ga)=>{Ga.exports=["null","none","nan","na","n/a","","undefined"]});var Wa=c((yx,La)=>{var Xy=d(),Qy=On();function Zy(t,e){if(t===void 0&&(t="undefined"),e==="null")return null;if(e==="number"){let n=parseFloat(t);return isNaN(n)?NaN:n}if(e==="boolean"){try{let n=t.trim().toLowerCase();if(n==="true"||n==="yes")return!0;if(n==="false"||n==="no")return!1}catch{}return null}if(e==="date"){let n=new Date(t);return n.toString()==="Invalid Date"?null:n}if(e==="object")try{let n=JSON.parse(t);return Xy(n)?null:n}catch{return null}if(e==="string"){try{if(Qy.indexOf(t.trim().toLowerCase())>-1)return null}catch{return null}return t}}La.exports=Zy});var Xa=c((bx,Ha)=>{var e1=ke(),t1=m(),n1=$a(),r1=Wa(),s1=Ne(),i1=T(),Ka=d(),o1=y(),u1=g(),a1=q(),c1=E(),l1=On();function Dn(t){if(o1(t)){let s=t.copy(),i=Dn(t.values);return s.values=i.values,{type:i.type,values:s}}if(a1(t)){let s=t.copy(),i=Dn(t.values);return s.values=i.values,{type:i.type,values:s}}t1(Ka(t),"The `inferType` function only works on arrays, Series, and DataFrames!");let e=i1(t).map(s=>{if(s===void 0)return"null";c1(s)||(s=JSON.stringify(s));let o=s.toLowerCase().trim();if(l1.indexOf(o)>-1)return"null";if(n1.indexOf(o)>-1)return"boolean";try{let u=JSON.parse(s);return u1(u)?"number":typeof u=="object"?Ka(u)?"string":"object":"string"}catch{return new Date(s).toString()!=="Invalid Date"?"date":"string"}}),r=s1(e).sort((s,i)=>i.count-s.count)[0].item;return{type:r,values:e1(t,s=>r1(s,r))}}Ha.exports=Dn});var Za=c((vx,Qa)=>{var f1=g(),h1=N();function m1(t){try{let e=JSON.parse(t);return f1(e)?parseInt(e):NaN}catch{return NaN}}Qa.exports=h1(m1)});var tc=c((Nx,ec)=>{var d1=m(),p1=d(),g1=y(),q1=R(),y1=q(),Fn=z();function b1(){let t=Object.values(arguments).map(n=>g1(n)||y1(n)?Fn(n.values):(d1(p1(n),"The `intersect` function only works on arrays, Series, and DataFrames!"),Fn(n)));return Fn(t).filter(n=>t.every(r=>r.findIndex(s=>q1(s,n))>-1))}ec.exports=b1});var ic=c((wx,sc)=>{var nc=rt(),X=m(),v1=wn(),N1=T(),w1=d(),S1=y(),In=g(),rc=fe(),x1=x();function qt(t){if(S1(t)){let n=t.copy();return n.values=qt(n.values),n}X(w1(t),"The `inverse` function only works on square 2-dimensional arrays or DataFrames!"),N1(t).forEach(n=>X(In(n),"The array passed into the `inverse` function must contain only numbers!"));let e=x1(t);if(X(e.length===2,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),X(e[0]===e[1],"The array passed into the `inverse` function must be exactly two-dimensional and square!"),X(e[0]>=0,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),e[0]===0)return t;if(e[0]===1)return X(t[0][0]!==0,"This matrix cannot be inverted!"),1/t[0][0];if(e[0]===2){let n=t[0][0],r=t[0][1],s=t[1][0],i=t[1][1],o=n*i-r*s;X(o!==0,"This matrix cannot be inverted!");let u=[[i,-r],[-s,n]];return rc(u,1/o)}else if(e[0]>1){let n=(r,s)=>In(r)||In(s)?rc(r,s):v1(r,s);for(let r=1;r<e[0]-1;r++)try{let s=t.slice(0,r).map(O=>O.slice(0,r)),i=t.slice(0,r).map(O=>O.slice(r,e[0])),o=t.slice(r,e[0]).map(O=>O.slice(0,r)),u=t.slice(r,e[0]).map(O=>O.slice(r,e[0])),a=qt(s),l=qt(nc(u,n(-1,n(n(o,a),i)))),f=nc(a,n(n(n(n(a,i),l),o),a)),h=n(-1,n(n(a,i),l)),p=n(-1,n(n(l,o),a)),b=l;return f.map((O,B)=>O.concat(h[B])).concat(p.map((O,B)=>O.concat(b[B])))}catch{}X(!1,"This matrix cannot be inverted!")}}sc.exports=qt});var uc=c((Sx,oc)=>{var An=g(),_1=N();function T1(t,e,n){try{return An(t)?An(e)?An(n)?n*(e-t)+t:NaN:NaN:NaN}catch{return NaN}}oc.exports=_1(T1)});var lc=c((xx,cc)=>{var ac=g(),O1=v(),D1=N();function F1(t,e){try{return e=O1(e)?Math.E:e,ac(t)?ac(e)?Math.log(t)/Math.log(e):NaN:NaN}catch{return NaN}}cc.exports=D1(F1)});var mc=c((_x,hc)=>{var I1=m(),A1=T(),E1=d(),M1=y(),j1=q(),k1=$();function fc(t){if(M1(t)||j1(t))return fc(t.values);I1(E1(t),"The `median` function only works on arrays, Series, and DataFrames!");try{let e=k1(A1(t));return e.length===0?NaN:e.length%2===0?(e[e.length/2-1]+e[e.length/2])/2:e[parseInt(e.length/2)]}catch{return NaN}}hc.exports=fc});var gc=c((Tx,pc)=>{var dc=g(),C1=N();function z1(t,e){try{return dc(t)?dc(e)?t%e:NaN:NaN}catch{return NaN}}pc.exports=C1(z1)});var vc=c((Ox,bc)=>{var R1=m(),U1=Ne(),P1=T(),B1=d(),V1=y(),Y1=q(),J1=z(),qc=$();function yc(t){if(V1(t)||Y1(t))return yc(t.values);R1(B1(t),"The `mode` function only works on arrays, Series, and DataFrames!");try{if(t.length===0)return NaN;let e=P1(t);if(e.length===0)return NaN;let n={},r=J1(e);r.forEach(u=>{n[u]=U1(e,u)});let s=qc(r,(u,a)=>n[a]-n[u]),i=s[0];return qc(s.filter(u=>n[u]===n[i]))}catch{return NaN}}bc.exports=yc});var xc=c((Dx,Sc)=>{var{random:Nc}=ue(),$1=ke(),G1=v(),L1=J();function wc(){let t=Nc(),e=Nc();return Math.sqrt(-2*Math.log(t))*Math.cos(2*Math.PI*e)}function W1(t){return G1(t)?wc():$1(L1(t),wc)}Sc.exports=W1});var Tc=c((Fx,_c)=>{var K1=ke(),H1=J();function X1(t){return K1(H1(t),()=>1)}_c.exports=X1});var Dc=c((Ix,Oc)=>{var En=m(),Q1=T(),Z1=d(),eb=y(),tb=g(),nb=q(),rb=v();function yt(t,e){if(eb(t)||nb(t))return yt(t.values,e);if(En(Z1(t),"The `permutations` function only works on arrays, Series, and DataFrames!"),rb(e)&&(e=t.length),En(tb(e),"`r` must be a whole number!"),t=Q1(t),e>t.length)return yt(t);if(e<=0)return[[]];if(En(e===parseInt(e),"`r` must be a whole number!"),t.length<2)return t;let n=[];return t.forEach((r,s)=>{let i=t.slice(0,s),o=t.slice(s+1),u=i.concat(o);yt(u,e-1).forEach(l=>{n.push([r].concat(l))})}),n}Oc.exports=yt});var Ic=c((Ax,Fc)=>{var{DataFrame:sb,Series:ib}=Me(),ob=d(),ub=y(),ab=we(),cb=q(),lb=x();function fb(){Object.keys(arguments).forEach(t=>{let e=arguments[t];if(ob(e))if(ab(e))console.log(e);else{let n=lb(e);n.length===1?new ib(e).print():n.length==2?new sb(e).print():console.log(e)}else ub(e)||cb(e)?e.print():console.log(e)})}Fc.exports=fb});var Mc=c((Ex,Ec)=>{var hb=d(),mb=g(),Ac=v(),db=le(),pb=st(),gb=N(),qb=gb(function(t,e,n,r,s){try{return[t,e,n,r,s].every(i=>mb(i))?n-e===0?NaN:(s-r)*(t-e)/(n-e)+r:NaN}catch{return NaN}});function yb(t,e,n,r,s){return hb(t)&&Ac(r)&&Ac(s)&&(r=e,s=n,e=pb(t),n=db(t)),qb(t,e,n,r,s)}Ec.exports=yb});var kc=c((Mx,jc)=>{var bb=g(),vb=N();function Nb(t){try{return bb(t)?Math.round(t):NaN}catch{return NaN}}jc.exports=vb(Nb)});var zc=c((jx,Cc)=>{var wb=g(),Sb=N();function xb(t){try{return wb(t)?t<0?-1:t>0?1:0:NaN}catch{return NaN}}Cc.exports=Sb(xb)});var Uc=c((kx,Rc)=>{var _b=g(),Tb=N();function Ob(t){try{return _b(t)?Math.sin(t):NaN}catch{return NaN}}Rc.exports=Tb(Ob)});var Bc=c((Cx,Pc)=>{var Db=at();function Fb(t){return Db(t)}Pc.exports=Fb});var Yc=c((zx,Vc)=>{var Ib=g(),Ab=N();function Eb(t){try{return Ib(t)?Math.tan(t):NaN}catch{return NaN}}Vc.exports=Ab(Eb)});var bt=c((Rx,Gc)=>{var Jc=m(),$c=A();function Mb(t,e){Jc($c(t),"`fn` must be a function!");let n=new Date;return e?t(...e):t(),new Date-n}async function jb(t,e){Jc($c(t),"`fn` must be a function!");let n=new Date;return e?await t(...e):await t(),new Date-n}Gc.exports={timeSync:Mb,timeAsync:jb}});var Wc=c((Ux,Lc)=>{var kb=d(),Cb=y(),zb=q(),Rb=z();function Ub(){return Rb([...arguments].map(t=>kb(t)?t:Cb(t)||zb(t)?t.values:[t]))}Lc.exports=Ub});var Hc=c((Px,Kc)=>{var Pb=m(),Bb=d(),Vb=y(),Yb=q(),Jb=v(),$b=le(),Gb=j();function Lb(){let t=[],e=Object.values(arguments).map(n=>((Vb(n)||Yb(n))&&(n=n.values),Pb(Bb(n),"The `zip` function only works on arrays, Series, and DataFrames!"),n));return Gb(0,$b(e.map(n=>n.length))).forEach(n=>{let r=[];e.forEach(s=>{let i=s[n];r.push(Jb(i)?void 0:i)}),t.push(r)}),t}Kc.exports=Lb});var w=c((Bx,Mn)=>{var{DataFrame:Wb,Series:Kb}=Me(),he={abs:nt(),add:rt(),apply:ke(),arccos:Po(),arcsin:Vo(),arctan:Jo(),argmax:Go(),argmin:Ho(),assert:m(),ceil:Qo(),chop:tu(),clamp:ru(),combinations:iu(),copy:C(),correl:_u(),cos:Ou(),count:Ne(),covariance:dn(),DataFrame:Wb,dataTypes:Fu(),decycle:Ct(),diff:ku(),distance:Ku(),divide:Xu(),dot:wn(),dropMissing:Sn(),dropMissingPairwise:ma(),dropNaN:Jt(),dropNaNPairwise:Na(),dropUndefined:Sa(),exp:_a(),factorial:Da(),find:Ea(),findAll:Ca(),flatten:T(),float:Ra(),floor:Pa(),identity:Ya(),indexOf:be(),inferType:Xa(),int:Za(),intersect:tc(),inverse:ic(),isArray:d(),isBoolean:Wt(),isDataFrame:y(),isEqual:R(),isFunction:A(),isJagged:we(),isNested:Be(),isNumber:g(),isObject:Q(),isSeries:q(),isString:E(),isUndefined:v(),lerp:uc(),log:lc(),MathError:se(),max:le(),mean:it(),median:mc(),min:st(),mod:gc(),mode:vc(),multiply:yn(),ndarray:J(),normal:xc(),ones:Tc(),permutations:Dc(),pow:ct(),print:Ic(),product:Oe(),random:ue().random,range:j(),remap:Mc(),reshape:Ke(),reverse:Se(),round:kc(),scale:fe(),seed:ue().seed,Series:Kb,set:z(),shape:x(),shuffle:He(),sign:zc(),sin:Uc(),sort:$(),sqrt:ut(),std:at(),stdev:Bc(),subtract:bn(),sum:lt(),tan:Yc(),time:bt().timeSync,timeSync:bt().timeSync,timeAsync:bt().timeAsync,transpose:ee(),union:Wc(),variance:pn(),vectorize:N(),zeros:Tn(),zip:Hc(),dump:function(){let t=typeof global<"u"?global:window;if(!t)throw new he.MathError("Cannot dump functions into global scope because neither `global` nor `window` exist in the current context!");Object.keys(he).forEach(e=>{try{Object.defineProperty(t,e,{configurable:!1,enumerable:!0,writable:!1,value:he[e]})}catch{t[e]=he[e]}})}};typeof Mn<"u"&&(Mn.exports=he);typeof window<"u"&&(window.JSMathTools=he)});var P=c((Vx,Xc)=>{Xc.exports={shouldIgnoreNaNValues:!0}});var me=c((Yx,Zc)=>{var{assert:Hb,flatten:Xb,isArray:Qb,isDataFrame:Zb,isNumber:ev,isSeries:tv}=w();function Qc(t){if(Zb(t)||tv(t))return Qc(t.values);Hb(Qb(t),"The `containsOnlyNumbers` function only works on arrays, Series, and DataFrames!");let e=Xb(t);for(let n=0;n<e.length;n++)if(!ev(e[n]))return!1;return!0}Zc.exports=Qc});var kn=c((Jx,el)=>{var{dropMissing:nv,flatten:rv,isArray:sv,isDataFrame:iv,isSeries:ov}=w();function jn(t){return typeof t=="number"?t===0||t===1:iv(t)||ov(t)?jn(t.values):sv(t)?t.length===0?!1:nv(rv(t)).every(n=>jn(n)):!1}el.exports=jn});var Cn=c(($x,cl)=>{var{abs:tl,apply:nl,assert:rl,clamp:uv,copy:av,divide:cv,dropNaN:lv,flatten:fv,isArray:hv,isDataFrame:mv,isNumber:sl,isSeries:dv,max:il,median:ol,min:pv,sort:gv,subtract:ul}=w(),qv=P(),yv=me(),bv=kn();function al(t,e){if(mv(t)||dv(t)){let a=t.copy();return a._values=al(a._values,e),a}if(rl(hv(t),"The `clipOutliers` function only works on arrays, Series, and DataFrames!"),e=e||5,rl(sl(e),"Any `maxScore` value passed into the `clipOutliers` function must be a number!"),!qv.shouldIgnoreNaNValues&&!yv(t))return nl(t,()=>NaN);let n=fv(t),r=lv(n);if(bv(r)||r.length===0)return t;let s=ol(r),i=ol(tl(ul(r,s))),o=!1;if(i===0){let a=gv(av(r)),l=a.filter(b=>b<s),f=a.filter(b=>b>s),h=s,p=s;if(l.length>0&&(h=il(l)),f.length>0&&(p=pv(f)),i=(p-h)/2,i===0)return t;o=(s-h)/i>e||(p-s)/i>e}return il(cv(tl(ul(r,s)),i))>e||o?nl(t,a=>sl(a)?uv(a,s-e*i,s+e*i):a):t}cl.exports=al});var Rn=c((Gx,ql)=>{var{assert:ll,dropNaN:fl,isArray:hl,isSeries:ml,mean:dl,shape:pl,variance:gl}=w(),vv=P();function zn(t,e){if(ml(t))return zn(t.values,e);if(ml(e))return zn(t,e.values);ll(hl(t)&&hl(e)&&pl(t).length===1&&pl(e).length===1,"The `cohensd` function only works on 1-dimensional arrays and Series!"),ll(t.length===e.length,"Two arrays or Series passed into the `cohensd` function must have the same length!"),vv.shouldIgnoreNaNValues&&(t=fl(t),e=fl(e));try{let n=dl(t),r=dl(e),s=Math.sqrt((gl(t)+gl(e))/2);return(n-r)/s}catch{return NaN}}ql.exports=zn});var Nl=c((Lx,vl)=>{var{assert:yl,DataFrame:Nv,isArray:wv,isSeries:Sv,shape:xv,zeros:_v}=w();function bl(t){if(Sv(t)){let r=new Nv(bl(t.values));return r.index=t.index.slice(),r.columns=t.index.slice(),r}yl(wv(t),"The `diagonalize` function only works on 1-dimensional arrays and Series!");let e=xv(t);yl(e.length===1,"The `diagonalize` function only works on 1-dimensional arrays and Series!");let n=_v([e[0],e[0]]);return t.forEach((r,s)=>n[s][s]=r),n}vl.exports=bl});var Vn=c((Wx,_l)=>{var{assert:Un,clamp:Tv,correl:wl,DataFrame:vt,dropNaNPairwise:Ov,isArray:Sl,isDataFrame:Nt,isJagged:xl,isUndefined:Dv,ndarray:Fv}=w(),Iv=P();function Pn(t){let e="@jrc03c/js-data-science-helpers/get-correlation-matrix";return Object.defineProperty(t,e,{configurable:!1,enumerable:!1,writable:!1,value:Symbol.for(e)}),t}function Bn(t,e){if(Dv(e)&&(e=t),Nt(t)){let r=new vt(Bn(t.values,e));return r.index=t.columns.slice(),r.columns=Nt(e)?e.columns.slice():new vt(e).columns.slice(),Pn(r)}if(Nt(e)){let r=new vt(Bn(t,e.values));return r.index=Nt(t)?t.columns.slice():new vt(t).columns.slice(),r.columns=e.columns.slice(),Pn(r)}Un(Sl(t)&&Sl(e),"The `getCorrelationMatrix` function only works on 2-dimensional arrays and DataFrames!"),Un(!xl(t)&&!xl(e),"The `getCorrelationMatrix` function only works on non-jagged 2-dimensional arrays and DataFrames!"),Un(t.length===e.length,'The dimensions of the matrices you passed into the `getCorrelationMatrix` function aren\'t compatible! ([shape(a).join(", ")] vs. [shape(b).join(", ")]) The function expects that you\'ll be comparing the columns of two matrices where the columns are all of the same length, so please make sure that the matrices are oriented accordingly.');let n=Fv([t[0].length,e[0].length]);for(let r=0;r<t[0].length;r++){let s=t.map(i=>i[r]);for(let i=0;i<e[0].length;i++){let o=e.map(u=>u[i]);Iv.shouldIgnoreNaNValues?n[r][i]=wl(...Ov(s,o)):n[r][i]=wl(s,o)}}return Pn(Tv(n,-1,1))}_l.exports=Bn});var Yn=c((Kx,Tl)=>{function Av(t){try{let e="@jrc03c/js-data-science-helpers/get-correlation-matrix";return t[e]===Symbol.for(e)}catch{return!1}}Tl.exports=Av});var Il=c((Hx,Fl)=>{var{DataFrame:Jn,isArray:Ev,isDataFrame:wt,isNumber:Ol,MathError:Mv,sort:jv}=w(),Dl=Vn(),kv=Yn();function Cv(t,e,n){n=Object.values(arguments).find(i=>Ol(i))||1-1e-5;let r=(()=>{let i=Object.values(arguments).filter(o=>Ev(o)||wt(o));if(i.length===1){let o=i[0];if(kv(o))return wt(o)?o:new Jn(o);{let u=Dl(o,null);return wt(u)?u:new Jn(u)}}if(i.length===2){let o=Dl(i[0],i[1]);return wt(o)?o:new Jn(o)}throw new Mv("You must pass 1 or 2 2-dimensional arrays or DataFrames into the `getHighlyCorrelatedColumns` function!")})(),s={};return r.values.forEach((i,o)=>{i.forEach((u,a)=>{if(Ol(u)&&u>n){let l=r.index[o],f=r.columns[a];s[l]||(s[l]=[]),s[l].indexOf(f)<0&&s[l].push(f),s[f]||(s[f]=[]),s[f].indexOf(l)<0&&s[f].push(l)}})}),Object.keys(s).forEach(i=>{s[i]=jv(s[i])}),s}Fl.exports=Cv});var $n=c((Xx,El)=>{var{dropNaN:zv,isArray:Rv,isDataFrame:Uv,isNumber:Pv,isSeries:Bv,pow:Vv,sqrt:Yv,sum:Jv}=w(),$v=P();function Al(t){return Uv(t)||Bv(t)?Al(t.values):Pv(t)?Math.abs(t):Rv(t)?($v.shouldIgnoreNaNValues&&(t=zv(t)),Yv(Jv(Vv(t,2)))):NaN}El.exports=Al});var Gn=c((Qx,kl)=>{var{assert:Ml,DataFrame:Gv,isArray:Lv,isSeries:Wv,isString:Kv,isUndefined:Hv,set:Xv,shape:Qv,sort:Zv}=w();function jl(){if(arguments.length===1&&Wv(arguments[0])){let{name:i,values:o}=arguments[0],u=jl(i,o),a=new Gv(u);return a.index=arguments[0].index.slice(),a}let[t,e]=arguments;Ml(Kv(t),"When passing two arguments into the `getOneHotEncodings` function, the first argument must be a string representing the name of the variable being encoded!"),Ml(Lv(e)&&Qv(e).length===1,"When passing two arguments into the `getOneHotEncodings` function, the second argument must be a 1-dimensional array!");let n={},r=t+"_"+e[0];return Zv(Xv(e)).filter(i=>!Hv(i)).map(i=>t+"_"+i).filter(i=>i!==r).forEach(i=>{n[i]=e.map(o=>i===t+"_"+o?1:0)}),n}kl.exports=jl});var zl=c((Zx,Cl)=>{var{count:eN}=w();function tN(t){return eN(t).map(n=>(n.percentage=n.count/t.length,n))}Cl.exports=tN});var Rl=c((e_,nN)=>{nN.exports=[.5,.49601,.49202,.48803,.48405,.48006,.47608,.4721,.46812,.46414,.46017,.4562,.45224,.44828,.44433,.44038,.4364,.43251,.42858,.42465,.42074,.41683,.41294,.40905,.40517,.40129,.39743,.39358,.38974,.38591,.38209,.37828,.37448,.3707,.36693,.36317,.35942,.35569,.35197,.34827,.34458,.3409,.33724,.3336,.32997,.32636,.32276,.31918,.31561,.31207,.30854,.30503,.30153,.29806,.2946,.29116,.28774,.28434,.28096,.2776,.27425,.27093,.26763,.26435,.26109,.25785,.25463,.25143,.24825,.2451,.24196,.23885,.23576,.2327,.22965,.22663,.22363,.22065,.2177,.21476,.21186,.20897,.20611,.20327,.20045,.19766,.19489,.19215,.18943,.18673,.18406,.18141,.17879,.17619,.17361,.17106,.16853,.16602,.16354,.16109,.15866,.15625,.15386,.15151,.14917,.14686,.14457,.14231,.14007,.13786,.13567,.1335,.13136,.12924,.12714,.12507,.12302,.121,.119,.11702,.11507,.11314,.11123,.10935,.10749,.10565,.10383,.10204,.10027,.09853,.0968,.0951,.09342,.09176,.09012,.08851,.08692,.08534,.08379,.08226,.08076,.07927,.0778,.07636,.07493,.07353,.07215,.07078,.06944,.06811,.06681,.06552,.06426,.06301,.06178,.06057,.05938,.05821,.05705,.05592,.0548,.0537,.05262,.05155,.0505,.04947,.04846,.04746,.04648,.04551,.04457,.04363,.04272,.04182,.04093,.04006,.0392,.03836,.03754,.03673,.03593,.03515,.03438,.03362,.03288,.03216,.03144,.03074,.03005,.02938,.02872,.02807,.02743,.0268,.02619,.02559,.025,.02442,.02385,.0233,.02275,.02222,.02169,.02118,.02068,.02018,.0197,.01923,.01876,.01831,.01786,.01743,.017,.01659,.01618,.01578,.01539,.015,.01463,.01426,.0139,.01355,.01321,.01287,.01255,.01222,.01191,.0116,.0113,.01101,.01072,.01044,.01017,.0099,.00964,.00939,.00914,.00889,.00866,.00842,.0082,.00798,.00776,.00755,.00734,.00714,.00695,.00676,.00657,.00639,.00621,.00604,.00587,.0057,.00554,.00539,.00523,.00508,.00494,.0048,.00466,.00453,.0044,.00427,.00415,.00402,.00391,.00379,.00368,.00357,.00347,.00336,.00326,.00317,.00307,.00298,.00289,.0028,.00272,.00264,.00256,.00248,.0024,.00233,.00226,.00219,.00212,.00205,.00199,.00193,.00187,.00181,.00175,.00169,.00164,.00159,.00154,.00149,.00144,.00139,.00135,.00131,.00126,.00122,.00118,.00114,.00111,.00107,.00104,.001,97e-5,94e-5,9e-4,87e-5,84e-5,82e-5,79e-5,76e-5,74e-5,71e-5,69e-5,66e-5,64e-5,62e-5,6e-4,58e-5,56e-5,54e-5,52e-5,5e-4,48e-5,47e-5,45e-5,43e-5,42e-5,4e-4,39e-5,38e-5,36e-5,35e-5,34e-5,32e-5,31e-5,3e-4,29e-5,28e-5,27e-5,26e-5,25e-5,24e-5,23e-5,22e-5,22e-5,21e-5,2e-4,19e-5,19e-5,18e-5,17e-5,17e-5,16e-5,15e-5,15e-5,14e-5,14e-5,13e-5,13e-5,12e-5,12e-5,11e-5,11e-5,1e-4,1e-4,1e-4,9e-5,9e-5,8e-5,8e-5,8e-5,8e-5,7e-5,7e-5,7e-5,6e-5,6e-5,6e-5,6e-5,5e-5,5e-5,5e-5,5e-5,5e-5,4e-5,4e-5,4e-5,4e-5,4e-5,4e-5,3e-5,3e-5,3e-5,3e-5,3e-5,3e-5,3e-5,3e-5,2e-5,2e-5,2e-5,2e-5]});var Wn=c((t_,Ll)=>{var{abs:Ul,assert:rN,dropNaNPairwise:sN,flatten:St,isArray:Pl,isDataFrame:Bl,isEqual:iN,isSeries:Vl,mean:Yl,remap:oN,round:uN,shape:Jl,sqrt:aN,std:$l}=w(),cN=P(),Gl=Rl();function lN(t){return Ul(t)>4.1?0:Gl[uN(oN(Ul(t),0,4.1,0,Gl.length))]}function Ln(t,e){if(Bl(t)||Vl(t))return Ln(t.values,e);if(Bl(e)||Vl(e))return Ln(t,e.values);rN(Pl(t)&&Pl(e)&&iN(Jl(t),Jl(e)),"You must pass two identically-shaped arrays, Series, or DataFrames into the `pValue` function!");let[n,r]=cN.shouldIgnoreNaNValues?sN(St(t),St(e)):[St(t),St(e)];if(n.length===0||r.length===0)return NaN;let s=Yl(n),i=Yl(r),o=$l(n),u=$l(r),a=n.length,l=r.length,f=(s-i)/aN(o*o/a+u*u/l);return 2*lN(f)}Ll.exports=Ln});var Ql=c((n_,Xl)=>{var{assert:Kn,clamp:fN,DataFrame:xt,dropNaNPairwise:hN,isArray:Wl,isDataFrame:_t,isJagged:Kl,isUndefined:mN,ndarray:dN}=w(),pN=P(),Hl=Wn();function Hn(t){let e="@jrc03c/js-data-science-helpers/get-p-value-matrix";return Object.defineProperty(t,e,{configurable:!1,enumerable:!1,writable:!1,value:Symbol.for(e)}),t}function Xn(t,e){if(mN(e)&&(e=t),_t(t)){let r=new xt(Xn(t.values,e));return r.index=t.columns.slice(),r.columns=_t(e)?e.columns.slice():new xt(e).columns.slice(),Hn(r)}if(_t(e)){let r=new xt(Xn(t,e.values));return r.index=_t(t)?t.columns.slice():new xt(t).columns.slice(),r.columns=e.columns.slice(),Hn(r)}Kn(Wl(t)&&Wl(e),"The `getPValueMatrix` function only works on 2-dimensional arrays and DataFrames!"),Kn(!Kl(t)&&!Kl(e),"The `getPValueMatrix` function only works on non-jagged 2-dimensional arrays and DataFrames!"),Kn(t.length===e.length,'The dimensions of the matrices you passed into the `getPValueMatrix` function aren\'t compatible! ([shape(a).join(", ")] vs. [shape(b).join(", ")]) The function expects that you\'ll be comparing the columns of two matrices where the columns are all of the same length, so please make sure that the matrices are oriented accordingly.');let n=dN([t[0].length,e[0].length]);for(let r=0;r<t[0].length;r++){let s=t.map(i=>i[r]);for(let i=0;i<e[0].length;i++){let o=e.map(u=>u[i]);pN.shouldIgnoreNaNValues?n[r][i]=Hl(...hN(s,o)):n[r][i]=Hl(s,o)}}return Hn(fN(n,0,1))}Xl.exports=Xn});var rf=c((r_,nf)=>{var{assert:Tt,intersect:gN,isDataFrame:Zl,isSeries:ef,isUndefined:tf}=w(),de=class{constructor(e){let n=this;Tt(tf(e)||e===de.DROP_NAN_MODE||e===de.DROP_MISSING_MODE,"The `mode` value passed into the `IndexMatcher` constructor must be undefined or one of [IndexMatcher.DROP_NAN_MODE, IndexMatcher.DROP_MISSING_MODE]! (By default, the mode is `Indexer.DROP_MISSING_MODE`.)"),n.mode=tf(e)?de.DROP_MISSING_MODE:e,n.index=null}fit(){let e=this,n=[];return Object.values(arguments).forEach(r=>{Tt(Zl(r)||ef(r),"The `IndexMatcher` only works on Series and DataFrames! To drop NaN values in a pair-wise fashion from regular arrays, use the `dropNaNPairwise` function from the @jrc03c/js-math-tools library."),e.mode===de.DROP_MISSING_MODE?n.push(r.dropMissing().index):n.push(r.dropNaN().index)}),e.index=gN(...n),e}transform(){let e=this;Tt(!!e.index,"The IndexMatcher hasn't been fitted yet! Please call the `fit` method before calling the `transform` method.");let n=Object.values(arguments).map(r=>(Tt(Zl(r)||ef(r),"The `IndexMatcher` only works on Series and DataFrames! To drop NaN values in a pair-wise fashion from regular arrays, use the `dropNaNPairwise` function from the @jrc03c/js-math-tools library."),r.get(e.index,null)));return n.length===1?n[0]:n}fitAndTransform(){return this.fit(...arguments).transform(...arguments)}},Ce=de;Et(Ce,"DROP_NAN_MODE","DROP_NAN_MODE"),Et(Ce,"DROP_MISSING_MODE","DROP_MISSING_MODE");nf.exports=Ce});var Zn=c((s_,cf)=>{var{assert:Qn,isArray:qN,isBoolean:yN,isDataFrame:sf,isSeries:of,int:bN,isNumber:vN,isUndefined:uf,range:af,set:NN,shape:wN,shuffle:SN}=w();cf.exports=function(){let e=Array.from(arguments),n=e.find(b=>yN(b)),r=uf(n)?!0:n,s=e.find(b=>vN(b)),i=uf(s)?.1:s;Qn(i>0&&i<1,"`testSize` must be a number between 0 and 1 (exclusive on both ends)!");let o=e.filter(b=>qN(b)||sf(b)||of(b));Qn(o.length>0,"You must pass at least one dataset into the `trainTestSplit` function!");let u=o.map(b=>wN(b)[0]);Qn(NN(u).length===1,`All datasets passed into the \`trainTestSplit\` function must be the same length at their shallowest dimension! The lengths of your datasets, though, are: ${u.join(", ")}`);let a=[],l=r?SN(af(0,u[0])):af(0,u[0]),f=bN((1-i)*l.length),h=l.slice(0,f),p=l.slice(f);return o.forEach(b=>{if(sf(b))a.push(b.get(h,null)),a.push(b.get(p,null));else if(of(b))a.push(b.get(h)),a.push(b.get(p));else{let S=[],O=[];b.forEach((B,F)=>{h.indexOf(F)>-1?S.push(B):O.push(B)}),a.push(S),a.push(O)}}),a}});var Dt=c((i_,pf)=>{var{add:xN,argmin:_N,assert:TN,flatten:lf,isArray:ON,isDataFrame:ff,isEqual:DN,int:FN,isNumber:IN,isSeries:hf,normal:er,pow:AN,random:EN,range:MN,scale:jN,shape:Ot,subtract:kN,sum:CN}=w(),zN=Zn();function tr(t,e){(ff(t)||hf(t))&&(t=t.values),(ff(e)||hf(e))&&(e=e.values),TN(DN(Ot(t),Ot(e)),"`yPred` and `yTrue` must have the same shape!");let n=lf(t),r=lf(e),s=0;return n.forEach((i,o)=>{i===r[o]&&s++}),s/n.length}function RN(t){test(`tests that the \`${t.name}\` model works correctly`,()=>{let e=er([5,10]).map(h=>h.map(p=>p*100+er()*100)),n=[],r=MN(0,500).map(()=>{let h=FN(EN()*e.length),p=e[h];return n.push(h),xN(p,jN(5,er(Ot(p))))}),[s,i,o,u]=zN(r,n),a=new t({k:e.length});a.fit(s),a.centroids=mf(e,a.centroids);let l=a.predict(s),f=a.predict(i);expect(tr(o,l)).toBeGreaterThan(.95),expect(tr(u,f)).toBeGreaterThan(.95)})}function UN(t){return ON(t)&&Ot(t).length===2}function PN(t){return IN(t)&&parseInt(t)===t&&t>=0}function mf(t,e){return t.map(n=>e[_N(e.map(r=>df(n,r)))])}function df(t,e){return CN(AN(kN(t,e),2))}pf.exports={accuracy:tr,createGenericTest:RN,isMatrix:UN,isWholeNumber:PN,orderCentroids:mf,sse:df}});var sr=c((o_,bf)=>{var{add:gf,argmin:BN,assert:te,copy:VN,distance:qf,divide:YN,isDataFrame:JN,isFunction:$N,isUndefined:Ft,normal:GN,random:LN,range:WN,scale:KN,shuffle:HN,zeros:yf}=w(),{isMatrix:XN,isWholeNumber:nr,sse:QN}=Dt(),rr=class{constructor(e){te(typeof e=="object","`config` must be an object! See the documentation for more information about the properties that the `config` object can contain."),te(nr(e.k),"`k` must be a whole number!"),te(nr(e.maxIterations)||Ft(e.maxIterations),"`maxIterations` must be a whole number or undefined!"),te(nr(e.maxRestarts)||Ft(e.maxRestarts),"`maxRestarts` must be a whole number or undefined!"),te(typeof e.tolerance=="number"||Ft(e.tolerance),"`tolerance` must be a number or undefined!");let n=this;n.k=e.k,n.maxRestarts=e.maxRestarts||25,n.maxIterations=e.maxIterations||100,n.tolerance=e.tolerance||1e-4,n.centroids=null,n._fitState=null}initializeCentroids(e){let n=this;return HN(e).slice(0,n.k)}fitStep(e,n){let r=this;if(te(XN(e),"`x` must be a matrix!"),JN(e)&&(e=e.values),Ft(n)||te($N(n),"If defined, `progress` must be a function!"),r._fitState){if(r._fitState.isFinished)return r}else{let a=r.initializeCentroids(e);r._fitState={currentRestart:0,currentIteration:0,currentCentroids:a,bestCentroids:a,bestScore:-1/0,isFinished:!1}}let s=r.predict(e,r._fitState.currentCentroids),i=[],o=yf(r.k);e.forEach((a,l)=>{let f=s[l];i[f]||(i[f]=yf(a.length)),i[f]=gf(i[f],a),o[f]++});let u=WN(0,r.k).map(a=>o[a]===0?gf(r._fitState.currentCentroids[parseInt(LN()*r._fitState.currentCentroids.length)],KN(.001,GN(r._fitState.currentCentroids[0].length))):YN(i[a],o[a]));if(qf(r._fitState.currentCentroids,u)<r.tolerance?r._fitState.currentIteration=r.maxIterations-1:r._fitState.currentCentroids=u,n&&n((r._fitState.currentRestart+r._fitState.currentIteration/r.maxIterations)/r.maxRestarts,r),r._fitState.currentIteration++,r._fitState.currentIteration>=r.maxIterations){let a=r.score(e,r._fitState.currentCentroids);if(a>r._fitState.bestScore&&(r._fitState.bestScore=a,r._fitState.bestCentroids=VN(r._fitState.currentCentroids)),r._fitState.currentIteration=0,r._fitState.currentRestart++,r._fitState.currentRestart>=r.maxRestarts)r._fitState.isFinished=!0,r.centroids=r._fitState.bestCentroids,n&&n(1,r);else{let l=r.initializeCentroids(e);r._fitState.currentCentroids=l}}return r}fit(e,n){let r=this;for(r._fitState&&(r._fitState=null);!r._fitState||!r._fitState.isFinished;)r.fitStep(e,n);return r}predict(e,n){if(n=n||this.centroids,!n)throw new Error("No centroids were provided to the `predict` method, and the K-Means model hasn't been fitted yet. Please either pass centroids as a second parameter to the `predict` method or run the `fit` method first!");return e.map(s=>BN(n.map(i=>qf(s,i))))}score(e,n){let r=this;if(n=n||r.centroids,!n)throw new Error("No centroids were provided to the `score` method, and the K-Means model hasn't been fitted yet. Please either pass centroids as a second parameter to the `score` method or run the `fit` method first!");let i=r.predict(e,n).map(o=>n[o]);return-QN(e,i)}};bf.exports=rr});var or=c((u_,wf)=>{var{argmin:ZN,distance:vf,divide:ew,max:tw,random:Nf}=w(),nw=sr(),ir=class extends nw{initializeCentroids(e){let n=this,r=[e[parseInt(Nf()*e.length)]];for(;r.length<n.k;){let s=e.map(o=>vf(o,r[ZN(r.map(u=>vf(o,u)))])),i=ew(s,tw(s));r.push(e[i.findIndex(o=>Nf()<o)])}return r}};wf.exports=ir});var _f=c((a_,xf)=>{var{assert:Y,isArray:rw,isDataFrame:sw,isEqual:iw,isFunction:ow,isUndefined:pe,range:uw,shape:Sf}=w(),{isMatrix:aw,isWholeNumber:ur}=Dt(),cw=or(),ar=class{constructor(e){pe(e)&&(e={}),Y(typeof e=="object","`config` must be an object! See the documentation for more information about the properties that the `config` object can contain."),pe(e.ks)&&(e.ks=uw(1,16)),Y(rw(e.ks),"`ks` must be an array of whole numbers!"),e.ks.forEach(r=>{Y(ur(r),"`ks` must be an array of whole numbers!")}),Y(ur(e.maxIterations)||pe(e.maxIterations),"`maxIterations` must be a whole number or undefined!"),Y(ur(e.maxRestarts)||pe(e.maxRestarts),"`maxRestarts` must be a whole number or undefined!"),Y(typeof e.tolerance=="number"||pe(e.tolerance),"`tolerance` must be a number or undefined!");let n=this;n.ks=e.ks,n.maxRestarts=e.maxRestarts||25,n.maxIterations=e.maxIterations||100,n.tolerance=e.tolerance||1e-4,n.scoreStopRatio=e.scoreStopRatio||.85,n.modelClass=e.modelClass||cw,n.fittedModel=null,n._fitState=null}fitStep(e,n){let r=this;if(Y(aw(e),"`x` must be a matrix!"),sw(e)&&(e=e.values),pe(n)||Y(ow(n),"If defined, `progress` must be a function!"),!r._fitState)r._fitState={isFinished:!1,lastScore:-1/0,currentIndex:0};else if(r._fitState.isFinished)return r;let s=r.ks[r._fitState.currentIndex],i=new r.modelClass({k:s,maxRestarts:10,maxIterations:20});i.fit(e,u=>n?n((r._fitState.currentIndex+u)/(r.ks.length+1)):null);let o=i.score(e);return o/r._fitState.lastScore>r.scoreStopRatio?(r._fitState.isFinished=!0,r._fitState.currentIndex--):(r._fitState.lastScore=o,r._fitState.currentIndex+1>=r.ks.length?r._fitState.isFinished=!0:r._fitState.currentIndex++),r._fitState.isFinished&&(r.fittedModel=new r.modelClass({k:r.ks[r._fitState.currentIndex],maxRestarts:r.maxRestarts,maxIterations:r.maxIterations}),r.fittedModel.fit(e,u=>n?n((r.ks.length+u)/(r.ks.length+1)):null),n&&n(1)),r}fit(e,n){let r=this;for(r._fitState=null;!r._fitState||!r._fitState.isFinished;)r.fitStep(e,n);return r}predict(e,n){return this.fittedModel.predict(e,n)}score(e,n){return this.fittedModel.score(e,n)}get k(){return this.fittedModel.k}set k(e){throw new Error("You can't set the k-value manually! It has to be set automatically via the `fit` method.")}get centroids(){return this.fittedModel.centroids}set centroids(e){let n=this;Y(iw(Sf(e),Sf(n.fittedModel.centroids)),"When assigning a new value to the `centroids` property, the new centroids must have the same shape as the old centroids!"),n.fittedModel.centroids=e}};xf.exports=ar});var Of=c((c_,Tf)=>{Tf.exports={KMeansMeta:_f(),KMeansNaive:sr(),KMeansPlusPlus:or(),helpers:Dt()}});var cr=c((l_,Mf)=>{var{apply:lw,assert:fw,dropNaN:Df,isArray:hw,isDataFrame:mw,isSeries:dw,mean:Ff,std:If}=w(),Af=P();function Ef(t){if(mw(t)||dw(t)){let r=t.copy();return r.values=Ef(r.values),r}fw(hw(t),"The `normalize` function only works on arrays, Series, and DataFrames!");let e=(()=>Af.shouldIgnoreNaNValues?Ff(Df(t)):Ff(t))(),n=(()=>Af.shouldIgnoreNaNValues?If(Df(t)):If(t))();return n===0?t:lw(t,r=>(r-e)/n)}Mf.exports=Ef});var fr=c((f_,Rf)=>{var{assert:ge,dot:jf,isArray:kf,isSeries:lr,scale:pw,Series:gw,shape:Cf}=w(),zf=me();function It(t,e){if(lr(t)){if(lr(e))return new gw(It(t.values,e.values));{let n=t.copy();return n.values=It(t.values,e),n}}if(lr(e)){let n=e.copy();return n.values=It(t,e.values),n}return ge(kf(t),"`project` only works on vectors!"),ge(kf(e),"`project` only works on vectors!"),ge(zf(t),"`project` only works on vectors of numbers!"),ge(zf(e),"`project` only works on vectors of numbers!"),ge(Cf(t).length===1,"`project` only works on vectors!"),ge(Cf(e).length===1,"`project` only works on vectors!"),pw(jf(e,t)/jf(e,e),e)}Rf.exports=It});var Yf=c((h_,Vf)=>{var{assert:Uf,copy:qw,DataFrame:yw,divide:bw,isArray:vw,isDataFrame:Nw,isJagged:ww,shape:Sw,subtract:xw,transpose:Pf}=w(),_w=me(),Tw=$n(),Ow=fr();function Bf(t){if(Nw(t)){let s=new yw(Bf(t.values));return s.index=t.index.slice(),s.columns=t.columns.slice(),s}Uf(vw(t)&&!ww(t)&&Sw(t).length===2,"`orthonormalize` only works on matrices!"),Uf(_w(t),"`orthonormalize` only works on matrices of numbers!");let e=Pf(t),n=[];e.forEach(s=>{let i=qw(s);n.forEach(o=>{i=xw(i,Ow(i,o))}),n.push(i)});let r=n.map(s=>bw(s,Tw(s)));return Pf(r)}Vf.exports=Bf});var Hf=c((m_,Kf)=>{var{assert:qe,correl:Dw,DataFrame:Jf,dropMissing:Fw,inferType:$f,isArray:Iw,isDataFrame:Aw,isEqual:Ew,isFunction:Mw,isJagged:jw,isNumber:ze,isUndefined:kw,set:Cw,shape:zw}=w(),Rw=Cn(),Uw=Gn(),Gf=(t,e)=>t.map(n=>n[e]),Lf=t=>ze(t)&&(parseInt(t)===t||t===1/0);function Wf(t,e){e=e||{};let n=ze(e.maxUniqueStrings)?e.maxUniqueStrings:7,r=ze(e.minNonMissingValues)?e.minNonMissingValues:15,s=ze(e.maxCorrelationThreshold)?e.maxCorrelationThreshold:1-1e-5,i=e.progress||null;if(Iw(t))return qe(zw(t).length===2&&!jw(t),"The `preprocess` function only works on non-jagged 2-dimensional arrays and DataFrames!"),Wf(new Jf(t));qe(Aw(t),"You must pass a DataFrame into the `preprocess` function!"),qe(Lf(n),"`maxUniqueStrings` must be a whole number!"),qe(Lf(r),"`minNonMissingValues` must be a whole number!"),qe(ze(s),"`maxCorrelationThreshold` must be a number!"),kw(i)||qe(Mw(i),"If defined, `progress` must be a function!");let o={},u={},a={},l=t.values;t.columns.forEach((h,p)=>{if(u[h])return;let b=Gf(l,p),S=(()=>{if(o[h])return o[h];{let F=$f(b);return F.type==="date"&&(F.values=F.values.map(ne=>ne-0)),o[h]=F,F}})();if(S.type==="null"||S.type==="object"){u[h]=!0;return}let O=Fw(S.values);if(O.length<=r){u[h]=!0;return}let B=Cw(O);if(B.length<2){u[h]=!0;return}if(S.type==="string"&&B.length<=n){let F=Uw(h,S.values);Object.keys(F).forEach(ne=>{a[ne]=F[ne]}),u[h]=!0;return}S.type==="number"&&(S.values=Rw(S.values)),t.columns.slice(p+1).forEach((F,ne)=>{if(u[F])return;let _h=Gf(l,p+ne+1),ye=(()=>{if(o[F])return o[F];{let re=$f(_h);return re.type==="date"&&(re.values=re.values.map(Th=>Th-0)),o[F]=re,re}})();if(ye.type===S.type){if(ye.type==="number"&&Dw(ye.values,S.values)>s){u[F]=!0;return}if(ye.type==="string"&&Ew(ye.values,S.values)){u[F]=!0;return}}}),a[h]=S.values,i&&i(p/t.columns.length)});let f=new Jf(a);return f.index=t.index.slice(),f}Kf.exports=Wf});var oh=c((d_,ih)=>{var{abs:Pw,add:Bw,assert:Re,isArray:Xf,isDataFrame:Qf,isEqual:Vw,isSeries:Zf,mean:Yw,pow:eh,scale:Jw,shape:th,sign:$w,sqrt:Gw,sum:nh}=w(),rh=me(),sh=(t,e)=>Bw(t,Jw(e,-1));function hr(t,e){if(Qf(t)||Zf(t))return hr(t.values,e);if(Qf(e)||Zf(e))return hr(t,e.values);Re(Xf(t),"You must pass two same-shaped numerical arrays into the `rScore` function!"),Re(Xf(e),"You must pass two same-shaped numerical arrays into the `rScore` function!"),Re(Vw(th(t),th(e)),"You must pass two same-shaped numerical arrays into the `rScore` function!"),Re(rh(t),"You must pass two same-shaped numerical arrays into the `rScore` function!"),Re(rh(e),"You must pass two same-shaped numerical arrays into the `rScore` function!");let n=nh(eh(sh(t,e),2)),r=nh(eh(sh(t,Yw(t)),2));if(r===0)return NaN;let s=1-n/r;return $w(s)*Gw(Pw(s))}ih.exports=hr});var fh=c((p_,lh)=>{var{argmax:uh,assert:Ue,copy:Lw,DataFrame:Ww,dot:Kw,isArray:Hw,isDataFrame:Xw,isEqual:ah,isJagged:Qw,max:Zw,min:eS,reverse:tS,shape:nS,transpose:rS}=w();function ch(t){if(Hw(t)){Ue(nS(t).length===2&&!Qw(t),"The `sortCorrelationMatrix` function only works on 2-dimensional arrays and DataFrames!");let s=new Ww(t);return s.index=s.columns.slice(),ch(s).values}Ue(Xw(t),"You must pass a DataFrame into the `sortCorrelationMatrix` function!"),Ue(Zw(t.values)<=1&&eS(t.values)>=-1,"The correlation matrix passed into the `sortCorrelationMatrix` function must not contain values less than -1 or greater than 1!"),Ue(ah(t.values,rS(t.values)),"The correlation matrix passed into the `sortCorrelationMatrix` function must be symmetrical!"),Ue(ah(t.index,t.columns),"The correlation matrix passed into the `sortCorrelationMatrix` function must be symmetrical! (In this case, although the values themselves are symmetrical, the row and column names differ.)");let e=Lw(t.index),n=[];for(;e.length>0;)if(n.length===0){let s=uh(t.values.map(i=>Kw(i,i)));n.push(e[s]),e.splice(s,1)}else{let s=t.index.indexOf(n.at(-1)),i=uh(e.map(u=>t.values[t.index.indexOf(u)][s])),o=e[i];n.push(o),e.splice(i,1)}let r=tS(n);return t.get(r,r)}lh.exports=ch});var mh=c((g_,hh)=>{var sS=cr();function iS(){return sS(...arguments)}hh.exports=iS});var wh=c((q_,Nh)=>{var{assert:At,DataFrame:dh,dropNaN:oS,flatten:ph,isArray:uS,isDataFrame:mr,isSeries:dr,mean:gh,range:aS,Series:qh,shape:yh,stdev:bh,transpose:vh}=w(),cS=P(),pr=class{constructor(){let e=this;e.means=[],e.stdevs=[],e.wasFittedOnAVector=!1,e.hasBeenFitted=!1}_getDataArrayAndShape(e){if(mr(e))return[e.values,e.shape];if(dr(e)){let r=vh([e.values]);return[r,yh(r)]}At(uS(e),"`x` must be a 1- or 2-dimensional array, DataFrame, or Series!");let n=yh(e);return At(n.length<3,"`x` must be a 1- or 2-dimensional array, DataFrame, or Series!"),n.length===1&&(n.push(1),e=vh([e])),[e,n]}fit(e){let n=this,r=n._getDataArrayAndShape(e);e=r[0];let s=r[1];return n.wasFittedOnAVector=s.indexOf(1)>-1,n.means=[],n.stdevs=[],aS(0,s[1]).forEach(i=>{let o=e.map(u=>u[i]);if(cS.shouldIgnoreNaNValues){let u=oS(o);n.means.push(gh(u)),n.stdevs.push(bh(u))}else n.means.push(gh(o)),n.stdevs.push(bh(o))}),n.hasBeenFitted=!0,n}transform(e){let n=this;if(!n.hasBeenFitted)throw new Error("This `StandardScaler` instance hasn't been trained on any data yet! Please use the `fit` method to train it before calling the `transform` method.");if(mr(e)){let o=new dh(n.transform(e.values));return o.columns=e.columns,o.index=e.index,o}if(dr(e)){let o=new qh(n.transform(e.values));return o.name=e.name,o.index=e.index,o}let r=n._getDataArrayAndShape(e);e=r[0];let s=r[1];At(s[1]===n.means.length,"The data you passed into the `transform` function doesn't have the same number of columns as the data set on which this StandardScaler was fitted!");let i=e.map(o=>o.map((u,a)=>(u-n.means[a])/n.stdevs[a]));return n.wasFittedOnAVector?ph(i):i}untransform(e){let n=this;if(!n.hasBeenFitted)throw new Error("This `StandardScaler` instance hasn't been trained on any data yet! Please use the `fit` method to train it before calling the `transform` method.");if(mr(e)){let o=new dh(n.untransform(e.values));return o.columns=e.columns,o.index=e.index,o}if(dr(e)){let o=new qh(n.untransform(e.values));return o.name=e.name,o.index=e.index,o}let r=n._getDataArrayAndShape(e);e=r[0];let s=r[1];At(s[1]===n.means.length,"The data you passed into the `untransform` function doesn't have the same number of columns as the data set on which this StandardScaler was fitted!");let i=e.map(o=>o.map((u,a)=>u*n.stdevs[a]+n.means[a]));return n.wasFittedOnAVector?ph(i):i}};Nh.exports=pr});var fS=c((y_,xh)=>{var{MathError:lS}=w(),Sh={clipOutliers:Cn(),cohensD:Rn(),cohensd:Rn(),common:P(),containsOnlyNumbers:me(),diagonalize:Nl(),getCorrelationMatrix:Vn(),getHighlyCorrelatedColumns:Il(),getMagnitude:$n(),getOneHotEncodings:Gn(),getPercentages:zl(),getPValueMatrix:Ql(),IndexMatcher:rf(),isBinary:kn(),isCorrelationMatrix:Yn(),KMeans:Of(),normalize:cr(),orthonormalize:Yf(),preprocess:Hf(),project:fr(),pValue:Wn(),rScore:oh(),sortCorrelationMatrix:fh(),standardize:mh(),StandardScaler:wh(),trainTestSplit:Zn(),dump(){let t=this,e=typeof global<"u"?global:typeof window<"u"?window:null;if(!e)throw new lS("Cannot dump functions into global scope because neither `global` nor `window` exist in the current context!");Object.keys(t).forEach(n=>{try{Object.defineProperty(e,n,{configurable:!1,enumerable:!0,writable:!1,value:t[n]})}catch{e[n]=t[n]}})}};try{window.JSDataScienceHelpers=Sh}catch{}try{xh.exports=Sh}catch{}});fS();})();
