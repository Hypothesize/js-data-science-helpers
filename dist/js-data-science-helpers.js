(()=>{var Fh=Object.defineProperty;var Ih=(t,e,n)=>e in t?Fh(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n;var yr=(t=>typeof require!="undefined"?require:typeof Proxy!="undefined"?new Proxy(t,{get:(e,n)=>(typeof require!="undefined"?require:e)[n]}):t)(function(t){if(typeof require!="undefined")return require.apply(this,arguments);throw new Error('Dynamic require of "'+t+'" is not supported')});var c=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports);var Et=(t,e,n)=>(Ih(t,typeof e!="symbol"?e+"":e,n),n);var se=c((dS,br)=>{var Ah=new Function(`
  try {
    return this === window
  } catch(e) {}

  try {
    return typeof importScripts !== "undefined"
  } catch(e) {}

  return false
`),Mt=class extends Error{constructor(e){Ah()?super(e):super(`

\x1B[31m`+e+`
\x1B[0m`)}};br.exports=Mt});var m=c((pS,vr)=>{var Eh=se();vr.exports=function(t,e){if(!t)throw new Eh(e)}});var C=c((gS,Nr)=>{function Mh(t){try{return structuredClone(t)}catch{return t}}Nr.exports=Mh});var d=c((qS,wr)=>{function jh(t){try{return t instanceof Array||typeof t.constructor<"u"&&t.constructor.name==="Array"}catch{return!1}}wr.exports=jh});var y=c((yS,Sr)=>{function kh(t){try{return!!t._symbol&&t._symbol===Symbol.for("@jrc03c/js-math-tools/dataframe")}catch{return!1}}Sr.exports=kh});var q=c((bS,xr)=>{function Ch(t){try{return!!t._symbol&&t._symbol===Symbol.for("@jrc03c/js-math-tools/series")}catch{return!1}}xr.exports=Ch});var T=c((vS,Or)=>{var zh=m(),Rh=C(),_r=d(),Uh=y(),Ph=q();function Tr(t){if(Uh(t)||Ph(t))return Tr(t.values);zh(_r(t),"The `flatten` function only works on arrays, Series, and DataFrames!");function e(n){let r=[];return Rh(n).forEach(s=>{_r(s)?r=r.concat(e(s)):r.push(s)}),r}return e(t)}Or.exports=Tr});var A=c((NS,Dr)=>{function Bh(t){return typeof t=="function"}Dr.exports=Bh});var g=c((wS,Fr)=>{function Vh(t){return typeof t=="number"&&!isNaN(t)}Fr.exports=Vh});var v=c((SS,Ir)=>{function Jh(t){return t===null||typeof t>"u"}Ir.exports=Jh});var Q=c((xS,Ar)=>{var Yh=d(),$h=v();function Gh(t){return typeof t=="object"&&!$h(t)&&!Yh(t)}Ar.exports=Gh});var be=c((_S,jr)=>{var Lh=m(),Er=d(),Wh=y(),Kh=A(),jt=g(),Mr=Q(),Hh=q();function kt(t,e){if(Wh(t)){let i=kt(t.values,e);return i.length>0&&jt(i[0])&&i[0]>=0&&i[0]<t.index.length&&(i[0]=t.index[i[0]]),i.length>1&&jt(i[1])&&i[1]>=0&&i[1]<t.columns.length&&(i[1]=t.columns[i[1]]),i}if(Hh(t)){let i=kt(t.values,e);return i.length>0&&jt(i[0])&&i[0]>=0&&i[0]<t.index.length&&(i[0]=t.index[i[0]]),i}if(Lh(Mr(t)||Er(t),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `indexOf` function!"),!Kh(e)){let i=e;e=o=>o===i}function n(i,o,u){if(u=u||[],u.indexOf(i)>-1)return null;if(Mr(i)){u.push(i);let a=Object.keys(i);for(let l=0;l<a.length;l++){let f=a[l],h=i[f];if(o(h))return[f];let p=n(h,o,u);if(p&&p.length>0)return[f].concat(p)}}else if(Er(i)){u.push(i);for(let a=0;a<i.length;a++){let l=i[a];if(o(l))return[a];let f=n(l,o,u);if(f&&f.length>0)return[a].concat(f)}}else if(o(i))return[];return null}function r(i){try{return e(i)}catch{return!1}}let s=n(t,r);return s&&s.length>0?s:null}jr.exports=kt});var Ct=c((TS,kr)=>{var Xh=C(),Qh=be(),Zh=d(),e0=y(),t0=q();kr.exports=function(e){function n(i,o,u){if(o=o||[],u=u||"",o.indexOf(i)>-1){let a=u.split("/").slice(u.startsWith("/")?1:0);if(a.some((f,h)=>{let p=a.slice(0,a.length-h-1),b=r;return p.forEach(S=>{b=b[S]}),b===i}))return`<reference to "${r===i?"/":"/"+Qh(r,i).join("/")}">`}return typeof i=="object"?i===null?null:(o.push(i),Zh(i)?i.map((a,l)=>n(a,o,u+"/"+l)):(Object.keys(i).forEach(a=>{i[a]=n(i[a],o,u+"/"+a)}),i)):i}let r=Xh(e),s=n(r);if(e0(e)){let i=e.copy();i._values=s.values,i._columns=s.columns,i._index=s.index,s=i}if(t0(e)){let i=e.copy();i.name=s.name,i._values=s.values,i._index=s.index,s=i}return s}});var R=c((OS,Rr)=>{var Cr=C(),zr=Ct();function n0(t,e){function n(r,s){let i=typeof r;if(i!==typeof s)return!1;if(i==="undefined")return!0;if(i==="boolean"||i==="symbol")return r===s;if(i==="number"||i==="bigint")return r.toString()==="NaN"&&s.toString()==="NaN"?!0:r===s;if(i==="string"||i==="function")return r===s;if(i==="object"){if(r===null||s===null)return r===null&&s===null;{let u=Object.keys(r),a=Object.keys(s);if(u.length!==a.length)return!1;for(let l=0;l<u.length;l++){let f=u[l];if(!n(r[f],s[f]))return!1}return!0}}}try{return n(Cr(t),Cr(e))}catch{return n(zr(t),zr(e))}}Rr.exports=n0});var z=c((DS,Vr)=>{var r0=m(),s0=T(),i0=d(),Ur=y(),o0=A(),Pr=q(),u0=v();function ve(t){let e="abcdefg1234567890",n="";for(;n.length<t;)n+=e[parseInt(Math.random()*e.length)];return n}var a0=ve(256),c0=ve(256),l0=ve(256),f0=ve(256),h0=ve(256);function Br(t){if(Ur(t)||Pr(t))return Br(t.values);r0(i0(t),"The `set` function only works on arrays, Series, and DataFrames!");let e=[],n={};return s0(t).forEach(r=>{let s=typeof r=="object"&&r===null?a0:u0(r)?c0:o0(r)?r.toString():typeof r=="symbol"?r.toString()+" - "+h0:r===1/0?l0:r===-1/0?f0:Ur(r)?r.toJSONString():Pr(r)?JSON.stringify(r.toObject()):JSON.stringify(r);n[s]||e.push(r),n[s]=!0}),e}Vr.exports=Br});var Ne=c((FS,$r)=>{var m0=m(),zt=T(),Jr=d(),d0=y(),Yr=R(),p0=A(),g0=q(),q0=z();function Pe(t,e){if(d0(t)||g0(t))return arguments.length>1?Pe(t.values,e):Pe(t.values,t.values);if(m0(Jr(t),"The first argument to the `count` function must be an array, Series, or DataFrame!"),p0(e))return zt(t).filter(n=>e(n)).length;if(Jr(e)){let n=zt(t);return q0(e).map(r=>({item:r,count:n.filter(s=>Yr(s,r)).length}))}else return arguments.length>1?zt(t).filter(n=>Yr(n,e)).length:Pe(t,t)}$r.exports=Pe});var we=c((IS,Lr)=>{var y0=m(),Gr=d(),b0=y(),v0=q();function Rt(t){if(b0(t)||v0(t))return Rt(t.values);y0(Gr(t),"The `isJagged` function only works on arrays, Series, and DataFrames!");let e=0,n=null;for(let r=0;r<t.length;r++)if(Gr(t[r])){if(e++,Rt(t[r]))return!0;if(n===null)n=t[r].length;else if(t[r].length!==n)return!0}return e>0&&e<t.length}Lr.exports=Rt});var Be=c((AS,Hr)=>{var N0=m(),Wr=d(),w0=y(),S0=q();function Kr(t){if(w0(t)||S0(t))return Kr(t.values);N0(Wr(t),"The `isNested` function only works on arrays, Series, and DataFrames!");for(let e=0;e<t.length;e++)if(Wr(t[e]))return!0;return!1}Hr.exports=Kr});var Y=c((ES,Qr)=>{var Z=m(),x0=d(),_0=Be(),T0=g(),O0=v(),ie="You must pass a natural number or a one-dimensional array of natural numbers into the `ndarray` function!";function Xr(t){Z(!O0(t),ie),x0(t)||(t=[t]),Z(!_0(t),ie),Z(t.length>0,ie);let e=t[0];if(Z(T0(e),ie),Z(parseInt(e)===e,ie),Z(e>=0,ie),Z(e!==1/0,"We can't create an array containing an infinite number of values!"),t.length===1){let n=[];for(let r=0;r<e;r++)n.push(void 0);return n}else{let n=[];for(let r=0;r<e;r++)n.push(Xr(t.slice(1)));return n}}Qr.exports=Xr});var Se=c((MS,Zr)=>{var D0=m(),F0=d(),I0=y(),A0=q();function Ut(t){if(I0(t)||A0(t)){let n=t.copy();return n.values=Ut(n.values),n.index=Ut(n.index),n}D0(F0(t),"The `reverse` function only works on arrays, Series, and DataFrames!");let e=[];for(let n=t.length-1;n>=0;n--)e.push(t[n]);return e}Zr.exports=Ut});var j=c((jS,es)=>{var Pt=m(),Bt=g(),Vt=v(),E0=Se();function M0(t,e,n=1){Pt(!Vt(t)&&!Vt(e)&&!Vt(n),"You must pass two numbers and optionally a step value to the `range` function!"),Pt(Bt(t)&&Bt(e)&&Bt(n),"You must pass two numbers and optionally a step value to the `range` function!"),Pt(n>0,"The step value must be greater than 0! (NOTE: The step value is a magnitude; it does not indicate direction.)");let r=!1;if(t>e){r=!0;let i=t;t=e+n,e=i+n}let s=[];for(let i=t;i<e;i+=n)s.push(i);return r&&(s=E0(s)),s}es.exports=M0});var x=c((kS,ss)=>{var j0=m(),ts=d(),k0=y(),C0=R(),z0=q(),R0=v();function ns(t){if(!ts(t))return;let e=[t.length],n=0,r=t.map(s=>{let i=ns(s);return R0(i)?i:(n++,i.length===1?i[0]:i)});return n>0?n===t.length&&r.slice(0,-1).every((i,o)=>C0(i,r[o+1]))?e.concat(r[0]):(e.push(r),e):e}function rs(t){return k0(t)||z0(t)?rs(t.values):(j0(ts(t),"The `shape` function only works on arrays, Series, and DataFrames!"),ns(t))}ss.exports=rs});var ls=c((CS,cs)=>{var is=m(),U0=d(),P0=y(),B0=we(),V0=q(),J0=v(),os=se(),Ve=Y(),us=j(),Y0=z(),$0=x();function as(t,e,n){if(J0(n)&&(n=0),is(n===0||n===1||n==="vertical"||n==="horizontal",'The only valid axis values for use when appending data to a DataFrame are 0, 1, "vertical", and "horizontal". Note that 0 == "horizontal" and 1 == "vertical".'),U0(e)){is(!B0(e),"The array of data you're trying to append to this DataFrame is jagged!");let r=$0(e);if(r.length===1)if(n===0){let s=t.copy();s._values.push(e);let i=Math.max(t.shape[1],r[0]);for(s._values.forEach(o=>{for(;o.length<i;)o.push(void 0)});s._index.length<s._values.length;)s._index.push("row"+s._index.length);for(;s._columns.length<i;)s._columns.push("col"+s._columns.length);return s}else{let s=Math.max(t.shape[0],r[0]),i=t.copy();for(us(0,s).forEach(o=>{o>=i._values.length&&i._values.push(Ve(t.shape[1])),i._values[o].push(e[o])});i._index.length<i._values.length;)i._index.push("row"+i._index.length);for(;i._columns.length<i._values[0].length;)i._columns.push("col"+i._columns.length);return i}else if(r.length===2)if(n===0){let s=Math.max(...e.map(o=>o.length).concat([t.shape[1]])),i=t.copy();for(i._values=i._values.concat(e).map(o=>{for(;o.length<s;)o.push(void 0);return o});i._index.length<i._values.length;)i._index.push("row"+i._index.length);for(;i._columns.length<s;)i._columns.push("col"+i._columns.length);return i}else{let s=Math.max(...e.map(u=>u.length))+t.shape[1],i=Math.max(t.shape[0],r[0]),o=t.copy();for(us(0,i).forEach(u=>{for(u>=o._values.length&&o._values.push(Ve(t.shape[1])),o._values[u]=o._values[u].concat(e[u]);o._values[u].length<s;)o._values[u].push(void 0)});o._index.length<o._values.length;)o._index.push("row"+o._index.length);for(;o._columns.length<s;)o._columns.push("col"+o._columns.length);return o}else throw new os("Only 1- and 2-dimensional arrays can be appended to a DataFrame!")}else if(V0(e)){let r=as(t,e.values,n);return n===0?r.index[r.index.length-1]=r.index.indexOf(e.name)>-1?e.name+" (2)":e.name:r.columns[r.columns.length-1]=r.columns.indexOf(e.name)>-1?e.name+" (2)":e.name,r}else if(P0(e))if(n===0){let r=t.copy(),s=Y0(r._columns.concat(e._columns)).length;for(r._values.forEach(i=>{for(;i.length<s;)i.push(void 0)}),e.apply(i=>{let o=i.copy(),u=[];r._columns.forEach(a=>{let l=o._index.indexOf(a);l>-1?(u.push(o._values[l]),o._values.splice(l,1),o._index.splice(l,1)):u.push(void 0)}),r._values.push(u.concat(o._values))},1),r._columns=r._columns.concat(e._columns.filter(i=>r._columns.indexOf(i)<0));r._index.length<r._values.length;){let i="row"+r._index.length;r._index.push(i+(t._index.indexOf(i)>-1?" (2)":""))}return r}else{let r=t.copy();return r._index.forEach((s,i)=>{let o=e._index.indexOf(s);o>-1?r._values[i]=r._values[i].concat(e._values[o]):r._values[i]=r._values[i].concat(Ve(e.shape[1]))}),e._index.forEach((s,i)=>{r._index.indexOf(s)<0&&(r._index.push(s),r._values.push(Ve(r._columns.length).concat(e._values[i])))}),r._columns=r._columns.concat(e._columns.map(s=>s+(r._columns.indexOf(s)>-1?" (2)":""))),r}else throw new os("Only 1- or 2-dimensional arrays, Series, and DataFrames can be appended to a DataFrame!")}cs.exports=as});var ps=c((zS,ds)=>{var fs=m(),hs=d(),G0=A(),ms=v();function L0(t,e,n,r,s){if(s=s||0,fs(G0(r),"The first parameter to the `apply` method must be a function."),fs(s===0||s===1,"The second parameter to the `apply` method (the `axis`) must be 0 or 1."),s===0){let i={},o;if(n.columns.forEach((u,a)=>{let l=new e(n.values.map(h=>h[a]));l.name=u,l.index=n.index;let f=r(l,a,n);f instanceof e?i[u]=f.values:i[u]=f,ms(o)&&(o=f instanceof e||hs(f))}),o){let u=new t(i);return u.index=n.index,u}else{let u=new e(n.columns.map(a=>i[a]));return u.index=n.columns,u}}else if(s===1){let i,o=n.values.map((u,a)=>{let l=new e(u);l.name=n.index[a],l.index=n.columns;let f=r(l,a,n);return ms(i)&&(i=f instanceof e||hs(f)),f instanceof e?f.values:f});if(i){let u=new t(o);return u.index=n.index,u.columns=n.columns,u}else{let u=new e(o);return u.index=n.index,u}}}ds.exports=L0});var E=c((RS,gs)=>{function W0(t){return typeof t=="string"}gs.exports=W0});var bs=c((US,ys)=>{var qs=m(),K0=d(),H0=we(),X0=Q(),Q0=E(),Z0=v(),em=se(),tm=x();function nm(t,e,n,r,s){let i=u=>u instanceof t,o=u=>u instanceof e;if(Z0(s)){if(i(r))return n.append(r,1);if(o(r))return n.append(r,1);if(X0(r)){let u=Math.max(...Object.keys(r).map(a=>r[a].length));return Object.keys(r).forEach(a=>{for(;r[a].length<u;)r[a].push(void 0)}),n.append(new t(r),1)}else throw new em("You must pass a DataFrame, Series, or object into the `assign` method!")}else{qs(Q0(r),"If passing two arguments into the `assign` method, then the first argument must be a string name!"),qs(K0(s)&&!H0(s)&&tm(s).length===1,"If passing two arguments into the `assign` method, then the second argument must be a 1-dimensional array!");let u=n.append(s,1);return u.columns[u.columns.length-1]=r,u}}ys.exports=nm});var Ns=c((PS,vs)=>{var rm=C();function sm(t,e){if(e.isEmpty)return new t;let n=new t(rm(e.values));return n.columns=e.columns.slice(),n.index=e.index.slice(),n}vs.exports=sm});var Ds=c((BS,Os)=>{var Je=m(),ws=d(),Ss=g(),xs=E(),_s=v(),Ts=x();function im(t,e,n,r,s){_s(r)&&(r=[]),_s(s)&&(s=[]),(xs(r)||Ss(r))&&(r=[r]),(xs(s)||Ss(s))&&(s=[s]),Je(ws(r),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),Je(ws(s),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),Je(Ts(r).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),Je(Ts(s).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");let i,o;n.index.forEach((a,l)=>{r.indexOf(a)<0&&r.indexOf(l)<0&&(i||(i=[]),i.push(a))}),n.columns.forEach((a,l)=>{s.indexOf(a)<0&&s.indexOf(l)<0&&(o||(o=[]),o.push(a))});let u=n.get(i,o);if(u instanceof e){let a=new t;a=a.assign(u),n.index.indexOf(u.name)>-1&&(a=a.transpose()),u=a}return u}Os.exports=im});var xe=c((VS,Fs)=>{var om=g();function um(t){return om(t)&&parseInt(t)===t}function am(t){return um(t)&&t>=0}Fs.exports=am});var As=c((JS,Is)=>{var Jt=m(),cm=E(),Ye=v(),lm=xe(),fm=x();function hm(t,e,n,r,s,i){r=r||0,Jt(r===0||r===1,"The first parameter of the `dropMissing` method (the `axis`) must be 0 or 1."),i=i||0,Jt(lm(i),"The third parameter of the `dropMissing` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` null values)."),s=i>0?"none":s||"any",Jt(s==="any"||s==="all"||s==="none","The second parameter of the `dropMissing` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains null values, then it should be dropped; or that if 'all' of the data contains null values, then it should be dropped).");function o(l){if(i>0){let f=0;for(let h=0;h<l.length;h++){let p=l[h];if(Ye(p)&&f++,f>=i)return[]}}else if(s==="any")for(let f=0;f<l.length;f++){let h=l[f];if(Ye(h))return[]}else if(s==="all"){for(let f=0;f<l.length;f++){let h=l[f];if(!Ye(h))return l}return[]}return l}let u=n.copy(),a=Math.random().toString();if(r===0){u=u.assign(a,u.index);let l=u.values.map(o).filter(h=>h.length>0);if(fm(l).length<2)return new t;u.values=l;let f=u.get(null,a);if(Ye(f))return new t;cm(f)&&(f=[f]),f instanceof e&&(f=f.values),u.index=f,u=u.drop(null,a)}else if(r===1){let l={};if(u.columns.forEach((h,p)=>{let b=u.values.map(O=>O[p]),S=o(b);S.length>0&&(l[h]=S)}),Object.keys(l).length===0)return new t;let f=new t(l);return f.index=u.index,f}return u}Is.exports=hm});var Yt=c((YS,Ms)=>{var mm=m(),dm=d(),pm=y(),gm=g(),qm=q();function Es(t){if(pm(t)||qm(t))return t.dropNaN(...Object.values(arguments).slice(1));mm(dm(t),"The `dropNaN` function only works on arrays, Series, and DataFrames!");let e=[];return t.forEach(n=>{try{return e.push(Es(n))}catch{if(gm(n))return e.push(n)}}),e}Ms.exports=Es});var ks=c(($S,js)=>{var $t=m(),ym=Yt(),bm=xe();function vm(t,e,n,r,s){n=n||0,$t(n===0||n===1,"The first parameter of the `dropNaN` method (the `axis`) must be 0 or 1."),s=s||0,$t(bm(s),"The third parameter of the `dropNaN` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` NaN values)."),r=s>0?"none":r||"any",$t(r==="any"||r==="all"||r==="none","The second parameter of the `dropNaN` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains NaN values, then it should be dropped; or that if 'all' of the data contains NaN values, then it should be dropped).");function i(u){let a=ym(u);return s>0?u.length-a.length<s:r==="any"?a.length===u.length:r==="all"?a.length>0:!0}let o=e.copy();if(n===0){let u=o.index.filter(a=>{let l=o.get(a,null).values;return i(l)});return u.length>0?o.get(u,null):new t}else if(n===1){let u=o.columns.filter(a=>{let l=o.get(null,a).values;return i(l)});return u.length>0?o.get(null,u):new t}return o}js.exports=vm});var Us=c((GS,Rs)=>{var Cs=m(),_e=T(),Nm=A(),wm=v();function zs(t){let e={};return _e(t).forEach((n,r)=>{e[n]=r}),e}function oe(t){return Object.keys(t).sort((e,n)=>t[e]-t[n])}function Sm(t,e,n,r,s){Cs(Nm(r),"The `filter` method takes a single parameter: a function that is used to filter the values."),wm(s)&&(s=0),Cs(s===0||s===1,"The `axis` parameter to the `filter` method must be 0 or 1.");let i=n.copy();if(i.isEmpty)return i;let o=zs(i.index),u=zs(i.columns);if(s===0){let a=i.values.filter((l,f)=>{let h=new e(l);h.name=n.index[f],h.index=n.columns;let p=r(h,f,n);return p||delete o[i.index[f]],p});if(_e(a).length===0)return new t;if(a.length===1){let l=new e(_e(a));return l.name=oe(o)[0],l.index=oe(u),l}i.values=a,i.index=oe(o)}else if(s===1){i=i.transpose();let a=i.values.filter((l,f)=>{let h=new e(l);h.name=n.columns[f],h.index=n.index;let p=r(h,f,n);return p||delete u[i.index[f]],p});if(_e(a).length===0)return new t;if(a.length===1){let l=new e(_e(a));return l.name=oe(u)[0],l.index=oe(o),l}i.values=a,i.index=oe(u),i=i.transpose()}return i}Rs.exports=Sm});var Vs=c((LS,Bs)=>{var k=m(),$e=g(),Ge=E(),Ps=v(),xm=z();function _m(t,e,n){(Ge(e)||$e(e))&&(e=[e]),(Ge(n)||$e(n))&&(n=[n]);let r=xm((e||[]).concat(n||[]).map(s=>typeof s));return k(r.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===1&&k(r[0]==="string"||r[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===2&&(k(r.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),k(r.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),Ps(e)||(e=e.map(s=>{if(Ge(s))return k(t.index.indexOf(s)>-1,`Row "${s}" does not exist!`),s;if($e(s))return k(s>=0,`Index ${s} is out of bounds!`),k(parseInt(s)===s,"Row numbers must be integers!"),k(s<t.index.length,`Index ${s} is out of bounds!`),t.index[s]})),Ps(n)||(n=n.map(s=>{if(Ge(s))return k(t.columns.indexOf(s)>-1,`Column "${s}" does not exist!`),s;if($e(s))return k(s>=0,`Column ${s} is out of bounds!`),k(parseInt(s)===s,"Column numbers must be integers!"),k(s<t.columns.length,`Column ${s} is out of bounds!`),t.columns[s]})),t.getSubsetByNames(e,n)}Bs.exports=_m});var $=c((WS,Ys)=>{var Js=m(),Tm=d(),Om=y(),Dm=A(),Fm=q(),Im=v();function Am(t,e){try{return t<e?-1:t>e?1:0}catch{return t=typeof t=="object"&&t!==null?JSON.stringify(t):t.toString(),e=typeof e=="object"&&e!==null?JSON.stringify(e):e.toString(),t<e?-1:t>e?1:0}}function Em(t,e){if(Im(e)&&(e=Am),Om(t)||Fm(t))return t.sort(...Object.values(arguments).slice(1));Js(Tm(t),"The `sort` function only works on arrays, Series, and DataFrames!"),Js(Dm(e),"The second parameter of the `sort` function must be a comparison function!");let n=t.slice();return n.sort(e),n}Ys.exports=Em});var Ws=c((KS,Ls)=>{var $s=m(),Gs=E(),Mm=v(),jm=z(),km=$();function Cm(t){let e=t.toLowerCase(),n="";for(let s=0;s<e.length;s++){let i=e[s];i.match(/[a-z0-9]/g)?n+=i:n+=" "}let r=n.split(" ").filter(s=>s.length>0);return r[0]+r.slice(1).map(s=>s[0].toUpperCase()+s.substring(1)).join("")}function zm(t,e,n){Mm(n)?n=e.columns:Gs(n)&&(n=[n]);let r={};n.forEach(i=>{$s(Gs(i),"You must pass either a string or a one-dimensional array of strings into the `getDummies` (AKA `oneHotEncode`) method!");let o=e.columns.indexOf(i);$s(o>-1,`The given DataFrame does not have a column called "${i}"!`);let u=e.values.map(l=>l[o]),a=km(jm(u));u.forEach(l=>{a.forEach(f=>{let h=i+"_"+Cm(f.toString());r[h]||(r[h]=[]),l===f?r[h].push(1):r[h].push(0)})})});let s=new t(r);return s.index=e.index,s}Ls.exports=zm});var ni=c((HS,ti)=>{var G=m(),Ks=d(),Hs=g(),Xs=v(),Qs=xe(),Zs=j(),ei=x();function Rm(t,e,n){let r=t.shape;Xs(e)&&(e=Zs(0,r[0])),Xs(n)&&(n=Zs(0,r[1])),Hs(e)&&(e=[e]),Hs(n)&&(n=[n]),G(Ks(e)&&Ks(n),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),G(ei(e).length===1&&ei(n).length===1,"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),G(e.length>0,"The `rowIndices` array must contain at least one index."),G(n.length>0,"The `colIndices` array must contain at least one index."),e.forEach(o=>{G(Qs(o),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),G(o<t.index.length,`The row index ${o} is out of bounds.`)}),n.forEach(o=>{G(Qs(o),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),G(o<t.columns.length,`The column index ${o} is out of bounds.`)});let s=e.map(o=>t.index[o]),i=n.map(o=>t.columns[o]);return t.getSubsetByNames(s,i)}ti.exports=Rm});var ui=c((XS,oi)=>{var L=m(),Gt=T(),ri=d(),Le=E(),si=v(),ii=x();function Um(t,e,n,r,s){si(r)&&(r=n.index),si(s)&&(s=n.columns),Le(r)&&(r=[r]),Le(s)&&(s=[s]),L(ri(r)&&ri(s),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),L(ii(r).length===1&&ii(s).length===1,"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),L(r.length>0,"The `rows` array must contain at least one row name."),L(s.length>0,"The `cols` array must contain at least one column name."),r.forEach(u=>{L(Le(u),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),L(n.index.indexOf(u)>-1,`The row name "${u}" does not exist in the list of rows.`)}),s.forEach(u=>{L(Le(u),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),L(n.columns.indexOf(u)>-1,`The column name "${u}" does not exist in the list of columns.`)});let i=r.map(u=>s.map(a=>n.values[n.index.indexOf(u)][n.columns.indexOf(a)]));if(r.length===1&&s.length===1)return Gt(i)[0];if(r.length===1){let u=new e(Gt(i));return u.name=r[0],u.index=s,u}if(s.length===1){let u=new e(Gt(i));return u.name=s[0],u.index=r,u}let o=new t(i);return o.columns=s,o.index=r,o}oi.exports=Um});var ci=c((QS,ai)=>{var Pm=E(),Te=j();function Bm(t,e,n){function r(p,b){return Pm(p)&&p.length>b?p.substring(0,b-3)+"...":p}if(n.isEmpty)return console.table({}),console.log("Shape:",[0,0],`
`),n;let s=typeof window>"u"?20:10,i=parseInt(s/2),o=typeof process>"u"?10:Math.floor(process.stdout.columns/24)-1,u=parseInt(o/2),a=s>n.index.length?null:Te(0,i).concat(Te(n.index.length-i,n.index.length)),l=o>n.columns.length?null:Te(0,u).concat(Te(n.columns.length-u,n.columns.length)),f=n.get(a,l);f instanceof e&&(n.shape[0]===1?(f=new t([f.values]),f.index=n.index,f.columns=new e(n.columns).get(l).values):n.shape[1]===1&&(f=new t([f.values]).transpose(),f.index=new e(n.index).get(a).values,f.columns=n.columns)),s<=n.index.length&&(f._index.splice(i,0,"..."),f._values.splice(i,0,Te(0,f.columns.length).map(()=>"..."))),o<=n.columns.length&&(f._columns.splice(u,0,"..."),f._values=f._values.map(p=>(p.splice(u,0,"..."),p)));let h=28;return f instanceof e?(f.values=f.values.map(p=>r(p,h)),f.name=r(f.name,h),f.index=f.index.map(p=>r(p,h))):(f.values=f.values.map(p=>p.map(b=>r(b,h))),f.columns=f.columns.map(p=>r(p,h)),f.index=f.index.map(p=>r(p,h))),console.table(f.toObject()),console.log("Shape:",n.shape,`
`),n}ai.exports=Bm});var We=c((ZS,li)=>{var Vm=m(),Jm=g();function Ym(t,e){Vm(Jm(t),"The `leftPad` function only works on numbers!");let n=t.toString();for(;n.length<e;)n="0"+n;return n}li.exports=Ym});var hi=c((e2,fi)=>{var $m=We(),Gm=j();function Lm(t,e){let n=e?t:t.copy();return n.index=Gm(0,t.shape[0]).map(r=>"row"+$m(r,(n.index.length-1).toString().length)),n}fi.exports=Lm});var Oe=c((t2,di)=>{var Wm=m(),Km=T(),Hm=d(),Xm=y(),Qm=q();function mi(t){if(Xm(t)||Qm(t))return mi(t.values);Wm(Hm(t),"The `product` function only works on arrays, Series, and DataFrames!");try{return t.length===0?NaN:Km(t).reduce((e,n)=>e*n,1)}catch{return NaN}}di.exports=mi});var Ke=c((n2,yi)=>{var De=m(),pi=T(),gi=d(),Zm=y(),qi=g(),ed=q(),td=Oe(),nd=x();function Lt(t,e){if(Zm(t)||ed(t))return Lt(t.values,e);if(De(gi(t),"The first argument passed into the `reshape` function must be an array!"),qi(e)&&(e=[e]),De(gi(e),"The second argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),De(nd(e).length===1,"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),e.forEach(i=>{De(qi(i)&&parseInt(i)===i&&i>0,"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!")}),e.length===0)return pi(t);let n=pi(t);if(e.length===1&&e[0]===n.length)return n;De(td(e)===n.length,"The new shape doesn't match the number of values available in `x` (the first argument passed into the `reshape` function)!");let r=[],s=parseInt(n.length/e[0]);for(let i=0;i<e[0];i++){let o=n.slice(i*s,(i+1)*s);r.push(Lt(o,e.slice(1)))}return r}yi.exports=Lt});var ue=c((r2,_i)=>{var rd=m(),Ni=C(),sd=d(),id=g(),wi=v(),od=Y(),ud=Oe(),ad=Ke(),Si=Math.pow(2,64),_=[];xi(parseInt(Math.random()*Si));function cd(t,e){t=I(t);function n(){t+=I("0x9e3779b97f4a7c15");let s=Ni(t);return s=(s^s>>30n)*I("0xbf58476d1ce4e5b9"),s=(s^s>>27n)*I("0x94d049bb133111eb"),s^s>>31n}let r=[];for(let s=0;s<e;s++)r.push(n());return r}function I(t){return BigInt.asUintN(64,BigInt(t))}function bi(t,e){return t=I(t),e=BigInt(e),I(I(t<<e)|I(t>>I(64n-e)))}function xi(t){if(wi(t))return Ni(_);{rd(id(t),"If passing a value into the `seed` function, then that value must be an integer!");let e=cd(parseInt(t),4);_[0]=e[0],_[1]=e[1],_[2]=e[2],_[3]=e[3]}}function vi(){let t=I(bi(_[0]+_[3],23)+_[0]),e=I(_[1]<<17n);return _[2]=I(_[2]^_[0]),_[3]=I(_[3]^_[1]),_[1]=I(_[1]^_[2]),_[0]=I(_[0]^_[3]),_[2]=I(_[2]^e),_[3]=bi(_[3],45),parseInt(t)/Si}function ld(t){return wi(t)?vi():(sd(t)||(t=[t]),ad(od(ud(t)).map(vi),t))}_i.exports={random:ld,seed:xi}});var He=c((s2,Ti)=>{var{random:fd}=ue(),hd=m(),md=d(),dd=y(),pd=q();function gd(t){if(dd(t)||pd(t))return t.shuffle(...Object.values(arguments).slice(1));hd(md(t),"The `shuffle` function only works on arrays, Series, and DataFrames!");let e=[],n=t.slice();for(let r=0;r<t.length;r++){let s=parseInt(fd()*n.length);e.push(n.splice(s,1)[0])}return e}Ti.exports=gd});var Fi=c((i2,Di)=>{var qd=m(),yd=v(),Oi=He();function bd(t,e){return yd(e)&&(e=0),qd(e===0||e===1,"The `axis` parameter to the `shuffle` must be 0, 1, or undefined."),t.get(e===0?Oi(t.index):null,e===1?Oi(t.columns):null)}Di.exports=bd});var Wt=c((o2,Ii)=>{function vd(t){return typeof t=="boolean"}Ii.exports=vd});var ki=c((u2,ji)=>{var{random:Nd}=ue(),M=m(),wd=T(),Ai=d(),Kt=Wt(),Mi=A(),Xe=g(),ae=E(),Ht=v(),Sd=j(),Ei=x(),Xt=$();function xd(t,e,n){return Mi(e)?_d(t,e,n):Td(t,e,n)}function _d(t,e,n){if(n=Ht(n)?0:n,M(Mi(e),"When sorting a DataFrame using a function, the first argument to the `sort` method must be a function!"),M(Xe(n),"When sorting a DataFrame using a function, the second argument to the `sort` method must be null, undefined, 0, or 1 to indicate the axis along which the data should be sorted! An axis of 0 means that the rows will be sorted relative to each other, whereas an axis of 1 means that the columns will be sorted relative to each other."),n===0){let r=Xt(t.index,(s,i)=>e(t.get(s,null),t.get(i,null)));return t.get(r,null)}else{let r=Xt(t.columns,(s,i)=>e(t.get(null,s),t.get(null,i)));return t.get(null,r)}}function Td(t,e,n){let r=t.copy(),s=Nd().toString();return r=r.assign(s,r.index),Ht(e)&&(e=[s],n=[!0]),(Xe(e)||ae(e))&&(e=[e],(Kt(n)||ae(n))&&(n=[n])),M(Ai(e),"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),M(Ei(e).length===1,"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),Ht(n)&&(n=Sd(0,e.length).map(()=>!0)),M(Ai(n),"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),M(Ei(n).length===1,"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),M(e.length===n.length,"The arrays passed into the `sort` method must be equal in length."),e=e.map(i=>{if(M(ae(i)||Xe(i),"Column references can either be column names (as strings) or column indices (as whole numbers)."),ae(i)){let o=r.columns.indexOf(i);return M(o>-1,`The column "${i}" does not exist!`),o}if(Xe(i))return M(parseInt(i)===i,"Column indices must be whole numbers!"),M(i>=0,`The column index ${i} is out of bounds!`),M(i<r.columns.length,`The index ${i} is out of bounds!`),i}),n=n.map(i=>{if(M(ae(i)||Kt(i),"Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),ae(i)){let o=i.trim().toLowerCase();return M(o==="ascending"||o==="descending","Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),o==="ascending"}if(Kt(i))return i}),r.values=Xt(r.values,(i,o)=>{let u=0;for(;i[e[u]]===o[e[u]]&&u<e.length;)u++;let a=n[u];if(i[e[u]]===o[e[u]])return 0;if(i[e[u]]<o[e[u]])return a?-1:1;if(i[e[u]]>o[e[u]])return a?1:-1}),r.index=wd(r.get(null,s).values),r=r.dropColumns(s),r}ji.exports=xd});var Qt=c((a2,Ci)=>{function Od(t,e){return JSON.stringify(t.toObject(e))}Ci.exports=Od});var zi=c((c2,en)=>{var Zt=se(),Dd=Qt();function Fd(t,e,n){let r=Dd(t,n),s=!1,i=!1,o,u;try{let a=e;if(e.includes("/")){let f=e.split("/");a=f[f.length-1]}let l=document.createElement("a");l.href=`data:application/json;charset=utf-8,${encodeURIComponent(r)}`,l.download=a,l.dispatchEvent(new MouseEvent("click")),s=!0}catch(a){o=a}try{let a=yr("fs"),l=yr("path");a.writeFileSync(l.resolve(e),r,"utf8"),i=!0}catch(a){u=a}if(!s&&!i)throw typeof window<"u"?new Zt(o):typeof en<"u"?new Zt(u):new Zt("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");return t}en.exports=Fd});var Ui=c((l2,Ri)=>{var Id=m(),Ad=v();function Ed(t,e){Ad(e)?e=0:Id(e===0||e===1,"The axis parameter of the `toObject` method must be undefined, 0, or 1. An axis of 0 indicates that the returned object should be organized first by rows and then by columns. An axis of 1 indicates that the returned object should be organized first by columns and then by rows.");let n={};return e===0?t.index.forEach((r,s)=>{let i={};t.columns.forEach((o,u)=>{i[o]=t.values[s][u]}),n[r]=i}):t.columns.forEach((r,s)=>{let i={};t.index.forEach((o,u)=>{i[o]=t.values[u][s]}),n[r]=i}),n}Ri.exports=Ed});var ee=c((f2,Vi)=>{var Pi=m(),Md=d(),jd=y(),kd=q(),Cd=Y(),Bi=Se(),zd=x();function Rd(t){if(jd(t)||kd(t))return t.transpose();Pi(Md(t),"The `transpose` function only works on arrays, Series, and DataFrames!");let e=zd(t);if(Pi(e.length<=2,"I'm not smart enough to know how to transpose arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `transpose` function!"),e.length===1)return Bi(t);if(e.length===2){let n=Cd(Bi(e));for(let r=0;r<e[0];r++)for(let s=0;s<e[1];s++)n[s][r]=t[r][s];return n}}Vi.exports=Rd});var Gi=c((h2,$i)=>{var Ji=m(),Ud=d(),Pd=y(),Bd=Be(),Vd=q(),Jd=x();function Yi(t,e,n){if(Vd(n))return new t(e.values.concat(n.values));if(Ud(n)){let r=Jd(n);Ji(r.length===1&&!Bd(r),"Only vectors can be appended to Series!");let s=e.copy();return n.forEach((i,o)=>{s._values.push(i),s._index.push("item"+(e.values.length+o))}),s}return Ji(!Pd(n),"DataFrames cannot be appended to Series!"),Yi(e,[n])}$i.exports=Yi});var Wi=c((m2,Li)=>{var Yd=m(),$d=A();function Gd(t,e){Yd($d(e),"The parameter to the `apply` method must be a function.");let n=t.copy();return n._values=n._values.map((r,s)=>e(r,s)),n}Li.exports=Gd});var Hi=c((d2,Ki)=>{var Ld=v();function Wd(t){let e=t.copy(),n=[];return e._values=e.values.filter((r,s)=>Ld(r)?!1:(n.push(e.index[s]),!0)),e._index=n,e}Ki.exports=Wd});var Qi=c((p2,Xi)=>{var Kd=g();function Hd(t,e){let n=[],r=[];e.values.forEach((i,o)=>{Kd(i)&&(r.push(i),n.push(e.index[o]))});let s=new t(r);return s.name=e.name,s.index=n,s}Xi.exports=Hd});var eo=c((g2,Zi)=>{var Xd=C();function Qd(t,e,n){let r=e.copy(),s=Xd(r.index),i=[],o=r.values.filter((u,a)=>{let l=n(u,a,r.values);return l||i.push(r.index[a]),l});return i.forEach(u=>{s.splice(s.indexOf(u),1)}),o.length===0?(r=new t,r.name=e.name,r):(r.values=o,r.index=s,r)}Zi.exports=Qd});var no=c((q2,to)=>{var W=m(),Zd=g(),ep=E(),tp=v(),np=z();function rp(t,e){(ep(e)||Zd(e))&&(e=[e]);let n=np((e||[]).map(r=>typeof r));return W(n.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===1&&W(n[0]==="string"||n[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===2&&(W(n.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),W(n.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),tp(e)||(e=e.map(r=>{if(typeof r=="string")return W(t.index.indexOf(r)>-1,`Index "${r}" does not exist!`),r;if(typeof r=="number")return W(r>=0,`Index ${r} is out of bounds!`),W(parseInt(r)===r,"Indices must be integers!"),W(r<t.index.length,`Index ${r} is out of bounds!`),t.index[r]})),t.getSubsetByNames(e)}to.exports=rp});var so=c((y2,ro)=>{var Fe=m(),sp=d(),ip=v(),op=xe(),up=j(),ap=x();function cp(t,e){let n=t.shape;ip(e)&&(e=up(0,n[0])),Fe(sp(e),"The `indices` array must be 1-dimensional array of whole numbers."),Fe(ap(e).length===1,"The `indices` array must be a 1-dimensional array of whole numbers."),Fe(e.length>0,"The `indices` array must contain at least one index."),e.forEach(s=>{Fe(op(s),"The `indices` array must be a 1-dimensional array of whole numbers."),Fe(s<t.index.length,`The row index ${s} is out of bounds.`)});let r=e.map(s=>t.index[s]);return t.getSubsetByNames(r)}ro.exports=cp});var oo=c((b2,io)=>{var Ie=m(),lp=d(),fp=E(),hp=v(),mp=x();function dp(t,e,n){hp(n)&&(n=e.index),Ie(lp(n),"The `indices` array must be a 1-dimensional array of strings."),Ie(mp(n).length===1,"The `indices` array must be a 1-dimensional array of strings."),Ie(n.length>0,"The `indices` array must contain at least one index name."),n.forEach(i=>{Ie(fp(i),"The `indices` array must contain only strings."),Ie(e.index.indexOf(i)>-1,`The name "${i}" does not exist in the index.`)});let r=n.map(i=>e.values[e.index.indexOf(i)]);if(r.length===1)return r[0];let s=new t(r);return s.index=n,s.name=e.name,s}io.exports=dp});var co=c((v2,ao)=>{var pp=C(),uo=j();function gp(t){let e=t.copy(),n=typeof window>"u"?20:10;if(e.index.length>n){e=e.get(uo(0,n/2).concat(uo(e.index.length-n/2,e.index.length)));let s=pp(e.index);s.splice(parseInt(s.length/2),0,"..."),e.values.push("..."),e.index.push("..."),e=e.get(s)}let r={};return e.values.forEach((s,i)=>{let o={};o[e.name]=s,r[e.index[i]]=o}),console.table(r),console.log("Shape:",t.shape,`
`),t}ao.exports=gp});var fo=c((N2,lo)=>{var qp=He();function yp(t){let e=t.copy();return e.get(qp(e.index))}lo.exports=yp});var mo=c((w2,ho)=>{var bp=m(),vp=A(),Np=v(),wp=$(),Sp=ee();function xp(t,e,n){n=n||((a,l)=>a<l?-1:1),bp(Np(n)||vp(n),"You must pass undefined, null, or a comparison function as the second argument to the `sort` method!");let r=Sp([e.values,e.index]),s=wp(r,(a,l)=>n(a[0],l[0])),i=[],o=[];s.forEach(a=>{i.push(a[0]),o.push(a[1])});let u=new t;return u._values=i,u._index=o,u.name=e.name,u}ho.exports=xp});var qo=c((S2,go)=>{var _p=$(),po=ee();function Tp(t,e){let n=po([e.values,e.index]);n=po(_p(n,(s,i)=>{if(s[1]===i[1])return 0;if(s[1]<i[1])return-1;if(s[1]>i[1])return 1}));let r=new t(n[0]);return r.index=n[1],r.name=e.name,r}go.exports=Tp});var bo=c((x2,yo)=>{function Op(t){let e={};return e[t.name]={},t.index.forEach((n,r)=>{e[t.name][n]=t.values[r]}),e}yo.exports=Op});var xo=c((_2,So)=>{var V=m(),Qe=C(),tn=d(),Dp=E(),Fp=v(),vo=We(),No=j(),Ze=Se(),Ip=Gi(),Ap=Wi(),Ep=Hi(),Mp=Qi(),jp=eo(),kp=no(),Cp=so(),zp=oo(),Rp=co(),Up=fo(),Pp=mo(),Bp=qo(),Vp=bo(),Ae=x(),Jp=ee(),wo=Symbol.for("@jrc03c/js-math-tools/series");So.exports=function(t){class e{static[Symbol.hasInstance](r){try{return!!r._symbol&&r._symbol===wo}catch{return!1}}constructor(r){let s=this;if(s.name="data",Object.defineProperty(s,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:wo}),Object.defineProperty(s,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(s,"values",{configurable:!0,enumerable:!0,get(){return s._values},set(i){V(tn(i),"The new values must be a 1-dimensional array!");let o=Ae(i);V(o.length===1,"The new array of values must be 1-dimensional!"),o[0]<s._index.length?s._index=s._index.slice(0,o[0]):o[0]>s._index.length&&(s._index=s._index.concat(No(s._index.length,o[0]).map(u=>"item"+vo(u,(i.length-1).toString().length)))),s._values=i}}),Object.defineProperty(s,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(s,"index",{configurable:!0,enumerable:!0,get(){return s._index},set(i){V(tn(i),"The new index must be a 1-dimensional array of strings!"),V(i.length===s.shape[0],"The new index must be the same length as the old index!"),V(Ae(i).length===1,"The new index must be a 1-dimensional array of strings!"),i.forEach(o=>{V(Dp(o),"All of the row names must be strings!")}),s._index=i}}),r){if(r instanceof e)s.name=r.name,s.values=Qe(r.values),s.index=Qe(r.index);else if(tn(r)){let i=Ae(r);V(i.length===1,"When passing an array into the constructor of a Series, the array must be 1-dimensional!"),s.values=r}else if(r instanceof Object){let i=Object.keys(r);V(i.length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");let o=i[0],u=r[o];V(Ae(u).length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!"),s.name=o,s.values=u.slice()}}}get shape(){return Ae(this.values)}get length(){return this.shape[0]}get isEmpty(){return this.values.filter(s=>!Fp(s)).length===0}clear(){let s=this.copy();return s.values.forEach((i,o)=>{s.values[o]=void 0}),s}get(r){return kp(this,r)}getSubsetByNames(r){return zp(e,this,r)}getSubsetByIndices(r){return Cp(this,r)}loc(r){return this.getSubsetByNames(r)}iloc(r){return this.getSubsetByIndices(r)}reverse(){let r=this,s=new e(Ze(r.values));return s.index=Ze(r.index),s.name=r.name,s}resetIndex(){let r=this,s=r.copy();return s.index=No(0,r.shape[0]).map(i=>"item"+vo(i,(s.index.length-1).toString().length)),s}copy(){let r=this,s=new e;return s._values=Qe(r.values),s._index=Qe(r.index),s.name=r.name,s}append(r){return Ip(e,this,r)}apply(r){return Ap(this,r)}concat(r){return this.append(r)}dropMissing(r,s){return Ep(this,r,s)}dropNaN(){return Mp(e,this)}toObject(){return Vp(this)}print(){return Rp(this)}shuffle(){return Up(this)}sort(r){return Pp(e,this,r)}sortByIndex(){return Bp(e,this)}filter(r){return jp(e,this,r)}toDataFrame(){let r=this,s=new t(Jp([r.values]));return s.columns=[r.name],s.index=r.index,s}transpose(){let s=this.copy();return s.values=Ze(s.values),s.index=Ze(s.index),s}getDummies(){return this.toDataFrame().getDummies()}oneHotEncode(){return this.getDummies()}}return e}});var Me=c((T2,Io)=>{var U=m(),nn=C(),_o=Ne(),Yp=ls(),$p=ps(),Gp=bs(),Lp=Ns(),Wp=Ds(),Kp=As(),Hp=ks(),Xp=Us(),Qp=Vs(),To=Ws(),Zp=ni(),eg=ui(),tg=ci(),ng=hi(),rg=Fi(),sg=ki(),ig=zi(),og=Qt(),ug=Ui(),ag=T(),Ee=d(),cg=Q(),Oo=v(),rn=We(),lg=Y(),sn=j(),ce=x(),Do=ee(),Fo=Symbol.for("@jrc03c/js-math-tools/dataframe");function et(t){let e="abcdefghijklmnopqrstuvwxyz1234567890",n="";for(let r=0;r<t;r++)n+=e[parseInt(Math.random()*e.length)];return n}var D=class{static[Symbol.hasInstance](e){try{return!!e._symbol&&e._symbol===Fo}catch{return!1}}constructor(e){let n=this;if(Object.defineProperty(n,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:Fo}),Object.defineProperty(n,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(n,"values",{configurable:!0,enumerable:!0,get(){return n._values.length===0||!Oo(n._values[0])&&n._values[0].length===0?[[]]:n._values},set(r){U(Ee(r),"The new values must be a 2-dimensional array!");let s=ce(r);U(s.length===2,"The new array of values must be 2-dimensional!"),s[0]<n._index.length?n._index=n._index.slice(0,s[0]):s[0]>n._index.length&&(n._index=n._index.concat(sn(n._index.length,s[0]).map(i=>"row"+rn(i,(s[0]-1).toString().length)))),s[1]<n._columns.length?n._columns=n._columns.slice(0,s[1]):s[1]>n._columns.length&&(n._columns=n._columns.concat(sn(n._columns.length,s[1]).map(i=>"col"+rn(i,(s[1]-1).toString().length)))),n._values=r}}),Object.defineProperty(n,"_columns",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(n,"columns",{configurable:!0,enumerable:!0,get(){return n._columns},set(r){U(Ee(r),"The new columns list must be a 1-dimensional array of strings!"),U(n.isEmpty||r.length===n.shape[1],"The new columns list must be the same length as the old columns list!"),U(ce(r).length===1,"The new columns list must be a 1-dimensional array of strings!"),r=r.map(i=>(typeof i!="string"&&(i=JSON.stringify(i)||i.toString()),i.trim().length===0?"untitled_"+et(8):i.trim()));let s=(()=>{let i=_o(r),o={};return i.forEach(u=>{o[u.item]=u.count}),o})();r=r.map(i=>s[i]>1?i+"_"+et(8):i),n._columns=r}}),Object.defineProperty(n,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(n,"index",{configurable:!0,enumerable:!0,get(){return n._index},set(r){U(Ee(r),"The new index must be a 1-dimensional array of strings!"),U(n.isEmpty||r.length===n.shape[0],"The new index must be the same length as the old index!"),U(ce(r).length===1,"The new index must be a 1-dimensional array of strings!"),r=r.map(i=>(typeof i!="string"&&(i=JSON.stringify(i)||i.toString()),i.trim().length===0?"untitled_"+et(8):i.trim()));let s=(()=>{let i=_o(r),o={};return i.forEach(u=>{o[u.item]=u.count}),o})();r=r.map(i=>s[i]>1?i+"_"+et(8):i),n._index=r}}),U(Oo(e)||cg(e)||Ee(e),"The `data` passed into the constructor of a DataFrame must be either (1) an object where the key-value pairs are (respectively) column names and 1-dimensional arrays of values, or (2) a 2-dimensional array of values."),e)if(e instanceof D)n.values=nn(e.values),n.columns=nn(e.columns),n.index=nn(e.index);else if(Ee(e)){let r=ce(e);U(r.length===2,"The `data` array passed into the constructor of a DataFrame must be 2-dimensional!"),n.values=e}else{n._columns=Object.keys(e);let r=[];n._columns.forEach(i=>{let o=e[i];r.push(o)}),n._values=Do(r);let s=ce(n.values);n._index=sn(0,s[0]).map(i=>"row"+rn(i,(s[0]-1).toString().length))}}get shape(){return ce(this.values)}get length(){return this.shape[0]}get width(){return this.shape[1]}get rows(){return this.index}set rows(e){let n=this;n.index=e}get isEmpty(){return ag(this.values).length===0}clear(){let e=this,n=new D(lg(e.shape));return n.columns=e.columns.slice(),n.index=e.index.slice(),n}get(e,n){let r=this;if(arguments.length===0)return r;if(arguments.length===1)try{return r.get(null,e)}catch{return r.get(e,null)}return Qp(r,e,n)}getSubsetByNames(e,n){return eg(D,K,this,e,n)}getSubsetByIndices(e,n){return Zp(this,e,n)}getDummies(e){return To(D,this,e)}oneHotEncode(e){return To(D,this,e)}transpose(){let e=this,n=new D(Do(e.values));return n.columns=e.index.slice(),n.index=e.columns.slice(),n}get T(){return this.transpose()}resetIndex(e){return ng(this,e)}copy(){return Lp(D,this)}assign(e,n){return Gp(D,K,this,e,n)}apply(e,n){return $p(D,K,this,e,n)}dropMissing(e,n,r){return Kp(D,K,this,e,n,r)}dropNaN(e,n,r){return Hp(D,this,e,n,r)}drop(e,n){return Wp(D,K,this,e,n)}dropColumns(e){return this.drop(null,e)}dropRows(e){return this.drop(e,null)}toObject(e){return ug(this,e)}toJSONString(e){return og(this,e)}saveAsJSON(e,n){return ig(this,e,n)}print(){return tg(D,K,this)}sort(e,n){return sg(this,e,n)}sortByIndex(){return this.sort()}filter(e,n){return Xp(D,K,this,e,n)}shuffle(e){return rg(this,e)}append(e,n){return Yp(this,e,n)}concat(e,n){return this.append(e,n)}join(e,n){return this.append(e,n)}toString(){let e=this;return JSON.stringify(e)}},K=xo()(D);Io.exports={DataFrame:D,Series:K}});var le=c((O2,Eo)=>{var fg=m(),hg=T(),mg=d(),dg=y(),pg=q();function Ao(t){if(dg(t)||pg(t))return Ao(t.values);fg(mg(t),"The `max` function only works on arrays, Series, and DataFrames!");try{return Math.max(...hg(t))}catch{return NaN}}Eo.exports=Ao});var N=c((D2,zo)=>{var{DataFrame:Mo,Series:jo}=Me(),ko=m(),je=d(),on=y(),Co=R(),gg=A(),un=q(),qg=le(),yg=j(),tt=x();function bg(t){return je(t)||un(t)||on(t)}function vg(t){return ko(gg(t),"You must pass a function into the `vectorize` function!"),function e(){let n,r,s=[],i=[],o=Object.keys(arguments).filter(u=>{let a=arguments[u];return je(a)?!0:un(a)?(n=!0,s.push(a),!0):on(a)?(r=!0,i.push(a),!0):!1}).map(u=>arguments[u]);if(o.slice(0,-1).forEach((u,a)=>{ko(Co(je(u)?tt(u):u.shape,je(o[a+1])?tt(o[a+1]):o[a+1].shape),`When passing multiple arrays into the \`${t.name}\` function, all of the arrays must have the same shape!`)}),o.length>0){let u=qg(o.map(l=>l.length?l.length:l.values.length)),a=yg(0,u).map(l=>{let f=Object.keys(arguments).map(h=>{if(bg(arguments[h])){if(je(arguments[h]))return arguments[h][l];if(un(arguments[h]))return arguments[h].values[l];if(on(arguments[h]))return arguments[h].values[l]}else return arguments[h]});return e(...f)});if(r)try{if(i.length===1&&Co(tt(i[0]),tt(a))){let l=new Mo(a);return l.index=i[0].index.slice(),l.columns=i[0].columns.slice(),l}else return new Mo(a)}catch{return a}if(n)try{if(s.length===1&&s[0].length===a.length){let l=new jo(a);return l.name=s[0].name,l.index=s[0].index.slice(),l}else return new jo(a)}catch{return a}return a}else return t(...arguments)}}zo.exports=vg});var nt=c((F2,Ro)=>{var Ng=g(),wg=N();function Sg(t){try{return Ng(t)?Math.abs(t):NaN}catch{return NaN}}Ro.exports=wg(Sg)});var rt=c((I2,Uo)=>{var xg=g(),_g=N();function Tg(){try{let t=0,e=Object.values(arguments);for(let n=0;n<e.length;n++){if(!xg(e[n]))return NaN;t+=e[n]}return t}catch{return NaN}}Uo.exports=_g(Tg)});var ke=c((A2,Po)=>{var Og=N();function Dg(t,e){try{return e(t)}catch{return NaN}}Po.exports=Og(Dg)});var Vo=c((E2,Bo)=>{var Fg=g(),Ig=N();function Ag(t){try{return Fg(t)?Math.acos(t):NaN}catch{return NaN}}Bo.exports=Ig(Ag)});var Yo=c((M2,Jo)=>{var Eg=g(),Mg=N();function jg(t){try{return Eg(t)?Math.asin(t):NaN}catch{return NaN}}Jo.exports=Mg(jg)});var Go=c((j2,$o)=>{var kg=g(),Cg=N();function zg(t){try{return kg(t)?Math.atan(t):NaN}catch{return NaN}}$o.exports=Cg(zg)});var Wo=c((k2,Lo)=>{var Rg=m(),Ug=be(),Pg=d(),Bg=y(),Vg=q(),Jg=le();function an(t){if(Bg(t)){let e=an(t.values);return[t.index[e[0]],t.columns[e[1]]]}if(Vg(t)){let e=an(t.values);return[t.index[e]]}Rg(Pg(t),"The `argmax` function only works on arrays, Series, and DataFrames!");try{let e=Ug(t,Jg(t));return e?e.length===0?void 0:e.length===1?e[0]:e:void 0}catch{return}}Lo.exports=an});var st=c((C2,Ho)=>{var Yg=m(),$g=T(),Gg=d(),Lg=y(),Wg=q();function Ko(t){if(Lg(t)||Wg(t))return Ko(t.values);Yg(Gg(t),"The `min` function only works on arrays, Series, and DataFrames!");try{return Math.min(...$g(t))}catch{return NaN}}Ho.exports=Ko});var Qo=c((z2,Xo)=>{var Kg=m(),Hg=be(),Xg=d(),Qg=y(),Zg=q(),eq=st();function cn(t){if(Qg(t)){let e=cn(t.values);return[t.index[e[0]],t.columns[e[1]]]}if(Zg(t)){let e=cn(t.values);return[t.index[e]]}Kg(Xg(t),"The `argmin` function only works on arrays, Series, and DataFrames!");try{let e=Hg(t,eq(t));return e?e.length===0?void 0:e.length===1?e[0]:e:void 0}catch{return}}Xo.exports=cn});var ln=c((R2,Zo)=>{Zo.exports=["null","none","nan","na","n/a","","undefined"]});var hn=c((U2,tu)=>{var eu=d(),tq=v(),nq=ln();function fn(t,e){if(eu(t))return t.map(n=>fn(n,e));if(e==="null")return null;if(e==="number"){let n=parseFloat(t);return isNaN(n)?NaN:n}if(e==="boolean")try{let n=(typeof t=="object"?t.toString()==="null"?"false":JSON.stringify(t):t.toString()).trim().toLowerCase();return n==="true"||n==="yes"||n==="y"?!0:n==="false"||n==="no"||n==="n"?!1:null}catch{return null}if(e==="date"){let n=new Date(t);return n.toString()==="Invalid Date"?null:n}if(e==="object")try{let n=JSON.parse(t);return eu(n)?n.map(r=>fn(r,e)):n}catch{return null}if(e==="string"){if(tq(t))return null;let n=(()=>typeof t=="object"?t===null?"null":JSON.stringify(t):t.toString())();return nq.indexOf(n.trim().toLowerCase())>-1?null:n}}tu.exports=fn});var ru=c((P2,nu)=>{var rq=g(),sq=N();function iq(t){try{return rq(t)?Math.ceil(t):NaN}catch{return NaN}}nu.exports=sq(iq)});var ou=c((B2,iu)=>{var oq=nt(),su=g(),uq=v(),aq=N();function cq(t,e){try{if(!su(t))return NaN;if(uq(e))e=1e-10;else if(!su(e))return NaN;return oq(t)<e?0:t}catch{return NaN}}iu.exports=aq(cq)});var au=c((V2,uu)=>{var mn=g(),lq=N();function fq(t,e,n){try{return mn(t)?mn(e)?mn(n)?t<e?e:t>n?n:t:NaN:NaN:NaN}catch{return NaN}}uu.exports=lq(fq)});var lu=c((J2,cu)=>{var dn=m(),hq=T(),mq=d(),dq=y(),pq=g(),gq=q();function pn(t,e){if(dq(t)||gq(t))return pn(t.values,e);if(dn(mq(t),"The `combinations` function only works on arrays, Series, and DataFrames!"),dn(pq(e),"`r` must be a whole number!"),t=hq(t),e>t.length)return[t];if(e<=0)return[[]];if(dn(e===parseInt(e),"`r` must be a whole number!"),t.length<2)return t;let n=[];return t.forEach((r,s)=>{let i=t.slice(s+1);if(i.length<e-1)return;pn(i,e-1).forEach(u=>{n.push([r].concat(u))})}),n}cu.exports=pn});var it=c((Y2,hu)=>{var qq=m(),yq=T(),bq=d(),vq=y(),Nq=q();function fu(t){if(vq(t)||Nq(t))return fu(t.values);qq(bq(t),"The `mean` function only works on arrays, Series, and DataFrames!");try{let e=yq(t),n=0;return e.forEach(r=>{n+=r}),n/e.length}catch{return NaN}}hu.exports=fu});var qn=c(($2,yu)=>{var mu=m(),du=d(),ot=g(),pu=q(),gu=it(),qu=x();function gn(t,e){if(pu(t))return gn(t.values,e);if(pu(e))return gn(t,e.values);mu(du(t)&&du(e)&&qu(t).length===1&&qu(e).length===1,"The `covariance` function only works on 1-dimensional arrays and Series!"),mu(t.length===e.length,"The two arrays or Series passed into the `covariance` function must have the same length!");try{let n=gu(t),r=gu(e);if(!ot(n)||!ot(r))return NaN;let s=Math.max(t.length,e.length),i=0;for(let o=0;o<s;o++){if(!ot(t[o]))return NaN;if(!ot(e[o]))return NaN;i+=(t[o]-n)*(e[o]-r)}return i/t.length}catch{return NaN}}yu.exports=gn});var ut=c((G2,bu)=>{var wq=g(),Sq=N();function xq(t){try{return wq(t)?Math.sqrt(t):NaN}catch{return NaN}}bu.exports=Sq(xq)});var yn=c((L2,Nu)=>{var _q=m(),Tq=T(),Oq=d(),Dq=y(),Fq=g(),Iq=q(),Aq=it();function vu(t){if(Dq(t)||Iq(t))return vu(t.values);_q(Oq(t),"The `variance` function only works on arrays, Series, and DataFrames!");try{let e=Tq(t),n=Aq(e),r=0;for(let s=0;s<e.length;s++){if(!Fq(e[s]))return NaN;r+=(e[s]-n)*(e[s]-n)}return r/e.length}catch{return NaN}}Nu.exports=vu});var at=c((W2,Su)=>{var Eq=m(),Mq=d(),jq=y(),kq=q(),Cq=ut(),zq=yn();function wu(t){if(jq(t)||kq(t))return wu(t.values);Eq(Mq(t),"The `std` function only works on arrays, Series, and DataFrames!");try{return Cq(zq(t))}catch{return NaN}}Su.exports=wu});var Iu=c((K2,Fu)=>{var xu=m(),Rq=qn(),_u=d(),Tu=q(),Ou=x(),Du=at();function bn(t,e){if(Tu(t))return bn(t.values,e);if(Tu(e))return bn(t,e.values);xu(_u(t)&&_u(e)&&Ou(t).length===1&&Ou(e).length===1,"The `correl` function only works on 1-dimensional arrays and Series!"),xu(t.length===e.length,"The two arrays or Series passed into the `correl` function must have the same length!");try{return Rq(t,e)/(Du(t)*Du(e))}catch{return NaN}}Fu.exports=bn});var Eu=c((H2,Au)=>{var Uq=g(),Pq=N();function Bq(t){try{return Uq(t)?Math.cos(t):NaN}catch{return NaN}}Au.exports=Pq(Bq)});var ju=c((X2,Mu)=>{Mu.exports=Object.freeze({boolean:"boolean",date:"date",null:"null",number:"number",object:"object",string:"string"})});var Pu=c((Q2,Uu)=>{var Vq=m(),ku=d(),Cu=y(),Jq=R(),zu=q(),Ru=z();function vn(t,e){if(Cu(t)||zu(t))return vn(t.values,e);if(Cu(e)||zu(e))return vn(t,e.values);Vq(ku(t)&&ku(e),"The `diff` function only works on arrays, Series, and DataFrames!");let n=Ru(t),r=Ru(e),s=[];return n.forEach(i=>{r.findIndex(o=>Jq(o,i))<0&&s.push(i)}),s}Uu.exports=vn});var ct=c((Z2,Vu)=>{var Bu=g(),Yq=N();function $q(t,e){try{return Bu(t)?Bu(e)?Math.pow(t,e):NaN:NaN}catch{return NaN}}Vu.exports=Yq($q)});var Nn=c((ex,Ju)=>{var Gq=g(),Lq=N();function Wq(){try{let t=Object.values(arguments);if(t.length===0)return NaN;let e=1;for(let n=0;n<t.length;n++){if(!Gq(t[n]))return NaN;e*=t[n]}return e}catch{return NaN}}Ju.exports=Lq(Wq)});var fe=c((tx,Yu)=>{var Kq=Nn();function Hq(){return Kq(...arguments)}Yu.exports=Hq});var wn=c((nx,$u)=>{var Xq=rt(),Qq=fe();function Zq(t,e){return Xq(t,Qq(e,-1))}$u.exports=Zq});var lt=c((rx,Lu)=>{var ey=m(),ty=T(),ny=d(),ry=y(),sy=q();function Gu(t){if(ry(t)||sy(t))return Gu(t.values);ey(ny(t),"The `sum` function only works on arrays, Series, and DataFrames!");try{return t.length===0?NaN:ty(t).reduce((e,n)=>e+n,0)}catch{return NaN}}Lu.exports=Gu});var ea=c((sx,Zu)=>{var iy=nt(),oy=m(),Wu=d(),Ku=y(),uy=R(),Hu=g(),Xu=q(),ay=ct(),Qu=x(),cy=ut(),ly=wn(),fy=lt();function Sn(t,e){if(Hu(t)&&Hu(e))return iy(t-e);if(Ku(t)||Xu(t))return Sn(t.values,e);if(Ku(e)||Xu(e))return Sn(t,e.values);Wu(t)&&Wu(e)&&oy(uy(Qu(t),Qu(e)),"If passing two arrays, Series, or DataFrames into the `distance` function, then those objects must have the same shape!");try{return cy(fy(ay(ly(t,e),2)))}catch{return NaN}}Zu.exports=Sn});var na=c((ix,ta)=>{var hy=ct(),my=fe();function dy(t,e){return my(t,hy(e,-1))}ta.exports=dy});var _n=c((ox,aa)=>{var{DataFrame:ra,Series:sa}=Me(),ft=m(),ia=T(),oa=d(),xn=y(),py=g(),ht=q(),gy=fe(),mt=x(),qy=lt(),ua=ee();function H(t,e){if(xn(t)){let s=H(t.values,e);if(mt(s).length===1){let i=new sa(s);return i.name=ht(e)?e.name:i.name,i.index=t.index.slice(),i}else{let i=new ra(s);return i.index=t.index.slice(),xn(e)&&(i.columns=e.columns.slice()),i}}if(xn(e)){let s=H(t,e.values);if(mt(s).length===1){let i=new sa(s);return i.name=ht(t)?t.name:i.name,i.index=e.columns.slice(),i}else{let i=new ra(s);return i.columns=e.columns.slice(),i}}if(ht(t))return H(t.values,e);if(ht(e))return H(t,e.values);ft(oa(t)&&oa(e),"The `dot` function only works on arrays, Series, and DataFrames!"),ia(t).concat(ia(e)).forEach(s=>{ft(py(s),"One of the arrays you passed into the `dot` function contains non-numerical values!")});let n=mt(t),r=mt(e);if(ft(n.length<=2&&r.length<=2,"I'm not smart enough to know how to get the dot-product of arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `dot` function!"),ft(n[n.length-1]===r[0],`There's a dimension misalignment in the two arrays you passed into the \`dot\` function. (${n[n.length-1]} !== ${r[0]})`),n.length===1&&r.length===1)return qy(gy(t,e));if(n.length===1&&r.length===2)return ua(e).map(s=>H(t,s));if(n.length===2&&r.length===1)return t.map(s=>H(s,e));if(n.length===2&&r.length===2){let s=ua(e),i=[];for(let o=0;o<t.length;o++){let u=[];for(let a=0;a<s.length;a++)u.push(H(t[o],s[a]));i.push(u)}return i}}aa.exports=H});var Tn=c((ux,la)=>{var yy=m(),by=d(),vy=y(),Ny=q(),wy=v();function ca(t){if(vy(t)||Ny(t))return t.dropMissing(...Object.values(arguments).slice(1));yy(by(t),"The `dropMissing` function only works on arrays, Series, and DataFrames!");let e=[];return t.forEach(n=>{try{return e.push(ca(n))}catch{wy(n)||e.push(n)}}),e}la.exports=ca});var ya=c((ax,qa)=>{var fa=m(),ha=d(),ma=y(),Sy=R(),da=q(),pa=v(),ga=x();function dt(t,e){if(ma(t)||da(t))return dt(t.values,e);if(ma(e)||da(e))return dt(t,e.values);fa(ha(t)&&ha(e),"The `dropMissingPairwise` function only works on arrays, Series, and DataFrames!"),fa(Sy(ga(t),ga(e)),"The two arrays, Series, and/or DataFrames passed into the `dropMissingPairwise` function must have the same shape!");let n=[],r=[];for(let s=0;s<t.length;s++)try{let[i,o]=dt(t[s],e[s]);n.push(i),r.push(o)}catch{!pa(t[s])&&!pa(e[s])&&(n.push(t[s]),r.push(e[s]))}return[n,r]}qa.exports=dt});var Ta=c((cx,_a)=>{var ba=m(),va=d(),Na=y(),xy=R(),wa=g(),Sa=q(),xa=x();function pt(t,e){if(Na(t)||Sa(t))return pt(t.values,e);if(Na(e)||Sa(e))return pt(t,e.values);ba(va(t)&&va(e),"The `dropNaNPairwise` only works on arrays, Series, and DataFrames!"),ba(xy(xa(t),xa(e)),"The two arrays, Series, and/or DataFrames passed into the `dropNaNPairwise` must have the same shape!");let n=[],r=[];for(let s=0;s<t.length;s++)try{let[i,o]=pt(t[s],e[s]);n.push(i),r.push(o)}catch{wa(t[s])&&wa(e[s])&&(n.push(t[s]),r.push(e[s]))}return[n,r]}_a.exports=pt});var Da=c((lx,Oa)=>{var _y=Tn();function Ty(t){return _y(t)}Oa.exports=Ty});var Ia=c((fx,Fa)=>{var Oy=g(),Dy=N();function Fy(t){try{return Oy(t)?Math.exp(t):NaN}catch{return NaN}}Fa.exports=Dy(Fy)});var Ma=c((hx,Ea)=>{var Iy=N();function Aa(t){try{return t!==parseInt(t)?NaN:t<=1?1:t*Aa(t-1)}catch{return NaN}}Ea.exports=Iy(Aa)});var za=c((mx,Ca)=>{var Ay=m(),Ey=T(),ja=d(),My=y(),jy=A(),ka=Q(),ky=q();function On(t,e){if(My(t))return On(Ey(t.values),e);if(ky(t))return On(t.values,e);if(Ay(ka(t)||ja(t),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `find` function!"),!jy(e)){let s=e;e=i=>i===s}function n(s,i,o){if(o=o||[],o.indexOf(s)>-1)return null;if(ka(s)){o.push(s);let u=Object.keys(s);for(let a=0;a<u.length;a++){let l=u[a],f=s[l];if(i(f))return f;let h=n(f,i,o);if(h)return h}}else if(ja(s)){o.push(s);for(let u=0;u<s.length;u++){let a=s[u];if(i(a))return a;let l=n(a,i,o);if(l)return l}}else if(i(s))return s;return null}function r(s){try{return e(s)}catch{return!1}}return n(t,r)}Ca.exports=On});var Ba=c((dx,Pa)=>{var Cy=m(),zy=T(),Ra=d(),Ry=y(),Uy=A(),Ua=Q(),Py=q();function Dn(t,e){if(Ry(t))return Dn(zy(t.values),e);if(Py(t))return Dn(t.values,e);if(Cy(Ua(t)||Ra(t),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `findAll` function!"),!Uy(e)){let i=e;e=o=>o===i}function n(i,o,u){if(u=u||[],u.indexOf(i)>-1)return null;if(Ua(i)){u.push(i);let a=Object.keys(i),l=[];for(let f=0;f<a.length;f++){let h=a[f],p=i[h],b=!1;o(p)&&(l.push(p),b=!0);let S=n(p,o,u);S&&S.length>0&&S.slice(b?1:0).forEach(O=>l.push(O))}return l}else if(Ra(i)){u.push(i);let a=[];for(let l=0;l<i.length;l++){let f=i[l],h=!1;o(f)&&(a.push(f),h=!0);let p=n(f,o,u);p&&p.length>0&&p.slice(h?1:0).forEach(b=>a.push(b))}return a}else if(o(i))return[i];return null}function r(i){try{return e(i)}catch{return!1}}let s=n(t,r);return s&&s.length>0?s:null}Pa.exports=Dn});var Ja=c((px,Va)=>{var By=g(),Vy=N();function Jy(t){try{if(t==="Infinity")return 1/0;if(t==="-Infinity")return-1/0;let e=JSON.parse(t);return By(e)?e:NaN}catch{return NaN}}Va.exports=Vy(Jy)});var $a=c((gx,Ya)=>{var Yy=g(),$y=N();function Gy(t){try{return Yy(t)?Math.floor(t):NaN}catch{return NaN}}Ya.exports=$y(Gy)});var Fn=c((qx,Ga)=>{var Ly=g(),Wy=Oe(),Ky=Ke();function Hy(t){Ly(t)&&(t=[t]);let e=[],n=Wy(t);for(let r=0;r<n;r++)e.push(0);return Ky(e,t)}Ga.exports=Hy});var Wa=c((yx,La)=>{var gt=m(),Xy=g(),Qy=v(),Zy=Fn();function e1(t){gt(!Qy(t),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),gt(Xy(t),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),gt(parseInt(t)===t,"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),gt(t>0,"You must pass an integer greater than 0 (representing the size) into the `identity` function!");let e=Zy([t,t]);for(let n=0;n<t;n++)e[n][n]=1;return e}La.exports=e1});var Ha=c((bx,Ka)=>{Ka.exports=["true","false","yes","no"]});var Za=c((vx,Qa)=>{var t1=ke(),n1=m(),r1=Ha(),s1=hn(),i1=Ne(),o1=T(),Xa=d(),u1=y(),a1=g(),c1=q(),l1=E(),f1=ln();function In(t){if(u1(t)){let s=t.copy(),i=In(t.values);return s.values=i.values,{type:i.type,values:s}}if(c1(t)){let s=t.copy(),i=In(t.values);return s.values=i.values,{type:i.type,values:s}}n1(Xa(t),"The `inferType` function only works on arrays, Series, and DataFrames!");let e=o1(t).map(s=>{if(s===void 0)return"null";l1(s)||(s=JSON.stringify(s));let o=s.toLowerCase().trim();if(f1.indexOf(o)>-1)return"null";if(r1.indexOf(o)>-1)return"boolean";try{let u=JSON.parse(s);return a1(u)?"number":typeof u=="object"?Xa(u)?"string":"object":"string"}catch{return new Date(s).toString()!=="Invalid Date"?"date":"string"}}),r=i1(e).sort((s,i)=>i.count-s.count)[0].item;return{type:r,values:t1(t,s=>s1(s,r))}}Qa.exports=In});var tc=c((Nx,ec)=>{var h1=g(),m1=N();function d1(t){try{let e=JSON.parse(t);return h1(e)?parseInt(e):NaN}catch{return NaN}}ec.exports=m1(d1)});var rc=c((wx,nc)=>{var p1=m(),g1=d(),q1=y(),y1=R(),b1=q(),An=z();function v1(){let t=Object.values(arguments).map(n=>q1(n)||b1(n)?An(n.values):(p1(g1(n),"The `intersect` function only works on arrays, Series, and DataFrames!"),An(n)));return An(t).filter(n=>t.every(r=>r.findIndex(s=>y1(s,n))>-1))}nc.exports=v1});var uc=c((Sx,oc)=>{var sc=rt(),X=m(),N1=_n(),w1=T(),S1=d(),x1=y(),En=g(),ic=fe(),_1=x();function qt(t){if(x1(t)){let n=t.copy();return n.values=qt(n.values),n}X(S1(t),"The `inverse` function only works on square 2-dimensional arrays or DataFrames!"),w1(t).forEach(n=>X(En(n),"The array passed into the `inverse` function must contain only numbers!"));let e=_1(t);if(X(e.length===2,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),X(e[0]===e[1],"The array passed into the `inverse` function must be exactly two-dimensional and square!"),X(e[0]>=0,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),e[0]===0)return t;if(e[0]===1)return X(t[0][0]!==0,"This matrix cannot be inverted!"),1/t[0][0];if(e[0]===2){let n=t[0][0],r=t[0][1],s=t[1][0],i=t[1][1],o=n*i-r*s;X(o!==0,"This matrix cannot be inverted!");let u=[[i,-r],[-s,n]];return ic(u,1/o)}else if(e[0]>1){let n=(r,s)=>En(r)||En(s)?ic(r,s):N1(r,s);for(let r=1;r<e[0]-1;r++)try{let s=t.slice(0,r).map(O=>O.slice(0,r)),i=t.slice(0,r).map(O=>O.slice(r,e[0])),o=t.slice(r,e[0]).map(O=>O.slice(0,r)),u=t.slice(r,e[0]).map(O=>O.slice(r,e[0])),a=qt(s),l=qt(sc(u,n(-1,n(n(o,a),i)))),f=sc(a,n(n(n(n(a,i),l),o),a)),h=n(-1,n(n(a,i),l)),p=n(-1,n(n(l,o),a)),b=l;return f.map((O,B)=>O.concat(h[B])).concat(p.map((O,B)=>O.concat(b[B])))}catch{}X(!1,"This matrix cannot be inverted!")}}oc.exports=qt});var cc=c((xx,ac)=>{var Mn=g(),T1=N();function O1(t,e,n){try{return Mn(t)?Mn(e)?Mn(n)?n*(e-t)+t:NaN:NaN:NaN}catch{return NaN}}ac.exports=T1(O1)});var hc=c((_x,fc)=>{var lc=g(),D1=v(),F1=N();function I1(t,e){try{return e=D1(e)?Math.E:e,lc(t)?lc(e)?Math.log(t)/Math.log(e):NaN:NaN}catch{return NaN}}fc.exports=F1(I1)});var pc=c((Tx,dc)=>{var A1=m(),E1=T(),M1=d(),j1=y(),k1=q(),C1=$();function mc(t){if(j1(t)||k1(t))return mc(t.values);A1(M1(t),"The `median` function only works on arrays, Series, and DataFrames!");try{let e=C1(E1(t));return e.length===0?NaN:e.length%2===0?(e[e.length/2-1]+e[e.length/2])/2:e[parseInt(e.length/2)]}catch{return NaN}}dc.exports=mc});var yc=c((Ox,qc)=>{var gc=g(),z1=N();function R1(t,e){try{return gc(t)?gc(e)?t%e:NaN:NaN}catch{return NaN}}qc.exports=z1(R1)});var wc=c((Dx,Nc)=>{var U1=m(),P1=Ne(),B1=T(),V1=d(),J1=y(),Y1=q(),$1=z(),bc=$();function vc(t){if(J1(t)||Y1(t))return vc(t.values);U1(V1(t),"The `mode` function only works on arrays, Series, and DataFrames!");try{if(t.length===0)return NaN;let e=B1(t);if(e.length===0)return NaN;let n={},r=$1(e);r.forEach(u=>{n[u]=P1(e,u)});let s=bc(r,(u,a)=>n[a]-n[u]),i=s[0];return bc(s.filter(u=>n[u]===n[i]))}catch{return NaN}}Nc.exports=vc});var Tc=c((Fx,_c)=>{var{random:Sc}=ue(),G1=ke(),L1=v(),W1=Y();function xc(){let t=Sc(),e=Sc();return Math.sqrt(-2*Math.log(t))*Math.cos(2*Math.PI*e)}function K1(t){return L1(t)?xc():G1(W1(t),xc)}_c.exports=K1});var Dc=c((Ix,Oc)=>{var H1=ke(),X1=Y();function Q1(t){return H1(X1(t),()=>1)}Oc.exports=Q1});var Ic=c((Ax,Fc)=>{var jn=m(),Z1=T(),eb=d(),tb=y(),nb=g(),rb=q(),sb=v();function yt(t,e){if(tb(t)||rb(t))return yt(t.values,e);if(jn(eb(t),"The `permutations` function only works on arrays, Series, and DataFrames!"),sb(e)&&(e=t.length),jn(nb(e),"`r` must be a whole number!"),t=Z1(t),e>t.length)return yt(t);if(e<=0)return[[]];if(jn(e===parseInt(e),"`r` must be a whole number!"),t.length<2)return t;let n=[];return t.forEach((r,s)=>{let i=t.slice(0,s),o=t.slice(s+1),u=i.concat(o);yt(u,e-1).forEach(l=>{n.push([r].concat(l))})}),n}Fc.exports=yt});var Ec=c((Ex,Ac)=>{var{DataFrame:ib,Series:ob}=Me(),ub=d(),ab=y(),cb=we(),lb=q(),fb=x();function hb(){Object.keys(arguments).forEach(t=>{let e=arguments[t];if(ub(e))if(cb(e))console.log(e);else{let n=fb(e);n.length===1?new ob(e).print():n.length==2?new ib(e).print():console.log(e)}else ab(e)||lb(e)?e.print():console.log(e)})}Ac.exports=hb});var kc=c((Mx,jc)=>{var mb=d(),db=g(),Mc=v(),pb=le(),gb=st(),qb=N(),yb=qb(function(t,e,n,r,s){try{return[t,e,n,r,s].every(i=>db(i))?n-e===0?NaN:(s-r)*(t-e)/(n-e)+r:NaN}catch{return NaN}});function bb(t,e,n,r,s){return mb(t)&&Mc(r)&&Mc(s)&&(r=e,s=n,e=gb(t),n=pb(t)),yb(t,e,n,r,s)}jc.exports=bb});var zc=c((jx,Cc)=>{var vb=g(),Nb=N();function wb(t){try{return vb(t)?Math.round(t):NaN}catch{return NaN}}Cc.exports=Nb(wb)});var Uc=c((kx,Rc)=>{var Sb=g(),xb=N();function _b(t){try{return Sb(t)?t<0?-1:t>0?1:0:NaN}catch{return NaN}}Rc.exports=xb(_b)});var Bc=c((Cx,Pc)=>{var Tb=g(),Ob=N();function Db(t){try{return Tb(t)?Math.sin(t):NaN}catch{return NaN}}Pc.exports=Ob(Db)});var Jc=c((zx,Vc)=>{var Fb=at();function Ib(t){return Fb(t)}Vc.exports=Ib});var $c=c((Rx,Yc)=>{var Ab=g(),Eb=N();function Mb(t){try{return Ab(t)?Math.tan(t):NaN}catch{return NaN}}Yc.exports=Eb(Mb)});var bt=c((Ux,Wc)=>{var Gc=m(),Lc=A();function jb(t,e){Gc(Lc(t),"`fn` must be a function!");let n=new Date;return e?t(...e):t(),new Date-n}async function kb(t,e){Gc(Lc(t),"`fn` must be a function!");let n=new Date;return e?await t(...e):await t(),new Date-n}Wc.exports={timeSync:jb,timeAsync:kb}});var Hc=c((Px,Kc)=>{var Cb=d(),zb=y(),Rb=q(),Ub=z();function Pb(){return Ub([...arguments].map(t=>Cb(t)?t:zb(t)||Rb(t)?t.values:[t]))}Kc.exports=Pb});var Qc=c((Bx,Xc)=>{var Bb=m(),Vb=d(),Jb=y(),Yb=q(),$b=v(),Gb=le(),Lb=j();function Wb(){let t=[],e=Object.values(arguments).map(n=>((Jb(n)||Yb(n))&&(n=n.values),Bb(Vb(n),"The `zip` function only works on arrays, Series, and DataFrames!"),n));return Lb(0,Gb(e.map(n=>n.length))).forEach(n=>{let r=[];e.forEach(s=>{let i=s[n];r.push($b(i)?void 0:i)}),t.push(r)}),t}Xc.exports=Wb});var w=c((Vx,kn)=>{var{DataFrame:Kb,Series:Hb}=Me(),he={abs:nt(),add:rt(),apply:ke(),arccos:Vo(),arcsin:Yo(),arctan:Go(),argmax:Wo(),argmin:Qo(),assert:m(),cast:hn(),ceil:ru(),chop:ou(),clamp:au(),combinations:lu(),copy:C(),correl:Iu(),cos:Eu(),count:Ne(),covariance:qn(),DataFrame:Kb,dataTypes:ju(),decycle:Ct(),diff:Pu(),distance:ea(),divide:na(),dot:_n(),dropMissing:Tn(),dropMissingPairwise:ya(),dropNaN:Yt(),dropNaNPairwise:Ta(),dropUndefined:Da(),exp:Ia(),factorial:Ma(),find:za(),findAll:Ba(),flatten:T(),float:Ja(),floor:$a(),identity:Wa(),indexOf:be(),inferType:Za(),int:tc(),intersect:rc(),inverse:uc(),isArray:d(),isBoolean:Wt(),isDataFrame:y(),isEqual:R(),isFunction:A(),isJagged:we(),isNested:Be(),isNumber:g(),isObject:Q(),isSeries:q(),isString:E(),isUndefined:v(),lerp:cc(),log:hc(),MathError:se(),max:le(),mean:it(),median:pc(),min:st(),mod:yc(),mode:wc(),multiply:Nn(),ndarray:Y(),normal:Tc(),ones:Dc(),permutations:Ic(),pow:ct(),print:Ec(),product:Oe(),random:ue().random,range:j(),remap:kc(),reshape:Ke(),reverse:Se(),round:zc(),scale:fe(),seed:ue().seed,Series:Hb,set:z(),shape:x(),shuffle:He(),sign:Uc(),sin:Bc(),sort:$(),sqrt:ut(),std:at(),stdev:Jc(),subtract:wn(),sum:lt(),tan:$c(),time:bt().timeSync,timeSync:bt().timeSync,timeAsync:bt().timeAsync,transpose:ee(),union:Hc(),variance:yn(),vectorize:N(),zeros:Fn(),zip:Qc(),dump:function(){let t=typeof global<"u"?global:window;if(!t)throw new he.MathError("Cannot dump functions into global scope because neither `global` nor `window` exist in the current context!");Object.keys(he).forEach(e=>{try{Object.defineProperty(t,e,{configurable:!1,enumerable:!0,writable:!1,value:he[e]})}catch{t[e]=he[e]}})}};typeof kn<"u"&&(kn.exports=he);typeof window<"u"&&(window.JSMathTools=he)});var P=c((Jx,Zc)=>{Zc.exports={shouldIgnoreNaNValues:!0}});var me=c((Yx,tl)=>{var{assert:Xb,flatten:Qb,isArray:Zb,isDataFrame:ev,isNumber:tv,isSeries:nv}=w();function el(t){if(ev(t)||nv(t))return el(t.values);Xb(Zb(t),"The `containsOnlyNumbers` function only works on arrays, Series, and DataFrames!");let e=Qb(t);for(let n=0;n<e.length;n++)if(!tv(e[n]))return!1;return!0}tl.exports=el});var zn=c(($x,nl)=>{var{dropMissing:rv,flatten:sv,isArray:iv,isDataFrame:ov,isSeries:uv}=w();function Cn(t){return typeof t=="number"?t===0||t===1:ov(t)||uv(t)?Cn(t.values):iv(t)?t.length===0?!1:rv(sv(t)).every(n=>Cn(n)):!1}nl.exports=Cn});var Rn=c((Gx,fl)=>{var{abs:rl,apply:sl,assert:il,clamp:av,copy:cv,divide:lv,dropNaN:fv,flatten:hv,isArray:mv,isDataFrame:dv,isNumber:ol,isSeries:pv,max:ul,median:al,min:gv,sort:qv,subtract:cl}=w(),yv=P(),bv=me(),vv=zn();function ll(t,e){if(dv(t)||pv(t)){let a=t.copy();return a._values=ll(a._values,e),a}if(il(mv(t),"The `clipOutliers` function only works on arrays, Series, and DataFrames!"),e=e||5,il(ol(e),"Any `maxScore` value passed into the `clipOutliers` function must be a number!"),!yv.shouldIgnoreNaNValues&&!bv(t))return sl(t,()=>NaN);let n=hv(t),r=fv(n);if(vv(r)||r.length===0)return t;let s=al(r),i=al(rl(cl(r,s))),o=!1;if(i===0){let a=qv(cv(r)),l=a.filter(b=>b<s),f=a.filter(b=>b>s),h=s,p=s;if(l.length>0&&(h=ul(l)),f.length>0&&(p=gv(f)),i=(p-h)/2,i===0)return t;o=(s-h)/i>e||(p-s)/i>e}return ul(lv(rl(cl(r,s)),i))>e||o?sl(t,a=>ol(a)?av(a,s-e*i,s+e*i):a):t}fl.exports=ll});var Pn=c((Lx,bl)=>{var{assert:hl,dropNaN:ml,isArray:dl,isSeries:pl,mean:gl,shape:ql,variance:yl}=w(),Nv=P();function Un(t,e){if(pl(t))return Un(t.values,e);if(pl(e))return Un(t,e.values);hl(dl(t)&&dl(e)&&ql(t).length===1&&ql(e).length===1,"The `cohensd` function only works on 1-dimensional arrays and Series!"),hl(t.length===e.length,"Two arrays or Series passed into the `cohensd` function must have the same length!"),Nv.shouldIgnoreNaNValues&&(t=ml(t),e=ml(e));try{let n=gl(t),r=gl(e),s=Math.sqrt((yl(t)+yl(e))/2);return(n-r)/s}catch{return NaN}}bl.exports=Un});var Sl=c((Wx,wl)=>{var{assert:vl,DataFrame:wv,isArray:Sv,isSeries:xv,shape:_v,zeros:Tv}=w();function Nl(t){if(xv(t)){let r=new wv(Nl(t.values));return r.index=t.index.slice(),r.columns=t.index.slice(),r}vl(Sv(t),"The `diagonalize` function only works on 1-dimensional arrays and Series!");let e=_v(t);vl(e.length===1,"The `diagonalize` function only works on 1-dimensional arrays and Series!");let n=Tv([e[0],e[0]]);return t.forEach((r,s)=>n[s][s]=r),n}wl.exports=Nl});var Yn=c((Kx,Ol)=>{var{assert:Bn,clamp:Ov,correl:xl,DataFrame:vt,dropNaNPairwise:Dv,isArray:_l,isDataFrame:Nt,isJagged:Tl,isUndefined:Fv,ndarray:Iv}=w(),Av=P();function Vn(t){let e="@jrc03c/js-data-science-helpers/get-correlation-matrix";return Object.defineProperty(t,e,{configurable:!1,enumerable:!1,writable:!1,value:Symbol.for(e)}),t}function Jn(t,e){if(Fv(e)&&(e=t),Nt(t)){let r=new vt(Jn(t.values,e));return r.index=t.columns.slice(),r.columns=Nt(e)?e.columns.slice():new vt(e).columns.slice(),Vn(r)}if(Nt(e)){let r=new vt(Jn(t,e.values));return r.index=Nt(t)?t.columns.slice():new vt(t).columns.slice(),r.columns=e.columns.slice(),Vn(r)}Bn(_l(t)&&_l(e),"The `getCorrelationMatrix` function only works on 2-dimensional arrays and DataFrames!"),Bn(!Tl(t)&&!Tl(e),"The `getCorrelationMatrix` function only works on non-jagged 2-dimensional arrays and DataFrames!"),Bn(t.length===e.length,'The dimensions of the matrices you passed into the `getCorrelationMatrix` function aren\'t compatible! ([shape(a).join(", ")] vs. [shape(b).join(", ")]) The function expects that you\'ll be comparing the columns of two matrices where the columns are all of the same length, so please make sure that the matrices are oriented accordingly.');let n=Iv([t[0].length,e[0].length]);for(let r=0;r<t[0].length;r++){let s=t.map(i=>i[r]);for(let i=0;i<e[0].length;i++){let o=e.map(u=>u[i]);Av.shouldIgnoreNaNValues?n[r][i]=xl(...Dv(s,o)):n[r][i]=xl(s,o)}}return Vn(Ov(n,-1,1))}Ol.exports=Jn});var $n=c((Hx,Dl)=>{function Ev(t){try{let e="@jrc03c/js-data-science-helpers/get-correlation-matrix";return t[e]===Symbol.for(e)}catch{return!1}}Dl.exports=Ev});var El=c((Xx,Al)=>{var{DataFrame:Gn,isArray:Mv,isDataFrame:wt,isNumber:Fl,MathError:jv,sort:kv}=w(),Il=Yn(),Cv=$n();function zv(t,e,n){n=Object.values(arguments).find(i=>Fl(i))||1-1e-5;let r=(()=>{let i=Object.values(arguments).filter(o=>Mv(o)||wt(o));if(i.length===1){let o=i[0];if(Cv(o))return wt(o)?o:new Gn(o);{let u=Il(o,null);return wt(u)?u:new Gn(u)}}if(i.length===2){let o=Il(i[0],i[1]);return wt(o)?o:new Gn(o)}throw new jv("You must pass 1 or 2 2-dimensional arrays or DataFrames into the `getHighlyCorrelatedColumns` function!")})(),s={};return r.values.forEach((i,o)=>{i.forEach((u,a)=>{if(Fl(u)&&u>n){let l=r.index[o],f=r.columns[a];s[l]||(s[l]=[]),s[l].indexOf(f)<0&&s[l].push(f),s[f]||(s[f]=[]),s[f].indexOf(l)<0&&s[f].push(l)}})}),Object.keys(s).forEach(i=>{s[i]=kv(s[i])}),s}Al.exports=zv});var Ln=c((Qx,jl)=>{var{dropNaN:Rv,isArray:Uv,isDataFrame:Pv,isNumber:Bv,isSeries:Vv,pow:Jv,sqrt:Yv,sum:$v}=w(),Gv=P();function Ml(t){return Pv(t)||Vv(t)?Ml(t.values):Bv(t)?Math.abs(t):Uv(t)?(Gv.shouldIgnoreNaNValues&&(t=Rv(t)),Yv($v(Jv(t,2)))):NaN}jl.exports=Ml});var Wn=c((Zx,zl)=>{var{assert:kl,DataFrame:Lv,isArray:Wv,isSeries:Kv,isString:Hv,isUndefined:Xv,set:Qv,shape:Zv,sort:eN}=w();function Cl(){if(arguments.length===1&&Kv(arguments[0])){let{name:i,values:o}=arguments[0],u=Cl(i,o),a=new Lv(u);return a.index=arguments[0].index.slice(),a}let[t,e]=arguments;kl(Hv(t),"When passing two arguments into the `getOneHotEncodings` function, the first argument must be a string representing the name of the variable being encoded!"),kl(Wv(e)&&Zv(e).length===1,"When passing two arguments into the `getOneHotEncodings` function, the second argument must be a 1-dimensional array!");let n={},r=t+"_"+e[0];return eN(Qv(e)).filter(i=>!Xv(i)).map(i=>t+"_"+i).filter(i=>i!==r).forEach(i=>{n[i]=e.map(o=>i===t+"_"+o?1:0)}),n}zl.exports=Cl});var Ul=c((e_,Rl)=>{var{count:tN}=w();function nN(t){return tN(t).map(n=>(n.percentage=n.count/t.length,n))}Rl.exports=nN});var Pl=c((t_,rN)=>{rN.exports=[.5,.49601,.49202,.48803,.48405,.48006,.47608,.4721,.46812,.46414,.46017,.4562,.45224,.44828,.44433,.44038,.4364,.43251,.42858,.42465,.42074,.41683,.41294,.40905,.40517,.40129,.39743,.39358,.38974,.38591,.38209,.37828,.37448,.3707,.36693,.36317,.35942,.35569,.35197,.34827,.34458,.3409,.33724,.3336,.32997,.32636,.32276,.31918,.31561,.31207,.30854,.30503,.30153,.29806,.2946,.29116,.28774,.28434,.28096,.2776,.27425,.27093,.26763,.26435,.26109,.25785,.25463,.25143,.24825,.2451,.24196,.23885,.23576,.2327,.22965,.22663,.22363,.22065,.2177,.21476,.21186,.20897,.20611,.20327,.20045,.19766,.19489,.19215,.18943,.18673,.18406,.18141,.17879,.17619,.17361,.17106,.16853,.16602,.16354,.16109,.15866,.15625,.15386,.15151,.14917,.14686,.14457,.14231,.14007,.13786,.13567,.1335,.13136,.12924,.12714,.12507,.12302,.121,.119,.11702,.11507,.11314,.11123,.10935,.10749,.10565,.10383,.10204,.10027,.09853,.0968,.0951,.09342,.09176,.09012,.08851,.08692,.08534,.08379,.08226,.08076,.07927,.0778,.07636,.07493,.07353,.07215,.07078,.06944,.06811,.06681,.06552,.06426,.06301,.06178,.06057,.05938,.05821,.05705,.05592,.0548,.0537,.05262,.05155,.0505,.04947,.04846,.04746,.04648,.04551,.04457,.04363,.04272,.04182,.04093,.04006,.0392,.03836,.03754,.03673,.03593,.03515,.03438,.03362,.03288,.03216,.03144,.03074,.03005,.02938,.02872,.02807,.02743,.0268,.02619,.02559,.025,.02442,.02385,.0233,.02275,.02222,.02169,.02118,.02068,.02018,.0197,.01923,.01876,.01831,.01786,.01743,.017,.01659,.01618,.01578,.01539,.015,.01463,.01426,.0139,.01355,.01321,.01287,.01255,.01222,.01191,.0116,.0113,.01101,.01072,.01044,.01017,.0099,.00964,.00939,.00914,.00889,.00866,.00842,.0082,.00798,.00776,.00755,.00734,.00714,.00695,.00676,.00657,.00639,.00621,.00604,.00587,.0057,.00554,.00539,.00523,.00508,.00494,.0048,.00466,.00453,.0044,.00427,.00415,.00402,.00391,.00379,.00368,.00357,.00347,.00336,.00326,.00317,.00307,.00298,.00289,.0028,.00272,.00264,.00256,.00248,.0024,.00233,.00226,.00219,.00212,.00205,.00199,.00193,.00187,.00181,.00175,.00169,.00164,.00159,.00154,.00149,.00144,.00139,.00135,.00131,.00126,.00122,.00118,.00114,.00111,.00107,.00104,.001,97e-5,94e-5,9e-4,87e-5,84e-5,82e-5,79e-5,76e-5,74e-5,71e-5,69e-5,66e-5,64e-5,62e-5,6e-4,58e-5,56e-5,54e-5,52e-5,5e-4,48e-5,47e-5,45e-5,43e-5,42e-5,4e-4,39e-5,38e-5,36e-5,35e-5,34e-5,32e-5,31e-5,3e-4,29e-5,28e-5,27e-5,26e-5,25e-5,24e-5,23e-5,22e-5,22e-5,21e-5,2e-4,19e-5,19e-5,18e-5,17e-5,17e-5,16e-5,15e-5,15e-5,14e-5,14e-5,13e-5,13e-5,12e-5,12e-5,11e-5,11e-5,1e-4,1e-4,1e-4,9e-5,9e-5,8e-5,8e-5,8e-5,8e-5,7e-5,7e-5,7e-5,6e-5,6e-5,6e-5,6e-5,5e-5,5e-5,5e-5,5e-5,5e-5,4e-5,4e-5,4e-5,4e-5,4e-5,4e-5,3e-5,3e-5,3e-5,3e-5,3e-5,3e-5,3e-5,3e-5,2e-5,2e-5,2e-5,2e-5]});var Hn=c((n_,Kl)=>{var{abs:Bl,assert:sN,dropNaNPairwise:iN,flatten:St,isArray:Vl,isDataFrame:Jl,isEqual:oN,isSeries:Yl,mean:$l,remap:uN,round:aN,shape:Gl,sqrt:cN,std:Ll}=w(),lN=P(),Wl=Pl();function fN(t){return Bl(t)>4.1?0:Wl[aN(uN(Bl(t),0,4.1,0,Wl.length))]}function Kn(t,e){if(Jl(t)||Yl(t))return Kn(t.values,e);if(Jl(e)||Yl(e))return Kn(t,e.values);sN(Vl(t)&&Vl(e)&&oN(Gl(t),Gl(e)),"You must pass two identically-shaped arrays, Series, or DataFrames into the `pValue` function!");let[n,r]=lN.shouldIgnoreNaNValues?iN(St(t),St(e)):[St(t),St(e)];if(n.length===0||r.length===0)return NaN;let s=$l(n),i=$l(r),o=Ll(n),u=Ll(r),a=n.length,l=r.length,f=(s-i)/cN(o*o/a+u*u/l);return 2*fN(f)}Kl.exports=Kn});var ef=c((r_,Zl)=>{var{assert:Xn,clamp:hN,DataFrame:xt,dropNaNPairwise:mN,isArray:Hl,isDataFrame:_t,isJagged:Xl,isUndefined:dN,ndarray:pN}=w(),gN=P(),Ql=Hn();function Qn(t){let e="@jrc03c/js-data-science-helpers/get-p-value-matrix";return Object.defineProperty(t,e,{configurable:!1,enumerable:!1,writable:!1,value:Symbol.for(e)}),t}function Zn(t,e){if(dN(e)&&(e=t),_t(t)){let r=new xt(Zn(t.values,e));return r.index=t.columns.slice(),r.columns=_t(e)?e.columns.slice():new xt(e).columns.slice(),Qn(r)}if(_t(e)){let r=new xt(Zn(t,e.values));return r.index=_t(t)?t.columns.slice():new xt(t).columns.slice(),r.columns=e.columns.slice(),Qn(r)}Xn(Hl(t)&&Hl(e),"The `getPValueMatrix` function only works on 2-dimensional arrays and DataFrames!"),Xn(!Xl(t)&&!Xl(e),"The `getPValueMatrix` function only works on non-jagged 2-dimensional arrays and DataFrames!"),Xn(t.length===e.length,'The dimensions of the matrices you passed into the `getPValueMatrix` function aren\'t compatible! ([shape(a).join(", ")] vs. [shape(b).join(", ")]) The function expects that you\'ll be comparing the columns of two matrices where the columns are all of the same length, so please make sure that the matrices are oriented accordingly.');let n=pN([t[0].length,e[0].length]);for(let r=0;r<t[0].length;r++){let s=t.map(i=>i[r]);for(let i=0;i<e[0].length;i++){let o=e.map(u=>u[i]);gN.shouldIgnoreNaNValues?n[r][i]=Ql(...mN(s,o)):n[r][i]=Ql(s,o)}}return Qn(hN(n,0,1))}Zl.exports=Zn});var of=c((s_,sf)=>{var{assert:Tt,intersect:qN,isDataFrame:tf,isSeries:nf,isUndefined:rf}=w(),de=class{constructor(e){let n=this;Tt(rf(e)||e===de.DROP_NAN_MODE||e===de.DROP_MISSING_MODE,"The `mode` value passed into the `IndexMatcher` constructor must be undefined or one of [IndexMatcher.DROP_NAN_MODE, IndexMatcher.DROP_MISSING_MODE]! (By default, the mode is `Indexer.DROP_MISSING_MODE`.)"),n.mode=rf(e)?de.DROP_MISSING_MODE:e,n.index=null}fit(){let e=this,n=[];return Object.values(arguments).forEach(r=>{Tt(tf(r)||nf(r),"The `IndexMatcher` only works on Series and DataFrames! To drop NaN values in a pair-wise fashion from regular arrays, use the `dropNaNPairwise` function from the @jrc03c/js-math-tools library."),e.mode===de.DROP_MISSING_MODE?n.push(r.dropMissing().index):n.push(r.dropNaN().index)}),e.index=qN(...n),e}transform(){let e=this;Tt(!!e.index,"The IndexMatcher hasn't been fitted yet! Please call the `fit` method before calling the `transform` method.");let n=Object.values(arguments).map(r=>(Tt(tf(r)||nf(r),"The `IndexMatcher` only works on Series and DataFrames! To drop NaN values in a pair-wise fashion from regular arrays, use the `dropNaNPairwise` function from the @jrc03c/js-math-tools library."),r.get(e.index,null)));return n.length===1?n[0]:n}fitAndTransform(){return this.fit(...arguments).transform(...arguments)}},Ce=de;Et(Ce,"DROP_NAN_MODE","DROP_NAN_MODE"),Et(Ce,"DROP_MISSING_MODE","DROP_MISSING_MODE");sf.exports=Ce});var tr=c((i_,ff)=>{var{assert:er,isArray:yN,isBoolean:bN,isDataFrame:uf,isSeries:af,int:vN,isNumber:NN,isUndefined:cf,range:lf,set:wN,shape:SN,shuffle:xN}=w();ff.exports=function(){let e=Array.from(arguments),n=e.find(b=>bN(b)),r=cf(n)?!0:n,s=e.find(b=>NN(b)),i=cf(s)?.1:s;er(i>0&&i<1,"`testSize` must be a number between 0 and 1 (exclusive on both ends)!");let o=e.filter(b=>yN(b)||uf(b)||af(b));er(o.length>0,"You must pass at least one dataset into the `trainTestSplit` function!");let u=o.map(b=>SN(b)[0]);er(wN(u).length===1,`All datasets passed into the \`trainTestSplit\` function must be the same length at their shallowest dimension! The lengths of your datasets, though, are: ${u.join(", ")}`);let a=[],l=r?xN(lf(0,u[0])):lf(0,u[0]),f=vN((1-i)*l.length),h=l.slice(0,f),p=l.slice(f);return o.forEach(b=>{if(uf(b))a.push(b.get(h,null)),a.push(b.get(p,null));else if(af(b))a.push(b.get(h)),a.push(b.get(p));else{let S=[],O=[];b.forEach((B,F)=>{h.indexOf(F)>-1?S.push(B):O.push(B)}),a.push(S),a.push(O)}}),a}});var Dt=c((o_,qf)=>{var{add:_N,argmin:TN,assert:ON,flatten:hf,isArray:DN,isDataFrame:mf,isEqual:FN,int:IN,isNumber:AN,isSeries:df,normal:nr,pow:EN,random:MN,range:jN,scale:kN,shape:Ot,subtract:CN,sum:zN}=w(),RN=tr();function rr(t,e){(mf(t)||df(t))&&(t=t.values),(mf(e)||df(e))&&(e=e.values),ON(FN(Ot(t),Ot(e)),"`yPred` and `yTrue` must have the same shape!");let n=hf(t),r=hf(e),s=0;return n.forEach((i,o)=>{i===r[o]&&s++}),s/n.length}function UN(t){test(`tests that the \`${t.name}\` model works correctly`,()=>{let e=nr([5,10]).map(h=>h.map(p=>p*100+nr()*100)),n=[],r=jN(0,500).map(()=>{let h=IN(MN()*e.length),p=e[h];return n.push(h),_N(p,kN(5,nr(Ot(p))))}),[s,i,o,u]=RN(r,n),a=new t({k:e.length});a.fit(s),a.centroids=pf(e,a.centroids);let l=a.predict(s),f=a.predict(i);expect(rr(o,l)).toBeGreaterThan(.95),expect(rr(u,f)).toBeGreaterThan(.95)})}function PN(t){return DN(t)&&Ot(t).length===2}function BN(t){return AN(t)&&parseInt(t)===t&&t>=0}function pf(t,e){return t.map(n=>e[TN(e.map(r=>gf(n,r)))])}function gf(t,e){return zN(EN(CN(t,e),2))}qf.exports={accuracy:rr,createGenericTest:UN,isMatrix:PN,isWholeNumber:BN,orderCentroids:pf,sse:gf}});var or=c((u_,Nf)=>{var{add:yf,argmin:VN,assert:te,copy:JN,distance:bf,divide:YN,isDataFrame:$N,isFunction:GN,isUndefined:Ft,normal:LN,random:WN,range:KN,scale:HN,shuffle:XN,zeros:vf}=w(),{isMatrix:QN,isWholeNumber:sr,sse:ZN}=Dt(),ir=class{constructor(e){te(typeof e=="object","`config` must be an object! See the documentation for more information about the properties that the `config` object can contain."),te(sr(e.k),"`k` must be a whole number!"),te(sr(e.maxIterations)||Ft(e.maxIterations),"`maxIterations` must be a whole number or undefined!"),te(sr(e.maxRestarts)||Ft(e.maxRestarts),"`maxRestarts` must be a whole number or undefined!"),te(typeof e.tolerance=="number"||Ft(e.tolerance),"`tolerance` must be a number or undefined!");let n=this;n.k=e.k,n.maxRestarts=e.maxRestarts||25,n.maxIterations=e.maxIterations||100,n.tolerance=e.tolerance||1e-4,n.centroids=null,n._fitState=null}initializeCentroids(e){let n=this;return XN(e).slice(0,n.k)}fitStep(e,n){let r=this;if(te(QN(e),"`x` must be a matrix!"),$N(e)&&(e=e.values),Ft(n)||te(GN(n),"If defined, `progress` must be a function!"),r._fitState){if(r._fitState.isFinished)return r}else{let a=r.initializeCentroids(e);r._fitState={currentRestart:0,currentIteration:0,currentCentroids:a,bestCentroids:a,bestScore:-1/0,isFinished:!1}}let s=r.predict(e,r._fitState.currentCentroids),i=[],o=vf(r.k);e.forEach((a,l)=>{let f=s[l];i[f]||(i[f]=vf(a.length)),i[f]=yf(i[f],a),o[f]++});let u=KN(0,r.k).map(a=>o[a]===0?yf(r._fitState.currentCentroids[parseInt(WN()*r._fitState.currentCentroids.length)],HN(.001,LN(r._fitState.currentCentroids[0].length))):YN(i[a],o[a]));if(bf(r._fitState.currentCentroids,u)<r.tolerance?r._fitState.currentIteration=r.maxIterations-1:r._fitState.currentCentroids=u,n&&n((r._fitState.currentRestart+r._fitState.currentIteration/r.maxIterations)/r.maxRestarts,r),r._fitState.currentIteration++,r._fitState.currentIteration>=r.maxIterations){let a=r.score(e,r._fitState.currentCentroids);if(a>r._fitState.bestScore&&(r._fitState.bestScore=a,r._fitState.bestCentroids=JN(r._fitState.currentCentroids)),r._fitState.currentIteration=0,r._fitState.currentRestart++,r._fitState.currentRestart>=r.maxRestarts)r._fitState.isFinished=!0,r.centroids=r._fitState.bestCentroids,n&&n(1,r);else{let l=r.initializeCentroids(e);r._fitState.currentCentroids=l}}return r}fit(e,n){let r=this;for(r._fitState&&(r._fitState=null);!r._fitState||!r._fitState.isFinished;)r.fitStep(e,n);return r}predict(e,n){if(n=n||this.centroids,!n)throw new Error("No centroids were provided to the `predict` method, and the K-Means model hasn't been fitted yet. Please either pass centroids as a second parameter to the `predict` method or run the `fit` method first!");return e.map(s=>VN(n.map(i=>bf(s,i))))}score(e,n){let r=this;if(n=n||r.centroids,!n)throw new Error("No centroids were provided to the `score` method, and the K-Means model hasn't been fitted yet. Please either pass centroids as a second parameter to the `score` method or run the `fit` method first!");let i=r.predict(e,n).map(o=>n[o]);return-ZN(e,i)}};Nf.exports=ir});var ar=c((a_,xf)=>{var{argmin:ew,distance:wf,divide:tw,max:nw,random:Sf}=w(),rw=or(),ur=class extends rw{initializeCentroids(e){let n=this,r=[e[parseInt(Sf()*e.length)]];for(;r.length<n.k;){let s=e.map(o=>wf(o,r[ew(r.map(u=>wf(o,u)))])),i=tw(s,nw(s));r.push(e[i.findIndex(o=>Sf()<o)])}return r}};xf.exports=ur});var Of=c((c_,Tf)=>{var{assert:J,isArray:sw,isDataFrame:iw,isEqual:ow,isFunction:uw,isUndefined:pe,range:aw,shape:_f}=w(),{isMatrix:cw,isWholeNumber:cr}=Dt(),lw=ar(),lr=class{constructor(e){pe(e)&&(e={}),J(typeof e=="object","`config` must be an object! See the documentation for more information about the properties that the `config` object can contain."),pe(e.ks)&&(e.ks=aw(1,16)),J(sw(e.ks),"`ks` must be an array of whole numbers!"),e.ks.forEach(r=>{J(cr(r),"`ks` must be an array of whole numbers!")}),J(cr(e.maxIterations)||pe(e.maxIterations),"`maxIterations` must be a whole number or undefined!"),J(cr(e.maxRestarts)||pe(e.maxRestarts),"`maxRestarts` must be a whole number or undefined!"),J(typeof e.tolerance=="number"||pe(e.tolerance),"`tolerance` must be a number or undefined!");let n=this;n.ks=e.ks,n.maxRestarts=e.maxRestarts||25,n.maxIterations=e.maxIterations||100,n.tolerance=e.tolerance||1e-4,n.scoreStopRatio=e.scoreStopRatio||.85,n.modelClass=e.modelClass||lw,n.fittedModel=null,n._fitState=null}fitStep(e,n){let r=this;if(J(cw(e),"`x` must be a matrix!"),iw(e)&&(e=e.values),pe(n)||J(uw(n),"If defined, `progress` must be a function!"),!r._fitState)r._fitState={isFinished:!1,lastScore:-1/0,currentIndex:0};else if(r._fitState.isFinished)return r;let s=r.ks[r._fitState.currentIndex],i=new r.modelClass({k:s,maxRestarts:10,maxIterations:20});i.fit(e,u=>n?n((r._fitState.currentIndex+u)/(r.ks.length+1)):null);let o=i.score(e);return o/r._fitState.lastScore>r.scoreStopRatio?(r._fitState.isFinished=!0,r._fitState.currentIndex--):(r._fitState.lastScore=o,r._fitState.currentIndex+1>=r.ks.length?r._fitState.isFinished=!0:r._fitState.currentIndex++),r._fitState.isFinished&&(r.fittedModel=new r.modelClass({k:r.ks[r._fitState.currentIndex],maxRestarts:r.maxRestarts,maxIterations:r.maxIterations}),r.fittedModel.fit(e,u=>n?n((r.ks.length+u)/(r.ks.length+1)):null),n&&n(1)),r}fit(e,n){let r=this;for(r._fitState=null;!r._fitState||!r._fitState.isFinished;)r.fitStep(e,n);return r}predict(e,n){return this.fittedModel.predict(e,n)}score(e,n){return this.fittedModel.score(e,n)}get k(){return this.fittedModel.k}set k(e){throw new Error("You can't set the k-value manually! It has to be set automatically via the `fit` method.")}get centroids(){return this.fittedModel.centroids}set centroids(e){let n=this;J(ow(_f(e),_f(n.fittedModel.centroids)),"When assigning a new value to the `centroids` property, the new centroids must have the same shape as the old centroids!"),n.fittedModel.centroids=e}};Tf.exports=lr});var Ff=c((l_,Df)=>{Df.exports={KMeansMeta:Of(),KMeansNaive:or(),KMeansPlusPlus:ar(),helpers:Dt()}});var fr=c((f_,kf)=>{var{apply:fw,assert:hw,dropNaN:If,isArray:mw,isDataFrame:dw,isSeries:pw,mean:Af,std:Ef}=w(),Mf=P();function jf(t){if(dw(t)||pw(t)){let r=t.copy();return r.values=jf(r.values),r}hw(mw(t),"The `normalize` function only works on arrays, Series, and DataFrames!");let e=(()=>Mf.shouldIgnoreNaNValues?Af(If(t)):Af(t))(),n=(()=>Mf.shouldIgnoreNaNValues?Ef(If(t)):Ef(t))();return n===0?t:fw(t,r=>(r-e)/n)}kf.exports=jf});var mr=c((h_,Pf)=>{var{assert:ge,dot:Cf,isArray:zf,isSeries:hr,scale:gw,Series:qw,shape:Rf}=w(),Uf=me();function It(t,e){if(hr(t)){if(hr(e))return new qw(It(t.values,e.values));{let n=t.copy();return n.values=It(t.values,e),n}}if(hr(e)){let n=e.copy();return n.values=It(t,e.values),n}return ge(zf(t),"`project` only works on vectors!"),ge(zf(e),"`project` only works on vectors!"),ge(Uf(t),"`project` only works on vectors of numbers!"),ge(Uf(e),"`project` only works on vectors of numbers!"),ge(Rf(t).length===1,"`project` only works on vectors!"),ge(Rf(e).length===1,"`project` only works on vectors!"),gw(Cf(e,t)/Cf(e,e),e)}Pf.exports=It});var $f=c((m_,Yf)=>{var{assert:Bf,copy:yw,DataFrame:bw,divide:vw,isArray:Nw,isDataFrame:ww,isJagged:Sw,shape:xw,subtract:_w,transpose:Vf}=w(),Tw=me(),Ow=Ln(),Dw=mr();function Jf(t){if(ww(t)){let s=new bw(Jf(t.values));return s.index=t.index.slice(),s.columns=t.columns.slice(),s}Bf(Nw(t)&&!Sw(t)&&xw(t).length===2,"`orthonormalize` only works on matrices!"),Bf(Tw(t),"`orthonormalize` only works on matrices of numbers!");let e=Vf(t),n=[];e.forEach(s=>{let i=yw(s);n.forEach(o=>{i=_w(i,Dw(i,o))}),n.push(i)});let r=n.map(s=>vw(s,Ow(s)));return Vf(r)}Yf.exports=Jf});var Qf=c((d_,Xf)=>{var{assert:qe,correl:Fw,DataFrame:Gf,dropMissing:Iw,inferType:Lf,isArray:Aw,isDataFrame:Ew,isEqual:Mw,isFunction:jw,isJagged:kw,isNumber:ze,isUndefined:Cw,set:zw,shape:Rw}=w(),Uw=Rn(),Pw=Wn(),Wf=(t,e)=>t.map(n=>n[e]),Kf=t=>ze(t)&&(parseInt(t)===t||t===1/0);function Hf(t,e){e=e||{};let n=ze(e.maxUniqueStrings)?e.maxUniqueStrings:7,r=ze(e.minNonMissingValues)?e.minNonMissingValues:15,s=ze(e.maxCorrelationThreshold)?e.maxCorrelationThreshold:1-1e-5,i=e.progress||null;if(Aw(t))return qe(Rw(t).length===2&&!kw(t),"The `preprocess` function only works on non-jagged 2-dimensional arrays and DataFrames!"),Hf(new Gf(t));qe(Ew(t),"You must pass a DataFrame into the `preprocess` function!"),qe(Kf(n),"`maxUniqueStrings` must be a whole number!"),qe(Kf(r),"`minNonMissingValues` must be a whole number!"),qe(ze(s),"`maxCorrelationThreshold` must be a number!"),Cw(i)||qe(jw(i),"If defined, `progress` must be a function!");let o={},u={},a={},l=t.values;t.columns.forEach((h,p)=>{if(u[h])return;let b=Wf(l,p),S=(()=>{if(o[h])return o[h];{let F=Lf(b);return F.type==="date"&&(F.values=F.values.map(ne=>ne-0)),o[h]=F,F}})();if(S.type==="null"||S.type==="object"){u[h]=!0;return}let O=Iw(S.values);if(O.length<=r){u[h]=!0;return}let B=zw(O);if(B.length<2){u[h]=!0;return}if(S.type==="string"&&B.length<=n){let F=Pw(h,S.values);Object.keys(F).forEach(ne=>{a[ne]=F[ne]}),u[h]=!0;return}S.type==="number"&&(S.values=Uw(S.values)),t.columns.slice(p+1).forEach((F,ne)=>{if(u[F])return;let Oh=Wf(l,p+ne+1),ye=(()=>{if(o[F])return o[F];{let re=Lf(Oh);return re.type==="date"&&(re.values=re.values.map(Dh=>Dh-0)),o[F]=re,re}})();if(ye.type===S.type){if(ye.type==="number"&&Fw(ye.values,S.values)>s){u[F]=!0;return}if(ye.type==="string"&&Mw(ye.values,S.values)){u[F]=!0;return}}}),a[h]=S.values,i&&i(p/t.columns.length)});let f=new Gf(a);return f.index=t.index.slice(),f}Xf.exports=Hf});var ah=c((p_,uh)=>{var{abs:Bw,add:Vw,assert:Re,isArray:Zf,isDataFrame:eh,isEqual:Jw,isSeries:th,mean:Yw,pow:nh,scale:$w,shape:rh,sign:Gw,sqrt:Lw,sum:sh}=w(),ih=me(),oh=(t,e)=>Vw(t,$w(e,-1));function dr(t,e){if(eh(t)||th(t))return dr(t.values,e);if(eh(e)||th(e))return dr(t,e.values);Re(Zf(t),"You must pass two same-shaped numerical arrays into the `rScore` function!"),Re(Zf(e),"You must pass two same-shaped numerical arrays into the `rScore` function!"),Re(Jw(rh(t),rh(e)),"You must pass two same-shaped numerical arrays into the `rScore` function!"),Re(ih(t),"You must pass two same-shaped numerical arrays into the `rScore` function!"),Re(ih(e),"You must pass two same-shaped numerical arrays into the `rScore` function!");let n=sh(nh(oh(t,e),2)),r=sh(nh(oh(t,Yw(t)),2));if(r===0)return NaN;let s=1-n/r;return Gw(s)*Lw(Bw(s))}uh.exports=dr});var mh=c((g_,hh)=>{var{argmax:ch,assert:Ue,copy:Ww,DataFrame:Kw,dot:Hw,isArray:Xw,isDataFrame:Qw,isEqual:lh,isJagged:Zw,max:eS,min:tS,reverse:nS,shape:rS,transpose:sS}=w();function fh(t){if(Xw(t)){Ue(rS(t).length===2&&!Zw(t),"The `sortCorrelationMatrix` function only works on 2-dimensional arrays and DataFrames!");let s=new Kw(t);return s.index=s.columns.slice(),fh(s).values}Ue(Qw(t),"You must pass a DataFrame into the `sortCorrelationMatrix` function!"),Ue(eS(t.values)<=1&&tS(t.values)>=-1,"The correlation matrix passed into the `sortCorrelationMatrix` function must not contain values less than -1 or greater than 1!"),Ue(lh(t.values,sS(t.values)),"The correlation matrix passed into the `sortCorrelationMatrix` function must be symmetrical!"),Ue(lh(t.index,t.columns),"The correlation matrix passed into the `sortCorrelationMatrix` function must be symmetrical! (In this case, although the values themselves are symmetrical, the row and column names differ.)");let e=Ww(t.index),n=[];for(;e.length>0;)if(n.length===0){let s=ch(t.values.map(i=>Hw(i,i)));n.push(e[s]),e.splice(s,1)}else{let s=t.index.indexOf(n.at(-1)),i=ch(e.map(u=>t.values[t.index.indexOf(u)][s])),o=e[i];n.push(o),e.splice(i,1)}let r=nS(n);return t.get(r,r)}hh.exports=fh});var ph=c((q_,dh)=>{var iS=fr();function oS(){return iS(...arguments)}dh.exports=oS});var xh=c((y_,Sh)=>{var{assert:At,DataFrame:gh,dropNaN:uS,flatten:qh,isArray:aS,isDataFrame:pr,isSeries:gr,mean:yh,range:cS,Series:bh,shape:vh,stdev:Nh,transpose:wh}=w(),lS=P(),qr=class{constructor(){let e=this;e.means=[],e.stdevs=[],e.wasFittedOnAVector=!1,e.hasBeenFitted=!1}_getDataArrayAndShape(e){if(pr(e))return[e.values,e.shape];if(gr(e)){let r=wh([e.values]);return[r,vh(r)]}At(aS(e),"`x` must be a 1- or 2-dimensional array, DataFrame, or Series!");let n=vh(e);return At(n.length<3,"`x` must be a 1- or 2-dimensional array, DataFrame, or Series!"),n.length===1&&(n.push(1),e=wh([e])),[e,n]}fit(e){let n=this,r=n._getDataArrayAndShape(e);e=r[0];let s=r[1];return n.wasFittedOnAVector=s.indexOf(1)>-1,n.means=[],n.stdevs=[],cS(0,s[1]).forEach(i=>{let o=e.map(u=>u[i]);if(lS.shouldIgnoreNaNValues){let u=uS(o);n.means.push(yh(u)),n.stdevs.push(Nh(u))}else n.means.push(yh(o)),n.stdevs.push(Nh(o))}),n.hasBeenFitted=!0,n}transform(e){let n=this;if(!n.hasBeenFitted)throw new Error("This `StandardScaler` instance hasn't been trained on any data yet! Please use the `fit` method to train it before calling the `transform` method.");if(pr(e)){let o=new gh(n.transform(e.values));return o.columns=e.columns,o.index=e.index,o}if(gr(e)){let o=new bh(n.transform(e.values));return o.name=e.name,o.index=e.index,o}let r=n._getDataArrayAndShape(e);e=r[0];let s=r[1];At(s[1]===n.means.length,"The data you passed into the `transform` function doesn't have the same number of columns as the data set on which this StandardScaler was fitted!");let i=e.map(o=>o.map((u,a)=>(u-n.means[a])/n.stdevs[a]));return n.wasFittedOnAVector?qh(i):i}untransform(e){let n=this;if(!n.hasBeenFitted)throw new Error("This `StandardScaler` instance hasn't been trained on any data yet! Please use the `fit` method to train it before calling the `transform` method.");if(pr(e)){let o=new gh(n.untransform(e.values));return o.columns=e.columns,o.index=e.index,o}if(gr(e)){let o=new bh(n.untransform(e.values));return o.name=e.name,o.index=e.index,o}let r=n._getDataArrayAndShape(e);e=r[0];let s=r[1];At(s[1]===n.means.length,"The data you passed into the `untransform` function doesn't have the same number of columns as the data set on which this StandardScaler was fitted!");let i=e.map(o=>o.map((u,a)=>u*n.stdevs[a]+n.means[a]));return n.wasFittedOnAVector?qh(i):i}};Sh.exports=qr});var hS=c((b_,Th)=>{var{MathError:fS}=w(),_h={clipOutliers:Rn(),cohensD:Pn(),cohensd:Pn(),common:P(),containsOnlyNumbers:me(),diagonalize:Sl(),getCorrelationMatrix:Yn(),getHighlyCorrelatedColumns:El(),getMagnitude:Ln(),getOneHotEncodings:Wn(),getPercentages:Ul(),getPValueMatrix:ef(),IndexMatcher:of(),isBinary:zn(),isCorrelationMatrix:$n(),KMeans:Ff(),normalize:fr(),orthonormalize:$f(),preprocess:Qf(),project:mr(),pValue:Hn(),rScore:ah(),sortCorrelationMatrix:mh(),standardize:ph(),StandardScaler:xh(),trainTestSplit:tr(),dump(){let t=this,e=typeof global<"u"?global:typeof window<"u"?window:null;if(!e)throw new fS("Cannot dump functions into global scope because neither `global` nor `window` exist in the current context!");Object.keys(t).forEach(n=>{try{Object.defineProperty(e,n,{configurable:!1,enumerable:!0,writable:!1,value:t[n]})}catch{e[n]=t[n]}})}};try{window.JSDataScienceHelpers=_h}catch{}try{Th.exports=_h}catch{}});hS();})();
