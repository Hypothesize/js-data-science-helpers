(()=>{var Ih=Object.defineProperty;var jh=(t,e,n)=>e in t?Ih(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n;var Ne=(t=>typeof require!="undefined"?require:typeof Proxy!="undefined"?new Proxy(t,{get:(e,n)=>(typeof require!="undefined"?require:e)[n]}):t)(function(t){if(typeof require!="undefined")return require.apply(this,arguments);throw new Error('Dynamic require of "'+t+'" is not supported')});var c=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports);var Vt=(t,e,n)=>(jh(t,typeof e!="symbol"?e+"":e,n),n);var U=c((MS,Tr)=>{var Pt=class extends Error{constructor(e){typeof window<"u"?super(e):super(`

\x1B[31m`+e+`
\x1B[0m`)}};Tr.exports=Pt});var d=c((IS,Or)=>{var kh=U();Or.exports=function(t,e){if(!t)throw new kh(e)}});var B=c((jS,Fr)=>{function Ch(t){try{return structuredClone(t)}catch{return t}}Fr.exports=Ch});var g=c((kS,Dr)=>{function zh(t){try{return t instanceof Array||typeof t.constructor<"u"&&t.constructor.name==="Array"}catch{return!1}}Dr.exports=zh});var b=c((CS,_r)=>{function Vh(t){try{return!!t._symbol&&t._symbol===Symbol.for("@jrc03c/js-math-tools/dataframe")}catch{return!1}}_r.exports=Vh});var y=c((zS,Er)=>{function Ph(t){try{return!!t._symbol&&t._symbol===Symbol.for("@jrc03c/js-math-tools/series")}catch{return!1}}Er.exports=Ph});var D=c((VS,Ir)=>{var Uh=d(),Bh=B(),Ar=g(),Rh=b(),Jh=y();function Mr(t){if(Rh(t)||Jh(t))return Mr(t.values);Uh(Ar(t),"The `flatten` function only works on arrays, Series, and DataFrames!");function e(n){let r=[];return Bh(n).forEach(s=>{Ar(s)?r=r.concat(e(s)):r.push(s)}),r}return e(t)}Ir.exports=Mr});var j=c((PS,jr)=>{function Yh(t){return typeof t=="function"}jr.exports=Yh});var q=c((US,kr)=>{function $h(t){return typeof t=="number"&&!isNaN(t)}kr.exports=$h});var w=c((BS,Cr)=>{function Lh(t){return t===null||typeof t>"u"}Cr.exports=Lh});var K=c((RS,zr)=>{var Kh=g(),Gh=w();function Wh(t){return typeof t=="object"&&!Gh(t)&&!Kh(t)}zr.exports=Wh});var ve=c((JS,Ur)=>{var Hh=d(),Vr=g(),Qh=b(),Xh=j(),Ut=q(),Pr=K(),Zh=y();function Bt(t,e){if(Qh(t)){let o=Bt(t.values,e);return o.length>0&&Ut(o[0])&&o[0]>=0&&o[0]<t.index.length&&(o[0]=t.index[o[0]]),o.length>1&&Ut(o[1])&&o[1]>=0&&o[1]<t.columns.length&&(o[1]=t.columns[o[1]]),o}if(Zh(t)){let o=Bt(t.values,e);return o.length>0&&Ut(o[0])&&o[0]>=0&&o[0]<t.index.length&&(o[0]=t.index[o[0]]),o}if(Hh(Pr(t)||Vr(t),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `indexOf` function!"),!Xh(e)){let o=e;e=i=>i===o}function n(o,i,u){if(u=u||[],u.indexOf(o)>-1)return null;if(Pr(o)){u.push(o);let a=Object.keys(o);for(let l=0;l<a.length;l++){let f=a[l],h=o[f];if(i(h))return[f];let m=n(h,i,u);if(m&&m.length>0)return[f].concat(m)}}else if(Vr(o)){u.push(o);for(let a=0;a<o.length;a++){let l=o[a];if(i(l))return[a];let f=n(l,i,u);if(f&&f.length>0)return[a].concat(f)}}else if(i(o))return[];return null}function r(o){try{return e(o)}catch{return!1}}let s=n(t,r);return s&&s.length>0?s:null}Ur.exports=Bt});var R=c((YS,Jr)=>{var Br=B(),e0=ve(),t0=g(),n0=b(),r0=y();function Rr(t){function e(r,s,o){if(n0(r)||r0(r))return r.copy();if(s=s||[],o=o||"",s.indexOf(r)>-1){let i=o.split("/").slice(o.startsWith("/")?1:0);if(i.some((a,l)=>{let f=i.slice(0,i.length-l-1),h=n;return f.forEach(m=>{h=h[m]}),h===r}))return`<reference to "${n===r?"/":"/"+e0(n,r).join("/")}">`}if(typeof r=="object"){if(r===null)return null;if(s.push(r),t0(r))return r.map((i,u)=>e(i,s,o+"/"+u));{let i={};return Object.keys(r).forEach(u=>{i[u]=e(r[u],s,o+"/"+u)}),i}}else return r}let n=t;return e(t)}function s0(t,e){function n(r,s){let o=typeof r;if(o!==typeof s)return!1;if(o==="undefined")return!0;if(o==="boolean"||o==="symbol")return r===s;if(o==="number"||o==="bigint")return r.toString()==="NaN"&&s.toString()==="NaN"?!0:r===s;if(o==="string"||o==="function")return r===s;if(o==="object"){if(r===null||s===null)return r===null&&s===null;{let u=Object.keys(r),a=Object.keys(s);if(u.length!==a.length)return!1;for(let l=0;l<u.length;l++){let f=u[l];if(!n(r[f],s[f]))return!1}return!0}}}try{return n(Br(t),Br(e))}catch{return n(Rr(t),Rr(e))}}Jr.exports=s0});var P=c(($S,Kr)=>{var o0=d(),i0=D(),u0=g(),Yr=b(),a0=j(),$r=y(),c0=w();function Se(t){let e="abcdefg1234567890",n="";for(;n.length<t;)n+=e[parseInt(Math.random()*e.length)];return n}var l0=Se(256),f0=Se(256),h0=Se(256),m0=Se(256),d0=Se(256);function Lr(t){if(Yr(t)||$r(t))return Lr(t.values);o0(u0(t),"The `set` function only works on arrays, Series, and DataFrames!");let e=[],n={};return i0(t).forEach(r=>{let s=typeof r=="object"&&r===null?l0:c0(r)?f0:a0(r)?r.toString():typeof r=="symbol"?r.toString()+" - "+d0:r===1/0?h0:r===-1/0?m0:Yr(r)?r.toJSONString():$r(r)?JSON.stringify(r.toObject()):JSON.stringify(r);n[s]||e.push(r),n[s]=!0}),e}Kr.exports=Lr});var Re=c((LS,Hr)=>{var p0=d(),Rt=D(),Gr=g(),g0=b(),Wr=R(),q0=j(),y0=y(),b0=P();function Be(t,e){if(g0(t)||y0(t))return arguments.length>1?Be(t.values,e):Be(t.values,t.values);if(p0(Gr(t),"The first argument to the `count` function must be an array, Series, or DataFrame!"),q0(e))return Rt(t).filter(n=>e(n)).length;if(Gr(e)){let n=Rt(t);return b0(e).map(r=>({item:r,count:n.filter(s=>Wr(s,r)).length}))}else return arguments.length>1?Rt(t).filter(n=>Wr(n,e)).length:Be(t,t)}Hr.exports=Be});var xe=c((KS,Xr)=>{var w0=d(),Qr=g(),N0=b(),v0=y();function Jt(t){if(N0(t)||v0(t))return Jt(t.values);w0(Qr(t),"The `isJagged` function only works on arrays, Series, and DataFrames!");let e=0,n=null;for(let r=0;r<t.length;r++)if(Qr(t[r])){if(e++,Jt(t[r]))return!0;if(n===null)n=t[r].length;else if(t[r].length!==n)return!0}return e>0&&e<t.length}Xr.exports=Jt});var Je=c((GS,ts)=>{var S0=d(),Zr=g(),x0=b(),T0=y();function es(t){if(x0(t)||T0(t))return es(t.values);S0(Zr(t),"The `isNested` function only works on arrays, Series, and DataFrames!");for(let e=0;e<t.length;e++)if(Zr(t[e]))return!0;return!1}ts.exports=es});var G=c((WS,rs)=>{var se=d(),O0=g(),F0=Je(),D0=q(),_0=w(),ce="You must pass a natural number or a one-dimensional array of natural numbers into the `ndarray` function!";function ns(t){se(!_0(t),ce),O0(t)||(t=[t]),se(!F0(t),ce),se(t.length>0,ce);let e=t[0];if(se(D0(e),ce),se(parseInt(e)===e,ce),se(e>=0,ce),se(e!==1/0,"We can't create an array containing an infinite number of values!"),t.length===1){let n=[];for(let r=0;r<e;r++)n.push(void 0);return n}else{let n=[];for(let r=0;r<e;r++)n.push(ns(t.slice(1)));return n}}rs.exports=ns});var Te=c((HS,ss)=>{var E0=d(),A0=g(),M0=b(),I0=y();function Yt(t){if(M0(t)||I0(t)){let n=t.copy();return n.values=Yt(n.values),n.index=Yt(n.index),n}E0(A0(t),"The `reverse` function only works on arrays, Series, and DataFrames!");let e=[];for(let n=t.length-1;n>=0;n--)e.push(t[n]);return e}ss.exports=Yt});var k=c((QS,os)=>{var $t=d(),Lt=q(),Kt=w(),j0=Te();function k0(t,e,n=1){$t(!Kt(t)&&!Kt(e)&&!Kt(n),"You must pass two numbers and optionally a step value to the `range` function!"),$t(Lt(t)&&Lt(e)&&Lt(n),"You must pass two numbers and optionally a step value to the `range` function!"),$t(n>0,"The step value must be greater than 0! (NOTE: The step value is a magnitude; it does not indicate direction.)");let r=!1;if(t>e){r=!0;let o=t;t=e+n,e=o+n}let s=[];for(let o=t;o<e;o+=n)s.push(o);return r&&(s=j0(s)),s}os.exports=k0});var T=c((XS,cs)=>{var C0=d(),is=g(),z0=b(),V0=R(),P0=y(),U0=w();function us(t){if(!is(t))return;let e=[t.length],n=0,r=t.map(s=>{let o=us(s);return U0(o)?o:(n++,o.length===1?o[0]:o)});return n>0?n===t.length&&r.slice(0,-1).every((o,i)=>V0(o,r[i+1]))?e.concat(r[0]):(e.push(r),e):e}function as(t){return z0(t)||P0(t)?as(t.values):(C0(is(t),"The `shape` function only works on arrays, Series, and DataFrames!"),us(t))}cs.exports=as});var ps=c((ZS,ds)=>{var ls=d(),B0=g(),R0=b(),J0=xe(),Y0=y(),$0=w(),fs=U(),Ye=G(),hs=k(),L0=P(),K0=T();function ms(t,e,n){if($0(n)&&(n=0),ls(n===0||n===1||n==="vertical"||n==="horizontal",'The only valid axis values for use when appending data to a DataFrame are 0, 1, "vertical", and "horizontal". Note that 0 == "horizontal" and 1 == "vertical".'),B0(e)){ls(!J0(e),"The array of data you're trying to append to this DataFrame is jagged!");let r=K0(e);if(r.length===1)if(n===0){let s=t.copy();s._values.push(e);let o=Math.max(t.shape[1],r[0]);for(s._values.forEach(i=>{for(;i.length<o;)i.push(void 0)});s._index.length<s._values.length;)s._index.push("row"+s._index.length);for(;s._columns.length<o;)s._columns.push("col"+s._columns.length);return s}else{let s=Math.max(t.shape[0],r[0]),o=t.copy();for(hs(0,s).forEach(i=>{i>=o._values.length&&o._values.push(Ye(t.shape[1])),o._values[i].push(e[i])});o._index.length<o._values.length;)o._index.push("row"+o._index.length);for(;o._columns.length<o._values[0].length;)o._columns.push("col"+o._columns.length);return o}else if(r.length===2)if(n===0){let s=Math.max(...e.map(i=>i.length).concat([t.shape[1]])),o=t.copy();for(o._values=o._values.concat(e).map(i=>{for(;i.length<s;)i.push(void 0);return i});o._index.length<o._values.length;)o._index.push("row"+o._index.length);for(;o._columns.length<s;)o._columns.push("col"+o._columns.length);return o}else{let s=Math.max(...e.map(u=>u.length))+t.shape[1],o=Math.max(t.shape[0],r[0]),i=t.copy();for(hs(0,o).forEach(u=>{for(u>=i._values.length&&i._values.push(Ye(t.shape[1])),i._values[u]=i._values[u].concat(e[u]);i._values[u].length<s;)i._values[u].push(void 0)});i._index.length<i._values.length;)i._index.push("row"+i._index.length);for(;i._columns.length<s;)i._columns.push("col"+i._columns.length);return i}else throw new fs("Only 1- and 2-dimensional arrays can be appended to a DataFrame!")}else if(Y0(e)){let r=ms(t,e.values,n);return n===0?r.index[r.index.length-1]=r.index.indexOf(e.name)>-1?e.name+" (2)":e.name:r.columns[r.columns.length-1]=r.columns.indexOf(e.name)>-1?e.name+" (2)":e.name,r}else if(R0(e))if(n===0){let r=t.copy(),s=L0(r._columns.concat(e._columns)).length;for(r._values.forEach(o=>{for(;o.length<s;)o.push(void 0)}),e.apply(o=>{let i=o.copy(),u=[];r._columns.forEach(a=>{let l=i._index.indexOf(a);l>-1?(u.push(i._values[l]),i._values.splice(l,1),i._index.splice(l,1)):u.push(void 0)}),r._values.push(u.concat(i._values))},1),r._columns=r._columns.concat(e._columns.filter(o=>r._columns.indexOf(o)<0));r._index.length<r._values.length;){let o="row"+r._index.length;r._index.push(o+(t._index.indexOf(o)>-1?" (2)":""))}return r}else{let r=t.copy();return r._index.forEach((s,o)=>{let i=e._index.indexOf(s);i>-1?r._values[o]=r._values[o].concat(e._values[i]):r._values[o]=r._values[o].concat(Ye(e.shape[1]))}),e._index.forEach((s,o)=>{r._index.indexOf(s)<0&&(r._index.push(s),r._values.push(Ye(r._columns.length).concat(e._values[o])))}),r._columns=r._columns.concat(e._columns.map(s=>s+(r._columns.indexOf(s)>-1?" (2)":""))),r}else throw new fs("Only 1- or 2-dimensional arrays, Series, and DataFrames can be appended to a DataFrame!")}ds.exports=ms});var ws=c((e2,bs)=>{var gs=d(),qs=g(),G0=j(),ys=w();function W0(t,e,n,r,s){if(s=s||0,gs(G0(r),"The first parameter to the `apply` method must be a function."),gs(s===0||s===1,"The second parameter to the `apply` method (the `axis`) must be 0 or 1."),s===0){let o={},i;if(n.columns.forEach((u,a)=>{let l=new e(n.values.map(h=>h[a]));l.name=u,l.index=n.index;let f=r(l,a,n);f instanceof e?o[u]=f.values:o[u]=f,ys(i)&&(i=f instanceof e||qs(f))}),i){let u=new t(o);return u.index=n.index,u}else{let u=new e(n.columns.map(a=>o[a]));return u.index=n.columns,u}}else if(s===1){let o,i=n.values.map((u,a)=>{let l=new e(u);l.name=n.index[a],l.index=n.columns;let f=r(l,a,n);return ys(o)&&(o=f instanceof e||qs(f)),f instanceof e?f.values:f});if(o){let u=new t(i);return u.index=n.index,u.columns=n.columns,u}else{let u=new e(i);return u.index=n.index,u}}}bs.exports=W0});var M=c((t2,Ns)=>{function H0(t){return typeof t=="string"}Ns.exports=H0});var xs=c((n2,Ss)=>{var vs=d(),Q0=g(),X0=xe(),Z0=K(),em=M(),tm=w(),nm=U(),rm=T();function sm(t,e,n,r,s){let o=u=>u instanceof t,i=u=>u instanceof e;if(tm(s)){if(o(r))return n.append(r,1);if(i(r))return n.append(r,1);if(Z0(r)){let u=Math.max(...Object.keys(r).map(a=>r[a].length));return Object.keys(r).forEach(a=>{for(;r[a].length<u;)r[a].push(void 0)}),n.append(new t(r),1)}else throw new nm("You must pass a DataFrame, Series, or object into the `assign` method!")}else{vs(em(r),"If passing two arguments into the `assign` method, then the first argument must be a string name!"),vs(Q0(s)&&!X0(s)&&rm(s).length===1,"If passing two arguments into the `assign` method, then the second argument must be a 1-dimensional array!");let u=n.append(s,1);return u.columns[u.columns.length-1]=r,u}}Ss.exports=sm});var Os=c((r2,Ts)=>{var om=B();function im(t,e){if(e.isEmpty)return new t;let n=new t(om(e.values));return n.columns=e.columns.slice(),n.index=e.index.slice(),n}Ts.exports=im});var Is=c((s2,Ms)=>{var $e=d(),Fs=g(),Ds=q(),_s=M(),Es=w(),As=T();function um(t,e,n,r,s){Es(r)&&(r=[]),Es(s)&&(s=[]),(_s(r)||Ds(r))&&(r=[r]),(_s(s)||Ds(s))&&(s=[s]),$e(Fs(r),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),$e(Fs(s),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),$e(As(r).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),$e(As(s).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");let o,i;n.index.forEach((a,l)=>{r.indexOf(a)<0&&r.indexOf(l)<0&&(o||(o=[]),o.push(a))}),n.columns.forEach((a,l)=>{s.indexOf(a)<0&&s.indexOf(l)<0&&(i||(i=[]),i.push(a))});let u=n.get(o,i);if(u instanceof e){let a=new t;a=a.assign(u),n.index.indexOf(u.name)>-1&&(a=a.transpose()),u=a}return u}Ms.exports=um});var Oe=c((o2,js)=>{var am=q();function cm(t){return am(t)&&parseInt(t)===t}function lm(t){return cm(t)&&t>=0}js.exports=lm});var Cs=c((i2,ks)=>{var Gt=d(),fm=M(),Le=w(),hm=Oe(),mm=T();function dm(t,e,n,r,s,o){r=r||0,Gt(r===0||r===1,"The first parameter of the `dropMissing` method (the `axis`) must be 0 or 1."),o=o||0,Gt(hm(o),"The third parameter of the `dropMissing` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` null values)."),s=o>0?"none":s||"any",Gt(s==="any"||s==="all"||s==="none","The second parameter of the `dropMissing` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains null values, then it should be dropped; or that if 'all' of the data contains null values, then it should be dropped).");function i(l){if(o>0){let f=0;for(let h=0;h<l.length;h++){let m=l[h];if(Le(m)&&f++,f>=o)return[]}}else if(s==="any")for(let f=0;f<l.length;f++){let h=l[f];if(Le(h))return[]}else if(s==="all"){for(let f=0;f<l.length;f++){let h=l[f];if(!Le(h))return l}return[]}return l}let u=n.copy(),a=Math.random().toString();if(r===0){u=u.assign(a,u.index);let l=u.values.map(i).filter(h=>h.length>0);if(mm(l).length<2)return new t;u.values=l;let f=u.get(null,a);if(Le(f))return new t;fm(f)&&(f=[f]),f instanceof e&&(f=f.values),u.index=f,u=u.drop(null,a)}else if(r===1){let l={};if(u.columns.forEach((h,m)=>{let p=u.values.map(N=>N[m]),v=i(p);v.length>0&&(l[h]=v)}),Object.keys(l).length===0)return new t;let f=new t(l);return f.index=u.index,f}return u}ks.exports=dm});var Wt=c((u2,Vs)=>{var pm=d(),gm=g(),qm=b(),ym=q(),bm=y();function zs(t){if(qm(t)||bm(t))return t.dropNaN(...Object.values(arguments).slice(1));pm(gm(t),"The `dropNaN` function only works on arrays, Series, and DataFrames!");let e=[];return t.forEach(n=>{try{return e.push(zs(n))}catch{if(ym(n))return e.push(n)}}),e}Vs.exports=zs});var Us=c((a2,Ps)=>{var Ht=d(),wm=Wt(),Nm=Oe();function vm(t,e,n,r,s){n=n||0,Ht(n===0||n===1,"The first parameter of the `dropNaN` method (the `axis`) must be 0 or 1."),s=s||0,Ht(Nm(s),"The third parameter of the `dropNaN` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` NaN values)."),r=s>0?"none":r||"any",Ht(r==="any"||r==="all"||r==="none","The second parameter of the `dropNaN` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains NaN values, then it should be dropped; or that if 'all' of the data contains NaN values, then it should be dropped).");function o(u){let a=wm(u);return s>0?u.length-a.length<s:r==="any"?a.length===u.length:r==="all"?a.length>0:!0}let i=e.copy();if(n===0){let u=i.index.filter(a=>{let l=i.get(a,null).values;return o(l)});return u.length>0?i.get(u,null):new t}else if(n===1){let u=i.columns.filter(a=>{let l=i.get(null,a).values;return o(l)});return u.length>0?i.get(null,u):new t}return i}Ps.exports=vm});var Ys=c((c2,Js)=>{var Bs=d(),Fe=D(),Sm=j(),xm=w();function Rs(t){let e={};return Fe(t).forEach((n,r)=>{e[n]=r}),e}function le(t){return Object.keys(t).sort((e,n)=>t[e]-t[n])}function Tm(t,e,n,r,s){Bs(Sm(r),"The `filter` method takes a single parameter: a function that is used to filter the values."),xm(s)&&(s=0),Bs(s===0||s===1,"The `axis` parameter to the `filter` method must be 0 or 1.");let o=n.copy();if(o.isEmpty)return o;let i=Rs(o.index),u=Rs(o.columns);if(s===0){let a=o.values.filter((l,f)=>{let h=new e(l);h.name=n.index[f],h.index=n.columns;let m=r(h,f,n);return m||delete i[o.index[f]],m});if(Fe(a).length===0)return new t;if(a.length===1){let l=new e(Fe(a));return l.name=le(i)[0],l.index=le(u),l}o.values=a,o.index=le(i)}else if(s===1){o=o.transpose();let a=o.values.filter((l,f)=>{let h=new e(l);h.name=n.columns[f],h.index=n.index;let m=r(h,f,n);return m||delete u[o.index[f]],m});if(Fe(a).length===0)return new t;if(a.length===1){let l=new e(Fe(a));return l.name=le(u)[0],l.index=le(i),l}o.values=a,o.index=le(u),o=o.transpose()}return o}Js.exports=Tm});var De=c((l2,$s)=>{function Om(t){return typeof t=="boolean"}$s.exports=Om});var oe=c((f2,Ks)=>{var Fm=d(),Dm=D(),_m=g(),Em=b(),Am=y();function Ls(t){if(Em(t)||Am(t))return Ls(t.values);Fm(_m(t),"The `max` function only works on arrays, Series, and DataFrames!");try{return Math.max(...Dm(t))}catch{return NaN}}Ks.exports=Ls});var Qt=c((h2,Hs)=>{var Ke=U(),W=d(),H=g(),Gs=De(),Ge=M(),We=w(),Mm=oe(),Ws=k();function Im(t,e,n,r,s,o){return n=(()=>{if(We(n))return!1;if(Gs(n))return n;throw new Ke("The `hasHeaderRow` parameter of the `fromCSV` method must be a boolean!")})(),r=(()=>{if(We(r))return!1;if(Gs(r))return r;throw new Ke("The `hasIndexColumn` parameter of the `fromCSV` method must be a boolean!")})(),s=(()=>{let u="The `fieldDelimiter` parameter of the `fromCSV` method must be one of:\n\n1) a single-character string (e.g., ',')\n2) an array containing two single-character strings, one each for a left delimiter and a right delimiter (e.g., ['<', '>'])";if(We(s))return",";if(Ge(s))return W(s.length===1,u),s;if(H(s))return W(s.length===2,u),W(s[0].length===1,u),W(s[1].length===1,u),s;throw new Ke(u)})(),o=(()=>{let u="The `stringDelimiter` parameter of the `fromCSV` method must be one of:\n\n1) a single-character string (e.g., '\"')\n2) an array containing two single-character strings, one each for a left delimiter and a right delimiter (e.g., ['\u201C', '\u201D'])";if(We(o))return'"';if(Ge(o))return W(o.length===1,u),o;if(H(o))return W(o.length===2,u),W(o[0].length===1,u),W(o[1].length===1,u),o;throw new Ke(u)})(),(()=>{let a=e.split(`
`).filter(p=>p.length>0).map(p=>{let v=[],N="",E=!1;for(let F=0;F<p.length;F++){let A=p[F];if(A.match(/\\/g))F++;else if(H(o)&&A===o[0])E=!0;else if(H(o)&&A===o[1])E=!1;else if(Ge(o)&&A===o)E=!E;else if(H(s)&&A===s[0]||H(s)&&A===s[1]||Ge(s)&&A===s)if(E)N+=A;else{let ae=N;try{let V=JSON.parse(ae);H(V)?v.push(ae.trim()):v.push(V)}catch{v.push(ae.trim())}N=""}else N+=A}if(N.length>0){let F=N;try{let A=JSON.parse(F);H(A)?v.push(F.trim()):v.push(A)}catch{v.push(F.trim())}}return v}),l=(()=>{let p=n?a.shift():Ws(0,a[0].length).map(v=>"col"+v);return r&&p.shift(),p})(),f=(()=>r?a.map(v=>v.shift()):Ws(0,a.length).map(v=>"row"+v))(),h=Mm(a.map(p=>p.length)),m=new t(a.map(p=>(p.length=h,p)));return n&&(m.columns=l),r&&(m.index=f),m})()}Hs.exports=Im});var Xs=c((m2,Qs)=>{var jm=U(),km=d(),Cm=Qt(),zm=M(),Vm=w();async function Pm(t,e,n,r,s,o,i){n=(()=>Vm(n)?"utf8":(km(zm(n),"The `encoding` parameter of the `fromCSV` method must be a string (e.g., 'utf8')!"),n))();let u=await(async()=>{try{return Ne("fs").readFileSync(e,n)}catch{}try{return await(await fetch(e)).text()}catch{}throw new jm(`The path "${e}" could not be loaded!`)})();return Cm(t,u,r,s,o,i)}Qs.exports=Pm});var to=c((d2,eo)=>{var z=d(),He=q(),Qe=M(),Zs=w(),Um=P();function Bm(t,e,n){(Qe(e)||He(e))&&(e=[e]),(Qe(n)||He(n))&&(n=[n]);let r=Um((e||[]).concat(n||[]).map(s=>typeof s));return z(r.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===1&&z(r[0]==="string"||r[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===2&&(z(r.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),z(r.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),Zs(e)||(e=e.map(s=>{if(Qe(s))return z(t.index.indexOf(s)>-1,`Row "${s}" does not exist!`),s;if(He(s))return z(s>=0,`Index ${s} is out of bounds!`),z(parseInt(s)===s,"Row numbers must be integers!"),z(s<t.index.length,`Index ${s} is out of bounds!`),t.index[s]})),Zs(n)||(n=n.map(s=>{if(Qe(s))return z(t.columns.indexOf(s)>-1,`Column "${s}" does not exist!`),s;if(He(s))return z(s>=0,`Column ${s} is out of bounds!`),z(parseInt(s)===s,"Column numbers must be integers!"),z(s<t.columns.length,`Column ${s} is out of bounds!`),t.columns[s]})),t.getSubsetByNames(e,n)}eo.exports=Bm});var Q=c((p2,ro)=>{var no=d(),Rm=g(),Jm=b(),Ym=j(),$m=y(),Lm=w();function Km(t,e){try{return t<e?-1:t>e?1:0}catch{return t=typeof t=="object"&&t!==null?JSON.stringify(t):t.toString(),e=typeof e=="object"&&e!==null?JSON.stringify(e):e.toString(),t<e?-1:t>e?1:0}}function Gm(t,e){if(Lm(e)&&(e=Km),Jm(t)||$m(t))return t.sort(...Object.values(arguments).slice(1));no(Rm(t),"The `sort` function only works on arrays, Series, and DataFrames!"),no(Ym(e),"The second parameter of the `sort` function must be a comparison function!");let n=t.slice();return n.sort(e),n}ro.exports=Gm});var uo=c((g2,io)=>{var so=d(),oo=M(),Wm=w(),Hm=P(),Qm=Q();function Xm(t){let e=t.toLowerCase(),n="";for(let s=0;s<e.length;s++){let o=e[s];o.match(/[a-z0-9]/g)?n+=o:n+=" "}let r=n.split(" ").filter(s=>s.length>0);return r[0]+r.slice(1).map(s=>s[0].toUpperCase()+s.substring(1)).join("")}function Zm(t,e,n){Wm(n)?n=e.columns:oo(n)&&(n=[n]);let r={};n.forEach(o=>{so(oo(o),"You must pass either a string or a one-dimensional array of strings into the `getDummies` (AKA `oneHotEncode`) method!");let i=e.columns.indexOf(o);so(i>-1,`The given DataFrame does not have a column called "${o}"!`);let u=e.values.map(l=>l[i]),a=Qm(Hm(u));u.forEach(l=>{a.forEach(f=>{let h=o+"_"+Xm(f.toString());r[h]||(r[h]=[]),l===f?r[h].push(1):r[h].push(0)})})});let s=new t(r);return s.index=e.index,s}io.exports=Zm});var go=c((q2,po)=>{var X=d(),ao=g(),co=q(),lo=w(),fo=Oe(),ho=k(),mo=T();function ed(t,e,n){let r=t.shape;lo(e)&&(e=ho(0,r[0])),lo(n)&&(n=ho(0,r[1])),co(e)&&(e=[e]),co(n)&&(n=[n]),X(ao(e)&&ao(n),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),X(mo(e).length===1&&mo(n).length===1,"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),X(e.length>0,"The `rowIndices` array must contain at least one index."),X(n.length>0,"The `colIndices` array must contain at least one index."),e.forEach(i=>{X(fo(i),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),X(i<t.index.length,`The row index ${i} is out of bounds.`)}),n.forEach(i=>{X(fo(i),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),X(i<t.columns.length,`The column index ${i} is out of bounds.`)});let s=e.map(i=>t.index[i]),o=n.map(i=>t.columns[i]);return t.getSubsetByNames(s,o)}po.exports=ed});var No=c((y2,wo)=>{var Z=d(),Xt=D(),qo=g(),Xe=M(),yo=w(),bo=T();function td(t,e,n,r,s){yo(r)&&(r=n.index),yo(s)&&(s=n.columns),Xe(r)&&(r=[r]),Xe(s)&&(s=[s]),Z(qo(r)&&qo(s),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),Z(bo(r).length===1&&bo(s).length===1,"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),Z(r.length>0,"The `rows` array must contain at least one row name."),Z(s.length>0,"The `cols` array must contain at least one column name."),r.forEach(u=>{Z(Xe(u),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),Z(n.index.indexOf(u)>-1,`The row name "${u}" does not exist in the list of rows.`)}),s.forEach(u=>{Z(Xe(u),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),Z(n.columns.indexOf(u)>-1,`The column name "${u}" does not exist in the list of columns.`)});let o=r.map(u=>s.map(a=>n.values[n.index.indexOf(u)][n.columns.indexOf(a)]));if(r.length===1&&s.length===1)return Xt(o)[0];if(r.length===1){let u=new e(Xt(o));return u.name=r[0],u.index=s,u}if(s.length===1){let u=new e(Xt(o));return u.name=s[0],u.index=r,u}let i=new t(o);return i.columns=s,i.index=r,i}wo.exports=td});var So=c((b2,vo)=>{var nd=M(),_e=k();function rd(t,e,n){function r(m,p){return nd(m)&&m.length>p?m.substring(0,p-3)+"...":m}if(n.isEmpty)return console.table({}),console.log("Shape:",[0,0],`
`),n;let s=typeof window>"u"?20:10,o=parseInt(s/2),i=typeof window>"u"?Math.floor(process.stdout.columns/24)-1:10,u=parseInt(i/2),a=s>n.index.length?null:_e(0,o).concat(_e(n.index.length-o,n.index.length)),l=i>n.columns.length?null:_e(0,u).concat(_e(n.columns.length-u,n.columns.length)),f=n.get(a,l);f instanceof e&&(n.shape[0]===1?(f=new t([f.values]),f.index=n.index,f.columns=new e(n.columns).get(l).values):n.shape[1]===1&&(f=new t([f.values]).transpose(),f.index=new e(n.index).get(a).values,f.columns=n.columns)),s<=n.index.length&&(f._index.splice(o,0,"..."),f._values.splice(o,0,_e(0,f.columns.length).map(()=>"..."))),i<=n.columns.length&&(f._columns.splice(u,0,"..."),f._values=f._values.map(m=>(m.splice(u,0,"..."),m)));let h=28;return f instanceof e?(f.values=f.values.map(m=>r(m,h)),f.name=r(f.name,h),f.index=f.index.map(m=>r(m,h))):(f.values=f.values.map(m=>m.map(p=>r(p,h))),f.columns=f.columns.map(m=>r(m,h)),f.index=f.index.map(m=>r(m,h))),console.table(f.toObject()),console.log("Shape:",n.shape,`
`),n}vo.exports=rd});var Ze=c((w2,xo)=>{var sd=d(),od=q();function id(t,e){sd(od(t),"The `leftPad` function only works on numbers!");let n=t.toString();for(;n.length<e;)n="0"+n;return n}xo.exports=id});var Oo=c((N2,To)=>{var ud=Ze(),ad=k();function cd(t,e){let n=e?t:t.copy();return n.index=ad(0,t.shape[0]).map(r=>"row"+ud(r,(n.index.length-1).toString().length)),n}To.exports=cd});var Ee=c((v2,Do)=>{var ld=d(),fd=D(),hd=g(),md=b(),dd=y();function Fo(t){if(md(t)||dd(t))return Fo(t.values);ld(hd(t),"The `product` function only works on arrays, Series, and DataFrames!");try{return t.length===0?NaN:fd(t).reduce((e,n)=>e*n,1)}catch{return NaN}}Do.exports=Fo});var et=c((S2,Mo)=>{var Ae=d(),_o=D(),Eo=g(),pd=b(),Ao=q(),gd=y(),qd=Ee(),yd=T();function Zt(t,e){if(pd(t)||gd(t))return Zt(t.values,e);if(Ae(Eo(t),"The first argument passed into the `reshape` function must be an array!"),Ao(e)&&(e=[e]),Ae(Eo(e),"The second argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),Ae(yd(e).length===1,"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),e.forEach(o=>{Ae(Ao(o)&&parseInt(o)===o&&o>0,"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!")}),e.length===0)return _o(t);let n=_o(t);if(e.length===1&&e[0]===n.length)return n;Ae(qd(e)===n.length,"The new shape doesn't match the number of values available in `x` (the first argument passed into the `reshape` function)!");let r=[],s=parseInt(n.length/e[0]);for(let o=0;o<e[0];o++){let i=n.slice(o*s,(o+1)*s);r.push(Zt(i,e.slice(1)))}return r}Mo.exports=Zt});var fe=c((x2,Po)=>{var bd=d(),ko=B(),wd=g(),Nd=q(),Co=w(),vd=G(),Sd=Ee(),xd=et(),zo=Math.pow(2,64),O=[];Vo(parseInt(Math.random()*zo));function Td(t,e){t=I(t);function n(){t+=I("0x9e3779b97f4a7c15");let s=ko(t);return s=(s^s>>30n)*I("0xbf58476d1ce4e5b9"),s=(s^s>>27n)*I("0x94d049bb133111eb"),s^s>>31n}let r=[];for(let s=0;s<e;s++)r.push(n());return r}function I(t){return BigInt.asUintN(64,BigInt(t))}function Io(t,e){return t=I(t),e=BigInt(e),I(I(t<<e)|I(t>>I(64n-e)))}function Vo(t){if(Co(t))return ko(O);{bd(Nd(t),"If passing a value into the `seed` function, then that value must be an integer!");let e=Td(parseInt(t),4);O[0]=e[0],O[1]=e[1],O[2]=e[2],O[3]=e[3]}}function jo(){let t=I(Io(O[0]+O[3],23)+O[0]),e=I(O[1]<<17n);return O[2]=I(O[2]^O[0]),O[3]=I(O[3]^O[1]),O[1]=I(O[1]^O[2]),O[0]=I(O[0]^O[3]),O[2]=I(O[2]^e),O[3]=Io(O[3],45),parseInt(t)/zo}function Od(t){return Co(t)?jo():(wd(t)||(t=[t]),xd(vd(Sd(t)).map(jo),t))}Po.exports={random:Od,seed:Vo}});var tt=c((T2,Uo)=>{var{random:Fd}=fe(),Dd=d(),_d=g(),Ed=b(),Ad=y();function Md(t){if(Ed(t)||Ad(t))return t.shuffle(...Object.values(arguments).slice(1));Dd(_d(t),"The `shuffle` function only works on arrays, Series, and DataFrames!");let e=[],n=t.slice();for(let r=0;r<t.length;r++){let s=parseInt(Fd()*n.length);e.push(n.splice(s,1)[0])}return e}Uo.exports=Md});var Jo=c((O2,Ro)=>{var Id=d(),jd=w(),Bo=tt();function kd(t,e){return jd(e)&&(e=0),Id(e===0||e===1,"The `axis` parameter to the `shuffle` must be 0, 1, or undefined."),t.get(e===0?Bo(t.index):null,e===1?Bo(t.columns):null)}Ro.exports=kd});var Go=c((F2,Ko)=>{var{random:Cd}=fe(),C=d(),zd=D(),Yo=g(),en=De(),Lo=j(),nt=q(),he=M(),tn=w(),Vd=k(),$o=T(),nn=Q();function Pd(t,e,n){return Lo(e)?Ud(t,e,n):Bd(t,e,n)}function Ud(t,e,n){if(n=tn(n)?0:n,C(Lo(e),"When sorting a DataFrame using a function, the first argument to the `sort` method must be a function!"),C(nt(n),"When sorting a DataFrame using a function, the second argument to the `sort` method must be null, undefined, 0, or 1 to indicate the axis along which the data should be sorted! An axis of 0 means that the rows will be sorted relative to each other, whereas an axis of 1 means that the columns will be sorted relative to each other."),n===0){let r=nn(t.index,(s,o)=>e(t.get(s,null),t.get(o,null)));return t.get(r,null)}else{let r=nn(t.columns,(s,o)=>e(t.get(null,s),t.get(null,o)));return t.get(null,r)}}function Bd(t,e,n){let r=t.copy(),s=Cd().toString();return r=r.assign(s,r.index),tn(e)&&(e=[s],n=[!0]),(nt(e)||he(e))&&(e=[e],(en(n)||he(n))&&(n=[n])),C(Yo(e),"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),C($o(e).length===1,"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),tn(n)&&(n=Vd(0,e.length).map(()=>!0)),C(Yo(n),"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),C($o(n).length===1,"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),C(e.length===n.length,"The arrays passed into the `sort` method must be equal in length."),e=e.map(o=>{if(C(he(o)||nt(o),"Column references can either be column names (as strings) or column indices (as whole numbers)."),he(o)){let i=r.columns.indexOf(o);return C(i>-1,`The column "${o}" does not exist!`),i}if(nt(o))return C(parseInt(o)===o,"Column indices must be whole numbers!"),C(o>=0,`The column index ${o} is out of bounds!`),C(o<r.columns.length,`The index ${o} is out of bounds!`),o}),n=n.map(o=>{if(C(he(o)||en(o),"Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),he(o)){let i=o.trim().toLowerCase();return C(i==="ascending"||i==="descending","Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),i==="ascending"}if(en(o))return o}),r.values=nn(r.values,(o,i)=>{let u=0;for(;o[e[u]]===i[e[u]]&&u<e.length;)u++;let a=n[u];if(o[e[u]]===i[e[u]])return 0;if(o[e[u]]<i[e[u]])return a?-1:1;if(o[e[u]]>i[e[u]])return a?1:-1}),r.index=zd(r.get(null,s).values),r=r.dropColumns(s),r}Ko.exports=Pd});var rn=c((D2,Ho)=>{var Rd=U(),Jd=De(),Yd=K(),$d=M(),Wo=w();function Ld(t,e){e=(()=>{if(Wo(e))return!0;if(Jd(e))return e;throw new Rd("The `shouldIncludeIndex` parameter of the `toCSVString` method must be a boolean!")})();let n=[""].concat(t.index);return[t.columns].concat(t.values).map((s,o)=>(e?[n[o]]:[]).concat(s).map(u=>$d(u)?JSON.stringify(u):Yd(u)?JSON.stringify(JSON.stringify(u)):Wo(u)?"":u.toString()).join(",")).join(`
`)}Ho.exports=Ld});var Qo=c((_2,on)=>{var sn=U(),Kd=rn();function Gd(t,e,n){let r=Kd(t,n),s=!1,o=!1,i,u;try{let a=e;if(e.includes("/")){let f=e.split("/");a=f[f.length-1]}let l=document.createElement("a");l.href=`data:text/csv;charset=utf-8,${encodeURIComponent(r)}`,l.download=a,l.dispatchEvent(new MouseEvent("click")),s=!0}catch(a){i=a}try{let a=Ne("fs"),l=Ne("path");a.writeFileSync(l.resolve(e),r,"utf8"),o=!0}catch(a){u=a}if(!s&&!o)throw typeof window<"u"?new sn(i):typeof on<"u"?new sn(u):new sn("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");return t}on.exports=Gd});var un=c((E2,Xo)=>{function Wd(t,e){return JSON.stringify(t.toObject(e))}Xo.exports=Wd});var Zo=c((A2,cn)=>{var an=U(),Hd=un();function Qd(t,e,n){let r=Hd(t,n),s=!1,o=!1,i,u;try{let a=e;if(e.includes("/")){let f=e.split("/");a=f[f.length-1]}let l=document.createElement("a");l.href=`data:application/json;charset=utf-8,${encodeURIComponent(r)}`,l.download=a,l.dispatchEvent(new MouseEvent("click")),s=!0}catch(a){i=a}try{let a=Ne("fs"),l=Ne("path");a.writeFileSync(l.resolve(e),r,"utf8"),o=!0}catch(a){u=a}if(!s&&!o)throw typeof window<"u"?new an(i):typeof cn<"u"?new an(u):new an("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");return t}cn.exports=Qd});var ti=c((M2,ei)=>{var Xd=d(),Zd=w();function ep(t,e){Zd(e)?e=0:Xd(e===0||e===1,"The axis parameter of the `toObject` method must be undefined, 0, or 1. An axis of 0 indicates that the returned object should be organized first by rows and then by columns. An axis of 1 indicates that the returned object should be organized first by columns and then by rows.");let n={};return e===0?t.index.forEach((r,s)=>{let o={};t.columns.forEach((i,u)=>{o[i]=t.values[s][u]}),n[r]=o}):t.columns.forEach((r,s)=>{let o={};t.index.forEach((i,u)=>{o[i]=t.values[u][s]}),n[r]=o}),n}ei.exports=ep});var ie=c((I2,si)=>{var ni=d(),tp=g(),np=b(),rp=y(),sp=G(),ri=Te(),op=T();function ip(t){if(np(t)||rp(t))return t.transpose();ni(tp(t),"The `transpose` function only works on arrays, Series, and DataFrames!");let e=op(t);if(ni(e.length<=2,"I'm not smart enough to know how to transpose arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `transpose` function!"),e.length===1)return ri(t);if(e.length===2){let n=sp(ri(e));for(let r=0;r<e[0];r++)for(let s=0;s<e[1];s++)n[s][r]=t[r][s];return n}}si.exports=ip});var ai=c((j2,ui)=>{var oi=d(),up=g(),ap=b(),cp=Je(),lp=y(),fp=T();function ii(t,e,n){if(lp(n))return new t(e.values.concat(n.values));if(up(n)){let r=fp(n);oi(r.length===1&&!cp(r),"Only vectors can be appended to Series!");let s=e.copy();return n.forEach((o,i)=>{s._values.push(o),s._index.push("item"+(e.values.length+i))}),s}return oi(!ap(n),"DataFrames cannot be appended to Series!"),ii(e,[n])}ui.exports=ii});var li=c((k2,ci)=>{var hp=d(),mp=j();function dp(t,e){hp(mp(e),"The parameter to the `apply` method must be a function.");let n=t.copy();return n._values=n._values.map((r,s)=>e(r,s)),n}ci.exports=dp});var hi=c((C2,fi)=>{var pp=w();function gp(t){let e=t.copy(),n=[];return e._values=e.values.filter((r,s)=>pp(r)?!1:(n.push(e.index[s]),!0)),e._index=n,e}fi.exports=gp});var di=c((z2,mi)=>{var qp=q();function yp(t,e){let n=[],r=[];e.values.forEach((o,i)=>{qp(o)&&(r.push(o),n.push(e.index[i]))});let s=new t(r);return s.name=e.name,s.index=n,s}mi.exports=yp});var gi=c((V2,pi)=>{var bp=B();function wp(t,e,n){let r=e.copy(),s=bp(r.index),o=[],i=r.values.filter((u,a)=>{let l=n(u,a,r.values);return l||o.push(r.index[a]),l});return o.forEach(u=>{s.splice(s.indexOf(u),1)}),i.length===0?(r=new t,r.name=e.name,r):(r.values=i,r.index=s,r)}pi.exports=wp});var yi=c((P2,qi)=>{var ee=d(),Np=q(),vp=M(),Sp=w(),xp=P();function Tp(t,e){(vp(e)||Np(e))&&(e=[e]);let n=xp((e||[]).map(r=>typeof r));return ee(n.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===1&&ee(n[0]==="string"||n[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===2&&(ee(n.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),ee(n.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),Sp(e)||(e=e.map(r=>{if(typeof r=="string")return ee(t.index.indexOf(r)>-1,`Index "${r}" does not exist!`),r;if(typeof r=="number")return ee(r>=0,`Index ${r} is out of bounds!`),ee(parseInt(r)===r,"Indices must be integers!"),ee(r<t.index.length,`Index ${r} is out of bounds!`),t.index[r]})),t.getSubsetByNames(e)}qi.exports=Tp});var wi=c((U2,bi)=>{var Me=d(),Op=g(),Fp=w(),Dp=Oe(),_p=k(),Ep=T();function Ap(t,e){let n=t.shape;Fp(e)&&(e=_p(0,n[0])),Me(Op(e),"The `indices` array must be 1-dimensional array of whole numbers."),Me(Ep(e).length===1,"The `indices` array must be a 1-dimensional array of whole numbers."),Me(e.length>0,"The `indices` array must contain at least one index."),e.forEach(s=>{Me(Dp(s),"The `indices` array must be a 1-dimensional array of whole numbers."),Me(s<t.index.length,`The row index ${s} is out of bounds.`)});let r=e.map(s=>t.index[s]);return t.getSubsetByNames(r)}bi.exports=Ap});var vi=c((B2,Ni)=>{var Ie=d(),Mp=g(),Ip=M(),jp=w(),kp=T();function Cp(t,e,n){jp(n)&&(n=e.index),Ie(Mp(n),"The `indices` array must be a 1-dimensional array of strings."),Ie(kp(n).length===1,"The `indices` array must be a 1-dimensional array of strings."),Ie(n.length>0,"The `indices` array must contain at least one index name."),n.forEach(o=>{Ie(Ip(o),"The `indices` array must contain only strings."),Ie(e.index.indexOf(o)>-1,`The name "${o}" does not exist in the index.`)});let r=n.map(o=>e.values[e.index.indexOf(o)]);if(r.length===1)return r[0];let s=new t(r);return s.index=n,s.name=e.name,s}Ni.exports=Cp});var Ti=c((R2,xi)=>{var zp=B(),Si=k();function Vp(t){let e=t.copy(),n=typeof window>"u"?20:10;if(e.index.length>n){e=e.get(Si(0,n/2).concat(Si(e.index.length-n/2,e.index.length)));let s=zp(e.index);s.splice(parseInt(s.length/2),0,"..."),e.values.push("..."),e.index.push("..."),e=e.get(s)}let r={};return e.values.forEach((s,o)=>{let i={};i[e.name]=s,r[e.index[o]]=i}),console.table(r),console.log("Shape:",t.shape,`
`),t}xi.exports=Vp});var Fi=c((J2,Oi)=>{var Pp=tt();function Up(t){let e=t.copy();return e.get(Pp(e.index))}Oi.exports=Up});var _i=c((Y2,Di)=>{var Bp=d(),Rp=j(),Jp=w(),Yp=Q(),$p=ie();function Lp(t,e,n){n=n||((a,l)=>a<l?-1:1),Bp(Jp(n)||Rp(n),"You must pass undefined, null, or a comparison function as the second argument to the `sort` method!");let r=$p([e.values,e.index]),s=Yp(r,(a,l)=>n(a[0],l[0])),o=[],i=[];s.forEach(a=>{o.push(a[0]),i.push(a[1])});let u=new t;return u._values=o,u._index=i,u.name=e.name,u}Di.exports=Lp});var Mi=c(($2,Ai)=>{var Kp=Q(),Ei=ie();function Gp(t,e){let n=Ei([e.values,e.index]);n=Ei(Kp(n,(s,o)=>{if(s[1]===o[1])return 0;if(s[1]<o[1])return-1;if(s[1]>o[1])return 1}));let r=new t(n[0]);return r.index=n[1],r.name=e.name,r}Ai.exports=Gp});var ji=c((L2,Ii)=>{function Wp(t){let e={};return e[t.name]={},t.index.forEach((n,r)=>{e[t.name][n]=t.values[r]}),e}Ii.exports=Wp});var Pi=c((K2,Vi)=>{var $=d(),rt=B(),ln=g(),Hp=M(),Qp=w(),ki=Ze(),Ci=k(),st=Te(),Xp=ai(),Zp=li(),eg=hi(),tg=di(),ng=gi(),rg=yi(),sg=wi(),og=vi(),ig=Ti(),ug=Fi(),ag=_i(),cg=Mi(),lg=ji(),je=T(),fg=ie(),zi=Symbol.for("@jrc03c/js-math-tools/series");Vi.exports=function(t){class e{static[Symbol.hasInstance](r){try{return!!r._symbol&&r._symbol===zi}catch{return!1}}constructor(r){let s=this;if(s.name="data",Object.defineProperty(s,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:zi}),Object.defineProperty(s,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(s,"values",{configurable:!0,enumerable:!0,get(){return s._values},set(o){$(ln(o),"The new values must be a 1-dimensional array!");let i=je(o);$(i.length===1,"The new array of values must be 1-dimensional!"),i[0]<s._index.length?s._index=s._index.slice(0,i[0]):i[0]>s._index.length&&(s._index=s._index.concat(Ci(s._index.length,i[0]).map(u=>"item"+ki(u,(o.length-1).toString().length)))),s._values=o}}),Object.defineProperty(s,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(s,"index",{configurable:!0,enumerable:!0,get(){return s._index},set(o){$(ln(o),"The new index must be a 1-dimensional array of strings!"),$(o.length===s.shape[0],"The new index must be the same length as the old index!"),$(je(o).length===1,"The new index must be a 1-dimensional array of strings!"),o.forEach(i=>{$(Hp(i),"All of the row names must be strings!")}),s._index=o}}),r){if(r instanceof e)s.name=r.name,s.values=rt(r.values),s.index=rt(r.index);else if(ln(r)){let o=je(r);$(o.length===1,"When passing an array into the constructor of a Series, the array must be 1-dimensional!"),s.values=r}else if(r instanceof Object){let o=Object.keys(r);$(o.length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");let i=o[0],u=r[i];$(je(u).length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!"),s.name=i,s.values=u.slice()}}}get shape(){return je(this.values)}get length(){return this.shape[0]}get isEmpty(){return this.values.filter(s=>!Qp(s)).length===0}clear(){let s=this.copy();return s.values.forEach((o,i)=>{s.values[i]=void 0}),s}get(r){return rg(this,r)}getSubsetByNames(r){return og(e,this,r)}getSubsetByIndices(r){return sg(this,r)}loc(r){return this.getSubsetByNames(r)}iloc(r){return this.getSubsetByIndices(r)}reverse(){let r=this,s=new e(st(r.values));return s.index=st(r.index),s.name=r.name,s}resetIndex(){let r=this,s=r.copy();return s.index=Ci(0,r.shape[0]).map(o=>"item"+ki(o,(s.index.length-1).toString().length)),s}copy(){let r=this,s=new e;return s._values=rt(r.values),s._index=rt(r.index),s.name=r.name,s}append(r){return Xp(e,this,r)}apply(r){return Zp(this,r)}concat(r){return this.append(r)}dropMissing(r,s){return eg(this,r,s)}dropNaN(){return tg(e,this)}toObject(){return lg(this)}print(){return ig(this)}shuffle(){return ug(this)}sort(r){return ag(e,this,r)}sortByIndex(){return cg(e,this)}filter(r){return ng(e,this,r)}toDataFrame(){let r=this,s=new t(fg([r.values]));return s.columns=[r.name],s.index=r.index,s}transpose(){let s=this.copy();return s.values=st(s.values),s.index=st(s.index),s}getDummies(){return this.toDataFrame().getDummies()}oneHotEncode(){return this.getDummies()}}return e}});var Ce=c((G2,$i)=>{var J=d(),fn=B(),Ui=Re(),hg=ps(),mg=ws(),dg=xs(),pg=Os(),gg=Is(),qg=Cs(),yg=Us(),bg=Ys(),wg=Xs(),Ng=Qt(),vg=to(),Bi=uo(),Sg=go(),xg=No(),Tg=So(),Og=Oo(),Fg=Jo(),Dg=Go(),_g=Qo(),Eg=rn(),Ag=Zo(),Mg=un(),Ig=ti(),jg=D(),ke=g(),kg=K(),Ri=w(),hn=Ze(),Cg=G(),mn=k(),me=T(),Ji=ie(),Yi=Symbol.for("@jrc03c/js-math-tools/dataframe");function ot(t){let e="abcdefghijklmnopqrstuvwxyz1234567890",n="";for(let r=0;r<t;r++)n+=e[parseInt(Math.random()*e.length)];return n}var _=class{static[Symbol.hasInstance](e){try{return!!e._symbol&&e._symbol===Yi}catch{return!1}}constructor(e){let n=this;if(Object.defineProperty(n,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:Yi}),Object.defineProperty(n,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(n,"values",{configurable:!0,enumerable:!0,get(){return n._values.length===0||!Ri(n._values[0])&&n._values[0].length===0?[[]]:n._values},set(r){J(ke(r),"The new values must be a 2-dimensional array!");let s=me(r);J(s.length===2,"The new array of values must be 2-dimensional!"),s[0]<n._index.length?n._index=n._index.slice(0,s[0]):s[0]>n._index.length&&(n._index=n._index.concat(mn(n._index.length,s[0]).map(o=>"row"+hn(o,(s[0]-1).toString().length)))),s[1]<n._columns.length?n._columns=n._columns.slice(0,s[1]):s[1]>n._columns.length&&(n._columns=n._columns.concat(mn(n._columns.length,s[1]).map(o=>"col"+hn(o,(s[1]-1).toString().length)))),n._values=r}}),Object.defineProperty(n,"_columns",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(n,"columns",{configurable:!0,enumerable:!0,get(){return n._columns},set(r){J(ke(r),"The new columns list must be a 1-dimensional array of strings!"),J(n.isEmpty||r.length===n.shape[1],"The new columns list must be the same length as the old columns list!"),J(me(r).length===1,"The new columns list must be a 1-dimensional array of strings!"),r=r.map(o=>(typeof o!="string"&&(o=JSON.stringify(o)||o.toString()),o.trim().length===0?"untitled_"+ot(8):o.trim()));let s=(()=>{let o=Ui(r),i={};return o.forEach(u=>{i[u.item]=u.count}),i})();r=r.map(o=>s[o]>1?o+"_"+ot(8):o),n._columns=r}}),Object.defineProperty(n,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(n,"index",{configurable:!0,enumerable:!0,get(){return n._index},set(r){J(ke(r),"The new index must be a 1-dimensional array of strings!"),J(n.isEmpty||r.length===n.shape[0],"The new index must be the same length as the old index!"),J(me(r).length===1,"The new index must be a 1-dimensional array of strings!"),r=r.map(o=>(typeof o!="string"&&(o=JSON.stringify(o)||o.toString()),o.trim().length===0?"untitled_"+ot(8):o.trim()));let s=(()=>{let o=Ui(r),i={};return o.forEach(u=>{i[u.item]=u.count}),i})();r=r.map(o=>s[o]>1?o+"_"+ot(8):o),n._index=r}}),J(Ri(e)||kg(e)||ke(e),"The `data` passed into the constructor of a DataFrame must be either (1) an object where the key-value pairs are (respectively) column names and 1-dimensional arrays of values, or (2) a 2-dimensional array of values."),e)if(e instanceof _)n.values=fn(e.values),n.columns=fn(e.columns),n.index=fn(e.index);else if(ke(e)){let r=me(e);J(r.length===2,"The `data` array passed into the constructor of a DataFrame must be 2-dimensional!"),n.values=e}else{n._columns=Object.keys(e);let r=[];n._columns.forEach(o=>{let i=e[o];r.push(i)}),n._values=Ji(r);let s=me(n.values);n._index=mn(0,s[0]).map(o=>"row"+hn(o,(s[0]-1).toString().length))}}get shape(){return me(this.values)}get length(){return this.shape[0]}get width(){return this.shape[1]}get rows(){return this.index}set rows(e){let n=this;n.index=e}get isEmpty(){return jg(this.values).length===0}clear(){let e=this,n=new _(Cg(e.shape));return n.columns=e.columns.slice(),n.index=e.index.slice(),n}get(e,n){let r=this;if(arguments.length===0)return r;if(arguments.length===1)try{return r.get(null,e)}catch{return r.get(e,null)}return vg(r,e,n)}getSubsetByNames(e,n){return xg(_,te,this,e,n)}getSubsetByIndices(e,n){return Sg(this,e,n)}getDummies(e){return Bi(_,this,e)}oneHotEncode(e){return Bi(_,this,e)}transpose(){let e=this,n=new _(Ji(e.values));return n.columns=e.index.slice(),n.index=e.columns.slice(),n}get T(){return this.transpose()}resetIndex(e){return Og(this,e)}copy(){return pg(_,this)}assign(e,n){return dg(_,te,this,e,n)}apply(e,n){return mg(_,te,this,e,n)}dropMissing(e,n,r){return qg(_,te,this,e,n,r)}dropNaN(e,n,r){return yg(_,this,e,n,r)}drop(e,n){return gg(_,te,this,e,n)}dropColumns(e){return this.drop(null,e)}dropRows(e){return this.drop(e,null)}toObject(e){return Ig(this,e)}toCSVString(e){return Eg(this,e)}saveAsCSV(e,n){return _g(this,e,n)}toJSONString(e){return Mg(this,e)}saveAsJSON(e,n){return Ag(this,e,n)}print(){return Tg(_,te,this)}sort(e,n){return Dg(this,e,n)}sortByIndex(){return this.sort()}filter(e,n){return bg(_,te,this,e,n)}shuffle(e){return Fg(this,e)}append(e,n){return hg(this,e,n)}concat(e,n){return this.append(e,n)}join(e,n){return this.append(e,n)}toString(){let e=this;return JSON.stringify(e)}};_.fromCSV=function(){return wg(_,...arguments)};_.fromCSVString=function(){return Ng(_,...arguments)};var te=Pi()(_);$i.exports={DataFrame:_,Series:te}});var S=c((W2,Hi)=>{var{DataFrame:Li,Series:Ki}=Ce(),Gi=d(),ze=g(),dn=b(),Wi=R(),zg=j(),pn=y(),Vg=oe(),Pg=k(),it=T();function Ug(t){return ze(t)||pn(t)||dn(t)}function Bg(t){return Gi(zg(t),"You must pass a function into the `vectorize` function!"),function e(){let n,r,s=[],o=[],i=Object.keys(arguments).filter(u=>{let a=arguments[u];return ze(a)?!0:pn(a)?(n=!0,s.push(a),!0):dn(a)?(r=!0,o.push(a),!0):!1}).map(u=>arguments[u]);if(i.slice(0,-1).forEach((u,a)=>{Gi(Wi(ze(u)?it(u):u.shape,ze(i[a+1])?it(i[a+1]):i[a+1].shape),`When passing multiple arrays into the \`${t.name}\` function, all of the arrays must have the same shape!`)}),i.length>0){let u=Vg(i.map(l=>l.length?l.length:l.values.length)),a=Pg(0,u).map(l=>{let f=Object.keys(arguments).map(h=>{if(Ug(arguments[h])){if(ze(arguments[h]))return arguments[h][l];if(pn(arguments[h]))return arguments[h].values[l];if(dn(arguments[h]))return arguments[h].values[l]}else return arguments[h]});return e(...f)});if(r)try{if(o.length===1&&Wi(it(o[0]),it(a))){let l=new Li(a);return l.index=o[0].index.slice(),l.columns=o[0].columns.slice(),l}else return new Li(a)}catch{return a}if(n)try{if(s.length===1&&s[0].length===a.length){let l=new Ki(a);return l.name=s[0].name,l.index=s[0].index.slice(),l}else return new Ki(a)}catch{return a}return a}else return t(...arguments)}}Hi.exports=Bg});var ut=c((H2,Qi)=>{var Rg=q(),Jg=S();function Yg(t){try{return Rg(t)?Math.abs(t):NaN}catch{return NaN}}Qi.exports=Jg(Yg)});var at=c((Q2,Xi)=>{var $g=q(),Lg=S();function Kg(){try{let t=0,e=Object.values(arguments);for(let n=0;n<e.length;n++){if(!$g(e[n]))return NaN;t+=e[n]}return t}catch{return NaN}}Xi.exports=Lg(Kg)});var ct=c((X2,Zi)=>{var Gg=S();function Wg(t,e){try{return e(t)}catch{return NaN}}Zi.exports=Gg(Wg)});var tu=c((Z2,eu)=>{var Hg=q(),Qg=S();function Xg(t){try{return Hg(t)?Math.acos(t):NaN}catch{return NaN}}eu.exports=Qg(Xg)});var ru=c((ex,nu)=>{var Zg=q(),eq=S();function tq(t){try{return Zg(t)?Math.asin(t):NaN}catch{return NaN}}nu.exports=eq(tq)});var ou=c((tx,su)=>{var nq=q(),rq=S();function sq(t){try{return nq(t)?Math.atan(t):NaN}catch{return NaN}}su.exports=rq(sq)});var uu=c((nx,iu)=>{var oq=d(),iq=ve(),uq=g(),aq=b(),cq=y(),lq=oe();function gn(t){if(aq(t)){let e=gn(t.values);return[t.index[e[0]],t.columns[e[1]]]}if(cq(t)){let e=gn(t.values);return[t.index[e]]}oq(uq(t),"The `argmax` function only works on arrays, Series, and DataFrames!");try{let e=iq(t,lq(t));return e?e.length===0?void 0:e.length===1?e[0]:e:void 0}catch{return}}iu.exports=gn});var lt=c((rx,cu)=>{var fq=d(),hq=D(),mq=g(),dq=b(),pq=y();function au(t){if(dq(t)||pq(t))return au(t.values);fq(mq(t),"The `min` function only works on arrays, Series, and DataFrames!");try{return Math.min(...hq(t))}catch{return NaN}}cu.exports=au});var fu=c((sx,lu)=>{var gq=d(),qq=ve(),yq=g(),bq=b(),wq=y(),Nq=lt();function qn(t){if(bq(t)){let e=qn(t.values);return[t.index[e[0]],t.columns[e[1]]]}if(wq(t)){let e=qn(t.values);return[t.index[e]]}gq(yq(t),"The `argmin` function only works on arrays, Series, and DataFrames!");try{let e=qq(t,Nq(t));return e?e.length===0?void 0:e.length===1?e[0]:e:void 0}catch{return}}lu.exports=qn});var mu=c((ox,hu)=>{var vq=q(),Sq=S();function xq(t){try{return vq(t)?Math.ceil(t):NaN}catch{return NaN}}hu.exports=Sq(xq)});var gu=c((ix,pu)=>{var Tq=ut(),du=q(),Oq=w(),Fq=S();function Dq(t,e){try{if(!du(t))return NaN;if(Oq(e))e=1e-10;else if(!du(e))return NaN;return Tq(t)<e?0:t}catch{return NaN}}pu.exports=Fq(Dq)});var yu=c((ux,qu)=>{var yn=q(),_q=S();function Eq(t,e,n){try{return yn(t)?yn(e)?yn(n)?t<e?e:t>n?n:t:NaN:NaN:NaN}catch{return NaN}}qu.exports=_q(Eq)});var wu=c((ax,bu)=>{var bn=d(),Aq=D(),Mq=g(),Iq=b(),jq=q(),kq=y();function wn(t,e){if(Iq(t)||kq(t))return wn(t.values,e);if(bn(Mq(t),"The `combinations` function only works on arrays, Series, and DataFrames!"),bn(jq(e),"`r` must be a whole number!"),t=Aq(t),e>t.length)return[t];if(e<=0)return[[]];if(bn(e===parseInt(e),"`r` must be a whole number!"),t.length<2)return t;let n=[];return t.forEach((r,s)=>{let o=t.slice(s+1);if(o.length<e-1)return;wn(o,e-1).forEach(u=>{n.push([r].concat(u))})}),n}bu.exports=wn});var ft=c((cx,vu)=>{var Cq=d(),zq=D(),Vq=g(),Pq=b(),Uq=y();function Nu(t){if(Pq(t)||Uq(t))return Nu(t.values);Cq(Vq(t),"The `mean` function only works on arrays, Series, and DataFrames!");try{let e=zq(t),n=0;return e.forEach(r=>{n+=r}),n/e.length}catch{return NaN}}vu.exports=Nu});var vn=c((lx,Du)=>{var Su=d(),xu=g(),ht=q(),Tu=y(),Ou=ft(),Fu=T();function Nn(t,e){if(Tu(t))return Nn(t.values,e);if(Tu(e))return Nn(t,e.values);Su(xu(t)&&xu(e)&&Fu(t).length===1&&Fu(e).length===1,"The `covariance` function only works on 1-dimensional arrays and Series!"),Su(t.length===e.length,"The two arrays or Series passed into the `covariance` function must have the same length!");try{let n=Ou(t),r=Ou(e);if(!ht(n)||!ht(r))return NaN;let s=Math.max(t.length,e.length),o=0;for(let i=0;i<s;i++){if(!ht(t[i]))return NaN;if(!ht(e[i]))return NaN;o+=(t[i]-n)*(e[i]-r)}return o/t.length}catch{return NaN}}Du.exports=Nn});var mt=c((fx,_u)=>{var Bq=q(),Rq=S();function Jq(t){try{return Bq(t)?Math.sqrt(t):NaN}catch{return NaN}}_u.exports=Rq(Jq)});var Sn=c((hx,Au)=>{var Yq=d(),$q=D(),Lq=g(),Kq=b(),Gq=q(),Wq=y(),Hq=ft();function Eu(t){if(Kq(t)||Wq(t))return Eu(t.values);Yq(Lq(t),"The `variance` function only works on arrays, Series, and DataFrames!");try{let e=$q(t),n=Hq(e),r=0;for(let s=0;s<e.length;s++){if(!Gq(e[s]))return NaN;r+=(e[s]-n)*(e[s]-n)}return r/e.length}catch{return NaN}}Au.exports=Eu});var dt=c((mx,Iu)=>{var Qq=d(),Xq=g(),Zq=b(),ey=y(),ty=mt(),ny=Sn();function Mu(t){if(Zq(t)||ey(t))return Mu(t.values);Qq(Xq(t),"The `std` function only works on arrays, Series, and DataFrames!");try{return ty(ny(t))}catch{return NaN}}Iu.exports=Mu});var Uu=c((dx,Pu)=>{var ju=d(),ry=vn(),ku=g(),Cu=y(),zu=T(),Vu=dt();function xn(t,e){if(Cu(t))return xn(t.values,e);if(Cu(e))return xn(t,e.values);ju(ku(t)&&ku(e)&&zu(t).length===1&&zu(e).length===1,"The `correl` function only works on 1-dimensional arrays and Series!"),ju(t.length===e.length,"The two arrays or Series passed into the `correl` function must have the same length!");try{return ry(t,e)/(Vu(t)*Vu(e))}catch{return NaN}}Pu.exports=xn});var Ru=c((px,Bu)=>{var sy=q(),oy=S();function iy(t){try{return sy(t)?Math.cos(t):NaN}catch{return NaN}}Bu.exports=oy(iy)});var Gu=c((gx,Ku)=>{var uy=d(),Ju=g(),Yu=b(),ay=R(),$u=y(),Lu=P();function Tn(t,e){if(Yu(t)||$u(t))return Tn(t.values,e);if(Yu(e)||$u(e))return Tn(t,e.values);uy(Ju(t)&&Ju(e),"The `diff` function only works on arrays, Series, and DataFrames!");let n=Lu(t),r=Lu(e),s=[];return n.forEach(o=>{r.findIndex(i=>ay(i,o))<0&&s.push(o)}),s}Ku.exports=Tn});var pt=c((qx,Hu)=>{var Wu=q(),cy=S();function ly(t,e){try{return Wu(t)?Wu(e)?Math.pow(t,e):NaN:NaN}catch{return NaN}}Hu.exports=cy(ly)});var On=c((yx,Qu)=>{var fy=q(),hy=S();function my(){try{let t=Object.values(arguments);if(t.length===0)return NaN;let e=1;for(let n=0;n<t.length;n++){if(!fy(t[n]))return NaN;e*=t[n]}return e}catch{return NaN}}Qu.exports=hy(my)});var de=c((bx,Xu)=>{var dy=On();function py(){return dy(...arguments)}Xu.exports=py});var Fn=c((wx,Zu)=>{var gy=at(),qy=de();function yy(t,e){return gy(t,qy(e,-1))}Zu.exports=yy});var gt=c((Nx,ta)=>{var by=d(),wy=D(),Ny=g(),vy=b(),Sy=y();function ea(t){if(vy(t)||Sy(t))return ea(t.values);by(Ny(t),"The `sum` function only works on arrays, Series, and DataFrames!");try{return t.length===0?NaN:wy(t).reduce((e,n)=>e+n,0)}catch{return NaN}}ta.exports=ea});var aa=c((vx,ua)=>{var xy=ut(),Ty=d(),na=g(),ra=b(),Oy=R(),sa=q(),oa=y(),Fy=pt(),ia=T(),Dy=mt(),_y=Fn(),Ey=gt();function Dn(t,e){if(sa(t)&&sa(e))return xy(t-e);if(ra(t)||oa(t))return Dn(t.values,e);if(ra(e)||oa(e))return Dn(t,e.values);na(t)&&na(e)&&Ty(Oy(ia(t),ia(e)),"If passing two arrays, Series, or DataFrames into the `distance` function, then those objects must have the same shape!");try{return Dy(Ey(Fy(_y(t,e),2)))}catch{return NaN}}ua.exports=Dn});var la=c((Sx,ca)=>{var Ay=pt(),My=de();function Iy(t,e){return My(t,Ay(e,-1))}ca.exports=Iy});var En=c((xx,ga)=>{var{DataFrame:fa,Series:ha}=Ce(),qt=d(),ma=D(),da=g(),_n=b(),jy=q(),yt=y(),ky=de(),bt=T(),Cy=gt(),pa=ie();function ne(t,e){if(_n(t)){let s=ne(t.values,e);if(bt(s).length===1){let o=new ha(s);return o.name=yt(e)?e.name:o.name,o.index=t.index.slice(),o}else{let o=new fa(s);return o.index=t.index.slice(),_n(e)&&(o.columns=e.columns.slice()),o}}if(_n(e)){let s=ne(t,e.values);if(bt(s).length===1){let o=new ha(s);return o.name=yt(t)?t.name:o.name,o.index=e.columns.slice(),o}else{let o=new fa(s);return o.columns=e.columns.slice(),o}}if(yt(t))return ne(t.values,e);if(yt(e))return ne(t,e.values);qt(da(t)&&da(e),"The `dot` function only works on arrays, Series, and DataFrames!"),ma(t).concat(ma(e)).forEach(s=>{qt(jy(s),"One of the arrays you passed into the `dot` function contains non-numerical values!")});let n=bt(t),r=bt(e);if(qt(n.length<=2&&r.length<=2,"I'm not smart enough to know how to get the dot-product of arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `dot` function!"),qt(n[n.length-1]===r[0],`There's a dimension misalignment in the two arrays you passed into the \`dot\` function. (${n[n.length-1]} !== ${r[0]})`),n.length===1&&r.length===1)return Cy(ky(t,e));if(n.length===1&&r.length===2)return pa(e).map(s=>ne(t,s));if(n.length===2&&r.length===1)return t.map(s=>ne(s,e));if(n.length===2&&r.length===2){let s=pa(e),o=[];for(let i=0;i<t.length;i++){let u=[];for(let a=0;a<s.length;a++)u.push(ne(t[i],s[a]));o.push(u)}return o}}ga.exports=ne});var An=c((Tx,ya)=>{var zy=d(),Vy=g(),Py=b(),Uy=y(),By=w();function qa(t){if(Py(t)||Uy(t))return t.dropMissing(...Object.values(arguments).slice(1));zy(Vy(t),"The `dropMissing` function only works on arrays, Series, and DataFrames!");let e=[];return t.forEach(n=>{try{return e.push(qa(n))}catch{By(n)||e.push(n)}}),e}ya.exports=qa});var Oa=c((Ox,Ta)=>{var ba=d(),wa=g(),Na=b(),Ry=R(),va=y(),Sa=w(),xa=T();function wt(t,e){if(Na(t)||va(t))return wt(t.values,e);if(Na(e)||va(e))return wt(t,e.values);ba(wa(t)&&wa(e),"The `dropMissingPairwise` function only works on arrays, Series, and DataFrames!"),ba(Ry(xa(t),xa(e)),"The two arrays, Series, and/or DataFrames passed into the `dropMissingPairwise` function must have the same shape!");let n=[],r=[];for(let s=0;s<t.length;s++)try{let[o,i]=wt(t[s],e[s]);n.push(o),r.push(i)}catch{!Sa(t[s])&&!Sa(e[s])&&(n.push(t[s]),r.push(e[s]))}return[n,r]}Ta.exports=wt});var ja=c((Fx,Ia)=>{var Fa=d(),Da=g(),_a=b(),Jy=R(),Ea=q(),Aa=y(),Ma=T();function Nt(t,e){if(_a(t)||Aa(t))return Nt(t.values,e);if(_a(e)||Aa(e))return Nt(t,e.values);Fa(Da(t)&&Da(e),"The `dropNaNPairwise` only works on arrays, Series, and DataFrames!"),Fa(Jy(Ma(t),Ma(e)),"The two arrays, Series, and/or DataFrames passed into the `dropNaNPairwise` must have the same shape!");let n=[],r=[];for(let s=0;s<t.length;s++)try{let[o,i]=Nt(t[s],e[s]);n.push(o),r.push(i)}catch{Ea(t[s])&&Ea(e[s])&&(n.push(t[s]),r.push(e[s]))}return[n,r]}Ia.exports=Nt});var Ca=c((Dx,ka)=>{var Yy=An();function $y(t){return Yy(t)}ka.exports=$y});var Va=c((_x,za)=>{var Ly=q(),Ky=S();function Gy(t){try{return Ly(t)?Math.exp(t):NaN}catch{return NaN}}za.exports=Ky(Gy)});var Ba=c((Ex,Ua)=>{var Wy=S();function Pa(t){try{return t!==parseInt(t)?NaN:t<=1?1:t*Pa(t-1)}catch{return NaN}}Ua.exports=Wy(Pa)});var $a=c((Ax,Ya)=>{var Hy=d(),Qy=D(),Ra=g(),Xy=b(),Zy=j(),Ja=K(),e1=y();function Mn(t,e){if(Xy(t))return Mn(Qy(t.values),e);if(e1(t))return Mn(t.values,e);if(Hy(Ja(t)||Ra(t),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `find` function!"),!Zy(e)){let s=e;e=o=>o===s}function n(s,o,i){if(i=i||[],i.indexOf(s)>-1)return null;if(Ja(s)){i.push(s);let u=Object.keys(s);for(let a=0;a<u.length;a++){let l=u[a],f=s[l];if(o(f))return f;let h=n(f,o,i);if(h)return h}}else if(Ra(s)){i.push(s);for(let u=0;u<s.length;u++){let a=s[u];if(o(a))return a;let l=n(a,o,i);if(l)return l}}else if(o(s))return s;return null}function r(s){try{return e(s)}catch{return!1}}return n(t,r)}Ya.exports=Mn});var Wa=c((Mx,Ga)=>{var t1=d(),n1=D(),La=g(),r1=b(),s1=j(),Ka=K(),o1=y();function In(t,e){if(r1(t))return In(n1(t.values),e);if(o1(t))return In(t.values,e);if(t1(Ka(t)||La(t),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `findAll` function!"),!s1(e)){let o=e;e=i=>i===o}function n(o,i,u){if(u=u||[],u.indexOf(o)>-1)return null;if(Ka(o)){u.push(o);let a=Object.keys(o),l=[];for(let f=0;f<a.length;f++){let h=a[f],m=o[h],p=!1;i(m)&&(l.push(m),p=!0);let v=n(m,i,u);v&&v.length>0&&v.slice(p?1:0).forEach(N=>l.push(N))}return l}else if(La(o)){u.push(o);let a=[];for(let l=0;l<o.length;l++){let f=o[l],h=!1;i(f)&&(a.push(f),h=!0);let m=n(f,i,u);m&&m.length>0&&m.slice(h?1:0).forEach(p=>a.push(p))}return a}else if(i(o))return[o];return null}function r(o){try{return e(o)}catch{return!1}}let s=n(t,r);return s&&s.length>0?s:null}Ga.exports=In});var Qa=c((Ix,Ha)=>{var i1=q(),u1=S();function a1(t){try{if(t==="Infinity")return 1/0;if(t==="-Infinity")return-1/0;let e=JSON.parse(t);return i1(e)?e:NaN}catch{return NaN}}Ha.exports=u1(a1)});var Za=c((jx,Xa)=>{var c1=q(),l1=S();function f1(t){try{return c1(t)?Math.floor(t):NaN}catch{return NaN}}Xa.exports=l1(f1)});var jn=c((kx,ec)=>{var h1=q(),m1=Ee(),d1=et();function p1(t){h1(t)&&(t=[t]);let e=[],n=m1(t);for(let r=0;r<n;r++)e.push(0);return d1(e,t)}ec.exports=p1});var nc=c((Cx,tc)=>{var vt=d(),g1=q(),q1=w(),y1=jn();function b1(t){vt(!q1(t),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),vt(g1(t),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),vt(parseInt(t)===t,"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),vt(t>0,"You must pass an integer greater than 0 (representing the size) into the `identity` function!");let e=y1([t,t]);for(let n=0;n<t;n++)e[n][n]=1;return e}tc.exports=b1});var sc=c((zx,rc)=>{var w1=q(),N1=S();function v1(t){try{let e=JSON.parse(t);return w1(e)?parseInt(e):NaN}catch{return NaN}}rc.exports=N1(v1)});var ic=c((Vx,oc)=>{var S1=d(),x1=g(),T1=b(),O1=R(),F1=y(),kn=P();function D1(){let t=Object.values(arguments).map(n=>T1(n)||F1(n)?kn(n.values):(S1(x1(n),"The `intersect` function only works on arrays, Series, and DataFrames!"),kn(n)));return kn(t).filter(n=>t.every(r=>r.findIndex(s=>O1(s,n))>-1))}oc.exports=D1});var lc=c((Px,cc)=>{var uc=at(),re=d(),_1=En(),E1=D(),A1=g(),M1=b(),Cn=q(),ac=de(),I1=T();function St(t){if(M1(t)){let n=t.copy();return n.values=St(n.values),n}re(A1(t),"The `inverse` function only works on square 2-dimensional arrays or DataFrames!"),E1(t).forEach(n=>re(Cn(n),"The array passed into the `inverse` function must contain only numbers!"));let e=I1(t);if(re(e.length===2,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),re(e[0]===e[1],"The array passed into the `inverse` function must be exactly two-dimensional and square!"),re(e[0]>=0,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),e[0]===0)return t;if(e[0]===1)return re(t[0][0]!==0,"This matrix cannot be inverted!"),1/t[0][0];if(e[0]===2){let n=t[0][0],r=t[0][1],s=t[1][0],o=t[1][1],i=n*o-r*s;re(i!==0,"This matrix cannot be inverted!");let u=[[o,-r],[-s,n]];return ac(u,1/i)}else if(e[0]>1){let n=(r,s)=>Cn(r)||Cn(s)?ac(r,s):_1(r,s);for(let r=1;r<e[0]-1;r++)try{let s=t.slice(0,r).map(N=>N.slice(0,r)),o=t.slice(0,r).map(N=>N.slice(r,e[0])),i=t.slice(r,e[0]).map(N=>N.slice(0,r)),u=t.slice(r,e[0]).map(N=>N.slice(r,e[0])),a=St(s),l=St(uc(u,n(-1,n(n(i,a),o)))),f=uc(a,n(n(n(n(a,o),l),i),a)),h=n(-1,n(n(a,o),l)),m=n(-1,n(n(l,i),a)),p=l;return f.map((N,E)=>N.concat(h[E])).concat(m.map((N,E)=>N.concat(p[E])))}catch{}re(!1,"This matrix cannot be inverted!")}}cc.exports=St});var hc=c((Ux,fc)=>{var zn=q(),j1=S();function k1(t,e,n){try{return zn(t)?zn(e)?zn(n)?n*(e-t)+t:NaN:NaN:NaN}catch{return NaN}}fc.exports=j1(k1)});var pc=c((Bx,dc)=>{var mc=q(),C1=w(),z1=S();function V1(t,e){try{return e=C1(e)?Math.E:e,mc(t)?mc(e)?Math.log(t)/Math.log(e):NaN:NaN}catch{return NaN}}dc.exports=z1(V1)});var yc=c((Rx,qc)=>{var P1=d(),U1=D(),B1=g(),R1=b(),J1=y(),Y1=Q();function gc(t){if(R1(t)||J1(t))return gc(t.values);P1(B1(t),"The `median` function only works on arrays, Series, and DataFrames!");try{let e=Y1(U1(t));return e.length===0?NaN:e.length%2===0?(e[e.length/2-1]+e[e.length/2])/2:e[parseInt(e.length/2)]}catch{return NaN}}qc.exports=gc});var Nc=c((Jx,wc)=>{var bc=q(),$1=S();function L1(t,e){try{return bc(t)?bc(e)?t%e:NaN:NaN}catch{return NaN}}wc.exports=$1(L1)});var Tc=c((Yx,xc)=>{var K1=d(),G1=Re(),W1=D(),H1=g(),Q1=b(),X1=y(),Z1=P(),vc=Q();function Sc(t){if(Q1(t)||X1(t))return Sc(t.values);K1(H1(t),"The `mode` function only works on arrays, Series, and DataFrames!");try{if(t.length===0)return NaN;let e=W1(t);if(e.length===0)return NaN;let n={},r=Z1(e);r.forEach(u=>{n[u]=G1(e,u)});let s=vc(r,(u,a)=>n[a]-n[u]),o=s[0];return vc(s.filter(u=>n[u]===n[o]))}catch{return NaN}}xc.exports=Sc});var _c=c(($x,Dc)=>{var{random:Oc}=fe(),eb=ct(),tb=w(),nb=G();function Fc(){let t=Oc(),e=Oc();return Math.sqrt(-2*Math.log(t))*Math.cos(2*Math.PI*e)}function rb(t){return tb(t)?Fc():eb(nb(t),Fc)}Dc.exports=rb});var Ac=c((Lx,Ec)=>{var sb=ct(),ob=G();function ib(t){return sb(ob(t),()=>1)}Ec.exports=ib});var Ic=c((Kx,Mc)=>{var Vn=d(),ub=D(),ab=g(),cb=b(),lb=q(),fb=y(),hb=w();function xt(t,e){if(cb(t)||fb(t))return xt(t.values,e);if(Vn(ab(t),"The `permutations` function only works on arrays, Series, and DataFrames!"),hb(e)&&(e=t.length),Vn(lb(e),"`r` must be a whole number!"),t=ub(t),e>t.length)return xt(t);if(e<=0)return[[]];if(Vn(e===parseInt(e),"`r` must be a whole number!"),t.length<2)return t;let n=[];return t.forEach((r,s)=>{let o=t.slice(0,s),i=t.slice(s+1),u=o.concat(i);xt(u,e-1).forEach(l=>{n.push([r].concat(l))})}),n}Mc.exports=xt});var kc=c((Gx,jc)=>{var{DataFrame:mb,Series:db}=Ce(),pb=g(),gb=b(),qb=xe(),yb=y(),bb=T();function wb(){Object.keys(arguments).forEach(t=>{let e=arguments[t];if(pb(e))if(qb(e))console.log(e);else{let n=bb(e);n.length===1?new db(e).print():n.length==2?new mb(e).print():console.log(e)}else gb(e)||yb(e)?e.print():console.log(e)})}jc.exports=wb});var Vc=c((Wx,zc)=>{var Nb=g(),vb=q(),Cc=w(),Sb=oe(),xb=lt(),Tb=S(),Ob=Tb(function(t,e,n,r,s){try{return[t,e,n,r,s].every(o=>vb(o))?n-e===0?NaN:(s-r)*(t-e)/(n-e)+r:NaN}catch{return NaN}});function Fb(t,e,n,r,s){return Nb(t)&&Cc(r)&&Cc(s)&&(r=e,s=n,e=xb(t),n=Sb(t)),Ob(t,e,n,r,s)}zc.exports=Fb});var Uc=c((Hx,Pc)=>{var Db=q(),_b=S();function Eb(t){try{return Db(t)?Math.round(t):NaN}catch{return NaN}}Pc.exports=_b(Eb)});var Rc=c((Qx,Bc)=>{var Ab=q(),Mb=S();function Ib(t){try{return Ab(t)?t<0?-1:t>0?1:0:NaN}catch{return NaN}}Bc.exports=Mb(Ib)});var Yc=c((Xx,Jc)=>{var jb=q(),kb=S();function Cb(t){try{return jb(t)?Math.sin(t):NaN}catch{return NaN}}Jc.exports=kb(Cb)});var Lc=c((Zx,$c)=>{var zb=dt();function Vb(t){return zb(t)}$c.exports=Vb});var Gc=c((eT,Kc)=>{var Pb=q(),Ub=S();function Bb(t){try{return Pb(t)?Math.tan(t):NaN}catch{return NaN}}Kc.exports=Ub(Bb)});var Tt=c((tT,Qc)=>{var Wc=d(),Hc=j();function Rb(t,e){Wc(Hc(t),"`fn` must be a function!");let n=new Date;return e?t(...e):t(),new Date-n}async function Jb(t,e){Wc(Hc(t),"`fn` must be a function!");let n=new Date;return e?await t(...e):await t(),new Date-n}Qc.exports={timeSync:Rb,timeAsync:Jb}});var Zc=c((nT,Xc)=>{var Yb=g(),$b=b(),Lb=y(),Kb=P();function Gb(){return Kb([...arguments].map(t=>Yb(t)?t:$b(t)||Lb(t)?t.values:[t]))}Xc.exports=Gb});var tl=c((rT,el)=>{var Wb=d(),Hb=g(),Qb=b(),Xb=y(),Zb=w(),ew=oe(),tw=k();function nw(){let t=[],e=Object.values(arguments).map(n=>((Qb(n)||Xb(n))&&(n=n.values),Wb(Hb(n),"The `zip` function only works on arrays, Series, and DataFrames!"),n));return tw(0,ew(e.map(n=>n.length))).forEach(n=>{let r=[];e.forEach(s=>{let o=s[n];r.push(Zb(o)?void 0:o)}),t.push(r)}),t}el.exports=nw});var x=c((sT,Pn)=>{var{DataFrame:rw,Series:sw}=Ce(),pe={abs:ut(),add:at(),apply:ct(),arccos:tu(),arcsin:ru(),arctan:ou(),argmax:uu(),argmin:fu(),assert:d(),ceil:mu(),chop:gu(),clamp:yu(),combinations:wu(),copy:B(),correl:Uu(),cos:Ru(),count:Re(),covariance:vn(),DataFrame:rw,diff:Gu(),distance:aa(),divide:la(),dot:En(),dropMissing:An(),dropMissingPairwise:Oa(),dropNaN:Wt(),dropNaNPairwise:ja(),dropUndefined:Ca(),exp:Va(),factorial:Ba(),find:$a(),findAll:Wa(),flatten:D(),float:Qa(),floor:Za(),identity:nc(),indexOf:ve(),int:sc(),intersect:ic(),inverse:lc(),isArray:g(),isBoolean:De(),isDataFrame:b(),isEqual:R(),isFunction:j(),isJagged:xe(),isNested:Je(),isNumber:q(),isObject:K(),isSeries:y(),isString:M(),isUndefined:w(),lerp:hc(),log:pc(),MathError:U(),max:oe(),mean:ft(),median:yc(),min:lt(),mod:Nc(),mode:Tc(),multiply:On(),ndarray:G(),normal:_c(),ones:Ac(),permutations:Ic(),pow:pt(),print:kc(),product:Ee(),random:fe().random,range:k(),remap:Vc(),reshape:et(),reverse:Te(),round:Uc(),scale:de(),seed:fe().seed,Series:sw,set:P(),shape:T(),shuffle:tt(),sign:Rc(),sin:Yc(),sort:Q(),sqrt:mt(),std:dt(),stdev:Lc(),subtract:Fn(),sum:gt(),tan:Gc(),time:Tt().timeSync,timeSync:Tt().timeSync,timeAsync:Tt().timeAsync,transpose:ie(),union:Zc(),variance:Sn(),vectorize:S(),zeros:jn(),zip:tl(),dump:function(){let t=typeof global<"u"?global:window;if(!t)throw new pe.MathError("Cannot dump functions into global scope because neither `global` nor `window` exist in the current context!");Object.keys(pe).forEach(e=>{try{Object.defineProperty(t,e,{configurable:!1,enumerable:!0,writable:!1,value:pe[e]})}catch{t[e]=pe[e]}})}};typeof Pn<"u"&&(Pn.exports=pe);typeof window<"u"&&(window.JSMathTools=pe)});var Y=c((oT,nl)=>{nl.exports={shouldIgnoreNaNValues:!0}});var ge=c((iT,sl)=>{var{assert:ow,flatten:iw,isArray:uw,isDataFrame:aw,isNumber:cw,isSeries:lw}=x();function rl(t){if(aw(t)||lw(t))return rl(t.values);ow(uw(t),"The `containsOnlyNumbers` function only works on arrays, Series, and DataFrames!");let e=iw(t);for(let n=0;n<e.length;n++)if(!cw(e[n]))return!1;return!0}sl.exports=rl});var Bn=c((uT,ol)=>{var{dropMissing:fw,flatten:hw,isArray:mw,isDataFrame:dw,isSeries:pw}=x();function Un(t){return typeof t=="number"?t===0||t===1:dw(t)||pw(t)?Un(t.values):mw(t)?t.length===0?!1:fw(hw(t)).every(n=>Un(n)):!1}ol.exports=Un});var Rn=c((aT,dl)=>{var{abs:il,apply:ul,assert:al,clamp:gw,copy:qw,divide:yw,dropNaN:bw,flatten:ww,isArray:Nw,isDataFrame:vw,isNumber:cl,isSeries:Sw,max:ll,median:fl,min:xw,sort:Tw,subtract:hl}=x(),Ow=Y(),Fw=ge(),Dw=Bn();function ml(t,e){if(vw(t)||Sw(t)){let a=t.copy();return a._values=ml(a._values,e),a}if(al(Nw(t),"The `clipOutliers` function only works on arrays, Series, and DataFrames!"),e=e||5,al(cl(e),"Any `maxScore` value passed into the `clipOutliers` function must be a number!"),!Ow.shouldIgnoreNaNValues&&!Fw(t))return ul(t,()=>NaN);let n=ww(t),r=bw(n);if(Dw(r)||r.length===0)return t;let s=fl(r),o=fl(il(hl(r,s))),i=!1;if(o===0){let a=Tw(qw(r)),l=a.filter(p=>p<s),f=a.filter(p=>p>s),h=s,m=s;if(l.length>0&&(h=ll(l)),f.length>0&&(m=xw(f)),o=(m-h)/2,o===0)return t;i=(s-h)/o>e||(m-s)/o>e}return ll(yw(il(hl(r,s)),o))>e||i?ul(t,a=>cl(a)?gw(a,s-e*o,s+e*o):a):t}dl.exports=ml});var Yn=c((cT,vl)=>{var{assert:pl,dropNaN:gl,isArray:ql,isSeries:yl,mean:bl,shape:wl,variance:Nl}=x(),_w=Y();function Jn(t,e){if(yl(t))return Jn(t.values,e);if(yl(e))return Jn(t,e.values);pl(ql(t)&&ql(e)&&wl(t).length===1&&wl(e).length===1,"The `cohensd` function only works on 1-dimensional arrays and Series!"),pl(t.length===e.length,"Two arrays or Series passed into the `cohensd` function must have the same length!"),_w.shouldIgnoreNaNValues&&(t=gl(t),e=gl(e));try{let n=bl(t),r=bl(e),s=Math.sqrt((Nl(t)+Nl(e))/2);return(n-r)/s}catch{return NaN}}vl.exports=Jn});var Ol=c((lT,Tl)=>{var{assert:Sl,DataFrame:Ew,isArray:Aw,isSeries:Mw,shape:Iw,zeros:jw}=x();function xl(t){if(Mw(t)){let r=new Ew(xl(t.values));return r.index=t.index.slice(),r.columns=t.index.slice(),r}Sl(Aw(t),"The `diagonalize` function only works on 1-dimensional arrays and Series!");let e=Iw(t);Sl(e.length===1,"The `diagonalize` function only works on 1-dimensional arrays and Series!");let n=jw([e[0],e[0]]);return t.forEach((r,s)=>n[s][s]=r),n}Tl.exports=xl});var Gn=c((fT,El)=>{var{assert:$n,clamp:kw,correl:Fl,DataFrame:Ot,dropNaNPairwise:Cw,isArray:Dl,isDataFrame:Ft,isJagged:_l,isUndefined:zw,ndarray:Vw}=x(),Pw=Y();function Ln(t){let e="@jrc03c/js-data-science-helpers/get-correlation-matrix";return Object.defineProperty(t,e,{configurable:!1,enumerable:!1,writable:!1,value:Symbol.for(e)}),t}function Kn(t,e){if(zw(e)&&(e=t),Ft(t)){let r=new Ot(Kn(t.values,e));return r.index=t.columns.slice(),r.columns=Ft(e)?e.columns.slice():new Ot(e).columns.slice(),Ln(r)}if(Ft(e)){let r=new Ot(Kn(t,e.values));return r.index=Ft(t)?t.columns.slice():new Ot(t).columns.slice(),r.columns=e.columns.slice(),Ln(r)}$n(Dl(t)&&Dl(e),"The `getCorrelationMatrix` function only works on 2-dimensional arrays and DataFrames!"),$n(!_l(t)&&!_l(e),"The `getCorrelationMatrix` function only works on non-jagged 2-dimensional arrays and DataFrames!"),$n(t.length===e.length,'The dimensions of the matrices you passed into the `getCorrelationMatrix` function aren\'t compatible! ([shape(a).join(", ")] vs. [shape(b).join(", ")]) The function expects that you\'ll be comparing the columns of two matrices where the columns are all of the same length, so please make sure that the matrices are oriented accordingly.');let n=Vw([t[0].length,e[0].length]);for(let r=0;r<t[0].length;r++){let s=t.map(o=>o[r]);for(let o=0;o<e[0].length;o++){let i=e.map(u=>u[o]);Pw.shouldIgnoreNaNValues?n[r][o]=Fl(...Cw(s,i)):n[r][o]=Fl(s,i)}}return Ln(kw(n,-1,1))}El.exports=Kn});var Wn=c((hT,Al)=>{function Uw(t){try{let e="@jrc03c/js-data-science-helpers/get-correlation-matrix";return t[e]===Symbol.for(e)}catch{return!1}}Al.exports=Uw});var kl=c((mT,jl)=>{var{DataFrame:Hn,isArray:Bw,isDataFrame:Dt,isNumber:Ml,MathError:Rw,sort:Jw}=x(),Il=Gn(),Yw=Wn();function $w(t,e,n){n=Object.values(arguments).find(o=>Ml(o))||1-1e-5;let r=(()=>{let o=Object.values(arguments).filter(i=>Bw(i)||Dt(i));if(o.length===1){let i=o[0];if(Yw(i))return Dt(i)?i:new Hn(i);{let u=Il(i,null);return Dt(u)?u:new Hn(u)}}if(o.length===2){let i=Il(o[0],o[1]);return Dt(i)?i:new Hn(i)}throw new Rw("You must pass 1 or 2 2-dimensional arrays or DataFrames into the `getHighlyCorrelatedColumns` function!")})(),s={};return r.values.forEach((o,i)=>{o.forEach((u,a)=>{if(Ml(u)&&u>n){let l=r.index[i],f=r.columns[a];s[l]||(s[l]=[]),s[l].indexOf(f)<0&&s[l].push(f),s[f]||(s[f]=[]),s[f].indexOf(l)<0&&s[f].push(l)}})}),Object.keys(s).forEach(o=>{s[o]=Jw(s[o])}),s}jl.exports=$w});var Qn=c((dT,zl)=>{var{dropNaN:Lw,isArray:Kw,isDataFrame:Gw,isNumber:Ww,isSeries:Hw,pow:Qw,sqrt:Xw,sum:Zw}=x(),eN=Y();function Cl(t){return Gw(t)||Hw(t)?Cl(t.values):Ww(t)?Math.abs(t):Kw(t)?(eN.shouldIgnoreNaNValues&&(t=Lw(t)),Xw(Zw(Qw(t,2)))):NaN}zl.exports=Cl});var Xn=c((pT,Ul)=>{var{assert:Vl,DataFrame:tN,isArray:nN,isSeries:rN,isString:sN,isUndefined:oN,set:iN,shape:uN,sort:aN}=x();function Pl(){if(arguments.length===1&&rN(arguments[0])){let{name:o,values:i}=arguments[0],u=Pl(o,i),a=new tN(u);return a.index=arguments[0].index.slice(),a}let[t,e]=arguments;Vl(sN(t),"When passing two arguments into the `getOneHotEncodings` function, the first argument must be a string representing the name of the variable being encoded!"),Vl(nN(e)&&uN(e).length===1,"When passing two arguments into the `getOneHotEncodings` function, the second argument must be a 1-dimensional array!");let n={},r=t+"_"+e[0];return aN(iN(e)).filter(o=>!oN(o)).map(o=>t+"_"+o).filter(o=>o!==r).forEach(o=>{n[o]=e.map(i=>o===t+"_"+i?1:0)}),n}Ul.exports=Pl});var Rl=c((gT,Bl)=>{var{count:cN}=x();function lN(t){return cN(t).map(n=>(n.percentage=n.count/t.length,n))}Bl.exports=lN});var Jl=c((qT,fN)=>{fN.exports=[.5,.49601,.49202,.48803,.48405,.48006,.47608,.4721,.46812,.46414,.46017,.4562,.45224,.44828,.44433,.44038,.4364,.43251,.42858,.42465,.42074,.41683,.41294,.40905,.40517,.40129,.39743,.39358,.38974,.38591,.38209,.37828,.37448,.3707,.36693,.36317,.35942,.35569,.35197,.34827,.34458,.3409,.33724,.3336,.32997,.32636,.32276,.31918,.31561,.31207,.30854,.30503,.30153,.29806,.2946,.29116,.28774,.28434,.28096,.2776,.27425,.27093,.26763,.26435,.26109,.25785,.25463,.25143,.24825,.2451,.24196,.23885,.23576,.2327,.22965,.22663,.22363,.22065,.2177,.21476,.21186,.20897,.20611,.20327,.20045,.19766,.19489,.19215,.18943,.18673,.18406,.18141,.17879,.17619,.17361,.17106,.16853,.16602,.16354,.16109,.15866,.15625,.15386,.15151,.14917,.14686,.14457,.14231,.14007,.13786,.13567,.1335,.13136,.12924,.12714,.12507,.12302,.121,.119,.11702,.11507,.11314,.11123,.10935,.10749,.10565,.10383,.10204,.10027,.09853,.0968,.0951,.09342,.09176,.09012,.08851,.08692,.08534,.08379,.08226,.08076,.07927,.0778,.07636,.07493,.07353,.07215,.07078,.06944,.06811,.06681,.06552,.06426,.06301,.06178,.06057,.05938,.05821,.05705,.05592,.0548,.0537,.05262,.05155,.0505,.04947,.04846,.04746,.04648,.04551,.04457,.04363,.04272,.04182,.04093,.04006,.0392,.03836,.03754,.03673,.03593,.03515,.03438,.03362,.03288,.03216,.03144,.03074,.03005,.02938,.02872,.02807,.02743,.0268,.02619,.02559,.025,.02442,.02385,.0233,.02275,.02222,.02169,.02118,.02068,.02018,.0197,.01923,.01876,.01831,.01786,.01743,.017,.01659,.01618,.01578,.01539,.015,.01463,.01426,.0139,.01355,.01321,.01287,.01255,.01222,.01191,.0116,.0113,.01101,.01072,.01044,.01017,.0099,.00964,.00939,.00914,.00889,.00866,.00842,.0082,.00798,.00776,.00755,.00734,.00714,.00695,.00676,.00657,.00639,.00621,.00604,.00587,.0057,.00554,.00539,.00523,.00508,.00494,.0048,.00466,.00453,.0044,.00427,.00415,.00402,.00391,.00379,.00368,.00357,.00347,.00336,.00326,.00317,.00307,.00298,.00289,.0028,.00272,.00264,.00256,.00248,.0024,.00233,.00226,.00219,.00212,.00205,.00199,.00193,.00187,.00181,.00175,.00169,.00164,.00159,.00154,.00149,.00144,.00139,.00135,.00131,.00126,.00122,.00118,.00114,.00111,.00107,.00104,.001,97e-5,94e-5,9e-4,87e-5,84e-5,82e-5,79e-5,76e-5,74e-5,71e-5,69e-5,66e-5,64e-5,62e-5,6e-4,58e-5,56e-5,54e-5,52e-5,5e-4,48e-5,47e-5,45e-5,43e-5,42e-5,4e-4,39e-5,38e-5,36e-5,35e-5,34e-5,32e-5,31e-5,3e-4,29e-5,28e-5,27e-5,26e-5,25e-5,24e-5,23e-5,22e-5,22e-5,21e-5,2e-4,19e-5,19e-5,18e-5,17e-5,17e-5,16e-5,15e-5,15e-5,14e-5,14e-5,13e-5,13e-5,12e-5,12e-5,11e-5,11e-5,1e-4,1e-4,1e-4,9e-5,9e-5,8e-5,8e-5,8e-5,8e-5,7e-5,7e-5,7e-5,6e-5,6e-5,6e-5,6e-5,5e-5,5e-5,5e-5,5e-5,5e-5,4e-5,4e-5,4e-5,4e-5,4e-5,4e-5,3e-5,3e-5,3e-5,3e-5,3e-5,3e-5,3e-5,3e-5,2e-5,2e-5,2e-5,2e-5]});var er=c((yT,Xl)=>{var{abs:Yl,assert:hN,dropNaNPairwise:mN,flatten:_t,isArray:$l,isDataFrame:Ll,isEqual:dN,isSeries:Kl,mean:Gl,remap:pN,round:gN,shape:Wl,sqrt:qN,std:Hl}=x(),yN=Y(),Ql=Jl();function bN(t){return Yl(t)>4.1?0:Ql[gN(pN(Yl(t),0,4.1,0,Ql.length))]}function Zn(t,e){if(Ll(t)||Kl(t))return Zn(t.values,e);if(Ll(e)||Kl(e))return Zn(t,e.values);hN($l(t)&&$l(e)&&dN(Wl(t),Wl(e)),"You must pass two identically-shaped arrays, Series, or DataFrames into the `pValue` function!");let[n,r]=yN.shouldIgnoreNaNValues?mN(_t(t),_t(e)):[_t(t),_t(e)];if(n.length===0||r.length===0)return NaN;let s=Gl(n),o=Gl(r),i=Hl(n),u=Hl(r),a=n.length,l=r.length,f=(s-o)/qN(i*i/a+u*u/l);return 2*bN(f)}Xl.exports=Zn});var rf=c((bT,nf)=>{var{assert:tr,clamp:wN,DataFrame:Et,dropNaNPairwise:NN,isArray:Zl,isDataFrame:At,isJagged:ef,isUndefined:vN,ndarray:SN}=x(),xN=Y(),tf=er();function nr(t){let e="@jrc03c/js-data-science-helpers/get-p-value-matrix";return Object.defineProperty(t,e,{configurable:!1,enumerable:!1,writable:!1,value:Symbol.for(e)}),t}function rr(t,e){if(vN(e)&&(e=t),At(t)){let r=new Et(rr(t.values,e));return r.index=t.columns.slice(),r.columns=At(e)?e.columns.slice():new Et(e).columns.slice(),nr(r)}if(At(e)){let r=new Et(rr(t,e.values));return r.index=At(t)?t.columns.slice():new Et(t).columns.slice(),r.columns=e.columns.slice(),nr(r)}tr(Zl(t)&&Zl(e),"The `getPValueMatrix` function only works on 2-dimensional arrays and DataFrames!"),tr(!ef(t)&&!ef(e),"The `getPValueMatrix` function only works on non-jagged 2-dimensional arrays and DataFrames!"),tr(t.length===e.length,'The dimensions of the matrices you passed into the `getPValueMatrix` function aren\'t compatible! ([shape(a).join(", ")] vs. [shape(b).join(", ")]) The function expects that you\'ll be comparing the columns of two matrices where the columns are all of the same length, so please make sure that the matrices are oriented accordingly.');let n=SN([t[0].length,e[0].length]);for(let r=0;r<t[0].length;r++){let s=t.map(o=>o[r]);for(let o=0;o<e[0].length;o++){let i=e.map(u=>u[o]);xN.shouldIgnoreNaNValues?n[r][o]=tf(...NN(s,i)):n[r][o]=tf(s,i)}}return nr(wN(n,0,1))}nf.exports=rr});var cf=c((wT,af)=>{var{assert:Mt,intersect:TN,isDataFrame:sf,isSeries:of,isUndefined:uf}=x(),qe=class{constructor(e){let n=this;Mt(uf(e)||e===qe.DROP_NAN_MODE||e===qe.DROP_MISSING_MODE,"The `mode` value passed into the `IndexMatcher` constructor must be undefined or one of [IndexMatcher.DROP_NAN_MODE, IndexMatcher.DROP_MISSING_MODE]! (By default, the mode is `Indexer.DROP_MISSING_MODE`.)"),n.mode=uf(e)?qe.DROP_MISSING_MODE:e,n.index=null}fit(){let e=this,n=[];return Object.values(arguments).forEach(r=>{Mt(sf(r)||of(r),"The `IndexMatcher` only works on Series and DataFrames! To drop NaN values in a pair-wise fashion from regular arrays, use the `dropNaNPairwise` function from the @jrc03c/js-math-tools library."),e.mode===qe.DROP_MISSING_MODE?n.push(r.dropMissing().index):n.push(r.dropNaN().index)}),e.index=TN(...n),e}transform(){let e=this;Mt(!!e.index,"The IndexMatcher hasn't been fitted yet! Please call the `fit` method before calling the `transform` method.");let n=Object.values(arguments).map(r=>(Mt(sf(r)||of(r),"The `IndexMatcher` only works on Series and DataFrames! To drop NaN values in a pair-wise fashion from regular arrays, use the `dropNaNPairwise` function from the @jrc03c/js-math-tools library."),r.get(e.index,null)));return n.length===1?n[0]:n}fitAndTransform(){return this.fit(...arguments).transform(...arguments)}},Ve=qe;Vt(Ve,"DROP_NAN_MODE","DROP_NAN_MODE"),Vt(Ve,"DROP_MISSING_MODE","DROP_MISSING_MODE");af.exports=Ve});var ir=c((NT,ff)=>{var{apply:ON,assert:FN,count:DN,flatten:_N,float:EN,isArray:sr,isDataFrame:AN,isNumber:MN,isSeries:IN,isString:jN}=x(),lf=["null","none","nan","na","n/a","","undefined"],kN=["true","false","yes","no"];function CN(t,e){if(t===void 0&&(t="undefined"),e==="null")return null;if(e==="number"){let n=EN(t);return isNaN(n)?NaN:n}if(e==="boolean"){try{let n=t.trim().toLowerCase();if(n==="true"||n==="yes")return!0;if(n==="false"||n==="no")return!1}catch{}return null}if(e==="date"){let n=new Date(t);return n.toString()==="Invalid Date"?null:n}if(e==="object")try{let n=JSON.parse(t);return sr(n)?null:n}catch{return null}if(e==="string"){try{if(lf.indexOf(t.trim().toLowerCase())>-1)return null}catch{return null}return t}}function or(t){if(AN(t)){let s=t.copy(),o=or(t.values);return s.values=o.values,{type:o.type,values:s}}if(IN(t)){let s=t.copy(),o=or(t.values);return s.values=o.values,{type:o.type,values:s}}FN(sr(t),"The `inferType` function only works on arrays, Series, and DataFrames!");let e=_N(t).map(s=>{if(s===void 0)return"null";jN(s)||(s=JSON.stringify(s));let i=s.toLowerCase().trim();if(lf.indexOf(i)>-1)return"null";if(kN.indexOf(i)>-1)return"boolean";try{let u=JSON.parse(s);return MN(u)?"number":typeof u=="object"?sr(u)?"string":"object":"string"}catch{return new Date(s).toString()!=="Invalid Date"?"date":"string"}}),r=DN(e).sort((s,o)=>o.count-s.count)[0].item;return{type:r,values:ON(t,s=>CN(s,r))}}ff.exports=or});var ar=c((vT,gf)=>{var{assert:ur,isArray:zN,isBoolean:VN,isDataFrame:hf,isSeries:mf,int:PN,isNumber:UN,isUndefined:df,range:pf,set:BN,shape:RN,shuffle:JN}=x();gf.exports=function(){let e=Array.from(arguments),n=e.find(p=>VN(p)),r=df(n)?!0:n,s=e.find(p=>UN(p)),o=df(s)?.1:s;ur(o>0&&o<1,"`testSize` must be a number between 0 and 1 (exclusive on both ends)!");let i=e.filter(p=>zN(p)||hf(p)||mf(p));ur(i.length>0,"You must pass at least one dataset into the `trainTestSplit` function!");let u=i.map(p=>RN(p)[0]);ur(BN(u).length===1,`All datasets passed into the \`trainTestSplit\` function must be the same length at their shallowest dimension! The lengths of your datasets, though, are: ${u.join(", ")}`);let a=[],l=r?JN(pf(0,u[0])):pf(0,u[0]),f=PN((1-o)*l.length),h=l.slice(0,f),m=l.slice(f);return i.forEach(p=>{if(hf(p))a.push(p.get(h,null)),a.push(p.get(m,null));else if(mf(p))a.push(p.get(h)),a.push(p.get(m));else{let v=[],N=[];p.forEach((E,F)=>{h.indexOf(F)>-1?v.push(E):N.push(E)}),a.push(v),a.push(N)}}),a}});var jt=c((ST,vf)=>{var{add:YN,argmin:$N,assert:LN,flatten:qf,isArray:KN,isDataFrame:yf,isEqual:GN,int:WN,isNumber:HN,isSeries:bf,normal:cr,pow:QN,random:XN,range:ZN,scale:ev,shape:It,subtract:tv,sum:nv}=x(),rv=ar();function lr(t,e){(yf(t)||bf(t))&&(t=t.values),(yf(e)||bf(e))&&(e=e.values),LN(GN(It(t),It(e)),"`yPred` and `yTrue` must have the same shape!");let n=qf(t),r=qf(e),s=0;return n.forEach((o,i)=>{o===r[i]&&s++}),s/n.length}function sv(t){test(`tests that the \`${t.name}\` model works correctly`,()=>{let e=cr([5,10]).map(h=>h.map(m=>m*100+cr()*100)),n=[],r=ZN(0,500).map(()=>{let h=WN(XN()*e.length),m=e[h];return n.push(h),YN(m,ev(5,cr(It(m))))}),[s,o,i,u]=rv(r,n),a=new t({k:e.length});a.fit(s),a.centroids=wf(e,a.centroids);let l=a.predict(s),f=a.predict(o);expect(lr(i,l)).toBeGreaterThan(.95),expect(lr(u,f)).toBeGreaterThan(.95)})}function ov(t){return KN(t)&&It(t).length===2}function iv(t){return HN(t)&&parseInt(t)===t&&t>=0}function wf(t,e){return t.map(n=>e[$N(e.map(r=>Nf(n,r)))])}function Nf(t,e){return nv(QN(tv(t,e),2))}vf.exports={accuracy:lr,createGenericTest:sv,isMatrix:ov,isWholeNumber:iv,orderCentroids:wf,sse:Nf}});var mr=c((xT,Of)=>{var{add:Sf,argmin:uv,assert:ue,distance:xf,divide:av,isDataFrame:cv,isFunction:lv,isUndefined:kt,normal:fv,random:hv,range:mv,scale:dv,shuffle:pv,zeros:Tf}=x(),{isMatrix:gv,isWholeNumber:fr,sse:qv}=jt(),hr=class{constructor(e){ue(typeof e=="object","`config` must be an object! See the documentation for more information about the properties that the `config` object can contain."),ue(fr(e.k),"`k` must be a whole number!"),ue(fr(e.maxIterations)||kt(e.maxIterations),"`maxIterations` must be a whole number or undefined!"),ue(fr(e.maxRestarts)||kt(e.maxRestarts),"`maxRestarts` must be a whole number or undefined!"),ue(typeof e.tolerance=="number"||kt(e.tolerance),"`tolerance` must be a number or undefined!");let n=this;n.k=e.k,n.maxRestarts=e.maxRestarts||25,n.maxIterations=e.maxIterations||100,n.tolerance=e.tolerance||1e-4,n.centroids=null}initializeCentroids(e){let n=this;return pv(e).slice(0,n.k)}fit(e,n,r){let s=this;function*o(u,a,l){ue(gv(u),"`x` must be a matrix!"),cv(u)&&(u=u.values),kt(a)||ue(lv(a),"If defined, `progress` must be a function!");let f,h=-1/0;for(let m=0;m<s.maxRestarts;m++){let p=s.initializeCentroids(u);for(let N=0;N<s.maxIterations;N++){let E=s.predict(u,p),F=[],A=Tf(s.k);u.forEach((V,Mh)=>{let we=E[Mh];F[we]||(F[we]=Tf(V.length)),F[we]=Sf(F[we],V),A[we]++});let ae=mv(0,s.k).map(V=>A[V]===0?Sf(p[parseInt(hv()*p.length)],dv(.001,fv(p[0].length))):av(F[V],A[V]));try{if(xf(p,ae)<s.tolerance)break}catch{break}p=ae,a&&a((m+N/s.maxIterations)/s.maxRestarts,f),l&&(yield)}let v=s.score(u,p);v>h&&(h=v,f=p)}return a&&a(1,f),s.centroids=f,s}let i=o(e,n,r);if(r)return i;{let u={done:!1};for(;!u.done;)u=i.next();return s}}predict(e,n){if(n=n||this.centroids,!n)throw new Error("No centroids were provided to the `predict` method, and the K-Means model hasn't been fitted yet. Please either pass centroids as a second parameter to the `predict` method or run the `fit` method first!");return e.map(s=>uv(n.map(o=>xf(s,o))))}score(e,n){let r=this;if(n=n||r.centroids,!n)throw new Error("No centroids were provided to the `score` method, and the K-Means model hasn't been fitted yet. Please either pass centroids as a second parameter to the `score` method or run the `fit` method first!");let o=r.predict(e,n).map(i=>n[i]);return-qv(e,o)}};Of.exports=hr});var pr=c((TT,_f)=>{var{argmin:yv,distance:Ff,divide:bv,max:wv,random:Df}=x(),Nv=mr(),dr=class extends Nv{initializeCentroids(e){let n=this,r=[e[parseInt(Df()*e.length)]];for(;r.length<n.k;){let s=e.map(i=>Ff(i,r[yv(r.map(u=>Ff(i,u)))])),o=bv(s,wv(s));r.push(e[o.findIndex(i=>Df()<i)])}return r}};_f.exports=dr});var Mf=c((OT,Af)=>{var{assert:L,isArray:vv,isDataFrame:Sv,isEqual:xv,isFunction:Tv,isUndefined:ye,range:Ov,shape:Ef}=x(),{isMatrix:Fv,isWholeNumber:gr}=jt(),Dv=pr(),qr=class{constructor(e){ye(e)&&(e={}),L(typeof e=="object","`config` must be an object! See the documentation for more information about the properties that the `config` object can contain."),ye(e.ks)&&(e.ks=Ov(1,16)),L(vv(e.ks),"`ks` must be an array of whole numbers!"),e.ks.forEach(r=>{L(gr(r),"`ks` must be an array of whole numbers!")}),L(gr(e.maxIterations)||ye(e.maxIterations),"`maxIterations` must be a whole number or undefined!"),L(gr(e.maxRestarts)||ye(e.maxRestarts),"`maxRestarts` must be a whole number or undefined!"),L(typeof e.tolerance=="number"||ye(e.tolerance),"`tolerance` must be a number or undefined!");let n=this;n.ks=e.ks,n.maxRestarts=e.maxRestarts||25,n.maxIterations=e.maxIterations||100,n.tolerance=e.tolerance||1e-4,n.scoreStopRatio=.85,n.modelClass=e.modelClass||Dv,n.fittedModel=null}fit(e,n,r){let s=this;function*o(u,a,l){L(Fv(u),"`x` must be a matrix!"),Sv(u)&&(u=u.values),ye(a)||L(Tv(a),"If defined, `progress` must be a function!");let f=s.ks[0],h=-1/0;for(let m=0;m<s.ks.length;m++){let p=s.ks[m],v=new s.modelClass({k:p,maxRestarts:10,maxIterations:25}),N=v.fit(u,a?(F,A)=>a((F+m)/(s.ks.length+1),A):null,l);if(l){let F={done:!1};for(;!F.done;)F=N.next(),yield}let E=v.score(u);if(E/h>s.scoreStopRatio)break;f=p,h=E,l&&(yield)}return s.fittedModel=new s.modelClass({k:f,maxRestarts:s.maxRestarts,maxIterations:s.maxIterations,tolerance:s.tolerance}),s.fittedModel.fit(u,a?(m,p)=>a((m+s.ks.length)/(s.ks.length+1),p):null,!1),a&&a(1,s.fittedModel.centroids),s}let i=o(e,n,r);if(r)return i;{let u={done:!1};for(;!u.done;)u=i.next();return s}}predict(e,n){return this.fittedModel.predict(e,n)}score(e,n){return this.fittedModel.score(e,n)}get k(){return this.fittedModel.k}set k(e){throw new Error("You can't set the k-value manually! It has to be set automatically via the `fit` method.")}get centroids(){return this.fittedModel.centroids}set centroids(e){let n=this;L(xv(Ef(e),Ef(n.fittedModel.centroids)),"When assigning a new value to the `centroids` property, the new centroids must have the same shape as the old centroids!"),n.fittedModel.centroids=e}};Af.exports=qr});var jf=c((FT,If)=>{If.exports={KMeansMeta:Mf(),KMeansNaive:mr(),KMeansPlusPlus:pr(),helpers:jt()}});var yr=c((DT,Uf)=>{var{apply:_v,assert:Ev,dropNaN:kf,isArray:Av,isDataFrame:Mv,isSeries:Iv,mean:Cf,std:zf}=x(),Vf=Y();function Pf(t){if(Mv(t)||Iv(t)){let r=t.copy();return r.values=Pf(r.values),r}Ev(Av(t),"The `normalize` function only works on arrays, Series, and DataFrames!");let e=(()=>Vf.shouldIgnoreNaNValues?Cf(kf(t)):Cf(t))(),n=(()=>Vf.shouldIgnoreNaNValues?zf(kf(t)):zf(t))();return n===0?t:_v(t,r=>(r-e)/n)}Uf.exports=Pf});var wr=c((_T,$f)=>{var{assert:be,dot:Bf,isArray:Rf,isSeries:br,scale:jv,Series:kv,shape:Jf}=x(),Yf=ge();function Ct(t,e){if(br(t)){if(br(e))return new kv(Ct(t.values,e.values));{let n=t.copy();return n.values=Ct(t.values,e),n}}if(br(e)){let n=e.copy();return n.values=Ct(t,e.values),n}return be(Rf(t),"`project` only works on vectors!"),be(Rf(e),"`project` only works on vectors!"),be(Yf(t),"`project` only works on vectors of numbers!"),be(Yf(e),"`project` only works on vectors of numbers!"),be(Jf(t).length===1,"`project` only works on vectors!"),be(Jf(e).length===1,"`project` only works on vectors!"),jv(Bf(e,t)/Bf(e,e),e)}$f.exports=Ct});var Hf=c((ET,Wf)=>{var{assert:Lf,copy:Cv,DataFrame:zv,divide:Vv,isArray:Pv,isDataFrame:Uv,isJagged:Bv,shape:Rv,subtract:Jv,transpose:Kf}=x(),Yv=ge(),$v=Qn(),Lv=wr();function Gf(t){if(Uv(t)){let s=new zv(Gf(t.values));return s.index=t.index.slice(),s.columns=t.columns.slice(),s}Lf(Pv(t)&&!Bv(t)&&Rv(t).length===2,"`orthonormalize` only works on matrices!"),Lf(Yv(t),"`orthonormalize` only works on matrices of numbers!");let e=Kf(t),n=[];e.forEach(s=>{let o=Cv(s);n.forEach(i=>{o=Jv(o,Lv(o,i))}),n.push(o)});let r=n.map(s=>Vv(s,$v(s)));return Kf(r)}Wf.exports=Gf});var rh=c((AT,nh)=>{var{assert:Qf,copy:Kv,correl:Gv,DataFrame:Xf,dropMissing:Wv,isArray:Hv,isDataFrame:Qv,isEqual:Xv,isJagged:Zv,isNumber:Zf,set:eS,shape:tS,transpose:eh}=x(),nS=Rn(),rS=Xn(),sS=ir();function th(t,e,n){if(e=Zf(e)?e:7,n=Zf(n)?n:1-1e-5,Hv(t))return Qf(tS(t).length===2&&!Zv(t),"The `preprocess` function only works on non-jagged 2-dimensional arrays and DataFrames!"),th(new Xf(t));Qf(Qv(t),"You must pass a DataFrame into the `preprocess` function!");let r={};t=t.apply(l=>{let f=sS(l.values);return r[l.name]=f.type,f.values});let s=Kv(t.columns),o=eh(t.values),i=0,u=!1;for(;!u;){let l=o[i];for(let f=i+1;f<o.length;f++){let h=o[f];Xv(l,h)&&(s.splice(f,1),o.splice(f,1))}i++,u=i>=s.length-1}for(i=0,u=!1;!u;){let l=s[i],f=o[i];if(!f)break;let h=Wv(f);if(h.length<15){s.splice(i,1),o.splice(i,1);continue}let m=eS(h);if(m.length===1){s.splice(i,1),o.splice(i,1);continue}let p=r[l];if(p==="string"){if(m.length<=e){let v=rS(l,f);Object.keys(v).forEach(N=>{s.push(N),o.push(v[N]),r[N]="number"}),s.splice(i,1),o.splice(i,1);continue}}else if(p==="number"){let v=nS(f);o[i]=v;let N=!1;for(let E=0;E<i;E++){let F=o[E];if(Gv(f,F)>n){s.splice(i,1),o.splice(i,1),N=!0;break}}if(N)continue}else{o.splice(i,1),s.splice(i,1);continue}i++,u=i>=s.length}let a=new Xf(eh(o));return a.columns=s,a}nh.exports=th});var mh=c((MT,hh)=>{var{abs:oS,add:iS,assert:Pe,isArray:sh,isDataFrame:oh,isEqual:uS,isSeries:ih,mean:aS,pow:uh,scale:cS,shape:ah,sign:lS,sqrt:fS,sum:ch}=x(),lh=ge(),fh=(t,e)=>iS(t,cS(e,-1));function Nr(t,e){if(oh(t)||ih(t))return Nr(t.values,e);if(oh(e)||ih(e))return Nr(t,e.values);Pe(sh(t),"You must pass two same-shaped numerical arrays into the `rScore` function!"),Pe(sh(e),"You must pass two same-shaped numerical arrays into the `rScore` function!"),Pe(uS(ah(t),ah(e)),"You must pass two same-shaped numerical arrays into the `rScore` function!"),Pe(lh(t),"You must pass two same-shaped numerical arrays into the `rScore` function!"),Pe(lh(e),"You must pass two same-shaped numerical arrays into the `rScore` function!");let n=ch(uh(fh(t,e),2)),r=ch(uh(fh(t,aS(t)),2));if(r===0)return NaN;let s=1-n/r;return lS(s)*fS(oS(s))}hh.exports=Nr});var yh=c((IT,qh)=>{var{argmax:dh,assert:Ue,copy:hS,DataFrame:mS,dot:dS,isArray:pS,isDataFrame:gS,isEqual:ph,isJagged:qS,max:yS,min:bS,reverse:wS,shape:NS,transpose:vS}=x();function gh(t){if(pS(t)){Ue(NS(t).length===2&&!qS(t),"The `sortCorrelationMatrix` function only works on 2-dimensional arrays and DataFrames!");let s=new mS(t);return s.index=s.columns.slice(),gh(s).values}Ue(gS(t),"You must pass a DataFrame into the `sortCorrelationMatrix` function!"),Ue(yS(t.values)<=1&&bS(t.values)>=-1,"The correlation matrix passed into the `sortCorrelationMatrix` function must not contain values less than -1 or greater than 1!"),Ue(ph(t.values,vS(t.values)),"The correlation matrix passed into the `sortCorrelationMatrix` function must be symmetrical!"),Ue(ph(t.index,t.columns),"The correlation matrix passed into the `sortCorrelationMatrix` function must be symmetrical! (In this case, although the values themselves are symmetrical, the row and column names differ.)");let e=hS(t.index),n=[];for(;e.length>0;)if(n.length===0){let s=dh(t.values.map(o=>dS(o,o)));n.push(e[s]),e.splice(s,1)}else{let s=t.index.indexOf(n.at(-1)),o=dh(e.map(u=>t.values[t.index.indexOf(u)][s])),i=e[o];n.push(i),e.splice(o,1)}let r=wS(n);return t.get(r,r)}qh.exports=gh});var wh=c((jT,bh)=>{var SS=yr();function xS(){return SS(...arguments)}bh.exports=xS});var _h=c((kT,Dh)=>{var{assert:zt,DataFrame:Nh,dropNaN:TS,flatten:vh,isArray:OS,isDataFrame:vr,isSeries:Sr,mean:Sh,range:FS,Series:xh,shape:Th,stdev:Oh,transpose:Fh}=x(),DS=Y(),xr=class{constructor(){let e=this;e.means=[],e.stdevs=[],e.wasFittedOnAVector=!1,e.hasBeenFitted=!1}_getDataArrayAndShape(e){if(vr(e))return[e.values,e.shape];if(Sr(e)){let r=Fh([e.values]);return[r,Th(r)]}zt(OS(e),"`x` must be a 1- or 2-dimensional array, DataFrame, or Series!");let n=Th(e);return zt(n.length<3,"`x` must be a 1- or 2-dimensional array, DataFrame, or Series!"),n.length===1&&(n.push(1),e=Fh([e])),[e,n]}fit(e){let n=this,r=n._getDataArrayAndShape(e);e=r[0];let s=r[1];return n.wasFittedOnAVector=s.indexOf(1)>-1,n.means=[],n.stdevs=[],FS(0,s[1]).forEach(o=>{let i=e.map(u=>u[o]);if(DS.shouldIgnoreNaNValues){let u=TS(i);n.means.push(Sh(u)),n.stdevs.push(Oh(u))}else n.means.push(Sh(i)),n.stdevs.push(Oh(i))}),n.hasBeenFitted=!0,n}transform(e){let n=this;if(!n.hasBeenFitted)throw new Error("This `StandardScaler` instance hasn't been trained on any data yet! Please use the `fit` method to train it before calling the `transform` method.");if(vr(e)){let i=new Nh(n.transform(e.values));return i.columns=e.columns,i.index=e.index,i}if(Sr(e)){let i=new xh(n.transform(e.values));return i.name=e.name,i.index=e.index,i}let r=n._getDataArrayAndShape(e);e=r[0];let s=r[1];zt(s[1]===n.means.length,"The data you passed into the `transform` function doesn't have the same number of columns as the data set on which this StandardScaler was fitted!");let o=e.map(i=>i.map((u,a)=>(u-n.means[a])/n.stdevs[a]));return n.wasFittedOnAVector?vh(o):o}untransform(e){let n=this;if(!n.hasBeenFitted)throw new Error("This `StandardScaler` instance hasn't been trained on any data yet! Please use the `fit` method to train it before calling the `transform` method.");if(vr(e)){let i=new Nh(n.untransform(e.values));return i.columns=e.columns,i.index=e.index,i}if(Sr(e)){let i=new xh(n.untransform(e.values));return i.name=e.name,i.index=e.index,i}let r=n._getDataArrayAndShape(e);e=r[0];let s=r[1];zt(s[1]===n.means.length,"The data you passed into the `untransform` function doesn't have the same number of columns as the data set on which this StandardScaler was fitted!");let o=e.map(i=>i.map((u,a)=>u*n.stdevs[a]+n.means[a]));return n.wasFittedOnAVector?vh(o):o}};Dh.exports=xr});var ES=c((CT,Ah)=>{var{MathError:_S}=x(),Eh={clipOutliers:Rn(),cohensD:Yn(),cohensd:Yn(),common:Y(),containsOnlyNumbers:ge(),diagonalize:Ol(),getCorrelationMatrix:Gn(),getHighlyCorrelatedColumns:kl(),getMagnitude:Qn(),getOneHotEncodings:Xn(),getPercentages:Rl(),getPValueMatrix:rf(),IndexMatcher:cf(),inferType:ir(),isBinary:Bn(),isCorrelationMatrix:Wn(),KMeans:jf(),normalize:yr(),orthonormalize:Hf(),preprocess:rh(),project:wr(),pValue:er(),rScore:mh(),sortCorrelationMatrix:yh(),standardize:wh(),StandardScaler:_h(),trainTestSplit:ar(),dump(){let t=this,e=typeof global<"u"?global:typeof window<"u"?window:null;if(!e)throw new _S("Cannot dump functions into global scope because neither `global` nor `window` exist in the current context!");Object.keys(t).forEach(n=>{try{Object.defineProperty(e,n,{configurable:!1,enumerable:!0,writable:!1,value:t[n]})}catch{e[n]=t[n]}})}};try{window.JSDataScienceHelpers=Eh}catch{}try{Ah.exports=Eh}catch{}});ES();})();
