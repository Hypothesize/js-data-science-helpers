(()=>{var Eh=Object.defineProperty;var Ah=(t,e,n)=>e in t?Eh(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n;var ye=(t=>typeof require!="undefined"?require:typeof Proxy!="undefined"?new Proxy(t,{get:(e,n)=>(typeof require!="undefined"?require:e)[n]}):t)(function(t){if(typeof require!="undefined")return require.apply(this,arguments);throw new Error('Dynamic require of "'+t+'" is not supported')});var c=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports);var zt=(t,e,n)=>(Ah(t,typeof e!="symbol"?e+"":e,n),n);var P=c((_S,xr)=>{var Vt=class extends Error{constructor(e){typeof window<"u"?super(e):super(`

\x1B[31m`+e+`
\x1B[0m`)}};xr.exports=Vt});var m=c((ES,Tr)=>{var Mh=P();Tr.exports=function(t,e){if(!t)throw new Mh(e)}});var p=c((AS,Or)=>{function Ih(t){try{return t instanceof Array||typeof t.constructor<"u"&&t.constructor.name==="Array"}catch{return!1}}Or.exports=Ih});var b=c((MS,Fr)=>{function jh(t){try{return!!t._symbol&&t._symbol===Symbol.for("@jrc03c/js-math-tools/dataframe")}catch{return!1}}Fr.exports=jh});var M=c((IS,Dr)=>{function kh(t){return typeof t=="function"}Dr.exports=kh});var q=c((jS,_r)=>{function Ch(t){return typeof t=="number"&&!isNaN(t)}_r.exports=Ch});var w=c((kS,Er)=>{function zh(t){return t===null||typeof t>"u"}Er.exports=zh});var L=c((CS,Ar)=>{var Vh=p(),Ph=w();function Rh(t){return typeof t=="object"&&!Ph(t)&&!Vh(t)}Ar.exports=Rh});var y=c((zS,Mr)=>{function Uh(t){try{return!!t._symbol&&t._symbol===Symbol.for("@jrc03c/js-math-tools/series")}catch{return!1}}Mr.exports=Uh});var be=c((VS,kr)=>{var Bh=m(),Ir=p(),Jh=b(),Yh=M(),Pt=q(),jr=L(),$h=y();function Rt(t,e){if(Jh(t)){let o=Rt(t.values,e);return o.length>0&&Pt(o[0])&&o[0]>=0&&o[0]<t.index.length&&(o[0]=t.index[o[0]]),o.length>1&&Pt(o[1])&&o[1]>=0&&o[1]<t.columns.length&&(o[1]=t.columns[o[1]]),o}if($h(t)){let o=Rt(t.values,e);return o.length>0&&Pt(o[0])&&o[0]>=0&&o[0]<t.index.length&&(o[0]=t.index[o[0]]),o}if(Bh(jr(t)||Ir(t),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `indexOf` function!"),!Yh(e)){let o=e;e=i=>i===o}function n(o,i,u){if(u=u||[],u.indexOf(o)>-1)return null;if(jr(o)){u.push(o);let a=Object.keys(o);for(let l=0;l<a.length;l++){let f=a[l],h=o[f];if(i(h))return[f];let d=n(h,i,u);if(d&&d.length>0)return[f].concat(d)}}else if(Ir(o)){u.push(o);for(let a=0;a<o.length;a++){let l=o[a];if(i(l))return[a];let f=n(l,i,u);if(f&&f.length>0)return[a].concat(f)}}else if(i(o))return[];return null}function r(o){try{return e(o)}catch{return!1}}let s=n(t,r);return s&&s.length>0?s:null}kr.exports=Rt});var R=c((PS,Cr)=>{var Lh=be(),Gh=p(),Kh=b(),Wh=y();function Hh(t){function e(r,s,o){if(Kh(r)||Wh(r))return r.copy();if(s=s||[],o=o||"",s.indexOf(r)>-1){let i=o.split("/").slice(o.startsWith("/")?1:0);if(i.some((a,l)=>{let f=i.slice(0,i.length-l-1),h=n;return f.forEach(d=>{h=h[d]}),h===r}))return`<reference to "${n===r?"/":"/"+Lh(n,r).join("/")}">`}if(typeof r=="object"){if(r===null)return null;if(s.push(r),Gh(r))return r.map((i,u)=>e(i,s,o+"/"+u));{let i={};return Object.keys(r).forEach(u=>{i[u]=e(r[u],s,o+"/"+u)}),i}}else return r}let n=t;return e(t)}Cr.exports=Hh});var F=c((RS,Pr)=>{var Qh=m(),Xh=R(),zr=p(),Zh=b(),e0=y();function Vr(t){if(Zh(t)||e0(t))return Vr(t.values);Qh(zr(t),"The `flatten` function only works on arrays, Series, and DataFrames!");function e(n){let r=[];return Xh(n).forEach(s=>{zr(s)?r=r.concat(e(s)):r.push(s)}),r}return e(t)}Pr.exports=Vr});var U=c((US,Ur)=>{var Rr=R();function t0(t,e){function n(r,s){let o=typeof r;if(o!==typeof s)return!1;if(o==="undefined")return!0;if(o==="boolean"||o==="symbol")return r===s;if(o==="number"||o==="bigint")return r.toString()==="NaN"&&s.toString()==="NaN"?!0:r===s;if(o==="string"||o==="function")return r===s;if(o==="object"){if(r===null||s===null)return r===null&&s===null;{let u=Object.keys(r),a=Object.keys(s);if(u.length!==a.length)return!1;for(let l=0;l<u.length;l++){let f=u[l];if(!n(r[f],s[f]))return!1}return!0}}}return n(Rr(t),Rr(e))}Ur.exports=t0});var V=c((BS,$r)=>{var n0=m(),r0=F(),s0=p(),Br=b(),o0=M(),Jr=y(),i0=w();function we(t){let e="abcdefg1234567890",n="";for(;n.length<t;)n+=e[parseInt(Math.random()*e.length)];return n}var u0=we(256),a0=we(256),c0=we(256),l0=we(256),f0=we(256);function Yr(t){if(Br(t)||Jr(t))return Yr(t.values);n0(s0(t),"The `set` function only works on arrays, Series, and DataFrames!");let e=[],n={};return r0(t).forEach(r=>{let s=typeof r=="object"&&r===null?u0:i0(r)?a0:o0(r)?r.toString():typeof r=="symbol"?r.toString()+" - "+f0:r===1/0?c0:r===-1/0?l0:Br(r)?r.toJSONString():Jr(r)?JSON.stringify(r.toObject()):JSON.stringify(r);n[s]||e.push(r),n[s]=!0}),e}$r.exports=Yr});var Pe=c((JS,Kr)=>{var h0=m(),Ut=F(),Lr=p(),m0=b(),Gr=U(),d0=M(),p0=y(),g0=V();function Ve(t,e){if(m0(t)||p0(t))return arguments.length>1?Ve(t.values,e):Ve(t.values,t.values);if(h0(Lr(t),"The first argument to the `count` function must be an array, Series, or DataFrame!"),d0(e))return Ut(t).filter(n=>e(n)).length;if(Lr(e)){let n=Ut(t);return g0(e).map(r=>({item:r,count:n.filter(s=>Gr(s,r)).length}))}else return arguments.length>1?Ut(t).filter(n=>Gr(n,e)).length:Ve(t,t)}Kr.exports=Ve});var Ne=c((YS,Hr)=>{var q0=m(),Wr=p(),y0=b(),b0=y();function Bt(t){if(y0(t)||b0(t))return Bt(t.values);q0(Wr(t),"The `isJagged` function only works on arrays, Series, and DataFrames!");let e=0,n=null;for(let r=0;r<t.length;r++)if(Wr(t[r])){if(e++,Bt(t[r]))return!0;if(n===null)n=t[r].length;else if(t[r].length!==n)return!0}return e>0&&e<t.length}Hr.exports=Bt});var Re=c(($S,Zr)=>{var w0=m(),Qr=p(),N0=b(),v0=y();function Xr(t){if(N0(t)||v0(t))return Xr(t.values);w0(Qr(t),"The `isNested` function only works on arrays, Series, and DataFrames!");for(let e=0;e<t.length;e++)if(Qr(t[e]))return!0;return!1}Zr.exports=Xr});var G=c((LS,ts)=>{var re=m(),S0=p(),x0=Re(),T0=q(),O0=w(),ue="You must pass a natural number or a one-dimensional array of natural numbers into the `ndarray` function!";function es(t){re(!O0(t),ue),S0(t)||(t=[t]),re(!x0(t),ue),re(t.length>0,ue);let e=t[0];if(re(T0(e),ue),re(parseInt(e)===e,ue),re(e>=0,ue),re(e!==1/0,"We can't create an array containing an infinite number of values!"),t.length===1){let n=[];for(let r=0;r<e;r++)n.push(void 0);return n}else{let n=[];for(let r=0;r<e;r++)n.push(es(t.slice(1)));return n}}ts.exports=es});var ve=c((GS,ns)=>{var F0=m(),D0=p(),_0=b(),E0=y();function Jt(t){if(_0(t)||E0(t)){let n=t.copy();return n.values=Jt(n.values),n.index=Jt(n.index),n}F0(D0(t),"The `reverse` function only works on arrays, Series, and DataFrames!");let e=[];for(let n=t.length-1;n>=0;n--)e.push(t[n]);return e}ns.exports=Jt});var j=c((KS,rs)=>{var Yt=m(),$t=q(),Lt=w(),A0=ve();function M0(t,e,n=1){Yt(!Lt(t)&&!Lt(e)&&!Lt(n),"You must pass two numbers and optionally a step value to the `range` function!"),Yt($t(t)&&$t(e)&&$t(n),"You must pass two numbers and optionally a step value to the `range` function!"),Yt(n>0,"The step value must be greater than 0! (NOTE: The step value is a magnitude; it does not indicate direction.)");let r=!1;if(t>e){r=!0;let o=t;t=e+n,e=o+n}let s=[];for(let o=t;o<e;o+=n)s.push(o);return r&&(s=A0(s)),s}rs.exports=M0});var T=c((WS,us)=>{var I0=m(),ss=p(),j0=b(),k0=U(),C0=y(),z0=w();function os(t){if(!ss(t))return;let e=[t.length],n=0,r=t.map(s=>{let o=os(s);return z0(o)?o:(n++,o.length===1?o[0]:o)});return n>0?n===t.length&&r.slice(0,-1).every((o,i)=>k0(o,r[i+1]))?e.concat(r[0]):(e.push(r),e):e}function is(t){return j0(t)||C0(t)?is(t.values):(I0(ss(t),"The `shape` function only works on arrays, Series, and DataFrames!"),os(t))}us.exports=is});var ms=c((HS,hs)=>{var as=m(),V0=p(),P0=b(),R0=Ne(),U0=y(),B0=w(),cs=P(),Ue=G(),ls=j(),J0=V(),Y0=T();function fs(t,e,n){if(B0(n)&&(n=0),as(n===0||n===1||n==="vertical"||n==="horizontal",'The only valid axis values for use when appending data to a DataFrame are 0, 1, "vertical", and "horizontal". Note that 0 == "horizontal" and 1 == "vertical".'),V0(e)){as(!R0(e),"The array of data you're trying to append to this DataFrame is jagged!");let r=Y0(e);if(r.length===1)if(n===0){let s=t.copy();s._values.push(e);let o=Math.max(t.shape[1],r[0]);for(s._values.forEach(i=>{for(;i.length<o;)i.push(void 0)});s._index.length<s._values.length;)s._index.push("row"+s._index.length);for(;s._columns.length<o;)s._columns.push("col"+s._columns.length);return s}else{let s=Math.max(t.shape[0],r[0]),o=t.copy();for(ls(0,s).forEach(i=>{i>=o._values.length&&o._values.push(Ue(t.shape[1])),o._values[i].push(e[i])});o._index.length<o._values.length;)o._index.push("row"+o._index.length);for(;o._columns.length<o._values[0].length;)o._columns.push("col"+o._columns.length);return o}else if(r.length===2)if(n===0){let s=Math.max(...e.map(i=>i.length).concat([t.shape[1]])),o=t.copy();for(o._values=o._values.concat(e).map(i=>{for(;i.length<s;)i.push(void 0);return i});o._index.length<o._values.length;)o._index.push("row"+o._index.length);for(;o._columns.length<s;)o._columns.push("col"+o._columns.length);return o}else{let s=Math.max(...e.map(u=>u.length))+t.shape[1],o=Math.max(t.shape[0],r[0]),i=t.copy();for(ls(0,o).forEach(u=>{for(u>=i._values.length&&i._values.push(Ue(t.shape[1])),i._values[u]=i._values[u].concat(e[u]);i._values[u].length<s;)i._values[u].push(void 0)});i._index.length<i._values.length;)i._index.push("row"+i._index.length);for(;i._columns.length<s;)i._columns.push("col"+i._columns.length);return i}else throw new cs("Only 1- and 2-dimensional arrays can be appended to a DataFrame!")}else if(U0(e)){let r=fs(t,e.values,n);return n===0?r.index[r.index.length-1]=r.index.indexOf(e.name)>-1?e.name+" (2)":e.name:r.columns[r.columns.length-1]=r.columns.indexOf(e.name)>-1?e.name+" (2)":e.name,r}else if(P0(e))if(n===0){let r=t.copy(),s=J0(r._columns.concat(e._columns)).length;for(r._values.forEach(o=>{for(;o.length<s;)o.push(void 0)}),e.apply(o=>{let i=o.copy(),u=[];r._columns.forEach(a=>{let l=i._index.indexOf(a);l>-1?(u.push(i._values[l]),i._values.splice(l,1),i._index.splice(l,1)):u.push(void 0)}),r._values.push(u.concat(i._values))},1),r._columns=r._columns.concat(e._columns.filter(o=>r._columns.indexOf(o)<0));r._index.length<r._values.length;){let o="row"+r._index.length;r._index.push(o+(t._index.indexOf(o)>-1?" (2)":""))}return r}else{let r=t.copy();return r._index.forEach((s,o)=>{let i=e._index.indexOf(s);i>-1?r._values[o]=r._values[o].concat(e._values[i]):r._values[o]=r._values[o].concat(Ue(e.shape[1]))}),e._index.forEach((s,o)=>{r._index.indexOf(s)<0&&(r._index.push(s),r._values.push(Ue(r._columns.length).concat(e._values[o])))}),r._columns=r._columns.concat(e._columns.map(s=>s+(r._columns.indexOf(s)>-1?" (2)":""))),r}else throw new cs("Only 1- or 2-dimensional arrays, Series, and DataFrames can be appended to a DataFrame!")}hs.exports=fs});var ys=c((QS,qs)=>{var ds=m(),ps=p(),$0=M(),gs=w();function L0(t,e,n,r,s){if(s=s||0,ds($0(r),"The first parameter to the `apply` method must be a function."),ds(s===0||s===1,"The second parameter to the `apply` method (the `axis`) must be 0 or 1."),s===0){let o={},i;if(n.columns.forEach((u,a)=>{let l=new e(n.values.map(h=>h[a]));l.name=u,l.index=n.index;let f=r(l,a,n);f instanceof e?o[u]=f.values:o[u]=f,gs(i)&&(i=f instanceof e||ps(f))}),i){let u=new t(o);return u.index=n.index,u}else{let u=new e(n.columns.map(a=>o[a]));return u.index=n.columns,u}}else if(s===1){let o,i=n.values.map((u,a)=>{let l=new e(u);l.name=n.index[a],l.index=n.columns;let f=r(l,a,n);return gs(o)&&(o=f instanceof e||ps(f)),f instanceof e?f.values:f});if(o){let u=new t(i);return u.index=n.index,u.columns=n.columns,u}else{let u=new e(i);return u.index=n.index,u}}}qs.exports=L0});var E=c((XS,bs)=>{function G0(t){return typeof t=="string"}bs.exports=G0});var vs=c((ZS,Ns)=>{var ws=m(),K0=p(),W0=Ne(),H0=L(),Q0=E(),X0=w(),Z0=P(),em=T();function tm(t,e,n,r,s){let o=u=>u instanceof t,i=u=>u instanceof e;if(X0(s)){if(o(r))return n.append(r,1);if(i(r))return n.append(r,1);if(H0(r)){let u=Math.max(...Object.keys(r).map(a=>r[a].length));return Object.keys(r).forEach(a=>{for(;r[a].length<u;)r[a].push(void 0)}),n.append(new t(r),1)}else throw new Z0("You must pass a DataFrame, Series, or object into the `assign` method!")}else{ws(Q0(r),"If passing two arguments into the `assign` method, then the first argument must be a string name!"),ws(K0(s)&&!W0(s)&&em(s).length===1,"If passing two arguments into the `assign` method, then the second argument must be a 1-dimensional array!");let u=n.append(s,1);return u.columns[u.columns.length-1]=r,u}}Ns.exports=tm});var xs=c((e2,Ss)=>{var nm=R();function rm(t,e){if(e.isEmpty)return new t;let n=new t(nm(e.values));return n.columns=e.columns.slice(),n.index=e.index.slice(),n}Ss.exports=rm});var As=c((t2,Es)=>{var Be=m(),Ts=p(),Os=q(),Fs=E(),Ds=w(),_s=T();function sm(t,e,n,r,s){Ds(r)&&(r=[]),Ds(s)&&(s=[]),(Fs(r)||Os(r))&&(r=[r]),(Fs(s)||Os(s))&&(s=[s]),Be(Ts(r),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),Be(Ts(s),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),Be(_s(r).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),Be(_s(s).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");let o,i;n.index.forEach((a,l)=>{r.indexOf(a)<0&&r.indexOf(l)<0&&(o||(o=[]),o.push(a))}),n.columns.forEach((a,l)=>{s.indexOf(a)<0&&s.indexOf(l)<0&&(i||(i=[]),i.push(a))});let u=n.get(o,i);if(u instanceof e){let a=new t;a=a.assign(u),n.index.indexOf(u.name)>-1&&(a=a.transpose()),u=a}return u}Es.exports=sm});var Se=c((n2,Ms)=>{var om=q();function im(t){return om(t)&&parseInt(t)===t}function um(t){return im(t)&&t>=0}Ms.exports=um});var js=c((r2,Is)=>{var Gt=m(),am=E(),Je=w(),cm=Se(),lm=T();function fm(t,e,n,r,s,o){r=r||0,Gt(r===0||r===1,"The first parameter of the `dropMissing` method (the `axis`) must be 0 or 1."),o=o||0,Gt(cm(o),"The third parameter of the `dropMissing` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` null values)."),s=o>0?"none":s||"any",Gt(s==="any"||s==="all"||s==="none","The second parameter of the `dropMissing` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains null values, then it should be dropped; or that if 'all' of the data contains null values, then it should be dropped).");function i(l){if(o>0){let f=0;for(let h=0;h<l.length;h++){let d=l[h];if(Je(d)&&f++,f>=o)return[]}}else if(s==="any")for(let f=0;f<l.length;f++){let h=l[f];if(Je(h))return[]}else if(s==="all"){for(let f=0;f<l.length;f++){let h=l[f];if(!Je(h))return l}return[]}return l}let u=n.copy(),a=Math.random().toString();if(r===0){u=u.assign(a,u.index);let l=u.values.map(i).filter(h=>h.length>0);if(lm(l).length<2)return new t;u.values=l;let f=u.get(null,a);if(Je(f))return new t;am(f)&&(f=[f]),f instanceof e&&(f=f.values),u.index=f,u=u.drop(null,a)}else if(r===1){let l={};if(u.columns.forEach((h,d)=>{let g=u.values.map(v=>v[d]),N=i(g);N.length>0&&(l[h]=N)}),Object.keys(l).length===0)return new t;let f=new t(l);return f.index=u.index,f}return u}Is.exports=fm});var Kt=c((s2,Cs)=>{var hm=m(),mm=p(),dm=b(),pm=q(),gm=y();function ks(t){if(dm(t)||gm(t))return t.dropNaN(...Object.values(arguments).slice(1));hm(mm(t),"The `dropNaN` function only works on arrays, Series, and DataFrames!");let e=[];return t.forEach(n=>{try{return e.push(ks(n))}catch{if(pm(n))return e.push(n)}}),e}Cs.exports=ks});var Vs=c((o2,zs)=>{var Wt=m(),qm=Kt(),ym=Se();function bm(t,e,n,r,s){n=n||0,Wt(n===0||n===1,"The first parameter of the `dropNaN` method (the `axis`) must be 0 or 1."),s=s||0,Wt(ym(s),"The third parameter of the `dropNaN` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` NaN values)."),r=s>0?"none":r||"any",Wt(r==="any"||r==="all"||r==="none","The second parameter of the `dropNaN` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains NaN values, then it should be dropped; or that if 'all' of the data contains NaN values, then it should be dropped).");function o(u){let a=qm(u);return s>0?u.length-a.length<s:r==="any"?a.length===u.length:r==="all"?a.length>0:!0}let i=e.copy();if(n===0){let u=i.index.filter(a=>{let l=i.get(a,null).values;return o(l)});return u.length>0?i.get(u,null):new t}else if(n===1){let u=i.columns.filter(a=>{let l=i.get(null,a).values;return o(l)});return u.length>0?i.get(null,u):new t}return i}zs.exports=bm});var Bs=c((i2,Us)=>{var Ps=m(),xe=F(),wm=M(),Nm=w();function Rs(t){let e={};return xe(t).forEach((n,r)=>{e[n]=r}),e}function ae(t){return Object.keys(t).sort((e,n)=>t[e]-t[n])}function vm(t,e,n,r,s){Ps(wm(r),"The `filter` method takes a single parameter: a function that is used to filter the values."),Nm(s)&&(s=0),Ps(s===0||s===1,"The `axis` parameter to the `filter` method must be 0 or 1.");let o=n.copy();if(o.isEmpty)return o;let i=Rs(o.index),u=Rs(o.columns);if(s===0){let a=o.values.filter((l,f)=>{let h=new e(l);h.name=n.index[f],h.index=n.columns;let d=r(h,f,n);return d||delete i[o.index[f]],d});if(xe(a).length===0)return new t;if(a.length===1){let l=new e(xe(a));return l.name=ae(i)[0],l.index=ae(u),l}o.values=a,o.index=ae(i)}else if(s===1){o=o.transpose();let a=o.values.filter((l,f)=>{let h=new e(l);h.name=n.columns[f],h.index=n.index;let d=r(h,f,n);return d||delete u[o.index[f]],d});if(xe(a).length===0)return new t;if(a.length===1){let l=new e(xe(a));return l.name=ae(u)[0],l.index=ae(i),l}o.values=a,o.index=ae(u),o=o.transpose()}return o}Us.exports=vm});var Te=c((u2,Js)=>{function Sm(t){return typeof t=="boolean"}Js.exports=Sm});var se=c((a2,$s)=>{var xm=m(),Tm=F(),Om=p(),Fm=b(),Dm=y();function Ys(t){if(Fm(t)||Dm(t))return Ys(t.values);xm(Om(t),"The `max` function only works on arrays, Series, and DataFrames!");try{return Math.max(...Tm(t))}catch{return NaN}}$s.exports=Ys});var Ht=c((c2,Ks)=>{var Ye=P(),K=m(),W=p(),Ls=Te(),$e=E(),Le=w(),_m=se(),Gs=j();function Em(t,e,n,r,s,o){return n=(()=>{if(Le(n))return!1;if(Ls(n))return n;throw new Ye("The `hasHeaderRow` parameter of the `fromCSV` method must be a boolean!")})(),r=(()=>{if(Le(r))return!1;if(Ls(r))return r;throw new Ye("The `hasIndexColumn` parameter of the `fromCSV` method must be a boolean!")})(),s=(()=>{let u="The `fieldDelimiter` parameter of the `fromCSV` method must be one of:\n\n1) a single-character string (e.g., ',')\n2) an array containing two single-character strings, one each for a left delimiter and a right delimiter (e.g., ['<', '>'])";if(Le(s))return",";if($e(s))return K(s.length===1,u),s;if(W(s))return K(s.length===2,u),K(s[0].length===1,u),K(s[1].length===1,u),s;throw new Ye(u)})(),o=(()=>{let u="The `stringDelimiter` parameter of the `fromCSV` method must be one of:\n\n1) a single-character string (e.g., '\"')\n2) an array containing two single-character strings, one each for a left delimiter and a right delimiter (e.g., ['\u201C', '\u201D'])";if(Le(o))return'"';if($e(o))return K(o.length===1,u),o;if(W(o))return K(o.length===2,u),K(o[0].length===1,u),K(o[1].length===1,u),o;throw new Ye(u)})(),(()=>{let a=e.split(`
`).filter(g=>g.length>0).map(g=>{let N=[],v="",_=!1;for(let C=0;C<g.length;C++){let I=g[C];if(I.match(/\\/g))C++;else if(W(o)&&I===o[0])_=!0;else if(W(o)&&I===o[1])_=!1;else if($e(o)&&I===o)_=!_;else if(W(s)&&I===s[0]||W(s)&&I===s[1]||$e(s)&&I===s)if(_)v+=I;else{let kt=v;try{let Ct=JSON.parse(kt);W(Ct)?N.push(kt.trim()):N.push(Ct)}catch{N.push(kt.trim())}v=""}else v+=I}if(v.length>0){let C=v;try{let I=JSON.parse(C);W(I)?N.push(C.trim()):N.push(I)}catch{N.push(C.trim())}}return N}),l=(()=>{let g=n?a.shift():Gs(0,a[0].length).map(N=>"col"+N);return r&&g.shift(),g})(),f=(()=>r?a.map(N=>N.shift()):Gs(0,a.length).map(N=>"row"+N))(),h=_m(a.map(g=>g.length)),d=new t(a.map(g=>(g.length=h,g)));return n&&(d.columns=l),r&&(d.index=f),d})()}Ks.exports=Em});var Hs=c((l2,Ws)=>{var Am=P(),Mm=m(),Im=Ht(),jm=E(),km=w();async function Cm(t,e,n,r,s,o,i){n=(()=>km(n)?"utf8":(Mm(jm(n),"The `encoding` parameter of the `fromCSV` method must be a string (e.g., 'utf8')!"),n))();let u=await(async()=>{try{return ye("fs").readFileSync(e,n)}catch{}try{return await(await fetch(e)).text()}catch{}throw new Am(`The path "${e}" could not be loaded!`)})();return Im(t,u,r,s,o,i)}Ws.exports=Cm});var Zs=c((f2,Xs)=>{var z=m(),Ge=q(),Ke=E(),Qs=w(),zm=V();function Vm(t,e,n){(Ke(e)||Ge(e))&&(e=[e]),(Ke(n)||Ge(n))&&(n=[n]);let r=zm((e||[]).concat(n||[]).map(s=>typeof s));return z(r.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===1&&z(r[0]==="string"||r[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===2&&(z(r.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),z(r.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),Qs(e)||(e=e.map(s=>{if(Ke(s))return z(t.index.indexOf(s)>-1,`Row "${s}" does not exist!`),s;if(Ge(s))return z(s>=0,`Index ${s} is out of bounds!`),z(parseInt(s)===s,"Row numbers must be integers!"),z(s<t.index.length,`Index ${s} is out of bounds!`),t.index[s]})),Qs(n)||(n=n.map(s=>{if(Ke(s))return z(t.columns.indexOf(s)>-1,`Column "${s}" does not exist!`),s;if(Ge(s))return z(s>=0,`Column ${s} is out of bounds!`),z(parseInt(s)===s,"Column numbers must be integers!"),z(s<t.columns.length,`Column ${s} is out of bounds!`),t.columns[s]})),t.getSubsetByNames(e,n)}Xs.exports=Vm});var H=c((h2,to)=>{var eo=m(),Pm=p(),Rm=b(),Um=M(),Bm=y(),Jm=w();function Ym(t,e){try{return t<e?-1:t>e?1:0}catch{return t=typeof t=="object"&&t!==null?JSON.stringify(t):t.toString(),e=typeof e=="object"&&e!==null?JSON.stringify(e):e.toString(),t<e?-1:t>e?1:0}}function $m(t,e){if(Jm(e)&&(e=Ym),Rm(t)||Bm(t))return t.sort(...Object.values(arguments).slice(1));eo(Pm(t),"The `sort` function only works on arrays, Series, and DataFrames!"),eo(Um(e),"The second parameter of the `sort` function must be a comparison function!");let n=t.slice();return n.sort(e),n}to.exports=$m});var oo=c((m2,so)=>{var no=m(),ro=E(),Lm=w(),Gm=V(),Km=H();function Wm(t){let e=t.toLowerCase(),n="";for(let s=0;s<e.length;s++){let o=e[s];o.match(/[a-z0-9]/g)?n+=o:n+=" "}let r=n.split(" ").filter(s=>s.length>0);return r[0]+r.slice(1).map(s=>s[0].toUpperCase()+s.substring(1)).join("")}function Hm(t,e,n){Lm(n)?n=e.columns:ro(n)&&(n=[n]);let r={};n.forEach(o=>{no(ro(o),"You must pass either a string or a one-dimensional array of strings into the `getDummies` (AKA `oneHotEncode`) method!");let i=e.columns.indexOf(o);no(i>-1,`The given DataFrame does not have a column called "${o}"!`);let u=e.values.map(l=>l[i]),a=Km(Gm(u));u.forEach(l=>{a.forEach(f=>{let h=o+"_"+Wm(f.toString());r[h]||(r[h]=[]),l===f?r[h].push(1):r[h].push(0)})})});let s=new t(r);return s.index=e.index,s}so.exports=Hm});var mo=c((d2,ho)=>{var Q=m(),io=p(),uo=q(),ao=w(),co=Se(),lo=j(),fo=T();function Qm(t,e,n){let r=t.shape;ao(e)&&(e=lo(0,r[0])),ao(n)&&(n=lo(0,r[1])),uo(e)&&(e=[e]),uo(n)&&(n=[n]),Q(io(e)&&io(n),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),Q(fo(e).length===1&&fo(n).length===1,"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),Q(e.length>0,"The `rowIndices` array must contain at least one index."),Q(n.length>0,"The `colIndices` array must contain at least one index."),e.forEach(i=>{Q(co(i),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),Q(i<t.index.length,`The row index ${i} is out of bounds.`)}),n.forEach(i=>{Q(co(i),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),Q(i<t.columns.length,`The column index ${i} is out of bounds.`)});let s=e.map(i=>t.index[i]),o=n.map(i=>t.columns[i]);return t.getSubsetByNames(s,o)}ho.exports=Qm});var bo=c((p2,yo)=>{var X=m(),Qt=F(),po=p(),We=E(),go=w(),qo=T();function Xm(t,e,n,r,s){go(r)&&(r=n.index),go(s)&&(s=n.columns),We(r)&&(r=[r]),We(s)&&(s=[s]),X(po(r)&&po(s),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),X(qo(r).length===1&&qo(s).length===1,"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),X(r.length>0,"The `rows` array must contain at least one row name."),X(s.length>0,"The `cols` array must contain at least one column name."),r.forEach(u=>{X(We(u),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),X(n.index.indexOf(u)>-1,`The row name "${u}" does not exist in the list of rows.`)}),s.forEach(u=>{X(We(u),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),X(n.columns.indexOf(u)>-1,`The column name "${u}" does not exist in the list of columns.`)});let o=r.map(u=>s.map(a=>n.values[n.index.indexOf(u)][n.columns.indexOf(a)]));if(r.length===1&&s.length===1)return Qt(o)[0];if(r.length===1){let u=new e(Qt(o));return u.name=r[0],u.index=s,u}if(s.length===1){let u=new e(Qt(o));return u.name=s[0],u.index=r,u}let i=new t(o);return i.columns=s,i.index=r,i}yo.exports=Xm});var No=c((g2,wo)=>{var Zm=E(),Oe=j();function ed(t,e,n){function r(d,g){return Zm(d)&&d.length>g?d.substring(0,g-3)+"...":d}if(n.isEmpty)return console.table({}),console.log("Shape:",[0,0],`
`),n;let s=typeof window>"u"?20:10,o=parseInt(s/2),i=typeof window>"u"?Math.floor(process.stdout.columns/24)-1:10,u=parseInt(i/2),a=s>n.index.length?null:Oe(0,o).concat(Oe(n.index.length-o,n.index.length)),l=i>n.columns.length?null:Oe(0,u).concat(Oe(n.columns.length-u,n.columns.length)),f=n.get(a,l);f instanceof e&&(n.shape[0]===1?(f=new t([f.values]),f.index=n.index,f.columns=new e(n.columns).get(l).values):n.shape[1]===1&&(f=new t([f.values]).transpose(),f.index=new e(n.index).get(a).values,f.columns=n.columns)),s<=n.index.length&&(f._index.splice(o,0,"..."),f._values.splice(o,0,Oe(0,f.columns.length).map(()=>"..."))),i<=n.columns.length&&(f._columns.splice(u,0,"..."),f._values=f._values.map(d=>(d.splice(u,0,"..."),d)));let h=28;return f instanceof e?(f.values=f.values.map(d=>r(d,h)),f.name=r(f.name,h),f.index=f.index.map(d=>r(d,h))):(f.values=f.values.map(d=>d.map(g=>r(g,h))),f.columns=f.columns.map(d=>r(d,h)),f.index=f.index.map(d=>r(d,h))),console.table(f.toObject()),console.log("Shape:",n.shape,`
`),n}wo.exports=ed});var He=c((q2,vo)=>{var td=m(),nd=q();function rd(t,e){td(nd(t),"The `leftPad` function only works on numbers!");let n=t.toString();for(;n.length<e;)n="0"+n;return n}vo.exports=rd});var xo=c((y2,So)=>{var sd=He(),od=j();function id(t,e){let n=e?t:t.copy();return n.index=od(0,t.shape[0]).map(r=>"row"+sd(r,(n.index.length-1).toString().length)),n}So.exports=id});var Fe=c((b2,Oo)=>{var ud=m(),ad=F(),cd=p(),ld=b(),fd=y();function To(t){if(ld(t)||fd(t))return To(t.values);ud(cd(t),"The `product` function only works on arrays, Series, and DataFrames!");try{return t.length===0?NaN:ad(t).reduce((e,n)=>e*n,1)}catch{return NaN}}Oo.exports=To});var Qe=c((w2,Eo)=>{var De=m(),Fo=F(),Do=p(),hd=b(),_o=q(),md=y(),dd=Fe(),pd=T();function Xt(t,e){if(hd(t)||md(t))return Xt(t.values,e);if(De(Do(t),"The first argument passed into the `reshape` function must be an array!"),_o(e)&&(e=[e]),De(Do(e),"The second argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),De(pd(e).length===1,"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),e.forEach(o=>{De(_o(o)&&parseInt(o)===o&&o>0,"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!")}),e.length===0)return Fo(t);let n=Fo(t);if(e.length===1&&e[0]===n.length)return n;De(dd(e)===n.length,"The new shape doesn't match the number of values available in `x` (the first argument passed into the `reshape` function)!");let r=[],s=parseInt(n.length/e[0]);for(let o=0;o<e[0];o++){let i=n.slice(o*s,(o+1)*s);r.push(Xt(i,e.slice(1)))}return r}Eo.exports=Xt});var ce=c((N2,zo)=>{var gd=m(),Io=R(),qd=p(),yd=q(),jo=w(),bd=G(),wd=Fe(),Nd=Qe(),ko=Math.pow(2,64),O=[];Co(parseInt(Math.random()*ko));function vd(t,e){t=A(t);function n(){t+=A("0x9e3779b97f4a7c15");let s=Io(t);return s=(s^s>>30n)*A("0xbf58476d1ce4e5b9"),s=(s^s>>27n)*A("0x94d049bb133111eb"),s^s>>31n}let r=[];for(let s=0;s<e;s++)r.push(n());return r}function A(t){return BigInt.asUintN(64,BigInt(t))}function Ao(t,e){return t=A(t),e=BigInt(e),A(A(t<<e)|A(t>>A(64n-e)))}function Co(t){if(jo(t))return Io(O);{gd(yd(t),"If passing a value into the `seed` function, then that value must be an integer!");let e=vd(parseInt(t),4);O[0]=e[0],O[1]=e[1],O[2]=e[2],O[3]=e[3]}}function Mo(){let t=A(Ao(O[0]+O[3],23)+O[0]),e=A(O[1]<<17n);return O[2]=A(O[2]^O[0]),O[3]=A(O[3]^O[1]),O[1]=A(O[1]^O[2]),O[0]=A(O[0]^O[3]),O[2]=A(O[2]^e),O[3]=Ao(O[3],45),parseInt(t)/ko}function Sd(t){return jo(t)?Mo():(qd(t)||(t=[t]),Nd(bd(wd(t)).map(Mo),t))}zo.exports={random:Sd,seed:Co}});var Xe=c((v2,Vo)=>{var{random:xd}=ce(),Td=m(),Od=p(),Fd=b(),Dd=y();function _d(t){if(Fd(t)||Dd(t))return t.shuffle(...Object.values(arguments).slice(1));Td(Od(t),"The `shuffle` function only works on arrays, Series, and DataFrames!");let e=[],n=t.slice();for(let r=0;r<t.length;r++){let s=parseInt(xd()*n.length);e.push(n.splice(s,1)[0])}return e}Vo.exports=_d});var Uo=c((S2,Ro)=>{var Ed=m(),Ad=w(),Po=Xe();function Md(t,e){return Ad(e)&&(e=0),Ed(e===0||e===1,"The `axis` parameter to the `shuffle` must be 0, 1, or undefined."),t.get(e===0?Po(t.index):null,e===1?Po(t.columns):null)}Ro.exports=Md});var Lo=c((x2,$o)=>{var{random:Id}=ce(),k=m(),jd=F(),Bo=p(),Zt=Te(),Yo=M(),Ze=q(),le=E(),en=w(),kd=j(),Jo=T(),tn=H();function Cd(t,e,n){return Yo(e)?zd(t,e,n):Vd(t,e,n)}function zd(t,e,n){if(n=en(n)?0:n,k(Yo(e),"When sorting a DataFrame using a function, the first argument to the `sort` method must be a function!"),k(Ze(n),"When sorting a DataFrame using a function, the second argument to the `sort` method must be null, undefined, 0, or 1 to indicate the axis along which the data should be sorted! An axis of 0 means that the rows will be sorted relative to each other, whereas an axis of 1 means that the columns will be sorted relative to each other."),n===0){let r=tn(t.index,(s,o)=>e(t.get(s,null),t.get(o,null)));return t.get(r,null)}else{let r=tn(t.columns,(s,o)=>e(t.get(null,s),t.get(null,o)));return t.get(null,r)}}function Vd(t,e,n){let r=t.copy(),s=Id().toString();return r=r.assign(s,r.index),en(e)&&(e=[s],n=[!0]),(Ze(e)||le(e))&&(e=[e],(Zt(n)||le(n))&&(n=[n])),k(Bo(e),"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),k(Jo(e).length===1,"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),en(n)&&(n=kd(0,e.length).map(()=>!0)),k(Bo(n),"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),k(Jo(n).length===1,"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),k(e.length===n.length,"The arrays passed into the `sort` method must be equal in length."),e=e.map(o=>{if(k(le(o)||Ze(o),"Column references can either be column names (as strings) or column indices (as whole numbers)."),le(o)){let i=r.columns.indexOf(o);return k(i>-1,`The column "${o}" does not exist!`),i}if(Ze(o))return k(parseInt(o)===o,"Column indices must be whole numbers!"),k(o>=0,`The column index ${o} is out of bounds!`),k(o<r.columns.length,`The index ${o} is out of bounds!`),o}),n=n.map(o=>{if(k(le(o)||Zt(o),"Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),le(o)){let i=o.trim().toLowerCase();return k(i==="ascending"||i==="descending","Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),i==="ascending"}if(Zt(o))return o}),r.values=tn(r.values,(o,i)=>{let u=0;for(;o[e[u]]===i[e[u]]&&u<e.length;)u++;let a=n[u];if(o[e[u]]===i[e[u]])return 0;if(o[e[u]]<i[e[u]])return a?-1:1;if(o[e[u]]>i[e[u]])return a?1:-1}),r.index=jd(r.get(null,s).values),r=r.dropColumns(s),r}$o.exports=Cd});var nn=c((T2,Ko)=>{var Pd=P(),Rd=Te(),Ud=L(),Bd=E(),Go=w();function Jd(t,e){e=(()=>{if(Go(e))return!0;if(Rd(e))return e;throw new Pd("The `shouldIncludeIndex` parameter of the `toCSVString` method must be a boolean!")})();let n=[""].concat(t.index);return[t.columns].concat(t.values).map((s,o)=>(e?[n[o]]:[]).concat(s).map(u=>Bd(u)?JSON.stringify(u):Ud(u)?JSON.stringify(JSON.stringify(u)):Go(u)?"":u.toString()).join(",")).join(`
`)}Ko.exports=Jd});var Wo=c((O2,sn)=>{var rn=P(),Yd=nn();function $d(t,e,n){let r=Yd(t,n),s=!1,o=!1,i,u;try{let a=e;if(e.includes("/")){let f=e.split("/");a=f[f.length-1]}let l=document.createElement("a");l.href=`data:text/csv;charset=utf-8,${encodeURIComponent(r)}`,l.download=a,l.dispatchEvent(new MouseEvent("click")),s=!0}catch(a){i=a}try{let a=ye("fs"),l=ye("path");a.writeFileSync(l.resolve(e),r,"utf8"),o=!0}catch(a){u=a}if(!s&&!o)throw typeof window<"u"?new rn(i):typeof sn<"u"?new rn(u):new rn("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");return t}sn.exports=$d});var on=c((F2,Ho)=>{function Ld(t,e){return JSON.stringify(t.toObject(e))}Ho.exports=Ld});var Qo=c((D2,an)=>{var un=P(),Gd=on();function Kd(t,e,n){let r=Gd(t,n),s=!1,o=!1,i,u;try{let a=e;if(e.includes("/")){let f=e.split("/");a=f[f.length-1]}let l=document.createElement("a");l.href=`data:application/json;charset=utf-8,${encodeURIComponent(r)}`,l.download=a,l.dispatchEvent(new MouseEvent("click")),s=!0}catch(a){i=a}try{let a=ye("fs"),l=ye("path");a.writeFileSync(l.resolve(e),r,"utf8"),o=!0}catch(a){u=a}if(!s&&!o)throw typeof window<"u"?new un(i):typeof an<"u"?new un(u):new un("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");return t}an.exports=Kd});var Zo=c((_2,Xo)=>{var Wd=m(),Hd=w();function Qd(t,e){Hd(e)?e=0:Wd(e===0||e===1,"The axis parameter of the `toObject` method must be undefined, 0, or 1. An axis of 0 indicates that the returned object should be organized first by rows and then by columns. An axis of 1 indicates that the returned object should be organized first by columns and then by rows.");let n={};return e===0?t.index.forEach((r,s)=>{let o={};t.columns.forEach((i,u)=>{o[i]=t.values[s][u]}),n[r]=o}):t.columns.forEach((r,s)=>{let o={};t.index.forEach((i,u)=>{o[i]=t.values[u][s]}),n[r]=o}),n}Xo.exports=Qd});var oe=c((E2,ni)=>{var ei=m(),Xd=p(),Zd=b(),ep=y(),tp=G(),ti=ve(),np=T();function rp(t){if(Zd(t)||ep(t))return t.transpose();ei(Xd(t),"The `transpose` function only works on arrays, Series, and DataFrames!");let e=np(t);if(ei(e.length<=2,"I'm not smart enough to know how to transpose arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `transpose` function!"),e.length===1)return ti(t);if(e.length===2){let n=tp(ti(e));for(let r=0;r<e[0];r++)for(let s=0;s<e[1];s++)n[s][r]=t[r][s];return n}}ni.exports=rp});var ii=c((A2,oi)=>{var ri=m(),sp=p(),op=b(),ip=Re(),up=y(),ap=T();function si(t,e,n){if(up(n))return new t(e.values.concat(n.values));if(sp(n)){let r=ap(n);ri(r.length===1&&!ip(r),"Only vectors can be appended to Series!");let s=e.copy();return n.forEach((o,i)=>{s._values.push(o),s._index.push("item"+(e.values.length+i))}),s}return ri(!op(n),"DataFrames cannot be appended to Series!"),si(e,[n])}oi.exports=si});var ai=c((M2,ui)=>{var cp=m(),lp=M();function fp(t,e){cp(lp(e),"The parameter to the `apply` method must be a function.");let n=t.copy();return n._values=n._values.map((r,s)=>e(r,s)),n}ui.exports=fp});var li=c((I2,ci)=>{var hp=w();function mp(t){let e=t.copy(),n=[];return e._values=e.values.filter((r,s)=>hp(r)?!1:(n.push(e.index[s]),!0)),e._index=n,e}ci.exports=mp});var hi=c((j2,fi)=>{var dp=q();function pp(t,e){let n=[],r=[];e.values.forEach((o,i)=>{dp(o)&&(r.push(o),n.push(e.index[i]))});let s=new t(r);return s.name=e.name,s.index=n,s}fi.exports=pp});var di=c((k2,mi)=>{var gp=R();function qp(t,e,n){let r=e.copy(),s=gp(r.index),o=[],i=r.values.filter((u,a)=>{let l=n(u,a,r.values);return l||o.push(r.index[a]),l});return o.forEach(u=>{s.splice(s.indexOf(u),1)}),i.length===0?(r=new t,r.name=e.name,r):(r.values=i,r.index=s,r)}mi.exports=qp});var gi=c((C2,pi)=>{var Z=m(),yp=q(),bp=E(),wp=w(),Np=V();function vp(t,e){(bp(e)||yp(e))&&(e=[e]);let n=Np((e||[]).map(r=>typeof r));return Z(n.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===1&&Z(n[0]==="string"||n[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===2&&(Z(n.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),Z(n.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),wp(e)||(e=e.map(r=>{if(typeof r=="string")return Z(t.index.indexOf(r)>-1,`Index "${r}" does not exist!`),r;if(typeof r=="number")return Z(r>=0,`Index ${r} is out of bounds!`),Z(parseInt(r)===r,"Indices must be integers!"),Z(r<t.index.length,`Index ${r} is out of bounds!`),t.index[r]})),t.getSubsetByNames(e)}pi.exports=vp});var yi=c((z2,qi)=>{var _e=m(),Sp=p(),xp=w(),Tp=Se(),Op=j(),Fp=T();function Dp(t,e){let n=t.shape;xp(e)&&(e=Op(0,n[0])),_e(Sp(e),"The `indices` array must be 1-dimensional array of whole numbers."),_e(Fp(e).length===1,"The `indices` array must be a 1-dimensional array of whole numbers."),_e(e.length>0,"The `indices` array must contain at least one index."),e.forEach(s=>{_e(Tp(s),"The `indices` array must be a 1-dimensional array of whole numbers."),_e(s<t.index.length,`The row index ${s} is out of bounds.`)});let r=e.map(s=>t.index[s]);return t.getSubsetByNames(r)}qi.exports=Dp});var wi=c((V2,bi)=>{var Ee=m(),_p=p(),Ep=E(),Ap=w(),Mp=T();function Ip(t,e,n){Ap(n)&&(n=e.index),Ee(_p(n),"The `indices` array must be a 1-dimensional array of strings."),Ee(Mp(n).length===1,"The `indices` array must be a 1-dimensional array of strings."),Ee(n.length>0,"The `indices` array must contain at least one index name."),n.forEach(o=>{Ee(Ep(o),"The `indices` array must contain only strings."),Ee(e.index.indexOf(o)>-1,`The name "${o}" does not exist in the index.`)});let r=n.map(o=>e.values[e.index.indexOf(o)]);if(r.length===1)return r[0];let s=new t(r);return s.index=n,s.name=e.name,s}bi.exports=Ip});var Si=c((P2,vi)=>{var jp=R(),Ni=j();function kp(t){let e=t.copy(),n=typeof window>"u"?20:10;if(e.index.length>n){e=e.get(Ni(0,n/2).concat(Ni(e.index.length-n/2,e.index.length)));let s=jp(e.index);s.splice(parseInt(s.length/2),0,"..."),e.values.push("..."),e.index.push("..."),e=e.get(s)}let r={};return e.values.forEach((s,o)=>{let i={};i[e.name]=s,r[e.index[o]]=i}),console.table(r),console.log("Shape:",t.shape,`
`),t}vi.exports=kp});var Ti=c((R2,xi)=>{var Cp=Xe();function zp(t){let e=t.copy();return e.get(Cp(e.index))}xi.exports=zp});var Fi=c((U2,Oi)=>{var Vp=m(),Pp=M(),Rp=w(),Up=H(),Bp=oe();function Jp(t,e,n){n=n||((a,l)=>a<l?-1:1),Vp(Rp(n)||Pp(n),"You must pass undefined, null, or a comparison function as the second argument to the `sort` method!");let r=Bp([e.values,e.index]),s=Up(r,(a,l)=>n(a[0],l[0])),o=[],i=[];s.forEach(a=>{o.push(a[0]),i.push(a[1])});let u=new t;return u._values=o,u._index=i,u.name=e.name,u}Oi.exports=Jp});var Ei=c((B2,_i)=>{var Yp=H(),Di=oe();function $p(t,e){let n=Di([e.values,e.index]);n=Di(Yp(n,(s,o)=>{if(s[1]===o[1])return 0;if(s[1]<o[1])return-1;if(s[1]>o[1])return 1}));let r=new t(n[0]);return r.index=n[1],r.name=e.name,r}_i.exports=$p});var Mi=c((J2,Ai)=>{function Lp(t){let e={};return e[t.name]={},t.index.forEach((n,r)=>{e[t.name][n]=t.values[r]}),e}Ai.exports=Lp});var zi=c((Y2,Ci)=>{var Y=m(),et=R(),cn=p(),Gp=E(),Kp=w(),Ii=He(),ji=j(),tt=ve(),Wp=ii(),Hp=ai(),Qp=li(),Xp=hi(),Zp=di(),eg=gi(),tg=yi(),ng=wi(),rg=Si(),sg=Ti(),og=Fi(),ig=Ei(),ug=Mi(),Ae=T(),ag=oe(),ki=Symbol.for("@jrc03c/js-math-tools/series");Ci.exports=function(t){class e{static[Symbol.hasInstance](r){try{return!!r._symbol&&r._symbol===ki}catch{return!1}}constructor(r){let s=this;if(s.name="data",Object.defineProperty(s,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:ki}),Object.defineProperty(s,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(s,"values",{configurable:!0,enumerable:!0,get(){return s._values},set(o){Y(cn(o),"The new values must be a 1-dimensional array!");let i=Ae(o);Y(i.length===1,"The new array of values must be 1-dimensional!"),i[0]<s._index.length?s._index=s._index.slice(0,i[0]):i[0]>s._index.length&&(s._index=s._index.concat(ji(s._index.length,i[0]).map(u=>"item"+Ii(u,(o.length-1).toString().length)))),s._values=o}}),Object.defineProperty(s,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(s,"index",{configurable:!0,enumerable:!0,get(){return s._index},set(o){Y(cn(o),"The new index must be a 1-dimensional array of strings!"),Y(o.length===s.shape[0],"The new index must be the same length as the old index!"),Y(Ae(o).length===1,"The new index must be a 1-dimensional array of strings!"),o.forEach(i=>{Y(Gp(i),"All of the row names must be strings!")}),s._index=o}}),r){if(r instanceof e)s.name=r.name,s.values=et(r.values),s.index=et(r.index);else if(cn(r)){let o=Ae(r);Y(o.length===1,"When passing an array into the constructor of a Series, the array must be 1-dimensional!"),s.values=r}else if(r instanceof Object){let o=Object.keys(r);Y(o.length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");let i=o[0],u=r[i];Y(Ae(u).length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!"),s.name=i,s.values=u.slice()}}}get shape(){return Ae(this.values)}get length(){return this.shape[0]}get isEmpty(){return this.values.filter(s=>!Kp(s)).length===0}clear(){let s=this.copy();return s.values.forEach((o,i)=>{s.values[i]=void 0}),s}get(r){return eg(this,r)}getSubsetByNames(r){return ng(e,this,r)}getSubsetByIndices(r){return tg(this,r)}loc(r){return this.getSubsetByNames(r)}iloc(r){return this.getSubsetByIndices(r)}reverse(){let r=this,s=new e(tt(r.values));return s.index=tt(r.index),s.name=r.name,s}resetIndex(){let r=this,s=r.copy();return s.index=ji(0,r.shape[0]).map(o=>"item"+Ii(o,(s.index.length-1).toString().length)),s}copy(){let r=this,s=new e;return s._values=et(r.values),s._index=et(r.index),s.name=r.name,s}append(r){return Wp(e,this,r)}apply(r){return Hp(this,r)}concat(r){return this.append(r)}dropMissing(r,s){return Qp(this,r,s)}dropNaN(){return Xp(e,this)}toObject(){return ug(this)}print(){return rg(this)}shuffle(){return sg(this)}sort(r){return og(e,this,r)}sortByIndex(){return ig(e,this)}filter(r){return Zp(e,this,r)}toDataFrame(){let r=this,s=new t(ag([r.values]));return s.columns=[r.name],s.index=r.index,s}transpose(){let s=this.copy();return s.values=tt(s.values),s.index=tt(s.index),s}getDummies(){return this.toDataFrame().getDummies()}oneHotEncode(){return this.getDummies()}}return e}});var Ie=c(($2,Ji)=>{var B=m(),ln=R(),Vi=Pe(),cg=ms(),lg=ys(),fg=vs(),hg=xs(),mg=As(),dg=js(),pg=Vs(),gg=Bs(),qg=Hs(),yg=Ht(),bg=Zs(),Pi=oo(),wg=mo(),Ng=bo(),vg=No(),Sg=xo(),xg=Uo(),Tg=Lo(),Og=Wo(),Fg=nn(),Dg=Qo(),_g=on(),Eg=Zo(),Ag=F(),Me=p(),Mg=L(),Ri=w(),fn=He(),Ig=G(),hn=j(),fe=T(),Ui=oe(),Bi=Symbol.for("@jrc03c/js-math-tools/dataframe");function nt(t){let e="abcdefghijklmnopqrstuvwxyz1234567890",n="";for(let r=0;r<t;r++)n+=e[parseInt(Math.random()*e.length)];return n}var D=class{static[Symbol.hasInstance](e){try{return!!e._symbol&&e._symbol===Bi}catch{return!1}}constructor(e){let n=this;if(Object.defineProperty(n,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:Bi}),Object.defineProperty(n,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(n,"values",{configurable:!0,enumerable:!0,get(){return n._values.length===0||!Ri(n._values[0])&&n._values[0].length===0?[[]]:n._values},set(r){B(Me(r),"The new values must be a 2-dimensional array!");let s=fe(r);B(s.length===2,"The new array of values must be 2-dimensional!"),s[0]<n._index.length?n._index=n._index.slice(0,s[0]):s[0]>n._index.length&&(n._index=n._index.concat(hn(n._index.length,s[0]).map(o=>"row"+fn(o,(s[0]-1).toString().length)))),s[1]<n._columns.length?n._columns=n._columns.slice(0,s[1]):s[1]>n._columns.length&&(n._columns=n._columns.concat(hn(n._columns.length,s[1]).map(o=>"col"+fn(o,(s[1]-1).toString().length)))),n._values=r}}),Object.defineProperty(n,"_columns",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(n,"columns",{configurable:!0,enumerable:!0,get(){return n._columns},set(r){B(Me(r),"The new columns list must be a 1-dimensional array of strings!"),B(n.isEmpty||r.length===n.shape[1],"The new columns list must be the same length as the old columns list!"),B(fe(r).length===1,"The new columns list must be a 1-dimensional array of strings!"),r=r.map(o=>(typeof o!="string"&&(o=JSON.stringify(o)||o.toString()),o.trim().length===0?"untitled_"+nt(8):o.trim()));let s=(()=>{let o=Vi(r),i={};return o.forEach(u=>{i[u.item]=u.count}),i})();r=r.map(o=>s[o]>1?o+"_"+nt(8):o),n._columns=r}}),Object.defineProperty(n,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(n,"index",{configurable:!0,enumerable:!0,get(){return n._index},set(r){B(Me(r),"The new index must be a 1-dimensional array of strings!"),B(n.isEmpty||r.length===n.shape[0],"The new index must be the same length as the old index!"),B(fe(r).length===1,"The new index must be a 1-dimensional array of strings!"),r=r.map(o=>(typeof o!="string"&&(o=JSON.stringify(o)||o.toString()),o.trim().length===0?"untitled_"+nt(8):o.trim()));let s=(()=>{let o=Vi(r),i={};return o.forEach(u=>{i[u.item]=u.count}),i})();r=r.map(o=>s[o]>1?o+"_"+nt(8):o),n._index=r}}),B(Ri(e)||Mg(e)||Me(e),"The `data` passed into the constructor of a DataFrame must be either (1) an object where the key-value pairs are (respectively) column names and 1-dimensional arrays of values, or (2) a 2-dimensional array of values."),e)if(e instanceof D)n.values=ln(e.values),n.columns=ln(e.columns),n.index=ln(e.index);else if(Me(e)){let r=fe(e);B(r.length===2,"The `data` array passed into the constructor of a DataFrame must be 2-dimensional!"),n.values=e}else{n._columns=Object.keys(e);let r=[];n._columns.forEach(o=>{let i=e[o];r.push(i)}),n._values=Ui(r);let s=fe(n.values);n._index=hn(0,s[0]).map(o=>"row"+fn(o,(s[0]-1).toString().length))}}get shape(){return fe(this.values)}get length(){return this.shape[0]}get width(){return this.shape[1]}get rows(){return this.index}set rows(e){let n=this;n.index=e}get isEmpty(){return Ag(this.values).length===0}clear(){let e=this,n=new D(Ig(e.shape));return n.columns=e.columns.slice(),n.index=e.index.slice(),n}get(e,n){let r=this;if(arguments.length===0)return r;if(arguments.length===1)try{return r.get(null,e)}catch{return r.get(e,null)}return bg(r,e,n)}getSubsetByNames(e,n){return Ng(D,ee,this,e,n)}getSubsetByIndices(e,n){return wg(this,e,n)}getDummies(e){return Pi(D,this,e)}oneHotEncode(e){return Pi(D,this,e)}transpose(){let e=this,n=new D(Ui(e.values));return n.columns=e.index.slice(),n.index=e.columns.slice(),n}get T(){return this.transpose()}resetIndex(e){return Sg(this,e)}copy(){return hg(D,this)}assign(e,n){return fg(D,ee,this,e,n)}apply(e,n){return lg(D,ee,this,e,n)}dropMissing(e,n,r){return dg(D,ee,this,e,n,r)}dropNaN(e,n,r){return pg(D,this,e,n,r)}drop(e,n){return mg(D,ee,this,e,n)}dropColumns(e){return this.drop(null,e)}dropRows(e){return this.drop(e,null)}toObject(e){return Eg(this,e)}toCSVString(e){return Fg(this,e)}saveAsCSV(e,n){return Og(this,e,n)}toJSONString(e){return _g(this,e)}saveAsJSON(e,n){return Dg(this,e,n)}print(){return vg(D,ee,this)}sort(e,n){return Tg(this,e,n)}sortByIndex(){return this.sort()}filter(e,n){return gg(D,ee,this,e,n)}shuffle(e){return xg(this,e)}append(e,n){return cg(this,e,n)}concat(e,n){return this.append(e,n)}join(e,n){return this.append(e,n)}toString(){let e=this;return JSON.stringify(e)}};D.fromCSV=function(){return qg(D,...arguments)};D.fromCSVString=function(){return yg(D,...arguments)};var ee=zi()(D);Ji.exports={DataFrame:D,Series:ee}});var S=c((L2,Ki)=>{var{DataFrame:Yi,Series:$i}=Ie(),Li=m(),je=p(),mn=b(),Gi=U(),jg=M(),dn=y(),kg=se(),Cg=j(),rt=T();function zg(t){return je(t)||dn(t)||mn(t)}function Vg(t){return Li(jg(t),"You must pass a function into the `vectorize` function!"),function e(){let n,r,s=[],o=[],i=Object.keys(arguments).filter(u=>{let a=arguments[u];return je(a)?!0:dn(a)?(n=!0,s.push(a),!0):mn(a)?(r=!0,o.push(a),!0):!1}).map(u=>arguments[u]);if(i.slice(0,-1).forEach((u,a)=>{Li(Gi(je(u)?rt(u):u.shape,je(i[a+1])?rt(i[a+1]):i[a+1].shape),`When passing multiple arrays into the \`${t.name}\` function, all of the arrays must have the same shape!`)}),i.length>0){let u=kg(i.map(l=>l.length?l.length:l.values.length)),a=Cg(0,u).map(l=>{let f=Object.keys(arguments).map(h=>{if(zg(arguments[h])){if(je(arguments[h]))return arguments[h][l];if(dn(arguments[h]))return arguments[h].values[l];if(mn(arguments[h]))return arguments[h].values[l]}else return arguments[h]});return e(...f)});if(r)try{if(o.length===1&&Gi(rt(o[0]),rt(a))){let l=new Yi(a);return l.index=o[0].index.slice(),l.columns=o[0].columns.slice(),l}else return new Yi(a)}catch{return a}if(n)try{if(s.length===1&&s[0].length===a.length){let l=new $i(a);return l.name=s[0].name,l.index=s[0].index.slice(),l}else return new $i(a)}catch{return a}return a}else return t(...arguments)}}Ki.exports=Vg});var st=c((G2,Wi)=>{var Pg=q(),Rg=S();function Ug(t){try{return Pg(t)?Math.abs(t):NaN}catch{return NaN}}Wi.exports=Rg(Ug)});var ot=c((K2,Hi)=>{var Bg=q(),Jg=S();function Yg(){try{let t=0,e=Object.values(arguments);for(let n=0;n<e.length;n++){if(!Bg(e[n]))return NaN;t+=e[n]}return t}catch{return NaN}}Hi.exports=Jg(Yg)});var it=c((W2,Qi)=>{var $g=S();function Lg(t,e){try{return e(t)}catch{return NaN}}Qi.exports=$g(Lg)});var Zi=c((H2,Xi)=>{var Gg=q(),Kg=S();function Wg(t){try{return Gg(t)?Math.acos(t):NaN}catch{return NaN}}Xi.exports=Kg(Wg)});var tu=c((Q2,eu)=>{var Hg=q(),Qg=S();function Xg(t){try{return Hg(t)?Math.asin(t):NaN}catch{return NaN}}eu.exports=Qg(Xg)});var ru=c((X2,nu)=>{var Zg=q(),eq=S();function tq(t){try{return Zg(t)?Math.atan(t):NaN}catch{return NaN}}nu.exports=eq(tq)});var ou=c((Z2,su)=>{var nq=m(),rq=be(),sq=p(),oq=b(),iq=y(),uq=se();function pn(t){if(oq(t)){let e=pn(t.values);return[t.index[e[0]],t.columns[e[1]]]}if(iq(t)){let e=pn(t.values);return[t.index[e]]}nq(sq(t),"The `argmax` function only works on arrays, Series, and DataFrames!");try{let e=rq(t,uq(t));return e?e.length===0?void 0:e.length===1?e[0]:e:void 0}catch{return}}su.exports=pn});var ut=c((ex,uu)=>{var aq=m(),cq=F(),lq=p(),fq=b(),hq=y();function iu(t){if(fq(t)||hq(t))return iu(t.values);aq(lq(t),"The `min` function only works on arrays, Series, and DataFrames!");try{return Math.min(...cq(t))}catch{return NaN}}uu.exports=iu});var cu=c((tx,au)=>{var mq=m(),dq=be(),pq=p(),gq=b(),qq=y(),yq=ut();function gn(t){if(gq(t)){let e=gn(t.values);return[t.index[e[0]],t.columns[e[1]]]}if(qq(t)){let e=gn(t.values);return[t.index[e]]}mq(pq(t),"The `argmin` function only works on arrays, Series, and DataFrames!");try{let e=dq(t,yq(t));return e?e.length===0?void 0:e.length===1?e[0]:e:void 0}catch{return}}au.exports=gn});var fu=c((nx,lu)=>{var bq=q(),wq=S();function Nq(t){try{return bq(t)?Math.ceil(t):NaN}catch{return NaN}}lu.exports=wq(Nq)});var du=c((rx,mu)=>{var vq=st(),hu=q(),Sq=w(),xq=S();function Tq(t,e){try{if(!hu(t))return NaN;if(Sq(e))e=1e-10;else if(!hu(e))return NaN;return vq(t)<e?0:t}catch{return NaN}}mu.exports=xq(Tq)});var gu=c((sx,pu)=>{var qn=q(),Oq=S();function Fq(t,e,n){try{return qn(t)?qn(e)?qn(n)?t<e?e:t>n?n:t:NaN:NaN:NaN}catch{return NaN}}pu.exports=Oq(Fq)});var yu=c((ox,qu)=>{var yn=m(),Dq=F(),_q=p(),Eq=b(),Aq=q(),Mq=y();function bn(t,e){if(Eq(t)||Mq(t))return bn(t.values,e);if(yn(_q(t),"The `combinations` function only works on arrays, Series, and DataFrames!"),yn(Aq(e),"`r` must be a whole number!"),t=Dq(t),e>t.length)return[t];if(e<=0)return[[]];if(yn(e===parseInt(e),"`r` must be a whole number!"),t.length<2)return t;let n=[];return t.forEach((r,s)=>{let o=t.slice(s+1);if(o.length<e-1)return;bn(o,e-1).forEach(u=>{n.push([r].concat(u))})}),n}qu.exports=bn});var at=c((ix,wu)=>{var Iq=m(),jq=F(),kq=p(),Cq=b(),zq=y();function bu(t){if(Cq(t)||zq(t))return bu(t.values);Iq(kq(t),"The `mean` function only works on arrays, Series, and DataFrames!");try{let e=jq(t),n=0;return e.forEach(r=>{n+=r}),n/e.length}catch{return NaN}}wu.exports=bu});var Nn=c((ux,Ou)=>{var Nu=m(),vu=p(),ct=q(),Su=y(),xu=at(),Tu=T();function wn(t,e){if(Su(t))return wn(t.values,e);if(Su(e))return wn(t,e.values);Nu(vu(t)&&vu(e)&&Tu(t).length===1&&Tu(e).length===1,"The `covariance` function only works on 1-dimensional arrays and Series!"),Nu(t.length===e.length,"The two arrays or Series passed into the `covariance` function must have the same length!");try{let n=xu(t),r=xu(e);if(!ct(n)||!ct(r))return NaN;let s=Math.max(t.length,e.length),o=0;for(let i=0;i<s;i++){if(!ct(t[i]))return NaN;if(!ct(e[i]))return NaN;o+=(t[i]-n)*(e[i]-r)}return o/t.length}catch{return NaN}}Ou.exports=wn});var lt=c((ax,Fu)=>{var Vq=q(),Pq=S();function Rq(t){try{return Vq(t)?Math.sqrt(t):NaN}catch{return NaN}}Fu.exports=Pq(Rq)});var vn=c((cx,_u)=>{var Uq=m(),Bq=F(),Jq=p(),Yq=b(),$q=q(),Lq=y(),Gq=at();function Du(t){if(Yq(t)||Lq(t))return Du(t.values);Uq(Jq(t),"The `variance` function only works on arrays, Series, and DataFrames!");try{let e=Bq(t),n=Gq(e),r=0;for(let s=0;s<e.length;s++){if(!$q(e[s]))return NaN;r+=(e[s]-n)*(e[s]-n)}return r/e.length}catch{return NaN}}_u.exports=Du});var ft=c((lx,Au)=>{var Kq=m(),Wq=p(),Hq=b(),Qq=y(),Xq=lt(),Zq=vn();function Eu(t){if(Hq(t)||Qq(t))return Eu(t.values);Kq(Wq(t),"The `std` function only works on arrays, Series, and DataFrames!");try{return Xq(Zq(t))}catch{return NaN}}Au.exports=Eu});var Vu=c((fx,zu)=>{var Mu=m(),ey=Nn(),Iu=p(),ju=y(),ku=T(),Cu=ft();function Sn(t,e){if(ju(t))return Sn(t.values,e);if(ju(e))return Sn(t,e.values);Mu(Iu(t)&&Iu(e)&&ku(t).length===1&&ku(e).length===1,"The `correl` function only works on 1-dimensional arrays and Series!"),Mu(t.length===e.length,"The two arrays or Series passed into the `correl` function must have the same length!");try{return ey(t,e)/(Cu(t)*Cu(e))}catch{return NaN}}zu.exports=Sn});var Ru=c((hx,Pu)=>{var ty=q(),ny=S();function ry(t){try{return ty(t)?Math.cos(t):NaN}catch{return NaN}}Pu.exports=ny(ry)});var Lu=c((mx,$u)=>{var sy=m(),Uu=p(),Bu=b(),oy=U(),Ju=y(),Yu=V();function xn(t,e){if(Bu(t)||Ju(t))return xn(t.values,e);if(Bu(e)||Ju(e))return xn(t,e.values);sy(Uu(t)&&Uu(e),"The `diff` function only works on arrays, Series, and DataFrames!");let n=Yu(t),r=Yu(e),s=[];return n.forEach(o=>{r.findIndex(i=>oy(i,o))<0&&s.push(o)}),s}$u.exports=xn});var ht=c((dx,Ku)=>{var Gu=q(),iy=S();function uy(t,e){try{return Gu(t)?Gu(e)?Math.pow(t,e):NaN:NaN}catch{return NaN}}Ku.exports=iy(uy)});var Tn=c((px,Wu)=>{var ay=q(),cy=S();function ly(){try{let t=Object.values(arguments);if(t.length===0)return NaN;let e=1;for(let n=0;n<t.length;n++){if(!ay(t[n]))return NaN;e*=t[n]}return e}catch{return NaN}}Wu.exports=cy(ly)});var he=c((gx,Hu)=>{var fy=Tn();function hy(){return fy(...arguments)}Hu.exports=hy});var On=c((qx,Qu)=>{var my=ot(),dy=he();function py(t,e){return my(t,dy(e,-1))}Qu.exports=py});var mt=c((yx,Zu)=>{var gy=m(),qy=F(),yy=p(),by=b(),wy=y();function Xu(t){if(by(t)||wy(t))return Xu(t.values);gy(yy(t),"The `sum` function only works on arrays, Series, and DataFrames!");try{return t.length===0?NaN:qy(t).reduce((e,n)=>e+n,0)}catch{return NaN}}Zu.exports=Xu});var ia=c((bx,oa)=>{var Ny=st(),vy=m(),ea=p(),ta=b(),Sy=U(),na=q(),ra=y(),xy=ht(),sa=T(),Ty=lt(),Oy=On(),Fy=mt();function Fn(t,e){if(na(t)&&na(e))return Ny(t-e);if(ta(t)||ra(t))return Fn(t.values,e);if(ta(e)||ra(e))return Fn(t,e.values);ea(t)&&ea(e)&&vy(Sy(sa(t),sa(e)),"If passing two arrays, Series, or DataFrames into the `distance` function, then those objects must have the same shape!");try{return Ty(Fy(xy(Oy(t,e),2)))}catch{return NaN}}oa.exports=Fn});var aa=c((wx,ua)=>{var Dy=ht(),_y=he();function Ey(t,e){return _y(t,Dy(e,-1))}ua.exports=Ey});var _n=c((Nx,da)=>{var{DataFrame:ca,Series:la}=Ie(),dt=m(),fa=F(),ha=p(),Dn=b(),Ay=q(),pt=y(),My=he(),gt=T(),Iy=mt(),ma=oe();function te(t,e){if(Dn(t)){let s=te(t.values,e);if(gt(s).length===1){let o=new la(s);return o.name=pt(e)?e.name:o.name,o.index=t.index.slice(),o}else{let o=new ca(s);return o.index=t.index.slice(),Dn(e)&&(o.columns=e.columns.slice()),o}}if(Dn(e)){let s=te(t,e.values);if(gt(s).length===1){let o=new la(s);return o.name=pt(t)?t.name:o.name,o.index=e.columns.slice(),o}else{let o=new ca(s);return o.columns=e.columns.slice(),o}}if(pt(t))return te(t.values,e);if(pt(e))return te(t,e.values);dt(ha(t)&&ha(e),"The `dot` function only works on arrays, Series, and DataFrames!"),fa(t).concat(fa(e)).forEach(s=>{dt(Ay(s),"One of the arrays you passed into the `dot` function contains non-numerical values!")});let n=gt(t),r=gt(e);if(dt(n.length<=2&&r.length<=2,"I'm not smart enough to know how to get the dot-product of arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `dot` function!"),dt(n[n.length-1]===r[0],`There's a dimension misalignment in the two arrays you passed into the \`dot\` function. (${n[n.length-1]} !== ${r[0]})`),n.length===1&&r.length===1)return Iy(My(t,e));if(n.length===1&&r.length===2)return ma(e).map(s=>te(t,s));if(n.length===2&&r.length===1)return t.map(s=>te(s,e));if(n.length===2&&r.length===2){let s=ma(e),o=[];for(let i=0;i<t.length;i++){let u=[];for(let a=0;a<s.length;a++)u.push(te(t[i],s[a]));o.push(u)}return o}}da.exports=te});var En=c((vx,ga)=>{var jy=m(),ky=p(),Cy=b(),zy=y(),Vy=w();function pa(t){if(Cy(t)||zy(t))return t.dropMissing(...Object.values(arguments).slice(1));jy(ky(t),"The `dropMissing` function only works on arrays, Series, and DataFrames!");let e=[];return t.forEach(n=>{try{return e.push(pa(n))}catch{Vy(n)||e.push(n)}}),e}ga.exports=pa});var xa=c((Sx,Sa)=>{var qa=m(),ya=p(),ba=b(),Py=U(),wa=y(),Na=w(),va=T();function qt(t,e){if(ba(t)||wa(t))return qt(t.values,e);if(ba(e)||wa(e))return qt(t,e.values);qa(ya(t)&&ya(e),"The `dropMissingPairwise` function only works on arrays, Series, and DataFrames!"),qa(Py(va(t),va(e)),"The two arrays, Series, and/or DataFrames passed into the `dropMissingPairwise` function must have the same shape!");let n=[],r=[];for(let s=0;s<t.length;s++)try{let[o,i]=qt(t[s],e[s]);n.push(o),r.push(i)}catch{!Na(t[s])&&!Na(e[s])&&(n.push(t[s]),r.push(e[s]))}return[n,r]}Sa.exports=qt});var Ma=c((xx,Aa)=>{var Ta=m(),Oa=p(),Fa=b(),Ry=U(),Da=q(),_a=y(),Ea=T();function yt(t,e){if(Fa(t)||_a(t))return yt(t.values,e);if(Fa(e)||_a(e))return yt(t,e.values);Ta(Oa(t)&&Oa(e),"The `dropNaNPairwise` only works on arrays, Series, and DataFrames!"),Ta(Ry(Ea(t),Ea(e)),"The two arrays, Series, and/or DataFrames passed into the `dropNaNPairwise` must have the same shape!");let n=[],r=[];for(let s=0;s<t.length;s++)try{let[o,i]=yt(t[s],e[s]);n.push(o),r.push(i)}catch{Da(t[s])&&Da(e[s])&&(n.push(t[s]),r.push(e[s]))}return[n,r]}Aa.exports=yt});var ja=c((Tx,Ia)=>{var Uy=En();function By(t){return Uy(t)}Ia.exports=By});var Ca=c((Ox,ka)=>{var Jy=q(),Yy=S();function $y(t){try{return Jy(t)?Math.exp(t):NaN}catch{return NaN}}ka.exports=Yy($y)});var Pa=c((Fx,Va)=>{var Ly=S();function za(t){try{return t!==parseInt(t)?NaN:t<=1?1:t*za(t-1)}catch{return NaN}}Va.exports=Ly(za)});var Ja=c((Dx,Ba)=>{var Gy=m(),Ky=F(),Ra=p(),Wy=b(),Hy=M(),Ua=L(),Qy=y();function An(t,e){if(Wy(t))return An(Ky(t.values),e);if(Qy(t))return An(t.values,e);if(Gy(Ua(t)||Ra(t),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `find` function!"),!Hy(e)){let s=e;e=o=>o===s}function n(s,o,i){if(i=i||[],i.indexOf(s)>-1)return null;if(Ua(s)){i.push(s);let u=Object.keys(s);for(let a=0;a<u.length;a++){let l=u[a],f=s[l];if(o(f))return f;let h=n(f,o,i);if(h)return h}}else if(Ra(s)){i.push(s);for(let u=0;u<s.length;u++){let a=s[u];if(o(a))return a;let l=n(a,o,i);if(l)return l}}else if(o(s))return s;return null}function r(s){try{return e(s)}catch{return!1}}return n(t,r)}Ba.exports=An});var Ga=c((_x,La)=>{var Xy=m(),Zy=F(),Ya=p(),e1=b(),t1=M(),$a=L(),n1=y();function Mn(t,e){if(e1(t))return Mn(Zy(t.values),e);if(n1(t))return Mn(t.values,e);if(Xy($a(t)||Ya(t),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `findAll` function!"),!t1(e)){let o=e;e=i=>i===o}function n(o,i,u){if(u=u||[],u.indexOf(o)>-1)return null;if($a(o)){u.push(o);let a=Object.keys(o),l=[];for(let f=0;f<a.length;f++){let h=a[f],d=o[h],g=!1;i(d)&&(l.push(d),g=!0);let N=n(d,i,u);N&&N.length>0&&N.slice(g?1:0).forEach(v=>l.push(v))}return l}else if(Ya(o)){u.push(o);let a=[];for(let l=0;l<o.length;l++){let f=o[l],h=!1;i(f)&&(a.push(f),h=!0);let d=n(f,i,u);d&&d.length>0&&d.slice(h?1:0).forEach(g=>a.push(g))}return a}else if(i(o))return[o];return null}function r(o){try{return e(o)}catch{return!1}}let s=n(t,r);return s&&s.length>0?s:null}La.exports=Mn});var Wa=c((Ex,Ka)=>{var r1=q(),s1=S();function o1(t){try{if(t==="Infinity")return 1/0;if(t==="-Infinity")return-1/0;let e=JSON.parse(t);return r1(e)?e:NaN}catch{return NaN}}Ka.exports=s1(o1)});var Qa=c((Ax,Ha)=>{var i1=q(),u1=S();function a1(t){try{return i1(t)?Math.floor(t):NaN}catch{return NaN}}Ha.exports=u1(a1)});var In=c((Mx,Xa)=>{var c1=q(),l1=Fe(),f1=Qe();function h1(t){c1(t)&&(t=[t]);let e=[],n=l1(t);for(let r=0;r<n;r++)e.push(0);return f1(e,t)}Xa.exports=h1});var ec=c((Ix,Za)=>{var bt=m(),m1=q(),d1=w(),p1=In();function g1(t){bt(!d1(t),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),bt(m1(t),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),bt(parseInt(t)===t,"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),bt(t>0,"You must pass an integer greater than 0 (representing the size) into the `identity` function!");let e=p1([t,t]);for(let n=0;n<t;n++)e[n][n]=1;return e}Za.exports=g1});var nc=c((jx,tc)=>{var q1=q(),y1=S();function b1(t){try{let e=JSON.parse(t);return q1(e)?parseInt(e):NaN}catch{return NaN}}tc.exports=y1(b1)});var sc=c((kx,rc)=>{var w1=m(),N1=p(),v1=b(),S1=U(),x1=y(),jn=V();function T1(){let t=Object.values(arguments).map(n=>v1(n)||x1(n)?jn(n.values):(w1(N1(n),"The `intersect` function only works on arrays, Series, and DataFrames!"),jn(n)));return jn(t).filter(n=>t.every(r=>r.findIndex(s=>S1(s,n))>-1))}rc.exports=T1});var ac=c((Cx,uc)=>{var oc=ot(),ne=m(),O1=_n(),F1=F(),D1=p(),_1=b(),kn=q(),ic=he(),E1=T();function wt(t){if(_1(t)){let n=t.copy();return n.values=wt(n.values),n}ne(D1(t),"The `inverse` function only works on square 2-dimensional arrays or DataFrames!"),F1(t).forEach(n=>ne(kn(n),"The array passed into the `inverse` function must contain only numbers!"));let e=E1(t);if(ne(e.length===2,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),ne(e[0]===e[1],"The array passed into the `inverse` function must be exactly two-dimensional and square!"),ne(e[0]>=0,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),e[0]===0)return t;if(e[0]===1)return ne(t[0][0]!==0,"This matrix cannot be inverted!"),1/t[0][0];if(e[0]===2){let n=t[0][0],r=t[0][1],s=t[1][0],o=t[1][1],i=n*o-r*s;ne(i!==0,"This matrix cannot be inverted!");let u=[[o,-r],[-s,n]];return ic(u,1/i)}else if(e[0]>1){let n=(r,s)=>kn(r)||kn(s)?ic(r,s):O1(r,s);for(let r=1;r<e[0]-1;r++)try{let s=t.slice(0,r).map(v=>v.slice(0,r)),o=t.slice(0,r).map(v=>v.slice(r,e[0])),i=t.slice(r,e[0]).map(v=>v.slice(0,r)),u=t.slice(r,e[0]).map(v=>v.slice(r,e[0])),a=wt(s),l=wt(oc(u,n(-1,n(n(i,a),o)))),f=oc(a,n(n(n(n(a,o),l),i),a)),h=n(-1,n(n(a,o),l)),d=n(-1,n(n(l,i),a)),g=l;return f.map((v,_)=>v.concat(h[_])).concat(d.map((v,_)=>v.concat(g[_])))}catch{}ne(!1,"This matrix cannot be inverted!")}}uc.exports=wt});var lc=c((zx,cc)=>{var Cn=q(),A1=S();function M1(t,e,n){try{return Cn(t)?Cn(e)?Cn(n)?n*(e-t)+t:NaN:NaN:NaN}catch{return NaN}}cc.exports=A1(M1)});var mc=c((Vx,hc)=>{var fc=q(),I1=w(),j1=S();function k1(t,e){try{return e=I1(e)?Math.E:e,fc(t)?fc(e)?Math.log(t)/Math.log(e):NaN:NaN}catch{return NaN}}hc.exports=j1(k1)});var gc=c((Px,pc)=>{var C1=m(),z1=F(),V1=p(),P1=b(),R1=y(),U1=H();function dc(t){if(P1(t)||R1(t))return dc(t.values);C1(V1(t),"The `median` function only works on arrays, Series, and DataFrames!");try{let e=U1(z1(t));return e.length===0?NaN:e.length%2===0?(e[e.length/2-1]+e[e.length/2])/2:e[parseInt(e.length/2)]}catch{return NaN}}pc.exports=dc});var bc=c((Rx,yc)=>{var qc=q(),B1=S();function J1(t,e){try{return qc(t)?qc(e)?t%e:NaN:NaN}catch{return NaN}}yc.exports=B1(J1)});var Sc=c((Ux,vc)=>{var Y1=m(),$1=Pe(),L1=F(),G1=p(),K1=b(),W1=y(),H1=V(),wc=H();function Nc(t){if(K1(t)||W1(t))return Nc(t.values);Y1(G1(t),"The `mode` function only works on arrays, Series, and DataFrames!");try{if(t.length===0)return NaN;let e=L1(t);if(e.length===0)return NaN;let n={},r=H1(e);r.forEach(u=>{n[u]=$1(e,u)});let s=wc(r,(u,a)=>n[a]-n[u]),o=s[0];return wc(s.filter(u=>n[u]===n[o]))}catch{return NaN}}vc.exports=Nc});var Fc=c((Bx,Oc)=>{var{random:xc}=ce(),Q1=it(),X1=w(),Z1=G();function Tc(){let t=xc(),e=xc();return Math.sqrt(-2*Math.log(t))*Math.cos(2*Math.PI*e)}function eb(t){return X1(t)?Tc():Q1(Z1(t),Tc)}Oc.exports=eb});var _c=c((Jx,Dc)=>{var tb=it(),nb=G();function rb(t){return tb(nb(t),()=>1)}Dc.exports=rb});var Ac=c((Yx,Ec)=>{var zn=m(),sb=F(),ob=p(),ib=b(),ub=q(),ab=y(),cb=w();function Nt(t,e){if(ib(t)||ab(t))return Nt(t.values,e);if(zn(ob(t),"The `permutations` function only works on arrays, Series, and DataFrames!"),cb(e)&&(e=t.length),zn(ub(e),"`r` must be a whole number!"),t=sb(t),e>t.length)return Nt(t);if(e<=0)return[[]];if(zn(e===parseInt(e),"`r` must be a whole number!"),t.length<2)return t;let n=[];return t.forEach((r,s)=>{let o=t.slice(0,s),i=t.slice(s+1),u=o.concat(i);Nt(u,e-1).forEach(l=>{n.push([r].concat(l))})}),n}Ec.exports=Nt});var Ic=c(($x,Mc)=>{var{DataFrame:lb,Series:fb}=Ie(),hb=p(),mb=b(),db=Ne(),pb=y(),gb=T();function qb(){Object.keys(arguments).forEach(t=>{let e=arguments[t];if(hb(e))if(db(e))console.log(e);else{let n=gb(e);n.length===1?new fb(e).print():n.length==2?new lb(e).print():console.log(e)}else mb(e)||pb(e)?e.print():console.log(e)})}Mc.exports=qb});var Cc=c((Lx,kc)=>{var yb=p(),bb=q(),jc=w(),wb=se(),Nb=ut(),vb=S(),Sb=vb(function(t,e,n,r,s){try{return[t,e,n,r,s].every(o=>bb(o))?n-e===0?NaN:(s-r)*(t-e)/(n-e)+r:NaN}catch{return NaN}});function xb(t,e,n,r,s){return yb(t)&&jc(r)&&jc(s)&&(r=e,s=n,e=Nb(t),n=wb(t)),Sb(t,e,n,r,s)}kc.exports=xb});var Vc=c((Gx,zc)=>{var Tb=q(),Ob=S();function Fb(t){try{return Tb(t)?Math.round(t):NaN}catch{return NaN}}zc.exports=Ob(Fb)});var Rc=c((Kx,Pc)=>{var Db=q(),_b=S();function Eb(t){try{return Db(t)?t<0?-1:t>0?1:0:NaN}catch{return NaN}}Pc.exports=_b(Eb)});var Bc=c((Wx,Uc)=>{var Ab=q(),Mb=S();function Ib(t){try{return Ab(t)?Math.sin(t):NaN}catch{return NaN}}Uc.exports=Mb(Ib)});var Yc=c((Hx,Jc)=>{var jb=ft();function kb(t){return jb(t)}Jc.exports=kb});var Lc=c((Qx,$c)=>{var Cb=q(),zb=S();function Vb(t){try{return Cb(t)?Math.tan(t):NaN}catch{return NaN}}$c.exports=zb(Vb)});var vt=c((Xx,Wc)=>{var Gc=m(),Kc=M();function Pb(t,e){Gc(Kc(t),"`fn` must be a function!");let n=new Date;return e?t(...e):t(),new Date-n}async function Rb(t,e){Gc(Kc(t),"`fn` must be a function!");let n=new Date;return e?await t(...e):await t(),new Date-n}Wc.exports={timeSync:Pb,timeAsync:Rb}});var Qc=c((Zx,Hc)=>{var Ub=p(),Bb=b(),Jb=y(),Yb=V();function $b(){return Yb([...arguments].map(t=>Ub(t)?t:Bb(t)||Jb(t)?t.values:[t]))}Hc.exports=$b});var Zc=c((eT,Xc)=>{var Lb=m(),Gb=p(),Kb=b(),Wb=y(),Hb=w(),Qb=se(),Xb=j();function Zb(){let t=[],e=Object.values(arguments).map(n=>((Kb(n)||Wb(n))&&(n=n.values),Lb(Gb(n),"The `zip` function only works on arrays, Series, and DataFrames!"),n));return Xb(0,Qb(e.map(n=>n.length))).forEach(n=>{let r=[];e.forEach(s=>{let o=s[n];r.push(Hb(o)?void 0:o)}),t.push(r)}),t}Xc.exports=Zb});var x=c((tT,Vn)=>{var{DataFrame:ew,Series:tw}=Ie(),me={abs:st(),add:ot(),apply:it(),arccos:Zi(),arcsin:tu(),arctan:ru(),argmax:ou(),argmin:cu(),assert:m(),ceil:fu(),chop:du(),clamp:gu(),combinations:yu(),copy:R(),correl:Vu(),cos:Ru(),count:Pe(),covariance:Nn(),DataFrame:ew,diff:Lu(),distance:ia(),divide:aa(),dot:_n(),dropMissing:En(),dropMissingPairwise:xa(),dropNaN:Kt(),dropNaNPairwise:Ma(),dropUndefined:ja(),exp:Ca(),factorial:Pa(),find:Ja(),findAll:Ga(),flatten:F(),float:Wa(),floor:Qa(),identity:ec(),indexOf:be(),int:nc(),intersect:sc(),inverse:ac(),isArray:p(),isBoolean:Te(),isDataFrame:b(),isEqual:U(),isFunction:M(),isJagged:Ne(),isNested:Re(),isNumber:q(),isObject:L(),isSeries:y(),isString:E(),isUndefined:w(),lerp:lc(),log:mc(),MathError:P(),max:se(),mean:at(),median:gc(),min:ut(),mod:bc(),mode:Sc(),multiply:Tn(),ndarray:G(),normal:Fc(),ones:_c(),permutations:Ac(),pow:ht(),print:Ic(),product:Fe(),random:ce().random,range:j(),remap:Cc(),reshape:Qe(),reverse:ve(),round:Vc(),scale:he(),seed:ce().seed,Series:tw,set:V(),shape:T(),shuffle:Xe(),sign:Rc(),sin:Bc(),sort:H(),sqrt:lt(),std:ft(),stdev:Yc(),subtract:On(),sum:mt(),tan:Lc(),time:vt().timeSync,timeSync:vt().timeSync,timeAsync:vt().timeAsync,transpose:oe(),union:Qc(),variance:vn(),vectorize:S(),zeros:In(),zip:Zc(),dump:function(){let t=typeof global<"u"?global:window;if(!t)throw new me.MathError("Cannot dump functions into global scope because neither `global` nor `window` exist in the current context!");Object.keys(me).forEach(e=>{try{Object.defineProperty(t,e,{configurable:!1,enumerable:!0,writable:!1,value:me[e]})}catch{t[e]=me[e]}})}};typeof Vn<"u"&&(Vn.exports=me);typeof window<"u"&&(window.JSMathTools=me)});var J=c((nT,el)=>{el.exports={shouldIgnoreNaNValues:!0}});var de=c((rT,nl)=>{var{assert:nw,flatten:rw,isArray:sw,isDataFrame:ow,isNumber:iw,isSeries:uw}=x();function tl(t){if(ow(t)||uw(t))return tl(t.values);nw(sw(t),"The `containsOnlyNumbers` function only works on arrays, Series, and DataFrames!");let e=rw(t);for(let n=0;n<e.length;n++)if(!iw(e[n]))return!1;return!0}nl.exports=tl});var Rn=c((sT,rl)=>{var{dropMissing:aw,flatten:cw,isArray:lw,isDataFrame:fw,isSeries:hw}=x();function Pn(t){return typeof t=="number"?t===0||t===1:fw(t)||hw(t)?Pn(t.values):lw(t)?t.length===0?!1:aw(cw(t)).every(n=>Pn(n)):!1}rl.exports=Pn});var Un=c((oT,hl)=>{var{abs:sl,apply:ol,assert:il,clamp:mw,copy:dw,divide:pw,dropNaN:gw,flatten:qw,isArray:yw,isDataFrame:bw,isNumber:ul,isSeries:ww,max:al,median:cl,min:Nw,sort:vw,subtract:ll}=x(),Sw=J(),xw=de(),Tw=Rn();function fl(t,e){if(bw(t)||ww(t)){let a=t.copy();return a._values=fl(a._values,e),a}if(il(yw(t),"The `clipOutliers` function only works on arrays, Series, and DataFrames!"),e=e||5,il(ul(e),"Any `maxScore` value passed into the `clipOutliers` function must be a number!"),!Sw.shouldIgnoreNaNValues&&!xw(t))return ol(t,()=>NaN);let n=qw(t),r=gw(n);if(Tw(r)||r.length===0)return t;let s=cl(r),o=cl(sl(ll(r,s))),i=!1;if(o===0){let a=vw(dw(r)),l=a.filter(g=>g<s),f=a.filter(g=>g>s),h=s,d=s;if(l.length>0&&(h=al(l)),f.length>0&&(d=Nw(f)),o=(d-h)/2,o===0)return t;i=(s-h)/o>e||(d-s)/o>e}return al(pw(sl(ll(r,s)),o))>e||i?ol(t,a=>ul(a)?mw(a,s-e*o,s+e*o):a):t}hl.exports=fl});var Jn=c((iT,wl)=>{var{assert:ml,dropNaN:dl,isArray:pl,isSeries:gl,mean:ql,shape:yl,variance:bl}=x(),Ow=J();function Bn(t,e){if(gl(t))return Bn(t.values,e);if(gl(e))return Bn(t,e.values);ml(pl(t)&&pl(e)&&yl(t).length===1&&yl(e).length===1,"The `cohensd` function only works on 1-dimensional arrays and Series!"),ml(t.length===e.length,"Two arrays or Series passed into the `cohensd` function must have the same length!"),Ow.shouldIgnoreNaNValues&&(t=dl(t),e=dl(e));try{let n=ql(t),r=ql(e),s=Math.sqrt((bl(t)+bl(e))/2);return(n-r)/s}catch{return NaN}}wl.exports=Bn});var xl=c((uT,Sl)=>{var{assert:Nl,DataFrame:Fw,isArray:Dw,isSeries:_w,shape:Ew,zeros:Aw}=x();function vl(t){if(_w(t)){let r=new Fw(vl(t.values));return r.index=t.index.slice(),r.columns=t.index.slice(),r}Nl(Dw(t),"The `diagonalize` function only works on 1-dimensional arrays and Series!");let e=Ew(t);Nl(e.length===1,"The `diagonalize` function only works on 1-dimensional arrays and Series!");let n=Aw([e[0],e[0]]);return t.forEach((r,s)=>n[s][s]=r),n}Sl.exports=vl});var Gn=c((aT,Dl)=>{var{assert:Yn,clamp:Mw,correl:Tl,DataFrame:St,dropNaNPairwise:Iw,isArray:Ol,isDataFrame:xt,isJagged:Fl,isUndefined:jw,ndarray:kw}=x(),Cw=J();function $n(t){let e="@jrc03c/js-data-science-helpers/get-correlation-matrix";return Object.defineProperty(t,e,{configurable:!1,enumerable:!1,writable:!1,value:Symbol.for(e)}),t}function Ln(t,e){if(jw(e)&&(e=t),xt(t)){let r=new St(Ln(t.values,e));return r.index=t.columns.slice(),r.columns=xt(e)?e.columns.slice():new St(e).columns.slice(),$n(r)}if(xt(e)){let r=new St(Ln(t,e.values));return r.index=xt(t)?t.columns.slice():new St(t).columns.slice(),r.columns=e.columns.slice(),$n(r)}Yn(Ol(t)&&Ol(e),"The `getCorrelationMatrix` function only works on 2-dimensional arrays and DataFrames!"),Yn(!Fl(t)&&!Fl(e),"The `getCorrelationMatrix` function only works on non-jagged 2-dimensional arrays and DataFrames!"),Yn(t.length===e.length,'The dimensions of the matrices you passed into the `getCorrelationMatrix` function aren\'t compatible! ([shape(a).join(", ")] vs. [shape(b).join(", ")]) The function expects that you\'ll be comparing the columns of two matrices where the columns are all of the same length, so please make sure that the matrices are oriented accordingly.');let n=kw([t[0].length,e[0].length]);for(let r=0;r<t[0].length;r++){let s=t.map(o=>o[r]);for(let o=0;o<e[0].length;o++){let i=e.map(u=>u[o]);Cw.shouldIgnoreNaNValues?n[r][o]=Tl(...Iw(s,i)):n[r][o]=Tl(s,i)}}return $n(Mw(n,-1,1))}Dl.exports=Ln});var Kn=c((cT,_l)=>{function zw(t){try{let e="@jrc03c/js-data-science-helpers/get-correlation-matrix";return t[e]===Symbol.for(e)}catch{return!1}}_l.exports=zw});var Il=c((lT,Ml)=>{var{DataFrame:Wn,isArray:Vw,isDataFrame:Tt,isNumber:El,MathError:Pw,sort:Rw}=x(),Al=Gn(),Uw=Kn();function Bw(t,e,n){n=Object.values(arguments).find(o=>El(o))||1-1e-5;let r=(()=>{let o=Object.values(arguments).filter(i=>Vw(i)||Tt(i));if(o.length===1){let i=o[0];if(Uw(i))return Tt(i)?i:new Wn(i);{let u=Al(i,null);return Tt(u)?u:new Wn(u)}}if(o.length===2){let i=Al(o[0],o[1]);return Tt(i)?i:new Wn(i)}throw new Pw("You must pass 1 or 2 2-dimensional arrays or DataFrames into the `getHighlyCorrelatedColumns` function!")})(),s={};return r.values.forEach((o,i)=>{o.forEach((u,a)=>{if(El(u)&&u>n){let l=r.index[i],f=r.columns[a];s[l]||(s[l]=[]),s[l].indexOf(f)<0&&s[l].push(f),s[f]||(s[f]=[]),s[f].indexOf(l)<0&&s[f].push(l)}})}),Object.keys(s).forEach(o=>{s[o]=Rw(s[o])}),s}Ml.exports=Bw});var Hn=c((fT,kl)=>{var{dropNaN:Jw,isArray:Yw,isDataFrame:$w,isNumber:Lw,isSeries:Gw,pow:Kw,sqrt:Ww,sum:Hw}=x(),Qw=J();function jl(t){return $w(t)||Gw(t)?jl(t.values):Lw(t)?Math.abs(t):Yw(t)?(Qw.shouldIgnoreNaNValues&&(t=Jw(t)),Ww(Hw(Kw(t,2)))):NaN}kl.exports=jl});var Qn=c((hT,Vl)=>{var{assert:Cl,DataFrame:Xw,isArray:Zw,isSeries:eN,isString:tN,isUndefined:nN,set:rN,shape:sN,sort:oN}=x();function zl(){if(arguments.length===1&&eN(arguments[0])){let{name:o,values:i}=arguments[0],u=zl(o,i),a=new Xw(u);return a.index=arguments[0].index.slice(),a}let[t,e]=arguments;Cl(tN(t),"When passing two arguments into the `getOneHotEncodings` function, the first argument must be a string representing the name of the variable being encoded!"),Cl(Zw(e)&&sN(e).length===1,"When passing two arguments into the `getOneHotEncodings` function, the second argument must be a 1-dimensional array!");let n={},r=t+"_"+e[0];return oN(rN(e)).filter(o=>!nN(o)).map(o=>t+"_"+o).filter(o=>o!==r).forEach(o=>{n[o]=e.map(i=>o===t+"_"+i?1:0)}),n}Vl.exports=zl});var Rl=c((mT,Pl)=>{var{count:iN}=x();function uN(t){return iN(t).map(n=>(n.percentage=n.count/t.length,n))}Pl.exports=uN});var Ul=c((dT,aN)=>{aN.exports=[.5,.49601,.49202,.48803,.48405,.48006,.47608,.4721,.46812,.46414,.46017,.4562,.45224,.44828,.44433,.44038,.4364,.43251,.42858,.42465,.42074,.41683,.41294,.40905,.40517,.40129,.39743,.39358,.38974,.38591,.38209,.37828,.37448,.3707,.36693,.36317,.35942,.35569,.35197,.34827,.34458,.3409,.33724,.3336,.32997,.32636,.32276,.31918,.31561,.31207,.30854,.30503,.30153,.29806,.2946,.29116,.28774,.28434,.28096,.2776,.27425,.27093,.26763,.26435,.26109,.25785,.25463,.25143,.24825,.2451,.24196,.23885,.23576,.2327,.22965,.22663,.22363,.22065,.2177,.21476,.21186,.20897,.20611,.20327,.20045,.19766,.19489,.19215,.18943,.18673,.18406,.18141,.17879,.17619,.17361,.17106,.16853,.16602,.16354,.16109,.15866,.15625,.15386,.15151,.14917,.14686,.14457,.14231,.14007,.13786,.13567,.1335,.13136,.12924,.12714,.12507,.12302,.121,.119,.11702,.11507,.11314,.11123,.10935,.10749,.10565,.10383,.10204,.10027,.09853,.0968,.0951,.09342,.09176,.09012,.08851,.08692,.08534,.08379,.08226,.08076,.07927,.0778,.07636,.07493,.07353,.07215,.07078,.06944,.06811,.06681,.06552,.06426,.06301,.06178,.06057,.05938,.05821,.05705,.05592,.0548,.0537,.05262,.05155,.0505,.04947,.04846,.04746,.04648,.04551,.04457,.04363,.04272,.04182,.04093,.04006,.0392,.03836,.03754,.03673,.03593,.03515,.03438,.03362,.03288,.03216,.03144,.03074,.03005,.02938,.02872,.02807,.02743,.0268,.02619,.02559,.025,.02442,.02385,.0233,.02275,.02222,.02169,.02118,.02068,.02018,.0197,.01923,.01876,.01831,.01786,.01743,.017,.01659,.01618,.01578,.01539,.015,.01463,.01426,.0139,.01355,.01321,.01287,.01255,.01222,.01191,.0116,.0113,.01101,.01072,.01044,.01017,.0099,.00964,.00939,.00914,.00889,.00866,.00842,.0082,.00798,.00776,.00755,.00734,.00714,.00695,.00676,.00657,.00639,.00621,.00604,.00587,.0057,.00554,.00539,.00523,.00508,.00494,.0048,.00466,.00453,.0044,.00427,.00415,.00402,.00391,.00379,.00368,.00357,.00347,.00336,.00326,.00317,.00307,.00298,.00289,.0028,.00272,.00264,.00256,.00248,.0024,.00233,.00226,.00219,.00212,.00205,.00199,.00193,.00187,.00181,.00175,.00169,.00164,.00159,.00154,.00149,.00144,.00139,.00135,.00131,.00126,.00122,.00118,.00114,.00111,.00107,.00104,.001,97e-5,94e-5,9e-4,87e-5,84e-5,82e-5,79e-5,76e-5,74e-5,71e-5,69e-5,66e-5,64e-5,62e-5,6e-4,58e-5,56e-5,54e-5,52e-5,5e-4,48e-5,47e-5,45e-5,43e-5,42e-5,4e-4,39e-5,38e-5,36e-5,35e-5,34e-5,32e-5,31e-5,3e-4,29e-5,28e-5,27e-5,26e-5,25e-5,24e-5,23e-5,22e-5,22e-5,21e-5,2e-4,19e-5,19e-5,18e-5,17e-5,17e-5,16e-5,15e-5,15e-5,14e-5,14e-5,13e-5,13e-5,12e-5,12e-5,11e-5,11e-5,1e-4,1e-4,1e-4,9e-5,9e-5,8e-5,8e-5,8e-5,8e-5,7e-5,7e-5,7e-5,6e-5,6e-5,6e-5,6e-5,5e-5,5e-5,5e-5,5e-5,5e-5,4e-5,4e-5,4e-5,4e-5,4e-5,4e-5,3e-5,3e-5,3e-5,3e-5,3e-5,3e-5,3e-5,3e-5,2e-5,2e-5,2e-5,2e-5]});var Zn=c((pT,Hl)=>{var{abs:Bl,assert:cN,dropNaNPairwise:lN,flatten:Ot,isArray:Jl,isDataFrame:Yl,isEqual:fN,isSeries:$l,mean:Ll,remap:hN,round:mN,shape:Gl,sqrt:dN,std:Kl}=x(),pN=J(),Wl=Ul();function gN(t){return Bl(t)>4.1?0:Wl[mN(hN(Bl(t),0,4.1,0,Wl.length))]}function Xn(t,e){if(Yl(t)||$l(t))return Xn(t.values,e);if(Yl(e)||$l(e))return Xn(t,e.values);cN(Jl(t)&&Jl(e)&&fN(Gl(t),Gl(e)),"You must pass two identically-shaped arrays, Series, or DataFrames into the `pValue` function!");let[n,r]=pN.shouldIgnoreNaNValues?lN(Ot(t),Ot(e)):[Ot(t),Ot(e)];if(n.length===0||r.length===0)return NaN;let s=Ll(n),o=Ll(r),i=Kl(n),u=Kl(r),a=n.length,l=r.length,f=(s-o)/dN(i*i/a+u*u/l);return 2*gN(f)}Hl.exports=Xn});var tf=c((gT,ef)=>{var{assert:er,clamp:qN,DataFrame:Ft,dropNaNPairwise:yN,isArray:Ql,isDataFrame:Dt,isJagged:Xl,isUndefined:bN,ndarray:wN}=x(),NN=J(),Zl=Zn();function tr(t){let e="@jrc03c/js-data-science-helpers/get-p-value-matrix";return Object.defineProperty(t,e,{configurable:!1,enumerable:!1,writable:!1,value:Symbol.for(e)}),t}function nr(t,e){if(bN(e)&&(e=t),Dt(t)){let r=new Ft(nr(t.values,e));return r.index=t.columns.slice(),r.columns=Dt(e)?e.columns.slice():new Ft(e).columns.slice(),tr(r)}if(Dt(e)){let r=new Ft(nr(t,e.values));return r.index=Dt(t)?t.columns.slice():new Ft(t).columns.slice(),r.columns=e.columns.slice(),tr(r)}er(Ql(t)&&Ql(e),"The `getPValueMatrix` function only works on 2-dimensional arrays and DataFrames!"),er(!Xl(t)&&!Xl(e),"The `getPValueMatrix` function only works on non-jagged 2-dimensional arrays and DataFrames!"),er(t.length===e.length,'The dimensions of the matrices you passed into the `getPValueMatrix` function aren\'t compatible! ([shape(a).join(", ")] vs. [shape(b).join(", ")]) The function expects that you\'ll be comparing the columns of two matrices where the columns are all of the same length, so please make sure that the matrices are oriented accordingly.');let n=wN([t[0].length,e[0].length]);for(let r=0;r<t[0].length;r++){let s=t.map(o=>o[r]);for(let o=0;o<e[0].length;o++){let i=e.map(u=>u[o]);NN.shouldIgnoreNaNValues?n[r][o]=Zl(...yN(s,i)):n[r][o]=Zl(s,i)}}return tr(qN(n,0,1))}ef.exports=nr});var uf=c((qT,of)=>{var{assert:_t,intersect:vN,isDataFrame:nf,isSeries:rf,isUndefined:sf}=x(),pe=class{constructor(e){let n=this;_t(sf(e)||e===pe.DROP_NAN_MODE||e===pe.DROP_MISSING_MODE,"The `mode` value passed into the `IndexMatcher` constructor must be undefined or one of [IndexMatcher.DROP_NAN_MODE, IndexMatcher.DROP_MISSING_MODE]! (By default, the mode is `Indexer.DROP_MISSING_MODE`.)"),n.mode=sf(e)?pe.DROP_MISSING_MODE:e,n.index=null}fit(){let e=this,n=[];return Object.values(arguments).forEach(r=>{_t(nf(r)||rf(r),"The `IndexMatcher` only works on Series and DataFrames! To drop NaN values in a pair-wise fashion from regular arrays, use the `dropNaNPairwise` function from the @jrc03c/js-math-tools library."),e.mode===pe.DROP_MISSING_MODE?n.push(r.dropMissing().index):n.push(r.dropNaN().index)}),e.index=vN(...n),e}transform(){let e=this;_t(!!e.index,"The IndexMatcher hasn't been fitted yet! Please call the `fit` method before calling the `transform` method.");let n=Object.values(arguments).map(r=>(_t(nf(r)||rf(r),"The `IndexMatcher` only works on Series and DataFrames! To drop NaN values in a pair-wise fashion from regular arrays, use the `dropNaNPairwise` function from the @jrc03c/js-math-tools library."),r.get(e.index,null)));return n.length===1?n[0]:n}fitAndTransform(){return this.fit(...arguments).transform(...arguments)}},ke=pe;zt(ke,"DROP_NAN_MODE","DROP_NAN_MODE"),zt(ke,"DROP_MISSING_MODE","DROP_MISSING_MODE");of.exports=ke});var or=c((yT,cf)=>{var{apply:SN,assert:xN,count:TN,flatten:ON,float:FN,isArray:rr,isDataFrame:DN,isNumber:_N,isSeries:EN,isString:AN}=x(),af=["null","none","nan","na","n/a","","undefined"],MN=["true","false","yes","no"];function IN(t,e){if(t===void 0&&(t="undefined"),e==="null")return null;if(e==="number"){let n=FN(t);return isNaN(n)?NaN:n}if(e==="boolean"){try{let n=t.trim().toLowerCase();if(n==="true"||n==="yes")return!0;if(n==="false"||n==="no")return!1}catch{}return null}if(e==="date"){let n=new Date(t);return n.toString()==="Invalid Date"?null:n}if(e==="object")try{let n=JSON.parse(t);return rr(n)?null:n}catch{return null}if(e==="string"){try{if(af.indexOf(t.trim().toLowerCase())>-1)return null}catch{return null}return t}}function sr(t){if(DN(t)){let s=t.copy(),o=sr(t.values);return s.values=o.values,{type:o.type,values:s}}if(EN(t)){let s=t.copy(),o=sr(t.values);return s.values=o.values,{type:o.type,values:s}}xN(rr(t),"The `inferType` function only works on arrays, Series, and DataFrames!");let e=ON(t).map(s=>{if(s===void 0)return"null";AN(s)||(s=JSON.stringify(s));let i=s.toLowerCase().trim();if(af.indexOf(i)>-1)return"null";if(MN.indexOf(i)>-1)return"boolean";try{let u=JSON.parse(s);return _N(u)?"number":typeof u=="object"?rr(u)?"string":"object":"string"}catch{return new Date(s).toString()!=="Invalid Date"?"date":"string"}}),r=TN(e).sort((s,o)=>o.count-s.count)[0].item;return{type:r,values:SN(t,s=>IN(s,r))}}cf.exports=sr});var ur=c((bT,df)=>{var{assert:ir,isArray:jN,isBoolean:kN,isDataFrame:lf,isSeries:ff,int:CN,isNumber:zN,isUndefined:hf,range:mf,set:VN,shape:PN,shuffle:RN}=x();df.exports=function(){let e=Array.from(arguments),n=e.find(g=>kN(g)),r=hf(n)?!0:n,s=e.find(g=>zN(g)),o=hf(s)?.1:s;ir(o>0&&o<1,"`testSize` must be a number between 0 and 1 (exclusive on both ends)!");let i=e.filter(g=>jN(g)||lf(g)||ff(g));ir(i.length>0,"You must pass at least one dataset into the `trainTestSplit` function!");let u=i.map(g=>PN(g)[0]);ir(VN(u).length===1,`All datasets passed into the \`trainTestSplit\` function must be the same length at their shallowest dimension! The lengths of your datasets, though, are: ${u.join(", ")}`);let a=[],l=r?RN(mf(0,u[0])):mf(0,u[0]),f=CN((1-o)*l.length),h=l.slice(0,f),d=l.slice(f);return i.forEach(g=>{if(lf(g))a.push(g.get(h,null)),a.push(g.get(d,null));else if(ff(g))a.push(g.get(h)),a.push(g.get(d));else{let N=[],v=[];g.forEach((_,C)=>{h.indexOf(C)>-1?N.push(_):v.push(_)}),a.push(N),a.push(v)}}),a}});var At=c((wT,wf)=>{var{add:UN,argmin:BN,assert:JN,flatten:pf,isArray:YN,isDataFrame:gf,isEqual:$N,int:LN,isNumber:GN,isSeries:qf,normal:ar,pow:KN,random:WN,range:HN,scale:QN,shape:Et,subtract:XN,sum:ZN}=x(),ev=ur();function cr(t,e){(gf(t)||qf(t))&&(t=t.values),(gf(e)||qf(e))&&(e=e.values),JN($N(Et(t),Et(e)),"`yPred` and `yTrue` must have the same shape!");let n=pf(t),r=pf(e),s=0;return n.forEach((o,i)=>{o===r[i]&&s++}),s/n.length}function tv(t){test(`tests that the \`${t.name}\` model works correctly`,()=>{let e=ar([5,10]).map(h=>h.map(d=>d*100+ar()*100)),n=[],r=HN(0,500).map(()=>{let h=LN(WN()*e.length),d=e[h];return n.push(h),UN(d,QN(5,ar(Et(d))))}),[s,o,i,u]=ev(r,n),a=new t({k:e.length});a.fit(s),a.centroids=yf(e,a.centroids);let l=a.predict(s),f=a.predict(o);expect(cr(i,l)).toBeGreaterThan(.95),expect(cr(u,f)).toBeGreaterThan(.95)})}function nv(t){return YN(t)&&Et(t).length===2}function rv(t){return GN(t)&&parseInt(t)===t&&t>=0}function yf(t,e){return t.map(n=>e[BN(e.map(r=>bf(n,r)))])}function bf(t,e){return ZN(KN(XN(t,e),2))}wf.exports={accuracy:cr,createGenericTest:tv,isMatrix:nv,isWholeNumber:rv,orderCentroids:yf,sse:bf}});var hr=c((NT,xf)=>{var{add:Nf,argmin:sv,assert:ie,distance:vf,divide:ov,isDataFrame:iv,isFunction:uv,isUndefined:Mt,normal:av,random:cv,range:lv,scale:fv,shuffle:hv,zeros:Sf}=x(),{isMatrix:mv,isWholeNumber:lr,sse:dv}=At(),fr=class{constructor(e){ie(typeof e=="object","`config` must be an object! See the documentation for more information about the properties that the `config` object can contain."),ie(lr(e.k),"`k` must be a whole number!"),ie(lr(e.maxIterations)||Mt(e.maxIterations),"`maxIterations` must be a whole number or undefined!"),ie(lr(e.maxRestarts)||Mt(e.maxRestarts),"`maxRestarts` must be a whole number or undefined!"),ie(typeof e.tolerance=="number"||Mt(e.tolerance),"`tolerance` must be a number or undefined!");let n=this;n.k=e.k,n.maxRestarts=e.maxRestarts||25,n.maxIterations=e.maxIterations||100,n.tolerance=e.tolerance||1e-4,n.centroids=null}initializeCentroids(e){let n=this;return hv(e).slice(0,n.k)}fit(e,n){let r=this;ie(mv(e),"`x` must be a matrix!"),iv(e)&&(e=e.values),Mt(n)||ie(uv(n),"If defined, `progress` must be a function!");let s,o=-1/0;for(let i=0;i<r.maxRestarts;i++){let u=r.initializeCentroids(e);for(let l=0;l<r.maxIterations;l++){n&&n((i+l/r.maxIterations)/r.maxRestarts);let f=r.predict(e,u),h=[],d=Sf(r.k);e.forEach((N,v)=>{let _=f[v];h[_]||(h[_]=Sf(N.length)),h[_]=Nf(h[_],N),d[_]++});let g=lv(0,r.k).map(N=>d[N]===0?Nf(u[parseInt(cv()*u.length)],fv(.001,av(u[0].length))):ov(h[N],d[N]));try{if(vf(u,g)<r.tolerance)break}catch{break}u=g}let a=r.score(e,u);a>o&&(o=a,s=u)}return n&&n(1),r.centroids=s,r}predict(e,n){if(n=n||this.centroids,!n)throw new Error("No centroids were provided to the `predict` method, and the K-Means model hasn't been fitted yet. Please either pass centroids as a second parameter to the `predict` method or run the `fit` method first!");return e.map(s=>sv(n.map(o=>vf(s,o))))}score(e,n){let r=this;if(n=n||r.centroids,!n)throw new Error("No centroids were provided to the `score` method, and the K-Means model hasn't been fitted yet. Please either pass centroids as a second parameter to the `score` method or run the `fit` method first!");let o=r.predict(e,n).map(i=>n[i]);return-dv(e,o)}};xf.exports=fr});var dr=c((vT,Ff)=>{var{argmin:pv,distance:Tf,divide:gv,max:qv,random:Of}=x(),yv=hr(),mr=class extends yv{initializeCentroids(e){let n=this,r=[e[parseInt(Of()*e.length)]];for(;r.length<n.k;){let s=e.map(i=>Tf(i,r[pv(r.map(u=>Tf(i,u)))])),o=gv(s,qv(s));r.push(e[o.findIndex(i=>Of()<i)])}return r}};Ff.exports=mr});var Ef=c((ST,_f)=>{var{assert:$,isArray:bv,isDataFrame:wv,isEqual:Nv,isFunction:vv,isUndefined:ge,range:Sv,shape:Df}=x(),{isMatrix:xv,isWholeNumber:pr}=At(),Tv=dr(),gr=class{constructor(e){ge(e)&&(e={}),$(typeof e=="object","`config` must be an object! See the documentation for more information about the properties that the `config` object can contain."),ge(e.ks)&&(e.ks=Sv(1,16)),$(bv(e.ks),"`ks` must be an array of whole numbers!"),e.ks.forEach(r=>{$(pr(r),"`ks` must be an array of whole numbers!")}),$(pr(e.maxIterations)||ge(e.maxIterations),"`maxIterations` must be a whole number or undefined!"),$(pr(e.maxRestarts)||ge(e.maxRestarts),"`maxRestarts` must be a whole number or undefined!"),$(typeof e.tolerance=="number"||ge(e.tolerance),"`tolerance` must be a number or undefined!");let n=this;n.ks=e.ks,n.maxRestarts=e.maxRestarts||25,n.maxIterations=e.maxIterations||100,n.tolerance=e.tolerance||1e-4,n.scoreStopRatio=.85,n.modelClass=e.modelClass||Tv,n.fittedModel=null}fit(e,n){let r=this;$(xv(e),"`x` must be a matrix!"),wv(e)&&(e=e.values),ge(n)||$(vv(n),"If defined, `progress` must be a function!");let s=r.ks[0],o=-1/0;for(let i=0;i<r.ks.length;i++){let u=r.ks[i],a=new r.modelClass({k:u,maxRestarts:10,maxIterations:25});a.fit(e);let l=a.score(e);if(l/o>r.scoreStopRatio)break;s=u,o=l}return r.fittedModel=new r.modelClass({k:s,maxRestarts:r.maxRestarts,maxIterations:r.maxIterations,tolerance:r.tolerance}),r.fittedModel.fit(e),r}predict(e,n){return this.fittedModel.predict(e,n)}score(e,n){return this.fittedModel.score(e,n)}get k(){return this.fittedModel.k}set k(e){throw new Error("You can't set the k-value manually! It has to be set automatically via the `fit` method.")}get centroids(){return this.fittedModel.centroids}set centroids(e){let n=this;$(Nv(Df(e),Df(n.fittedModel.centroids)),"When assigning a new value to the `centroids` property, the new centroids must have the same shape as the old centroids!"),n.fittedModel.centroids=e}};_f.exports=gr});var Mf=c((xT,Af)=>{Af.exports={KMeansCV:Ef(),KMeansNaive:hr(),KMeansPlusPlus:dr(),helpers:At()}});var qr=c((TT,Vf)=>{var{apply:Ov,assert:Fv,dropNaN:If,isArray:Dv,isDataFrame:_v,isSeries:Ev,mean:jf,std:kf}=x(),Cf=J();function zf(t){if(_v(t)||Ev(t)){let r=t.copy();return r.values=zf(r.values),r}Fv(Dv(t),"The `normalize` function only works on arrays, Series, and DataFrames!");let e=(()=>Cf.shouldIgnoreNaNValues?jf(If(t)):jf(t))(),n=(()=>Cf.shouldIgnoreNaNValues?kf(If(t)):kf(t))();return n===0?t:Ov(t,r=>(r-e)/n)}Vf.exports=zf});var br=c((OT,Jf)=>{var{assert:qe,dot:Pf,isArray:Rf,isSeries:yr,scale:Av,Series:Mv,shape:Uf}=x(),Bf=de();function It(t,e){if(yr(t)){if(yr(e))return new Mv(It(t.values,e.values));{let n=t.copy();return n.values=It(t.values,e),n}}if(yr(e)){let n=e.copy();return n.values=It(t,e.values),n}return qe(Rf(t),"`project` only works on vectors!"),qe(Rf(e),"`project` only works on vectors!"),qe(Bf(t),"`project` only works on vectors of numbers!"),qe(Bf(e),"`project` only works on vectors of numbers!"),qe(Uf(t).length===1,"`project` only works on vectors!"),qe(Uf(e).length===1,"`project` only works on vectors!"),Av(Pf(e,t)/Pf(e,e),e)}Jf.exports=It});var Kf=c((FT,Gf)=>{var{assert:Yf,copy:Iv,DataFrame:jv,divide:kv,isArray:Cv,isDataFrame:zv,isJagged:Vv,shape:Pv,subtract:Rv,transpose:$f}=x(),Uv=de(),Bv=Hn(),Jv=br();function Lf(t){if(zv(t)){let s=new jv(Lf(t.values));return s.index=t.index.slice(),s.columns=t.columns.slice(),s}Yf(Cv(t)&&!Vv(t)&&Pv(t).length===2,"`orthonormalize` only works on matrices!"),Yf(Uv(t),"`orthonormalize` only works on matrices of numbers!");let e=$f(t),n=[];e.forEach(s=>{let o=Iv(s);n.forEach(i=>{o=Rv(o,Jv(o,i))}),n.push(o)});let r=n.map(s=>kv(s,Bv(s)));return $f(r)}Gf.exports=Lf});var th=c((DT,eh)=>{var{assert:Wf,copy:Yv,correl:$v,DataFrame:Hf,dropMissing:Lv,isArray:Gv,isDataFrame:Kv,isEqual:Wv,isJagged:Hv,isNumber:Qf,set:Qv,shape:Xv,transpose:Xf}=x(),Zv=Un(),eS=Qn(),tS=or();function Zf(t,e,n){if(e=Qf(e)?e:7,n=Qf(n)?n:1-1e-5,Gv(t))return Wf(Xv(t).length===2&&!Hv(t),"The `preprocess` function only works on non-jagged 2-dimensional arrays and DataFrames!"),Zf(new Hf(t));Wf(Kv(t),"You must pass a DataFrame into the `preprocess` function!");let r={};t=t.apply(l=>{let f=tS(l.values);return r[l.name]=f.type,f.values});let s=Yv(t.columns),o=Xf(t.values),i=0,u=!1;for(;!u;){let l=o[i];for(let f=i+1;f<o.length;f++){let h=o[f];Wv(l,h)&&(s.splice(f,1),o.splice(f,1))}i++,u=i>=s.length-1}for(i=0,u=!1;!u;){let l=s[i],f=o[i];if(!f)break;let h=Lv(f);if(h.length<15){s.splice(i,1),o.splice(i,1);continue}let d=Qv(h);if(d.length===1){s.splice(i,1),o.splice(i,1);continue}let g=r[l];if(g==="string"){if(d.length<=e){let N=eS(l,f);Object.keys(N).forEach(v=>{s.push(v),o.push(N[v]),r[v]="number"}),s.splice(i,1),o.splice(i,1);continue}}else if(g==="number"){let N=Zv(f);o[i]=N;let v=!1;for(let _=0;_<i;_++){let C=o[_];if($v(f,C)>n){s.splice(i,1),o.splice(i,1),v=!0;break}}if(v)continue}else{o.splice(i,1),s.splice(i,1);continue}i++,u=i>=s.length}let a=new Hf(Xf(o));return a.columns=s,a}eh.exports=Zf});var fh=c((_T,lh)=>{var{abs:nS,add:rS,assert:Ce,isArray:nh,isDataFrame:rh,isEqual:sS,isSeries:sh,mean:oS,pow:oh,scale:iS,shape:ih,sign:uS,sqrt:aS,sum:uh}=x(),ah=de(),ch=(t,e)=>rS(t,iS(e,-1));function wr(t,e){if(rh(t)||sh(t))return wr(t.values,e);if(rh(e)||sh(e))return wr(t,e.values);Ce(nh(t),"You must pass two same-shaped numerical arrays into the `rScore` function!"),Ce(nh(e),"You must pass two same-shaped numerical arrays into the `rScore` function!"),Ce(sS(ih(t),ih(e)),"You must pass two same-shaped numerical arrays into the `rScore` function!"),Ce(ah(t),"You must pass two same-shaped numerical arrays into the `rScore` function!"),Ce(ah(e),"You must pass two same-shaped numerical arrays into the `rScore` function!");let n=uh(oh(ch(t,e),2)),r=uh(oh(ch(t,oS(t)),2));if(r===0)return NaN;let s=1-n/r;return uS(s)*aS(nS(s))}lh.exports=wr});var gh=c((ET,ph)=>{var{argmax:hh,assert:ze,copy:cS,DataFrame:lS,dot:fS,isArray:hS,isDataFrame:mS,isEqual:mh,isJagged:dS,max:pS,min:gS,reverse:qS,shape:yS,transpose:bS}=x();function dh(t){if(hS(t)){ze(yS(t).length===2&&!dS(t),"The `sortCorrelationMatrix` function only works on 2-dimensional arrays and DataFrames!");let s=new lS(t);return s.index=s.columns.slice(),dh(s).values}ze(mS(t),"You must pass a DataFrame into the `sortCorrelationMatrix` function!"),ze(pS(t.values)<=1&&gS(t.values)>=-1,"The correlation matrix passed into the `sortCorrelationMatrix` function must not contain values less than -1 or greater than 1!"),ze(mh(t.values,bS(t.values)),"The correlation matrix passed into the `sortCorrelationMatrix` function must be symmetrical!"),ze(mh(t.index,t.columns),"The correlation matrix passed into the `sortCorrelationMatrix` function must be symmetrical! (In this case, although the values themselves are symmetrical, the row and column names differ.)");let e=cS(t.index),n=[];for(;e.length>0;)if(n.length===0){let s=hh(t.values.map(o=>fS(o,o)));n.push(e[s]),e.splice(s,1)}else{let s=t.index.indexOf(n.at(-1)),o=hh(e.map(u=>t.values[t.index.indexOf(u)][s])),i=e[o];n.push(i),e.splice(o,1)}let r=qS(n);return t.get(r,r)}ph.exports=dh});var yh=c((AT,qh)=>{var wS=qr();function NS(){return wS(...arguments)}qh.exports=NS});var Fh=c((MT,Oh)=>{var{assert:jt,DataFrame:bh,dropNaN:vS,flatten:wh,isArray:SS,isDataFrame:Nr,isSeries:vr,mean:Nh,range:xS,Series:vh,shape:Sh,stdev:xh,transpose:Th}=x(),TS=J(),Sr=class{constructor(){let e=this;e.means=[],e.stdevs=[],e.wasFittedOnAVector=!1,e.hasBeenFitted=!1}_getDataArrayAndShape(e){if(Nr(e))return[e.values,e.shape];if(vr(e)){let r=Th([e.values]);return[r,Sh(r)]}jt(SS(e),"`x` must be a 1- or 2-dimensional array, DataFrame, or Series!");let n=Sh(e);return jt(n.length<3,"`x` must be a 1- or 2-dimensional array, DataFrame, or Series!"),n.length===1&&(n.push(1),e=Th([e])),[e,n]}fit(e){let n=this,r=n._getDataArrayAndShape(e);e=r[0];let s=r[1];return n.wasFittedOnAVector=s.indexOf(1)>-1,n.means=[],n.stdevs=[],xS(0,s[1]).forEach(o=>{let i=e.map(u=>u[o]);if(TS.shouldIgnoreNaNValues){let u=vS(i);n.means.push(Nh(u)),n.stdevs.push(xh(u))}else n.means.push(Nh(i)),n.stdevs.push(xh(i))}),n.hasBeenFitted=!0,n}transform(e){let n=this;if(!n.hasBeenFitted)throw new Error("This `StandardScaler` instance hasn't been trained on any data yet! Please use the `fit` method to train it before calling the `transform` method.");if(Nr(e)){let i=new bh(n.transform(e.values));return i.columns=e.columns,i.index=e.index,i}if(vr(e)){let i=new vh(n.transform(e.values));return i.name=e.name,i.index=e.index,i}let r=n._getDataArrayAndShape(e);e=r[0];let s=r[1];jt(s[1]===n.means.length,"The data you passed into the `transform` function doesn't have the same number of columns as the data set on which this StandardScaler was fitted!");let o=e.map(i=>i.map((u,a)=>(u-n.means[a])/n.stdevs[a]));return n.wasFittedOnAVector?wh(o):o}untransform(e){let n=this;if(!n.hasBeenFitted)throw new Error("This `StandardScaler` instance hasn't been trained on any data yet! Please use the `fit` method to train it before calling the `transform` method.");if(Nr(e)){let i=new bh(n.untransform(e.values));return i.columns=e.columns,i.index=e.index,i}if(vr(e)){let i=new vh(n.untransform(e.values));return i.name=e.name,i.index=e.index,i}let r=n._getDataArrayAndShape(e);e=r[0];let s=r[1];jt(s[1]===n.means.length,"The data you passed into the `untransform` function doesn't have the same number of columns as the data set on which this StandardScaler was fitted!");let o=e.map(i=>i.map((u,a)=>u*n.stdevs[a]+n.means[a]));return n.wasFittedOnAVector?wh(o):o}};Oh.exports=Sr});var FS=c((IT,_h)=>{var{MathError:OS}=x(),Dh={clipOutliers:Un(),cohensD:Jn(),cohensd:Jn(),common:J(),containsOnlyNumbers:de(),diagonalize:xl(),getCorrelationMatrix:Gn(),getHighlyCorrelatedColumns:Il(),getMagnitude:Hn(),getOneHotEncodings:Qn(),getPercentages:Rl(),getPValueMatrix:tf(),IndexMatcher:uf(),inferType:or(),isBinary:Rn(),isCorrelationMatrix:Kn(),KMeans:Mf(),normalize:qr(),orthonormalize:Kf(),preprocess:th(),project:br(),pValue:Zn(),rScore:fh(),sortCorrelationMatrix:gh(),standardize:yh(),StandardScaler:Fh(),trainTestSplit:ur(),dump(){let t=this,e=typeof global<"u"?global:typeof window<"u"?window:null;if(!e)throw new OS("Cannot dump functions into global scope because neither `global` nor `window` exist in the current context!");Object.keys(t).forEach(n=>{try{Object.defineProperty(e,n,{configurable:!1,enumerable:!0,writable:!1,value:t[n]})}catch{e[n]=t[n]}})}};try{window.JSDataScienceHelpers=Dh}catch{}try{_h.exports=Dh}catch{}});FS();})();
