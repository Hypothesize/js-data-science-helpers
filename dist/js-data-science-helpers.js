(()=>{var Ah=Object.defineProperty;var Ih=(t,e,n)=>e in t?Ah(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n;var ye=(t=>typeof require!="undefined"?require:typeof Proxy!="undefined"?new Proxy(t,{get:(e,n)=>(typeof require!="undefined"?require:e)[n]}):t)(function(t){if(typeof require!="undefined")return require.apply(this,arguments);throw new Error('Dynamic require of "'+t+'" is not supported')});var c=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports);var zt=(t,e,n)=>(Ih(t,typeof e!="symbol"?e+"":e,n),n);var R=c((AS,xr)=>{var Vt=class extends Error{constructor(e){typeof window<"u"?super(e):super(`

\x1B[31m`+e+`
\x1B[0m`)}};xr.exports=Vt});var m=c((IS,_r)=>{var Mh=R();_r.exports=function(t,e){if(!t)throw new Mh(e)}});var P=c((MS,Tr)=>{function jh(t){try{return structuredClone(t)}catch{return t}}Tr.exports=jh});var p=c((jS,Or)=>{function Ch(t){try{return t instanceof Array||typeof t.constructor<"u"&&t.constructor.name==="Array"}catch{return!1}}Or.exports=Ch});var b=c((CS,Fr)=>{function kh(t){try{return!!t._symbol&&t._symbol===Symbol.for("@jrc03c/js-math-tools/dataframe")}catch{return!1}}Fr.exports=kh});var y=c((kS,Dr)=>{function zh(t){try{return!!t._symbol&&t._symbol===Symbol.for("@jrc03c/js-math-tools/series")}catch{return!1}}Dr.exports=zh});var O=c((zS,Ir)=>{var Vh=m(),Rh=P(),Er=p(),Ph=b(),Uh=y();function Ar(t){if(Ph(t)||Uh(t))return Ar(t.values);Vh(Er(t),"The `flatten` function only works on arrays, Series, and DataFrames!");function e(n){let r=[];return Rh(n).forEach(s=>{Er(s)?r=r.concat(e(s)):r.push(s)}),r}return e(t)}Ir.exports=Ar});var I=c((VS,Mr)=>{function Bh(t){return typeof t=="function"}Mr.exports=Bh});var q=c((RS,jr)=>{function Jh(t){return typeof t=="number"&&!isNaN(t)}jr.exports=Jh});var w=c((PS,Cr)=>{function Yh(t){return t===null||typeof t>"u"}Cr.exports=Yh});var L=c((US,kr)=>{var $h=p(),Lh=w();function Gh(t){return typeof t=="object"&&!Lh(t)&&!$h(t)}kr.exports=Gh});var be=c((BS,Rr)=>{var Kh=m(),zr=p(),Wh=b(),Hh=I(),Rt=q(),Vr=L(),Qh=y();function Pt(t,e){if(Wh(t)){let o=Pt(t.values,e);return o.length>0&&Rt(o[0])&&o[0]>=0&&o[0]<t.index.length&&(o[0]=t.index[o[0]]),o.length>1&&Rt(o[1])&&o[1]>=0&&o[1]<t.columns.length&&(o[1]=t.columns[o[1]]),o}if(Qh(t)){let o=Pt(t.values,e);return o.length>0&&Rt(o[0])&&o[0]>=0&&o[0]<t.index.length&&(o[0]=t.index[o[0]]),o}if(Kh(Vr(t)||zr(t),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `indexOf` function!"),!Hh(e)){let o=e;e=i=>i===o}function n(o,i,u){if(u=u||[],u.indexOf(o)>-1)return null;if(Vr(o)){u.push(o);let a=Object.keys(o);for(let l=0;l<a.length;l++){let f=a[l],h=o[f];if(i(h))return[f];let d=n(h,i,u);if(d&&d.length>0)return[f].concat(d)}}else if(zr(o)){u.push(o);for(let a=0;a<o.length;a++){let l=o[a];if(i(l))return[a];let f=n(l,i,u);if(f&&f.length>0)return[a].concat(f)}}else if(i(o))return[];return null}function r(o){try{return e(o)}catch{return!1}}let s=n(t,r);return s&&s.length>0?s:null}Rr.exports=Pt});var U=c((JS,Br)=>{var Pr=P(),Xh=be(),Zh=p(),e0=b(),t0=y();function Ur(t){function e(r,s,o){if(e0(r)||t0(r))return r.copy();if(s=s||[],o=o||"",s.indexOf(r)>-1){let i=o.split("/").slice(o.startsWith("/")?1:0);if(i.some((a,l)=>{let f=i.slice(0,i.length-l-1),h=n;return f.forEach(d=>{h=h[d]}),h===r}))return`<reference to "${n===r?"/":"/"+Xh(n,r).join("/")}">`}if(typeof r=="object"){if(r===null)return null;if(s.push(r),Zh(r))return r.map((i,u)=>e(i,s,o+"/"+u));{let i={};return Object.keys(r).forEach(u=>{i[u]=e(r[u],s,o+"/"+u)}),i}}else return r}let n=t;return e(t)}function n0(t,e){function n(r,s){let o=typeof r;if(o!==typeof s)return!1;if(o==="undefined")return!0;if(o==="boolean"||o==="symbol")return r===s;if(o==="number"||o==="bigint")return r.toString()==="NaN"&&s.toString()==="NaN"?!0:r===s;if(o==="string"||o==="function")return r===s;if(o==="object"){if(r===null||s===null)return r===null&&s===null;{let u=Object.keys(r),a=Object.keys(s);if(u.length!==a.length)return!1;for(let l=0;l<u.length;l++){let f=u[l];if(!n(r[f],s[f]))return!1}return!0}}}try{return n(Pr(t),Pr(e))}catch{return n(Ur(t),Ur(e))}}Br.exports=n0});var V=c((YS,Lr)=>{var r0=m(),s0=O(),o0=p(),Jr=b(),i0=I(),Yr=y(),u0=w();function we(t){let e="abcdefg1234567890",n="";for(;n.length<t;)n+=e[parseInt(Math.random()*e.length)];return n}var a0=we(256),c0=we(256),l0=we(256),f0=we(256),h0=we(256);function $r(t){if(Jr(t)||Yr(t))return $r(t.values);r0(o0(t),"The `set` function only works on arrays, Series, and DataFrames!");let e=[],n={};return s0(t).forEach(r=>{let s=typeof r=="object"&&r===null?a0:u0(r)?c0:i0(r)?r.toString():typeof r=="symbol"?r.toString()+" - "+h0:r===1/0?l0:r===-1/0?f0:Jr(r)?r.toJSONString():Yr(r)?JSON.stringify(r.toObject()):JSON.stringify(r);n[s]||e.push(r),n[s]=!0}),e}Lr.exports=$r});var Re=c(($S,Wr)=>{var m0=m(),Ut=O(),Gr=p(),d0=b(),Kr=U(),p0=I(),g0=y(),q0=V();function Ve(t,e){if(d0(t)||g0(t))return arguments.length>1?Ve(t.values,e):Ve(t.values,t.values);if(m0(Gr(t),"The first argument to the `count` function must be an array, Series, or DataFrame!"),p0(e))return Ut(t).filter(n=>e(n)).length;if(Gr(e)){let n=Ut(t);return q0(e).map(r=>({item:r,count:n.filter(s=>Kr(s,r)).length}))}else return arguments.length>1?Ut(t).filter(n=>Kr(n,e)).length:Ve(t,t)}Wr.exports=Ve});var Ne=c((LS,Qr)=>{var y0=m(),Hr=p(),b0=b(),w0=y();function Bt(t){if(b0(t)||w0(t))return Bt(t.values);y0(Hr(t),"The `isJagged` function only works on arrays, Series, and DataFrames!");let e=0,n=null;for(let r=0;r<t.length;r++)if(Hr(t[r])){if(e++,Bt(t[r]))return!0;if(n===null)n=t[r].length;else if(t[r].length!==n)return!0}return e>0&&e<t.length}Qr.exports=Bt});var Pe=c((GS,es)=>{var N0=m(),Xr=p(),v0=b(),S0=y();function Zr(t){if(v0(t)||S0(t))return Zr(t.values);N0(Xr(t),"The `isNested` function only works on arrays, Series, and DataFrames!");for(let e=0;e<t.length;e++)if(Xr(t[e]))return!0;return!1}es.exports=Zr});var G=c((KS,ns)=>{var re=m(),x0=p(),_0=Pe(),T0=q(),O0=w(),ue="You must pass a natural number or a one-dimensional array of natural numbers into the `ndarray` function!";function ts(t){re(!O0(t),ue),x0(t)||(t=[t]),re(!_0(t),ue),re(t.length>0,ue);let e=t[0];if(re(T0(e),ue),re(parseInt(e)===e,ue),re(e>=0,ue),re(e!==1/0,"We can't create an array containing an infinite number of values!"),t.length===1){let n=[];for(let r=0;r<e;r++)n.push(void 0);return n}else{let n=[];for(let r=0;r<e;r++)n.push(ts(t.slice(1)));return n}}ns.exports=ts});var ve=c((WS,rs)=>{var F0=m(),D0=p(),E0=b(),A0=y();function Jt(t){if(E0(t)||A0(t)){let n=t.copy();return n.values=Jt(n.values),n.index=Jt(n.index),n}F0(D0(t),"The `reverse` function only works on arrays, Series, and DataFrames!");let e=[];for(let n=t.length-1;n>=0;n--)e.push(t[n]);return e}rs.exports=Jt});var j=c((HS,ss)=>{var Yt=m(),$t=q(),Lt=w(),I0=ve();function M0(t,e,n=1){Yt(!Lt(t)&&!Lt(e)&&!Lt(n),"You must pass two numbers and optionally a step value to the `range` function!"),Yt($t(t)&&$t(e)&&$t(n),"You must pass two numbers and optionally a step value to the `range` function!"),Yt(n>0,"The step value must be greater than 0! (NOTE: The step value is a magnitude; it does not indicate direction.)");let r=!1;if(t>e){r=!0;let o=t;t=e+n,e=o+n}let s=[];for(let o=t;o<e;o+=n)s.push(o);return r&&(s=I0(s)),s}ss.exports=M0});var _=c((QS,as)=>{var j0=m(),os=p(),C0=b(),k0=U(),z0=y(),V0=w();function is(t){if(!os(t))return;let e=[t.length],n=0,r=t.map(s=>{let o=is(s);return V0(o)?o:(n++,o.length===1?o[0]:o)});return n>0?n===t.length&&r.slice(0,-1).every((o,i)=>k0(o,r[i+1]))?e.concat(r[0]):(e.push(r),e):e}function us(t){return C0(t)||z0(t)?us(t.values):(j0(os(t),"The `shape` function only works on arrays, Series, and DataFrames!"),is(t))}as.exports=us});var ds=c((XS,ms)=>{var cs=m(),R0=p(),P0=b(),U0=Ne(),B0=y(),J0=w(),ls=R(),Ue=G(),fs=j(),Y0=V(),$0=_();function hs(t,e,n){if(J0(n)&&(n=0),cs(n===0||n===1||n==="vertical"||n==="horizontal",'The only valid axis values for use when appending data to a DataFrame are 0, 1, "vertical", and "horizontal". Note that 0 == "horizontal" and 1 == "vertical".'),R0(e)){cs(!U0(e),"The array of data you're trying to append to this DataFrame is jagged!");let r=$0(e);if(r.length===1)if(n===0){let s=t.copy();s._values.push(e);let o=Math.max(t.shape[1],r[0]);for(s._values.forEach(i=>{for(;i.length<o;)i.push(void 0)});s._index.length<s._values.length;)s._index.push("row"+s._index.length);for(;s._columns.length<o;)s._columns.push("col"+s._columns.length);return s}else{let s=Math.max(t.shape[0],r[0]),o=t.copy();for(fs(0,s).forEach(i=>{i>=o._values.length&&o._values.push(Ue(t.shape[1])),o._values[i].push(e[i])});o._index.length<o._values.length;)o._index.push("row"+o._index.length);for(;o._columns.length<o._values[0].length;)o._columns.push("col"+o._columns.length);return o}else if(r.length===2)if(n===0){let s=Math.max(...e.map(i=>i.length).concat([t.shape[1]])),o=t.copy();for(o._values=o._values.concat(e).map(i=>{for(;i.length<s;)i.push(void 0);return i});o._index.length<o._values.length;)o._index.push("row"+o._index.length);for(;o._columns.length<s;)o._columns.push("col"+o._columns.length);return o}else{let s=Math.max(...e.map(u=>u.length))+t.shape[1],o=Math.max(t.shape[0],r[0]),i=t.copy();for(fs(0,o).forEach(u=>{for(u>=i._values.length&&i._values.push(Ue(t.shape[1])),i._values[u]=i._values[u].concat(e[u]);i._values[u].length<s;)i._values[u].push(void 0)});i._index.length<i._values.length;)i._index.push("row"+i._index.length);for(;i._columns.length<s;)i._columns.push("col"+i._columns.length);return i}else throw new ls("Only 1- and 2-dimensional arrays can be appended to a DataFrame!")}else if(B0(e)){let r=hs(t,e.values,n);return n===0?r.index[r.index.length-1]=r.index.indexOf(e.name)>-1?e.name+" (2)":e.name:r.columns[r.columns.length-1]=r.columns.indexOf(e.name)>-1?e.name+" (2)":e.name,r}else if(P0(e))if(n===0){let r=t.copy(),s=Y0(r._columns.concat(e._columns)).length;for(r._values.forEach(o=>{for(;o.length<s;)o.push(void 0)}),e.apply(o=>{let i=o.copy(),u=[];r._columns.forEach(a=>{let l=i._index.indexOf(a);l>-1?(u.push(i._values[l]),i._values.splice(l,1),i._index.splice(l,1)):u.push(void 0)}),r._values.push(u.concat(i._values))},1),r._columns=r._columns.concat(e._columns.filter(o=>r._columns.indexOf(o)<0));r._index.length<r._values.length;){let o="row"+r._index.length;r._index.push(o+(t._index.indexOf(o)>-1?" (2)":""))}return r}else{let r=t.copy();return r._index.forEach((s,o)=>{let i=e._index.indexOf(s);i>-1?r._values[o]=r._values[o].concat(e._values[i]):r._values[o]=r._values[o].concat(Ue(e.shape[1]))}),e._index.forEach((s,o)=>{r._index.indexOf(s)<0&&(r._index.push(s),r._values.push(Ue(r._columns.length).concat(e._values[o])))}),r._columns=r._columns.concat(e._columns.map(s=>s+(r._columns.indexOf(s)>-1?" (2)":""))),r}else throw new ls("Only 1- or 2-dimensional arrays, Series, and DataFrames can be appended to a DataFrame!")}ms.exports=hs});var bs=c((ZS,ys)=>{var ps=m(),gs=p(),L0=I(),qs=w();function G0(t,e,n,r,s){if(s=s||0,ps(L0(r),"The first parameter to the `apply` method must be a function."),ps(s===0||s===1,"The second parameter to the `apply` method (the `axis`) must be 0 or 1."),s===0){let o={},i;if(n.columns.forEach((u,a)=>{let l=new e(n.values.map(h=>h[a]));l.name=u,l.index=n.index;let f=r(l,a,n);f instanceof e?o[u]=f.values:o[u]=f,qs(i)&&(i=f instanceof e||gs(f))}),i){let u=new t(o);return u.index=n.index,u}else{let u=new e(n.columns.map(a=>o[a]));return u.index=n.columns,u}}else if(s===1){let o,i=n.values.map((u,a)=>{let l=new e(u);l.name=n.index[a],l.index=n.columns;let f=r(l,a,n);return qs(o)&&(o=f instanceof e||gs(f)),f instanceof e?f.values:f});if(o){let u=new t(i);return u.index=n.index,u.columns=n.columns,u}else{let u=new e(i);return u.index=n.index,u}}}ys.exports=G0});var E=c((e2,ws)=>{function K0(t){return typeof t=="string"}ws.exports=K0});var Ss=c((t2,vs)=>{var Ns=m(),W0=p(),H0=Ne(),Q0=L(),X0=E(),Z0=w(),em=R(),tm=_();function nm(t,e,n,r,s){let o=u=>u instanceof t,i=u=>u instanceof e;if(Z0(s)){if(o(r))return n.append(r,1);if(i(r))return n.append(r,1);if(Q0(r)){let u=Math.max(...Object.keys(r).map(a=>r[a].length));return Object.keys(r).forEach(a=>{for(;r[a].length<u;)r[a].push(void 0)}),n.append(new t(r),1)}else throw new em("You must pass a DataFrame, Series, or object into the `assign` method!")}else{Ns(X0(r),"If passing two arguments into the `assign` method, then the first argument must be a string name!"),Ns(W0(s)&&!H0(s)&&tm(s).length===1,"If passing two arguments into the `assign` method, then the second argument must be a 1-dimensional array!");let u=n.append(s,1);return u.columns[u.columns.length-1]=r,u}}vs.exports=nm});var _s=c((n2,xs)=>{var rm=P();function sm(t,e){if(e.isEmpty)return new t;let n=new t(rm(e.values));return n.columns=e.columns.slice(),n.index=e.index.slice(),n}xs.exports=sm});var Is=c((r2,As)=>{var Be=m(),Ts=p(),Os=q(),Fs=E(),Ds=w(),Es=_();function om(t,e,n,r,s){Ds(r)&&(r=[]),Ds(s)&&(s=[]),(Fs(r)||Os(r))&&(r=[r]),(Fs(s)||Os(s))&&(s=[s]),Be(Ts(r),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),Be(Ts(s),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),Be(Es(r).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),Be(Es(s).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");let o,i;n.index.forEach((a,l)=>{r.indexOf(a)<0&&r.indexOf(l)<0&&(o||(o=[]),o.push(a))}),n.columns.forEach((a,l)=>{s.indexOf(a)<0&&s.indexOf(l)<0&&(i||(i=[]),i.push(a))});let u=n.get(o,i);if(u instanceof e){let a=new t;a=a.assign(u),n.index.indexOf(u.name)>-1&&(a=a.transpose()),u=a}return u}As.exports=om});var Se=c((s2,Ms)=>{var im=q();function um(t){return im(t)&&parseInt(t)===t}function am(t){return um(t)&&t>=0}Ms.exports=am});var Cs=c((o2,js)=>{var Gt=m(),cm=E(),Je=w(),lm=Se(),fm=_();function hm(t,e,n,r,s,o){r=r||0,Gt(r===0||r===1,"The first parameter of the `dropMissing` method (the `axis`) must be 0 or 1."),o=o||0,Gt(lm(o),"The third parameter of the `dropMissing` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` null values)."),s=o>0?"none":s||"any",Gt(s==="any"||s==="all"||s==="none","The second parameter of the `dropMissing` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains null values, then it should be dropped; or that if 'all' of the data contains null values, then it should be dropped).");function i(l){if(o>0){let f=0;for(let h=0;h<l.length;h++){let d=l[h];if(Je(d)&&f++,f>=o)return[]}}else if(s==="any")for(let f=0;f<l.length;f++){let h=l[f];if(Je(h))return[]}else if(s==="all"){for(let f=0;f<l.length;f++){let h=l[f];if(!Je(h))return l}return[]}return l}let u=n.copy(),a=Math.random().toString();if(r===0){u=u.assign(a,u.index);let l=u.values.map(i).filter(h=>h.length>0);if(fm(l).length<2)return new t;u.values=l;let f=u.get(null,a);if(Je(f))return new t;cm(f)&&(f=[f]),f instanceof e&&(f=f.values),u.index=f,u=u.drop(null,a)}else if(r===1){let l={};if(u.columns.forEach((h,d)=>{let g=u.values.map(N=>N[d]),v=i(g);v.length>0&&(l[h]=v)}),Object.keys(l).length===0)return new t;let f=new t(l);return f.index=u.index,f}return u}js.exports=hm});var Kt=c((i2,zs)=>{var mm=m(),dm=p(),pm=b(),gm=q(),qm=y();function ks(t){if(pm(t)||qm(t))return t.dropNaN(...Object.values(arguments).slice(1));mm(dm(t),"The `dropNaN` function only works on arrays, Series, and DataFrames!");let e=[];return t.forEach(n=>{try{return e.push(ks(n))}catch{if(gm(n))return e.push(n)}}),e}zs.exports=ks});var Rs=c((u2,Vs)=>{var Wt=m(),ym=Kt(),bm=Se();function wm(t,e,n,r,s){n=n||0,Wt(n===0||n===1,"The first parameter of the `dropNaN` method (the `axis`) must be 0 or 1."),s=s||0,Wt(bm(s),"The third parameter of the `dropNaN` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` NaN values)."),r=s>0?"none":r||"any",Wt(r==="any"||r==="all"||r==="none","The second parameter of the `dropNaN` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains NaN values, then it should be dropped; or that if 'all' of the data contains NaN values, then it should be dropped).");function o(u){let a=ym(u);return s>0?u.length-a.length<s:r==="any"?a.length===u.length:r==="all"?a.length>0:!0}let i=e.copy();if(n===0){let u=i.index.filter(a=>{let l=i.get(a,null).values;return o(l)});return u.length>0?i.get(u,null):new t}else if(n===1){let u=i.columns.filter(a=>{let l=i.get(null,a).values;return o(l)});return u.length>0?i.get(null,u):new t}return i}Vs.exports=wm});var Js=c((a2,Bs)=>{var Ps=m(),xe=O(),Nm=I(),vm=w();function Us(t){let e={};return xe(t).forEach((n,r)=>{e[n]=r}),e}function ae(t){return Object.keys(t).sort((e,n)=>t[e]-t[n])}function Sm(t,e,n,r,s){Ps(Nm(r),"The `filter` method takes a single parameter: a function that is used to filter the values."),vm(s)&&(s=0),Ps(s===0||s===1,"The `axis` parameter to the `filter` method must be 0 or 1.");let o=n.copy();if(o.isEmpty)return o;let i=Us(o.index),u=Us(o.columns);if(s===0){let a=o.values.filter((l,f)=>{let h=new e(l);h.name=n.index[f],h.index=n.columns;let d=r(h,f,n);return d||delete i[o.index[f]],d});if(xe(a).length===0)return new t;if(a.length===1){let l=new e(xe(a));return l.name=ae(i)[0],l.index=ae(u),l}o.values=a,o.index=ae(i)}else if(s===1){o=o.transpose();let a=o.values.filter((l,f)=>{let h=new e(l);h.name=n.columns[f],h.index=n.index;let d=r(h,f,n);return d||delete u[o.index[f]],d});if(xe(a).length===0)return new t;if(a.length===1){let l=new e(xe(a));return l.name=ae(u)[0],l.index=ae(i),l}o.values=a,o.index=ae(u),o=o.transpose()}return o}Bs.exports=Sm});var _e=c((c2,Ys)=>{function xm(t){return typeof t=="boolean"}Ys.exports=xm});var se=c((l2,Ls)=>{var _m=m(),Tm=O(),Om=p(),Fm=b(),Dm=y();function $s(t){if(Fm(t)||Dm(t))return $s(t.values);_m(Om(t),"The `max` function only works on arrays, Series, and DataFrames!");try{return Math.max(...Tm(t))}catch{return NaN}}Ls.exports=$s});var Ht=c((f2,Ws)=>{var Ye=R(),K=m(),W=p(),Gs=_e(),$e=E(),Le=w(),Em=se(),Ks=j();function Am(t,e,n,r,s,o){return n=(()=>{if(Le(n))return!1;if(Gs(n))return n;throw new Ye("The `hasHeaderRow` parameter of the `fromCSV` method must be a boolean!")})(),r=(()=>{if(Le(r))return!1;if(Gs(r))return r;throw new Ye("The `hasIndexColumn` parameter of the `fromCSV` method must be a boolean!")})(),s=(()=>{let u="The `fieldDelimiter` parameter of the `fromCSV` method must be one of:\n\n1) a single-character string (e.g., ',')\n2) an array containing two single-character strings, one each for a left delimiter and a right delimiter (e.g., ['<', '>'])";if(Le(s))return",";if($e(s))return K(s.length===1,u),s;if(W(s))return K(s.length===2,u),K(s[0].length===1,u),K(s[1].length===1,u),s;throw new Ye(u)})(),o=(()=>{let u="The `stringDelimiter` parameter of the `fromCSV` method must be one of:\n\n1) a single-character string (e.g., '\"')\n2) an array containing two single-character strings, one each for a left delimiter and a right delimiter (e.g., ['\u201C', '\u201D'])";if(Le(o))return'"';if($e(o))return K(o.length===1,u),o;if(W(o))return K(o.length===2,u),K(o[0].length===1,u),K(o[1].length===1,u),o;throw new Ye(u)})(),(()=>{let a=e.split(`
`).filter(g=>g.length>0).map(g=>{let v=[],N="",D=!1;for(let k=0;k<g.length;k++){let M=g[k];if(M.match(/\\/g))k++;else if(W(o)&&M===o[0])D=!0;else if(W(o)&&M===o[1])D=!1;else if($e(o)&&M===o)D=!D;else if(W(s)&&M===s[0]||W(s)&&M===s[1]||$e(s)&&M===s)if(D)N+=M;else{let Ct=N;try{let kt=JSON.parse(Ct);W(kt)?v.push(Ct.trim()):v.push(kt)}catch{v.push(Ct.trim())}N=""}else N+=M}if(N.length>0){let k=N;try{let M=JSON.parse(k);W(M)?v.push(k.trim()):v.push(M)}catch{v.push(k.trim())}}return v}),l=(()=>{let g=n?a.shift():Ks(0,a[0].length).map(v=>"col"+v);return r&&g.shift(),g})(),f=(()=>r?a.map(v=>v.shift()):Ks(0,a.length).map(v=>"row"+v))(),h=Em(a.map(g=>g.length)),d=new t(a.map(g=>(g.length=h,g)));return n&&(d.columns=l),r&&(d.index=f),d})()}Ws.exports=Am});var Qs=c((h2,Hs)=>{var Im=R(),Mm=m(),jm=Ht(),Cm=E(),km=w();async function zm(t,e,n,r,s,o,i){n=(()=>km(n)?"utf8":(Mm(Cm(n),"The `encoding` parameter of the `fromCSV` method must be a string (e.g., 'utf8')!"),n))();let u=await(async()=>{try{return ye("fs").readFileSync(e,n)}catch{}try{return await(await fetch(e)).text()}catch{}throw new Im(`The path "${e}" could not be loaded!`)})();return jm(t,u,r,s,o,i)}Hs.exports=zm});var eo=c((m2,Zs)=>{var z=m(),Ge=q(),Ke=E(),Xs=w(),Vm=V();function Rm(t,e,n){(Ke(e)||Ge(e))&&(e=[e]),(Ke(n)||Ge(n))&&(n=[n]);let r=Vm((e||[]).concat(n||[]).map(s=>typeof s));return z(r.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===1&&z(r[0]==="string"||r[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===2&&(z(r.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),z(r.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),Xs(e)||(e=e.map(s=>{if(Ke(s))return z(t.index.indexOf(s)>-1,`Row "${s}" does not exist!`),s;if(Ge(s))return z(s>=0,`Index ${s} is out of bounds!`),z(parseInt(s)===s,"Row numbers must be integers!"),z(s<t.index.length,`Index ${s} is out of bounds!`),t.index[s]})),Xs(n)||(n=n.map(s=>{if(Ke(s))return z(t.columns.indexOf(s)>-1,`Column "${s}" does not exist!`),s;if(Ge(s))return z(s>=0,`Column ${s} is out of bounds!`),z(parseInt(s)===s,"Column numbers must be integers!"),z(s<t.columns.length,`Column ${s} is out of bounds!`),t.columns[s]})),t.getSubsetByNames(e,n)}Zs.exports=Rm});var H=c((d2,no)=>{var to=m(),Pm=p(),Um=b(),Bm=I(),Jm=y(),Ym=w();function $m(t,e){try{return t<e?-1:t>e?1:0}catch{return t=typeof t=="object"&&t!==null?JSON.stringify(t):t.toString(),e=typeof e=="object"&&e!==null?JSON.stringify(e):e.toString(),t<e?-1:t>e?1:0}}function Lm(t,e){if(Ym(e)&&(e=$m),Um(t)||Jm(t))return t.sort(...Object.values(arguments).slice(1));to(Pm(t),"The `sort` function only works on arrays, Series, and DataFrames!"),to(Bm(e),"The second parameter of the `sort` function must be a comparison function!");let n=t.slice();return n.sort(e),n}no.exports=Lm});var io=c((p2,oo)=>{var ro=m(),so=E(),Gm=w(),Km=V(),Wm=H();function Hm(t){let e=t.toLowerCase(),n="";for(let s=0;s<e.length;s++){let o=e[s];o.match(/[a-z0-9]/g)?n+=o:n+=" "}let r=n.split(" ").filter(s=>s.length>0);return r[0]+r.slice(1).map(s=>s[0].toUpperCase()+s.substring(1)).join("")}function Qm(t,e,n){Gm(n)?n=e.columns:so(n)&&(n=[n]);let r={};n.forEach(o=>{ro(so(o),"You must pass either a string or a one-dimensional array of strings into the `getDummies` (AKA `oneHotEncode`) method!");let i=e.columns.indexOf(o);ro(i>-1,`The given DataFrame does not have a column called "${o}"!`);let u=e.values.map(l=>l[i]),a=Wm(Km(u));u.forEach(l=>{a.forEach(f=>{let h=o+"_"+Hm(f.toString());r[h]||(r[h]=[]),l===f?r[h].push(1):r[h].push(0)})})});let s=new t(r);return s.index=e.index,s}oo.exports=Qm});var po=c((g2,mo)=>{var Q=m(),uo=p(),ao=q(),co=w(),lo=Se(),fo=j(),ho=_();function Xm(t,e,n){let r=t.shape;co(e)&&(e=fo(0,r[0])),co(n)&&(n=fo(0,r[1])),ao(e)&&(e=[e]),ao(n)&&(n=[n]),Q(uo(e)&&uo(n),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),Q(ho(e).length===1&&ho(n).length===1,"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),Q(e.length>0,"The `rowIndices` array must contain at least one index."),Q(n.length>0,"The `colIndices` array must contain at least one index."),e.forEach(i=>{Q(lo(i),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),Q(i<t.index.length,`The row index ${i} is out of bounds.`)}),n.forEach(i=>{Q(lo(i),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),Q(i<t.columns.length,`The column index ${i} is out of bounds.`)});let s=e.map(i=>t.index[i]),o=n.map(i=>t.columns[i]);return t.getSubsetByNames(s,o)}mo.exports=Xm});var wo=c((q2,bo)=>{var X=m(),Qt=O(),go=p(),We=E(),qo=w(),yo=_();function Zm(t,e,n,r,s){qo(r)&&(r=n.index),qo(s)&&(s=n.columns),We(r)&&(r=[r]),We(s)&&(s=[s]),X(go(r)&&go(s),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),X(yo(r).length===1&&yo(s).length===1,"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),X(r.length>0,"The `rows` array must contain at least one row name."),X(s.length>0,"The `cols` array must contain at least one column name."),r.forEach(u=>{X(We(u),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),X(n.index.indexOf(u)>-1,`The row name "${u}" does not exist in the list of rows.`)}),s.forEach(u=>{X(We(u),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),X(n.columns.indexOf(u)>-1,`The column name "${u}" does not exist in the list of columns.`)});let o=r.map(u=>s.map(a=>n.values[n.index.indexOf(u)][n.columns.indexOf(a)]));if(r.length===1&&s.length===1)return Qt(o)[0];if(r.length===1){let u=new e(Qt(o));return u.name=r[0],u.index=s,u}if(s.length===1){let u=new e(Qt(o));return u.name=s[0],u.index=r,u}let i=new t(o);return i.columns=s,i.index=r,i}bo.exports=Zm});var vo=c((y2,No)=>{var ed=E(),Te=j();function td(t,e,n){function r(d,g){return ed(d)&&d.length>g?d.substring(0,g-3)+"...":d}if(n.isEmpty)return console.table({}),console.log("Shape:",[0,0],`
`),n;let s=typeof window>"u"?20:10,o=parseInt(s/2),i=typeof window>"u"?Math.floor(process.stdout.columns/24)-1:10,u=parseInt(i/2),a=s>n.index.length?null:Te(0,o).concat(Te(n.index.length-o,n.index.length)),l=i>n.columns.length?null:Te(0,u).concat(Te(n.columns.length-u,n.columns.length)),f=n.get(a,l);f instanceof e&&(n.shape[0]===1?(f=new t([f.values]),f.index=n.index,f.columns=new e(n.columns).get(l).values):n.shape[1]===1&&(f=new t([f.values]).transpose(),f.index=new e(n.index).get(a).values,f.columns=n.columns)),s<=n.index.length&&(f._index.splice(o,0,"..."),f._values.splice(o,0,Te(0,f.columns.length).map(()=>"..."))),i<=n.columns.length&&(f._columns.splice(u,0,"..."),f._values=f._values.map(d=>(d.splice(u,0,"..."),d)));let h=28;return f instanceof e?(f.values=f.values.map(d=>r(d,h)),f.name=r(f.name,h),f.index=f.index.map(d=>r(d,h))):(f.values=f.values.map(d=>d.map(g=>r(g,h))),f.columns=f.columns.map(d=>r(d,h)),f.index=f.index.map(d=>r(d,h))),console.table(f.toObject()),console.log("Shape:",n.shape,`
`),n}No.exports=td});var He=c((b2,So)=>{var nd=m(),rd=q();function sd(t,e){nd(rd(t),"The `leftPad` function only works on numbers!");let n=t.toString();for(;n.length<e;)n="0"+n;return n}So.exports=sd});var _o=c((w2,xo)=>{var od=He(),id=j();function ud(t,e){let n=e?t:t.copy();return n.index=id(0,t.shape[0]).map(r=>"row"+od(r,(n.index.length-1).toString().length)),n}xo.exports=ud});var Oe=c((N2,Oo)=>{var ad=m(),cd=O(),ld=p(),fd=b(),hd=y();function To(t){if(fd(t)||hd(t))return To(t.values);ad(ld(t),"The `product` function only works on arrays, Series, and DataFrames!");try{return t.length===0?NaN:cd(t).reduce((e,n)=>e*n,1)}catch{return NaN}}Oo.exports=To});var Qe=c((v2,Ao)=>{var Fe=m(),Fo=O(),Do=p(),md=b(),Eo=q(),dd=y(),pd=Oe(),gd=_();function Xt(t,e){if(md(t)||dd(t))return Xt(t.values,e);if(Fe(Do(t),"The first argument passed into the `reshape` function must be an array!"),Eo(e)&&(e=[e]),Fe(Do(e),"The second argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),Fe(gd(e).length===1,"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),e.forEach(o=>{Fe(Eo(o)&&parseInt(o)===o&&o>0,"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!")}),e.length===0)return Fo(t);let n=Fo(t);if(e.length===1&&e[0]===n.length)return n;Fe(pd(e)===n.length,"The new shape doesn't match the number of values available in `x` (the first argument passed into the `reshape` function)!");let r=[],s=parseInt(n.length/e[0]);for(let o=0;o<e[0];o++){let i=n.slice(o*s,(o+1)*s);r.push(Xt(i,e.slice(1)))}return r}Ao.exports=Xt});var ce=c((S2,Vo)=>{var qd=m(),jo=P(),yd=p(),bd=q(),Co=w(),wd=G(),Nd=Oe(),vd=Qe(),ko=Math.pow(2,64),T=[];zo(parseInt(Math.random()*ko));function Sd(t,e){t=A(t);function n(){t+=A("0x9e3779b97f4a7c15");let s=jo(t);return s=(s^s>>30n)*A("0xbf58476d1ce4e5b9"),s=(s^s>>27n)*A("0x94d049bb133111eb"),s^s>>31n}let r=[];for(let s=0;s<e;s++)r.push(n());return r}function A(t){return BigInt.asUintN(64,BigInt(t))}function Io(t,e){return t=A(t),e=BigInt(e),A(A(t<<e)|A(t>>A(64n-e)))}function zo(t){if(Co(t))return jo(T);{qd(bd(t),"If passing a value into the `seed` function, then that value must be an integer!");let e=Sd(parseInt(t),4);T[0]=e[0],T[1]=e[1],T[2]=e[2],T[3]=e[3]}}function Mo(){let t=A(Io(T[0]+T[3],23)+T[0]),e=A(T[1]<<17n);return T[2]=A(T[2]^T[0]),T[3]=A(T[3]^T[1]),T[1]=A(T[1]^T[2]),T[0]=A(T[0]^T[3]),T[2]=A(T[2]^e),T[3]=Io(T[3],45),parseInt(t)/ko}function xd(t){return Co(t)?Mo():(yd(t)||(t=[t]),vd(wd(Nd(t)).map(Mo),t))}Vo.exports={random:xd,seed:zo}});var Xe=c((x2,Ro)=>{var{random:_d}=ce(),Td=m(),Od=p(),Fd=b(),Dd=y();function Ed(t){if(Fd(t)||Dd(t))return t.shuffle(...Object.values(arguments).slice(1));Td(Od(t),"The `shuffle` function only works on arrays, Series, and DataFrames!");let e=[],n=t.slice();for(let r=0;r<t.length;r++){let s=parseInt(_d()*n.length);e.push(n.splice(s,1)[0])}return e}Ro.exports=Ed});var Bo=c((_2,Uo)=>{var Ad=m(),Id=w(),Po=Xe();function Md(t,e){return Id(e)&&(e=0),Ad(e===0||e===1,"The `axis` parameter to the `shuffle` must be 0, 1, or undefined."),t.get(e===0?Po(t.index):null,e===1?Po(t.columns):null)}Uo.exports=Md});var Go=c((T2,Lo)=>{var{random:jd}=ce(),C=m(),Cd=O(),Jo=p(),Zt=_e(),$o=I(),Ze=q(),le=E(),en=w(),kd=j(),Yo=_(),tn=H();function zd(t,e,n){return $o(e)?Vd(t,e,n):Rd(t,e,n)}function Vd(t,e,n){if(n=en(n)?0:n,C($o(e),"When sorting a DataFrame using a function, the first argument to the `sort` method must be a function!"),C(Ze(n),"When sorting a DataFrame using a function, the second argument to the `sort` method must be null, undefined, 0, or 1 to indicate the axis along which the data should be sorted! An axis of 0 means that the rows will be sorted relative to each other, whereas an axis of 1 means that the columns will be sorted relative to each other."),n===0){let r=tn(t.index,(s,o)=>e(t.get(s,null),t.get(o,null)));return t.get(r,null)}else{let r=tn(t.columns,(s,o)=>e(t.get(null,s),t.get(null,o)));return t.get(null,r)}}function Rd(t,e,n){let r=t.copy(),s=jd().toString();return r=r.assign(s,r.index),en(e)&&(e=[s],n=[!0]),(Ze(e)||le(e))&&(e=[e],(Zt(n)||le(n))&&(n=[n])),C(Jo(e),"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),C(Yo(e).length===1,"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),en(n)&&(n=kd(0,e.length).map(()=>!0)),C(Jo(n),"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),C(Yo(n).length===1,"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),C(e.length===n.length,"The arrays passed into the `sort` method must be equal in length."),e=e.map(o=>{if(C(le(o)||Ze(o),"Column references can either be column names (as strings) or column indices (as whole numbers)."),le(o)){let i=r.columns.indexOf(o);return C(i>-1,`The column "${o}" does not exist!`),i}if(Ze(o))return C(parseInt(o)===o,"Column indices must be whole numbers!"),C(o>=0,`The column index ${o} is out of bounds!`),C(o<r.columns.length,`The index ${o} is out of bounds!`),o}),n=n.map(o=>{if(C(le(o)||Zt(o),"Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),le(o)){let i=o.trim().toLowerCase();return C(i==="ascending"||i==="descending","Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),i==="ascending"}if(Zt(o))return o}),r.values=tn(r.values,(o,i)=>{let u=0;for(;o[e[u]]===i[e[u]]&&u<e.length;)u++;let a=n[u];if(o[e[u]]===i[e[u]])return 0;if(o[e[u]]<i[e[u]])return a?-1:1;if(o[e[u]]>i[e[u]])return a?1:-1}),r.index=Cd(r.get(null,s).values),r=r.dropColumns(s),r}Lo.exports=zd});var nn=c((O2,Wo)=>{var Pd=R(),Ud=_e(),Bd=L(),Jd=E(),Ko=w();function Yd(t,e){e=(()=>{if(Ko(e))return!0;if(Ud(e))return e;throw new Pd("The `shouldIncludeIndex` parameter of the `toCSVString` method must be a boolean!")})();let n=[""].concat(t.index);return[t.columns].concat(t.values).map((s,o)=>(e?[n[o]]:[]).concat(s).map(u=>Jd(u)?JSON.stringify(u):Bd(u)?JSON.stringify(JSON.stringify(u)):Ko(u)?"":u.toString()).join(",")).join(`
`)}Wo.exports=Yd});var Ho=c((F2,sn)=>{var rn=R(),$d=nn();function Ld(t,e,n){let r=$d(t,n),s=!1,o=!1,i,u;try{let a=e;if(e.includes("/")){let f=e.split("/");a=f[f.length-1]}let l=document.createElement("a");l.href=`data:text/csv;charset=utf-8,${encodeURIComponent(r)}`,l.download=a,l.dispatchEvent(new MouseEvent("click")),s=!0}catch(a){i=a}try{let a=ye("fs"),l=ye("path");a.writeFileSync(l.resolve(e),r,"utf8"),o=!0}catch(a){u=a}if(!s&&!o)throw typeof window<"u"?new rn(i):typeof sn<"u"?new rn(u):new rn("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");return t}sn.exports=Ld});var on=c((D2,Qo)=>{function Gd(t,e){return JSON.stringify(t.toObject(e))}Qo.exports=Gd});var Xo=c((E2,an)=>{var un=R(),Kd=on();function Wd(t,e,n){let r=Kd(t,n),s=!1,o=!1,i,u;try{let a=e;if(e.includes("/")){let f=e.split("/");a=f[f.length-1]}let l=document.createElement("a");l.href=`data:application/json;charset=utf-8,${encodeURIComponent(r)}`,l.download=a,l.dispatchEvent(new MouseEvent("click")),s=!0}catch(a){i=a}try{let a=ye("fs"),l=ye("path");a.writeFileSync(l.resolve(e),r,"utf8"),o=!0}catch(a){u=a}if(!s&&!o)throw typeof window<"u"?new un(i):typeof an<"u"?new un(u):new un("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");return t}an.exports=Wd});var ei=c((A2,Zo)=>{var Hd=m(),Qd=w();function Xd(t,e){Qd(e)?e=0:Hd(e===0||e===1,"The axis parameter of the `toObject` method must be undefined, 0, or 1. An axis of 0 indicates that the returned object should be organized first by rows and then by columns. An axis of 1 indicates that the returned object should be organized first by columns and then by rows.");let n={};return e===0?t.index.forEach((r,s)=>{let o={};t.columns.forEach((i,u)=>{o[i]=t.values[s][u]}),n[r]=o}):t.columns.forEach((r,s)=>{let o={};t.index.forEach((i,u)=>{o[i]=t.values[u][s]}),n[r]=o}),n}Zo.exports=Xd});var oe=c((I2,ri)=>{var ti=m(),Zd=p(),ep=b(),tp=y(),np=G(),ni=ve(),rp=_();function sp(t){if(ep(t)||tp(t))return t.transpose();ti(Zd(t),"The `transpose` function only works on arrays, Series, and DataFrames!");let e=rp(t);if(ti(e.length<=2,"I'm not smart enough to know how to transpose arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `transpose` function!"),e.length===1)return ni(t);if(e.length===2){let n=np(ni(e));for(let r=0;r<e[0];r++)for(let s=0;s<e[1];s++)n[s][r]=t[r][s];return n}}ri.exports=sp});var ui=c((M2,ii)=>{var si=m(),op=p(),ip=b(),up=Pe(),ap=y(),cp=_();function oi(t,e,n){if(ap(n))return new t(e.values.concat(n.values));if(op(n)){let r=cp(n);si(r.length===1&&!up(r),"Only vectors can be appended to Series!");let s=e.copy();return n.forEach((o,i)=>{s._values.push(o),s._index.push("item"+(e.values.length+i))}),s}return si(!ip(n),"DataFrames cannot be appended to Series!"),oi(e,[n])}ii.exports=oi});var ci=c((j2,ai)=>{var lp=m(),fp=I();function hp(t,e){lp(fp(e),"The parameter to the `apply` method must be a function.");let n=t.copy();return n._values=n._values.map((r,s)=>e(r,s)),n}ai.exports=hp});var fi=c((C2,li)=>{var mp=w();function dp(t){let e=t.copy(),n=[];return e._values=e.values.filter((r,s)=>mp(r)?!1:(n.push(e.index[s]),!0)),e._index=n,e}li.exports=dp});var mi=c((k2,hi)=>{var pp=q();function gp(t,e){let n=[],r=[];e.values.forEach((o,i)=>{pp(o)&&(r.push(o),n.push(e.index[i]))});let s=new t(r);return s.name=e.name,s.index=n,s}hi.exports=gp});var pi=c((z2,di)=>{var qp=P();function yp(t,e,n){let r=e.copy(),s=qp(r.index),o=[],i=r.values.filter((u,a)=>{let l=n(u,a,r.values);return l||o.push(r.index[a]),l});return o.forEach(u=>{s.splice(s.indexOf(u),1)}),i.length===0?(r=new t,r.name=e.name,r):(r.values=i,r.index=s,r)}di.exports=yp});var qi=c((V2,gi)=>{var Z=m(),bp=q(),wp=E(),Np=w(),vp=V();function Sp(t,e){(wp(e)||bp(e))&&(e=[e]);let n=vp((e||[]).map(r=>typeof r));return Z(n.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===1&&Z(n[0]==="string"||n[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===2&&(Z(n.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),Z(n.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),Np(e)||(e=e.map(r=>{if(typeof r=="string")return Z(t.index.indexOf(r)>-1,`Index "${r}" does not exist!`),r;if(typeof r=="number")return Z(r>=0,`Index ${r} is out of bounds!`),Z(parseInt(r)===r,"Indices must be integers!"),Z(r<t.index.length,`Index ${r} is out of bounds!`),t.index[r]})),t.getSubsetByNames(e)}gi.exports=Sp});var bi=c((R2,yi)=>{var De=m(),xp=p(),_p=w(),Tp=Se(),Op=j(),Fp=_();function Dp(t,e){let n=t.shape;_p(e)&&(e=Op(0,n[0])),De(xp(e),"The `indices` array must be 1-dimensional array of whole numbers."),De(Fp(e).length===1,"The `indices` array must be a 1-dimensional array of whole numbers."),De(e.length>0,"The `indices` array must contain at least one index."),e.forEach(s=>{De(Tp(s),"The `indices` array must be a 1-dimensional array of whole numbers."),De(s<t.index.length,`The row index ${s} is out of bounds.`)});let r=e.map(s=>t.index[s]);return t.getSubsetByNames(r)}yi.exports=Dp});var Ni=c((P2,wi)=>{var Ee=m(),Ep=p(),Ap=E(),Ip=w(),Mp=_();function jp(t,e,n){Ip(n)&&(n=e.index),Ee(Ep(n),"The `indices` array must be a 1-dimensional array of strings."),Ee(Mp(n).length===1,"The `indices` array must be a 1-dimensional array of strings."),Ee(n.length>0,"The `indices` array must contain at least one index name."),n.forEach(o=>{Ee(Ap(o),"The `indices` array must contain only strings."),Ee(e.index.indexOf(o)>-1,`The name "${o}" does not exist in the index.`)});let r=n.map(o=>e.values[e.index.indexOf(o)]);if(r.length===1)return r[0];let s=new t(r);return s.index=n,s.name=e.name,s}wi.exports=jp});var xi=c((U2,Si)=>{var Cp=P(),vi=j();function kp(t){let e=t.copy(),n=typeof window>"u"?20:10;if(e.index.length>n){e=e.get(vi(0,n/2).concat(vi(e.index.length-n/2,e.index.length)));let s=Cp(e.index);s.splice(parseInt(s.length/2),0,"..."),e.values.push("..."),e.index.push("..."),e=e.get(s)}let r={};return e.values.forEach((s,o)=>{let i={};i[e.name]=s,r[e.index[o]]=i}),console.table(r),console.log("Shape:",t.shape,`
`),t}Si.exports=kp});var Ti=c((B2,_i)=>{var zp=Xe();function Vp(t){let e=t.copy();return e.get(zp(e.index))}_i.exports=Vp});var Fi=c((J2,Oi)=>{var Rp=m(),Pp=I(),Up=w(),Bp=H(),Jp=oe();function Yp(t,e,n){n=n||((a,l)=>a<l?-1:1),Rp(Up(n)||Pp(n),"You must pass undefined, null, or a comparison function as the second argument to the `sort` method!");let r=Jp([e.values,e.index]),s=Bp(r,(a,l)=>n(a[0],l[0])),o=[],i=[];s.forEach(a=>{o.push(a[0]),i.push(a[1])});let u=new t;return u._values=o,u._index=i,u.name=e.name,u}Oi.exports=Yp});var Ai=c((Y2,Ei)=>{var $p=H(),Di=oe();function Lp(t,e){let n=Di([e.values,e.index]);n=Di($p(n,(s,o)=>{if(s[1]===o[1])return 0;if(s[1]<o[1])return-1;if(s[1]>o[1])return 1}));let r=new t(n[0]);return r.index=n[1],r.name=e.name,r}Ei.exports=Lp});var Mi=c(($2,Ii)=>{function Gp(t){let e={};return e[t.name]={},t.index.forEach((n,r)=>{e[t.name][n]=t.values[r]}),e}Ii.exports=Gp});var Vi=c((L2,zi)=>{var Y=m(),et=P(),cn=p(),Kp=E(),Wp=w(),ji=He(),Ci=j(),tt=ve(),Hp=ui(),Qp=ci(),Xp=fi(),Zp=mi(),eg=pi(),tg=qi(),ng=bi(),rg=Ni(),sg=xi(),og=Ti(),ig=Fi(),ug=Ai(),ag=Mi(),Ae=_(),cg=oe(),ki=Symbol.for("@jrc03c/js-math-tools/series");zi.exports=function(t){class e{static[Symbol.hasInstance](r){try{return!!r._symbol&&r._symbol===ki}catch{return!1}}constructor(r){let s=this;if(s.name="data",Object.defineProperty(s,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:ki}),Object.defineProperty(s,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(s,"values",{configurable:!0,enumerable:!0,get(){return s._values},set(o){Y(cn(o),"The new values must be a 1-dimensional array!");let i=Ae(o);Y(i.length===1,"The new array of values must be 1-dimensional!"),i[0]<s._index.length?s._index=s._index.slice(0,i[0]):i[0]>s._index.length&&(s._index=s._index.concat(Ci(s._index.length,i[0]).map(u=>"item"+ji(u,(o.length-1).toString().length)))),s._values=o}}),Object.defineProperty(s,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(s,"index",{configurable:!0,enumerable:!0,get(){return s._index},set(o){Y(cn(o),"The new index must be a 1-dimensional array of strings!"),Y(o.length===s.shape[0],"The new index must be the same length as the old index!"),Y(Ae(o).length===1,"The new index must be a 1-dimensional array of strings!"),o.forEach(i=>{Y(Kp(i),"All of the row names must be strings!")}),s._index=o}}),r){if(r instanceof e)s.name=r.name,s.values=et(r.values),s.index=et(r.index);else if(cn(r)){let o=Ae(r);Y(o.length===1,"When passing an array into the constructor of a Series, the array must be 1-dimensional!"),s.values=r}else if(r instanceof Object){let o=Object.keys(r);Y(o.length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");let i=o[0],u=r[i];Y(Ae(u).length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!"),s.name=i,s.values=u.slice()}}}get shape(){return Ae(this.values)}get length(){return this.shape[0]}get isEmpty(){return this.values.filter(s=>!Wp(s)).length===0}clear(){let s=this.copy();return s.values.forEach((o,i)=>{s.values[i]=void 0}),s}get(r){return tg(this,r)}getSubsetByNames(r){return rg(e,this,r)}getSubsetByIndices(r){return ng(this,r)}loc(r){return this.getSubsetByNames(r)}iloc(r){return this.getSubsetByIndices(r)}reverse(){let r=this,s=new e(tt(r.values));return s.index=tt(r.index),s.name=r.name,s}resetIndex(){let r=this,s=r.copy();return s.index=Ci(0,r.shape[0]).map(o=>"item"+ji(o,(s.index.length-1).toString().length)),s}copy(){let r=this,s=new e;return s._values=et(r.values),s._index=et(r.index),s.name=r.name,s}append(r){return Hp(e,this,r)}apply(r){return Qp(this,r)}concat(r){return this.append(r)}dropMissing(r,s){return Xp(this,r,s)}dropNaN(){return Zp(e,this)}toObject(){return ag(this)}print(){return sg(this)}shuffle(){return og(this)}sort(r){return ig(e,this,r)}sortByIndex(){return ug(e,this)}filter(r){return eg(e,this,r)}toDataFrame(){let r=this,s=new t(cg([r.values]));return s.columns=[r.name],s.index=r.index,s}transpose(){let s=this.copy();return s.values=tt(s.values),s.index=tt(s.index),s}getDummies(){return this.toDataFrame().getDummies()}oneHotEncode(){return this.getDummies()}}return e}});var Me=c((G2,Yi)=>{var B=m(),ln=P(),Ri=Re(),lg=ds(),fg=bs(),hg=Ss(),mg=_s(),dg=Is(),pg=Cs(),gg=Rs(),qg=Js(),yg=Qs(),bg=Ht(),wg=eo(),Pi=io(),Ng=po(),vg=wo(),Sg=vo(),xg=_o(),_g=Bo(),Tg=Go(),Og=Ho(),Fg=nn(),Dg=Xo(),Eg=on(),Ag=ei(),Ig=O(),Ie=p(),Mg=L(),Ui=w(),fn=He(),jg=G(),hn=j(),fe=_(),Bi=oe(),Ji=Symbol.for("@jrc03c/js-math-tools/dataframe");function nt(t){let e="abcdefghijklmnopqrstuvwxyz1234567890",n="";for(let r=0;r<t;r++)n+=e[parseInt(Math.random()*e.length)];return n}var F=class{static[Symbol.hasInstance](e){try{return!!e._symbol&&e._symbol===Ji}catch{return!1}}constructor(e){let n=this;if(Object.defineProperty(n,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:Ji}),Object.defineProperty(n,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(n,"values",{configurable:!0,enumerable:!0,get(){return n._values.length===0||!Ui(n._values[0])&&n._values[0].length===0?[[]]:n._values},set(r){B(Ie(r),"The new values must be a 2-dimensional array!");let s=fe(r);B(s.length===2,"The new array of values must be 2-dimensional!"),s[0]<n._index.length?n._index=n._index.slice(0,s[0]):s[0]>n._index.length&&(n._index=n._index.concat(hn(n._index.length,s[0]).map(o=>"row"+fn(o,(s[0]-1).toString().length)))),s[1]<n._columns.length?n._columns=n._columns.slice(0,s[1]):s[1]>n._columns.length&&(n._columns=n._columns.concat(hn(n._columns.length,s[1]).map(o=>"col"+fn(o,(s[1]-1).toString().length)))),n._values=r}}),Object.defineProperty(n,"_columns",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(n,"columns",{configurable:!0,enumerable:!0,get(){return n._columns},set(r){B(Ie(r),"The new columns list must be a 1-dimensional array of strings!"),B(n.isEmpty||r.length===n.shape[1],"The new columns list must be the same length as the old columns list!"),B(fe(r).length===1,"The new columns list must be a 1-dimensional array of strings!"),r=r.map(o=>(typeof o!="string"&&(o=JSON.stringify(o)||o.toString()),o.trim().length===0?"untitled_"+nt(8):o.trim()));let s=(()=>{let o=Ri(r),i={};return o.forEach(u=>{i[u.item]=u.count}),i})();r=r.map(o=>s[o]>1?o+"_"+nt(8):o),n._columns=r}}),Object.defineProperty(n,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(n,"index",{configurable:!0,enumerable:!0,get(){return n._index},set(r){B(Ie(r),"The new index must be a 1-dimensional array of strings!"),B(n.isEmpty||r.length===n.shape[0],"The new index must be the same length as the old index!"),B(fe(r).length===1,"The new index must be a 1-dimensional array of strings!"),r=r.map(o=>(typeof o!="string"&&(o=JSON.stringify(o)||o.toString()),o.trim().length===0?"untitled_"+nt(8):o.trim()));let s=(()=>{let o=Ri(r),i={};return o.forEach(u=>{i[u.item]=u.count}),i})();r=r.map(o=>s[o]>1?o+"_"+nt(8):o),n._index=r}}),B(Ui(e)||Mg(e)||Ie(e),"The `data` passed into the constructor of a DataFrame must be either (1) an object where the key-value pairs are (respectively) column names and 1-dimensional arrays of values, or (2) a 2-dimensional array of values."),e)if(e instanceof F)n.values=ln(e.values),n.columns=ln(e.columns),n.index=ln(e.index);else if(Ie(e)){let r=fe(e);B(r.length===2,"The `data` array passed into the constructor of a DataFrame must be 2-dimensional!"),n.values=e}else{n._columns=Object.keys(e);let r=[];n._columns.forEach(o=>{let i=e[o];r.push(i)}),n._values=Bi(r);let s=fe(n.values);n._index=hn(0,s[0]).map(o=>"row"+fn(o,(s[0]-1).toString().length))}}get shape(){return fe(this.values)}get length(){return this.shape[0]}get width(){return this.shape[1]}get rows(){return this.index}set rows(e){let n=this;n.index=e}get isEmpty(){return Ig(this.values).length===0}clear(){let e=this,n=new F(jg(e.shape));return n.columns=e.columns.slice(),n.index=e.index.slice(),n}get(e,n){let r=this;if(arguments.length===0)return r;if(arguments.length===1)try{return r.get(null,e)}catch{return r.get(e,null)}return wg(r,e,n)}getSubsetByNames(e,n){return vg(F,ee,this,e,n)}getSubsetByIndices(e,n){return Ng(this,e,n)}getDummies(e){return Pi(F,this,e)}oneHotEncode(e){return Pi(F,this,e)}transpose(){let e=this,n=new F(Bi(e.values));return n.columns=e.index.slice(),n.index=e.columns.slice(),n}get T(){return this.transpose()}resetIndex(e){return xg(this,e)}copy(){return mg(F,this)}assign(e,n){return hg(F,ee,this,e,n)}apply(e,n){return fg(F,ee,this,e,n)}dropMissing(e,n,r){return pg(F,ee,this,e,n,r)}dropNaN(e,n,r){return gg(F,this,e,n,r)}drop(e,n){return dg(F,ee,this,e,n)}dropColumns(e){return this.drop(null,e)}dropRows(e){return this.drop(e,null)}toObject(e){return Ag(this,e)}toCSVString(e){return Fg(this,e)}saveAsCSV(e,n){return Og(this,e,n)}toJSONString(e){return Eg(this,e)}saveAsJSON(e,n){return Dg(this,e,n)}print(){return Sg(F,ee,this)}sort(e,n){return Tg(this,e,n)}sortByIndex(){return this.sort()}filter(e,n){return qg(F,ee,this,e,n)}shuffle(e){return _g(this,e)}append(e,n){return lg(this,e,n)}concat(e,n){return this.append(e,n)}join(e,n){return this.append(e,n)}toString(){let e=this;return JSON.stringify(e)}};F.fromCSV=function(){return yg(F,...arguments)};F.fromCSVString=function(){return bg(F,...arguments)};var ee=Vi()(F);Yi.exports={DataFrame:F,Series:ee}});var S=c((K2,Wi)=>{var{DataFrame:$i,Series:Li}=Me(),Gi=m(),je=p(),mn=b(),Ki=U(),Cg=I(),dn=y(),kg=se(),zg=j(),rt=_();function Vg(t){return je(t)||dn(t)||mn(t)}function Rg(t){return Gi(Cg(t),"You must pass a function into the `vectorize` function!"),function e(){let n,r,s=[],o=[],i=Object.keys(arguments).filter(u=>{let a=arguments[u];return je(a)?!0:dn(a)?(n=!0,s.push(a),!0):mn(a)?(r=!0,o.push(a),!0):!1}).map(u=>arguments[u]);if(i.slice(0,-1).forEach((u,a)=>{Gi(Ki(je(u)?rt(u):u.shape,je(i[a+1])?rt(i[a+1]):i[a+1].shape),`When passing multiple arrays into the \`${t.name}\` function, all of the arrays must have the same shape!`)}),i.length>0){let u=kg(i.map(l=>l.length?l.length:l.values.length)),a=zg(0,u).map(l=>{let f=Object.keys(arguments).map(h=>{if(Vg(arguments[h])){if(je(arguments[h]))return arguments[h][l];if(dn(arguments[h]))return arguments[h].values[l];if(mn(arguments[h]))return arguments[h].values[l]}else return arguments[h]});return e(...f)});if(r)try{if(o.length===1&&Ki(rt(o[0]),rt(a))){let l=new $i(a);return l.index=o[0].index.slice(),l.columns=o[0].columns.slice(),l}else return new $i(a)}catch{return a}if(n)try{if(s.length===1&&s[0].length===a.length){let l=new Li(a);return l.name=s[0].name,l.index=s[0].index.slice(),l}else return new Li(a)}catch{return a}return a}else return t(...arguments)}}Wi.exports=Rg});var st=c((W2,Hi)=>{var Pg=q(),Ug=S();function Bg(t){try{return Pg(t)?Math.abs(t):NaN}catch{return NaN}}Hi.exports=Ug(Bg)});var ot=c((H2,Qi)=>{var Jg=q(),Yg=S();function $g(){try{let t=0,e=Object.values(arguments);for(let n=0;n<e.length;n++){if(!Jg(e[n]))return NaN;t+=e[n]}return t}catch{return NaN}}Qi.exports=Yg($g)});var it=c((Q2,Xi)=>{var Lg=S();function Gg(t,e){try{return e(t)}catch{return NaN}}Xi.exports=Lg(Gg)});var eu=c((X2,Zi)=>{var Kg=q(),Wg=S();function Hg(t){try{return Kg(t)?Math.acos(t):NaN}catch{return NaN}}Zi.exports=Wg(Hg)});var nu=c((Z2,tu)=>{var Qg=q(),Xg=S();function Zg(t){try{return Qg(t)?Math.asin(t):NaN}catch{return NaN}}tu.exports=Xg(Zg)});var su=c((ex,ru)=>{var eq=q(),tq=S();function nq(t){try{return eq(t)?Math.atan(t):NaN}catch{return NaN}}ru.exports=tq(nq)});var iu=c((tx,ou)=>{var rq=m(),sq=be(),oq=p(),iq=b(),uq=y(),aq=se();function pn(t){if(iq(t)){let e=pn(t.values);return[t.index[e[0]],t.columns[e[1]]]}if(uq(t)){let e=pn(t.values);return[t.index[e]]}rq(oq(t),"The `argmax` function only works on arrays, Series, and DataFrames!");try{let e=sq(t,aq(t));return e?e.length===0?void 0:e.length===1?e[0]:e:void 0}catch{return}}ou.exports=pn});var ut=c((nx,au)=>{var cq=m(),lq=O(),fq=p(),hq=b(),mq=y();function uu(t){if(hq(t)||mq(t))return uu(t.values);cq(fq(t),"The `min` function only works on arrays, Series, and DataFrames!");try{return Math.min(...lq(t))}catch{return NaN}}au.exports=uu});var lu=c((rx,cu)=>{var dq=m(),pq=be(),gq=p(),qq=b(),yq=y(),bq=ut();function gn(t){if(qq(t)){let e=gn(t.values);return[t.index[e[0]],t.columns[e[1]]]}if(yq(t)){let e=gn(t.values);return[t.index[e]]}dq(gq(t),"The `argmin` function only works on arrays, Series, and DataFrames!");try{let e=pq(t,bq(t));return e?e.length===0?void 0:e.length===1?e[0]:e:void 0}catch{return}}cu.exports=gn});var hu=c((sx,fu)=>{var wq=q(),Nq=S();function vq(t){try{return wq(t)?Math.ceil(t):NaN}catch{return NaN}}fu.exports=Nq(vq)});var pu=c((ox,du)=>{var Sq=st(),mu=q(),xq=w(),_q=S();function Tq(t,e){try{if(!mu(t))return NaN;if(xq(e))e=1e-10;else if(!mu(e))return NaN;return Sq(t)<e?0:t}catch{return NaN}}du.exports=_q(Tq)});var qu=c((ix,gu)=>{var qn=q(),Oq=S();function Fq(t,e,n){try{return qn(t)?qn(e)?qn(n)?t<e?e:t>n?n:t:NaN:NaN:NaN}catch{return NaN}}gu.exports=Oq(Fq)});var bu=c((ux,yu)=>{var yn=m(),Dq=O(),Eq=p(),Aq=b(),Iq=q(),Mq=y();function bn(t,e){if(Aq(t)||Mq(t))return bn(t.values,e);if(yn(Eq(t),"The `combinations` function only works on arrays, Series, and DataFrames!"),yn(Iq(e),"`r` must be a whole number!"),t=Dq(t),e>t.length)return[t];if(e<=0)return[[]];if(yn(e===parseInt(e),"`r` must be a whole number!"),t.length<2)return t;let n=[];return t.forEach((r,s)=>{let o=t.slice(s+1);if(o.length<e-1)return;bn(o,e-1).forEach(u=>{n.push([r].concat(u))})}),n}yu.exports=bn});var at=c((ax,Nu)=>{var jq=m(),Cq=O(),kq=p(),zq=b(),Vq=y();function wu(t){if(zq(t)||Vq(t))return wu(t.values);jq(kq(t),"The `mean` function only works on arrays, Series, and DataFrames!");try{let e=Cq(t),n=0;return e.forEach(r=>{n+=r}),n/e.length}catch{return NaN}}Nu.exports=wu});var Nn=c((cx,Ou)=>{var vu=m(),Su=p(),ct=q(),xu=y(),_u=at(),Tu=_();function wn(t,e){if(xu(t))return wn(t.values,e);if(xu(e))return wn(t,e.values);vu(Su(t)&&Su(e)&&Tu(t).length===1&&Tu(e).length===1,"The `covariance` function only works on 1-dimensional arrays and Series!"),vu(t.length===e.length,"The two arrays or Series passed into the `covariance` function must have the same length!");try{let n=_u(t),r=_u(e);if(!ct(n)||!ct(r))return NaN;let s=Math.max(t.length,e.length),o=0;for(let i=0;i<s;i++){if(!ct(t[i]))return NaN;if(!ct(e[i]))return NaN;o+=(t[i]-n)*(e[i]-r)}return o/t.length}catch{return NaN}}Ou.exports=wn});var lt=c((lx,Fu)=>{var Rq=q(),Pq=S();function Uq(t){try{return Rq(t)?Math.sqrt(t):NaN}catch{return NaN}}Fu.exports=Pq(Uq)});var vn=c((fx,Eu)=>{var Bq=m(),Jq=O(),Yq=p(),$q=b(),Lq=q(),Gq=y(),Kq=at();function Du(t){if($q(t)||Gq(t))return Du(t.values);Bq(Yq(t),"The `variance` function only works on arrays, Series, and DataFrames!");try{let e=Jq(t),n=Kq(e),r=0;for(let s=0;s<e.length;s++){if(!Lq(e[s]))return NaN;r+=(e[s]-n)*(e[s]-n)}return r/e.length}catch{return NaN}}Eu.exports=Du});var ft=c((hx,Iu)=>{var Wq=m(),Hq=p(),Qq=b(),Xq=y(),Zq=lt(),ey=vn();function Au(t){if(Qq(t)||Xq(t))return Au(t.values);Wq(Hq(t),"The `std` function only works on arrays, Series, and DataFrames!");try{return Zq(ey(t))}catch{return NaN}}Iu.exports=Au});var Ru=c((mx,Vu)=>{var Mu=m(),ty=Nn(),ju=p(),Cu=y(),ku=_(),zu=ft();function Sn(t,e){if(Cu(t))return Sn(t.values,e);if(Cu(e))return Sn(t,e.values);Mu(ju(t)&&ju(e)&&ku(t).length===1&&ku(e).length===1,"The `correl` function only works on 1-dimensional arrays and Series!"),Mu(t.length===e.length,"The two arrays or Series passed into the `correl` function must have the same length!");try{return ty(t,e)/(zu(t)*zu(e))}catch{return NaN}}Vu.exports=Sn});var Uu=c((dx,Pu)=>{var ny=q(),ry=S();function sy(t){try{return ny(t)?Math.cos(t):NaN}catch{return NaN}}Pu.exports=ry(sy)});var Gu=c((px,Lu)=>{var oy=m(),Bu=p(),Ju=b(),iy=U(),Yu=y(),$u=V();function xn(t,e){if(Ju(t)||Yu(t))return xn(t.values,e);if(Ju(e)||Yu(e))return xn(t,e.values);oy(Bu(t)&&Bu(e),"The `diff` function only works on arrays, Series, and DataFrames!");let n=$u(t),r=$u(e),s=[];return n.forEach(o=>{r.findIndex(i=>iy(i,o))<0&&s.push(o)}),s}Lu.exports=xn});var ht=c((gx,Wu)=>{var Ku=q(),uy=S();function ay(t,e){try{return Ku(t)?Ku(e)?Math.pow(t,e):NaN:NaN}catch{return NaN}}Wu.exports=uy(ay)});var _n=c((qx,Hu)=>{var cy=q(),ly=S();function fy(){try{let t=Object.values(arguments);if(t.length===0)return NaN;let e=1;for(let n=0;n<t.length;n++){if(!cy(t[n]))return NaN;e*=t[n]}return e}catch{return NaN}}Hu.exports=ly(fy)});var he=c((yx,Qu)=>{var hy=_n();function my(){return hy(...arguments)}Qu.exports=my});var Tn=c((bx,Xu)=>{var dy=ot(),py=he();function gy(t,e){return dy(t,py(e,-1))}Xu.exports=gy});var mt=c((wx,ea)=>{var qy=m(),yy=O(),by=p(),wy=b(),Ny=y();function Zu(t){if(wy(t)||Ny(t))return Zu(t.values);qy(by(t),"The `sum` function only works on arrays, Series, and DataFrames!");try{return t.length===0?NaN:yy(t).reduce((e,n)=>e+n,0)}catch{return NaN}}ea.exports=Zu});var ua=c((Nx,ia)=>{var vy=st(),Sy=m(),ta=p(),na=b(),xy=U(),ra=q(),sa=y(),_y=ht(),oa=_(),Ty=lt(),Oy=Tn(),Fy=mt();function On(t,e){if(ra(t)&&ra(e))return vy(t-e);if(na(t)||sa(t))return On(t.values,e);if(na(e)||sa(e))return On(t,e.values);ta(t)&&ta(e)&&Sy(xy(oa(t),oa(e)),"If passing two arrays, Series, or DataFrames into the `distance` function, then those objects must have the same shape!");try{return Ty(Fy(_y(Oy(t,e),2)))}catch{return NaN}}ia.exports=On});var ca=c((vx,aa)=>{var Dy=ht(),Ey=he();function Ay(t,e){return Ey(t,Dy(e,-1))}aa.exports=Ay});var Dn=c((Sx,pa)=>{var{DataFrame:la,Series:fa}=Me(),dt=m(),ha=O(),ma=p(),Fn=b(),Iy=q(),pt=y(),My=he(),gt=_(),jy=mt(),da=oe();function te(t,e){if(Fn(t)){let s=te(t.values,e);if(gt(s).length===1){let o=new fa(s);return o.name=pt(e)?e.name:o.name,o.index=t.index.slice(),o}else{let o=new la(s);return o.index=t.index.slice(),Fn(e)&&(o.columns=e.columns.slice()),o}}if(Fn(e)){let s=te(t,e.values);if(gt(s).length===1){let o=new fa(s);return o.name=pt(t)?t.name:o.name,o.index=e.columns.slice(),o}else{let o=new la(s);return o.columns=e.columns.slice(),o}}if(pt(t))return te(t.values,e);if(pt(e))return te(t,e.values);dt(ma(t)&&ma(e),"The `dot` function only works on arrays, Series, and DataFrames!"),ha(t).concat(ha(e)).forEach(s=>{dt(Iy(s),"One of the arrays you passed into the `dot` function contains non-numerical values!")});let n=gt(t),r=gt(e);if(dt(n.length<=2&&r.length<=2,"I'm not smart enough to know how to get the dot-product of arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `dot` function!"),dt(n[n.length-1]===r[0],`There's a dimension misalignment in the two arrays you passed into the \`dot\` function. (${n[n.length-1]} !== ${r[0]})`),n.length===1&&r.length===1)return jy(My(t,e));if(n.length===1&&r.length===2)return da(e).map(s=>te(t,s));if(n.length===2&&r.length===1)return t.map(s=>te(s,e));if(n.length===2&&r.length===2){let s=da(e),o=[];for(let i=0;i<t.length;i++){let u=[];for(let a=0;a<s.length;a++)u.push(te(t[i],s[a]));o.push(u)}return o}}pa.exports=te});var En=c((xx,qa)=>{var Cy=m(),ky=p(),zy=b(),Vy=y(),Ry=w();function ga(t){if(zy(t)||Vy(t))return t.dropMissing(...Object.values(arguments).slice(1));Cy(ky(t),"The `dropMissing` function only works on arrays, Series, and DataFrames!");let e=[];return t.forEach(n=>{try{return e.push(ga(n))}catch{Ry(n)||e.push(n)}}),e}qa.exports=ga});var _a=c((_x,xa)=>{var ya=m(),ba=p(),wa=b(),Py=U(),Na=y(),va=w(),Sa=_();function qt(t,e){if(wa(t)||Na(t))return qt(t.values,e);if(wa(e)||Na(e))return qt(t,e.values);ya(ba(t)&&ba(e),"The `dropMissingPairwise` function only works on arrays, Series, and DataFrames!"),ya(Py(Sa(t),Sa(e)),"The two arrays, Series, and/or DataFrames passed into the `dropMissingPairwise` function must have the same shape!");let n=[],r=[];for(let s=0;s<t.length;s++)try{let[o,i]=qt(t[s],e[s]);n.push(o),r.push(i)}catch{!va(t[s])&&!va(e[s])&&(n.push(t[s]),r.push(e[s]))}return[n,r]}xa.exports=qt});var Ma=c((Tx,Ia)=>{var Ta=m(),Oa=p(),Fa=b(),Uy=U(),Da=q(),Ea=y(),Aa=_();function yt(t,e){if(Fa(t)||Ea(t))return yt(t.values,e);if(Fa(e)||Ea(e))return yt(t,e.values);Ta(Oa(t)&&Oa(e),"The `dropNaNPairwise` only works on arrays, Series, and DataFrames!"),Ta(Uy(Aa(t),Aa(e)),"The two arrays, Series, and/or DataFrames passed into the `dropNaNPairwise` must have the same shape!");let n=[],r=[];for(let s=0;s<t.length;s++)try{let[o,i]=yt(t[s],e[s]);n.push(o),r.push(i)}catch{Da(t[s])&&Da(e[s])&&(n.push(t[s]),r.push(e[s]))}return[n,r]}Ia.exports=yt});var Ca=c((Ox,ja)=>{var By=En();function Jy(t){return By(t)}ja.exports=Jy});var za=c((Fx,ka)=>{var Yy=q(),$y=S();function Ly(t){try{return Yy(t)?Math.exp(t):NaN}catch{return NaN}}ka.exports=$y(Ly)});var Pa=c((Dx,Ra)=>{var Gy=S();function Va(t){try{return t!==parseInt(t)?NaN:t<=1?1:t*Va(t-1)}catch{return NaN}}Ra.exports=Gy(Va)});var Ya=c((Ex,Ja)=>{var Ky=m(),Wy=O(),Ua=p(),Hy=b(),Qy=I(),Ba=L(),Xy=y();function An(t,e){if(Hy(t))return An(Wy(t.values),e);if(Xy(t))return An(t.values,e);if(Ky(Ba(t)||Ua(t),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `find` function!"),!Qy(e)){let s=e;e=o=>o===s}function n(s,o,i){if(i=i||[],i.indexOf(s)>-1)return null;if(Ba(s)){i.push(s);let u=Object.keys(s);for(let a=0;a<u.length;a++){let l=u[a],f=s[l];if(o(f))return f;let h=n(f,o,i);if(h)return h}}else if(Ua(s)){i.push(s);for(let u=0;u<s.length;u++){let a=s[u];if(o(a))return a;let l=n(a,o,i);if(l)return l}}else if(o(s))return s;return null}function r(s){try{return e(s)}catch{return!1}}return n(t,r)}Ja.exports=An});var Ka=c((Ax,Ga)=>{var Zy=m(),e1=O(),$a=p(),t1=b(),n1=I(),La=L(),r1=y();function In(t,e){if(t1(t))return In(e1(t.values),e);if(r1(t))return In(t.values,e);if(Zy(La(t)||$a(t),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `findAll` function!"),!n1(e)){let o=e;e=i=>i===o}function n(o,i,u){if(u=u||[],u.indexOf(o)>-1)return null;if(La(o)){u.push(o);let a=Object.keys(o),l=[];for(let f=0;f<a.length;f++){let h=a[f],d=o[h],g=!1;i(d)&&(l.push(d),g=!0);let v=n(d,i,u);v&&v.length>0&&v.slice(g?1:0).forEach(N=>l.push(N))}return l}else if($a(o)){u.push(o);let a=[];for(let l=0;l<o.length;l++){let f=o[l],h=!1;i(f)&&(a.push(f),h=!0);let d=n(f,i,u);d&&d.length>0&&d.slice(h?1:0).forEach(g=>a.push(g))}return a}else if(i(o))return[o];return null}function r(o){try{return e(o)}catch{return!1}}let s=n(t,r);return s&&s.length>0?s:null}Ga.exports=In});var Ha=c((Ix,Wa)=>{var s1=q(),o1=S();function i1(t){try{if(t==="Infinity")return 1/0;if(t==="-Infinity")return-1/0;let e=JSON.parse(t);return s1(e)?e:NaN}catch{return NaN}}Wa.exports=o1(i1)});var Xa=c((Mx,Qa)=>{var u1=q(),a1=S();function c1(t){try{return u1(t)?Math.floor(t):NaN}catch{return NaN}}Qa.exports=a1(c1)});var Mn=c((jx,Za)=>{var l1=q(),f1=Oe(),h1=Qe();function m1(t){l1(t)&&(t=[t]);let e=[],n=f1(t);for(let r=0;r<n;r++)e.push(0);return h1(e,t)}Za.exports=m1});var tc=c((Cx,ec)=>{var bt=m(),d1=q(),p1=w(),g1=Mn();function q1(t){bt(!p1(t),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),bt(d1(t),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),bt(parseInt(t)===t,"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),bt(t>0,"You must pass an integer greater than 0 (representing the size) into the `identity` function!");let e=g1([t,t]);for(let n=0;n<t;n++)e[n][n]=1;return e}ec.exports=q1});var rc=c((kx,nc)=>{var y1=q(),b1=S();function w1(t){try{let e=JSON.parse(t);return y1(e)?parseInt(e):NaN}catch{return NaN}}nc.exports=b1(w1)});var oc=c((zx,sc)=>{var N1=m(),v1=p(),S1=b(),x1=U(),_1=y(),jn=V();function T1(){let t=Object.values(arguments).map(n=>S1(n)||_1(n)?jn(n.values):(N1(v1(n),"The `intersect` function only works on arrays, Series, and DataFrames!"),jn(n)));return jn(t).filter(n=>t.every(r=>r.findIndex(s=>x1(s,n))>-1))}sc.exports=T1});var cc=c((Vx,ac)=>{var ic=ot(),ne=m(),O1=Dn(),F1=O(),D1=p(),E1=b(),Cn=q(),uc=he(),A1=_();function wt(t){if(E1(t)){let n=t.copy();return n.values=wt(n.values),n}ne(D1(t),"The `inverse` function only works on square 2-dimensional arrays or DataFrames!"),F1(t).forEach(n=>ne(Cn(n),"The array passed into the `inverse` function must contain only numbers!"));let e=A1(t);if(ne(e.length===2,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),ne(e[0]===e[1],"The array passed into the `inverse` function must be exactly two-dimensional and square!"),ne(e[0]>=0,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),e[0]===0)return t;if(e[0]===1)return ne(t[0][0]!==0,"This matrix cannot be inverted!"),1/t[0][0];if(e[0]===2){let n=t[0][0],r=t[0][1],s=t[1][0],o=t[1][1],i=n*o-r*s;ne(i!==0,"This matrix cannot be inverted!");let u=[[o,-r],[-s,n]];return uc(u,1/i)}else if(e[0]>1){let n=(r,s)=>Cn(r)||Cn(s)?uc(r,s):O1(r,s);for(let r=1;r<e[0]-1;r++)try{let s=t.slice(0,r).map(N=>N.slice(0,r)),o=t.slice(0,r).map(N=>N.slice(r,e[0])),i=t.slice(r,e[0]).map(N=>N.slice(0,r)),u=t.slice(r,e[0]).map(N=>N.slice(r,e[0])),a=wt(s),l=wt(ic(u,n(-1,n(n(i,a),o)))),f=ic(a,n(n(n(n(a,o),l),i),a)),h=n(-1,n(n(a,o),l)),d=n(-1,n(n(l,i),a)),g=l;return f.map((N,D)=>N.concat(h[D])).concat(d.map((N,D)=>N.concat(g[D])))}catch{}ne(!1,"This matrix cannot be inverted!")}}ac.exports=wt});var fc=c((Rx,lc)=>{var kn=q(),I1=S();function M1(t,e,n){try{return kn(t)?kn(e)?kn(n)?n*(e-t)+t:NaN:NaN:NaN}catch{return NaN}}lc.exports=I1(M1)});var dc=c((Px,mc)=>{var hc=q(),j1=w(),C1=S();function k1(t,e){try{return e=j1(e)?Math.E:e,hc(t)?hc(e)?Math.log(t)/Math.log(e):NaN:NaN}catch{return NaN}}mc.exports=C1(k1)});var qc=c((Ux,gc)=>{var z1=m(),V1=O(),R1=p(),P1=b(),U1=y(),B1=H();function pc(t){if(P1(t)||U1(t))return pc(t.values);z1(R1(t),"The `median` function only works on arrays, Series, and DataFrames!");try{let e=B1(V1(t));return e.length===0?NaN:e.length%2===0?(e[e.length/2-1]+e[e.length/2])/2:e[parseInt(e.length/2)]}catch{return NaN}}gc.exports=pc});var wc=c((Bx,bc)=>{var yc=q(),J1=S();function Y1(t,e){try{return yc(t)?yc(e)?t%e:NaN:NaN}catch{return NaN}}bc.exports=J1(Y1)});var xc=c((Jx,Sc)=>{var $1=m(),L1=Re(),G1=O(),K1=p(),W1=b(),H1=y(),Q1=V(),Nc=H();function vc(t){if(W1(t)||H1(t))return vc(t.values);$1(K1(t),"The `mode` function only works on arrays, Series, and DataFrames!");try{if(t.length===0)return NaN;let e=G1(t);if(e.length===0)return NaN;let n={},r=Q1(e);r.forEach(u=>{n[u]=L1(e,u)});let s=Nc(r,(u,a)=>n[a]-n[u]),o=s[0];return Nc(s.filter(u=>n[u]===n[o]))}catch{return NaN}}Sc.exports=vc});var Fc=c((Yx,Oc)=>{var{random:_c}=ce(),X1=it(),Z1=w(),eb=G();function Tc(){let t=_c(),e=_c();return Math.sqrt(-2*Math.log(t))*Math.cos(2*Math.PI*e)}function tb(t){return Z1(t)?Tc():X1(eb(t),Tc)}Oc.exports=tb});var Ec=c(($x,Dc)=>{var nb=it(),rb=G();function sb(t){return nb(rb(t),()=>1)}Dc.exports=sb});var Ic=c((Lx,Ac)=>{var zn=m(),ob=O(),ib=p(),ub=b(),ab=q(),cb=y(),lb=w();function Nt(t,e){if(ub(t)||cb(t))return Nt(t.values,e);if(zn(ib(t),"The `permutations` function only works on arrays, Series, and DataFrames!"),lb(e)&&(e=t.length),zn(ab(e),"`r` must be a whole number!"),t=ob(t),e>t.length)return Nt(t);if(e<=0)return[[]];if(zn(e===parseInt(e),"`r` must be a whole number!"),t.length<2)return t;let n=[];return t.forEach((r,s)=>{let o=t.slice(0,s),i=t.slice(s+1),u=o.concat(i);Nt(u,e-1).forEach(l=>{n.push([r].concat(l))})}),n}Ac.exports=Nt});var jc=c((Gx,Mc)=>{var{DataFrame:fb,Series:hb}=Me(),mb=p(),db=b(),pb=Ne(),gb=y(),qb=_();function yb(){Object.keys(arguments).forEach(t=>{let e=arguments[t];if(mb(e))if(pb(e))console.log(e);else{let n=qb(e);n.length===1?new hb(e).print():n.length==2?new fb(e).print():console.log(e)}else db(e)||gb(e)?e.print():console.log(e)})}Mc.exports=yb});var zc=c((Kx,kc)=>{var bb=p(),wb=q(),Cc=w(),Nb=se(),vb=ut(),Sb=S(),xb=Sb(function(t,e,n,r,s){try{return[t,e,n,r,s].every(o=>wb(o))?n-e===0?NaN:(s-r)*(t-e)/(n-e)+r:NaN}catch{return NaN}});function _b(t,e,n,r,s){return bb(t)&&Cc(r)&&Cc(s)&&(r=e,s=n,e=vb(t),n=Nb(t)),xb(t,e,n,r,s)}kc.exports=_b});var Rc=c((Wx,Vc)=>{var Tb=q(),Ob=S();function Fb(t){try{return Tb(t)?Math.round(t):NaN}catch{return NaN}}Vc.exports=Ob(Fb)});var Uc=c((Hx,Pc)=>{var Db=q(),Eb=S();function Ab(t){try{return Db(t)?t<0?-1:t>0?1:0:NaN}catch{return NaN}}Pc.exports=Eb(Ab)});var Jc=c((Qx,Bc)=>{var Ib=q(),Mb=S();function jb(t){try{return Ib(t)?Math.sin(t):NaN}catch{return NaN}}Bc.exports=Mb(jb)});var $c=c((Xx,Yc)=>{var Cb=ft();function kb(t){return Cb(t)}Yc.exports=kb});var Gc=c((Zx,Lc)=>{var zb=q(),Vb=S();function Rb(t){try{return zb(t)?Math.tan(t):NaN}catch{return NaN}}Lc.exports=Vb(Rb)});var vt=c((e_,Hc)=>{var Kc=m(),Wc=I();function Pb(t,e){Kc(Wc(t),"`fn` must be a function!");let n=new Date;return e?t(...e):t(),new Date-n}async function Ub(t,e){Kc(Wc(t),"`fn` must be a function!");let n=new Date;return e?await t(...e):await t(),new Date-n}Hc.exports={timeSync:Pb,timeAsync:Ub}});var Xc=c((t_,Qc)=>{var Bb=p(),Jb=b(),Yb=y(),$b=V();function Lb(){return $b([...arguments].map(t=>Bb(t)?t:Jb(t)||Yb(t)?t.values:[t]))}Qc.exports=Lb});var el=c((n_,Zc)=>{var Gb=m(),Kb=p(),Wb=b(),Hb=y(),Qb=w(),Xb=se(),Zb=j();function ew(){let t=[],e=Object.values(arguments).map(n=>((Wb(n)||Hb(n))&&(n=n.values),Gb(Kb(n),"The `zip` function only works on arrays, Series, and DataFrames!"),n));return Zb(0,Xb(e.map(n=>n.length))).forEach(n=>{let r=[];e.forEach(s=>{let o=s[n];r.push(Qb(o)?void 0:o)}),t.push(r)}),t}Zc.exports=ew});var x=c((r_,Vn)=>{var{DataFrame:tw,Series:nw}=Me(),me={abs:st(),add:ot(),apply:it(),arccos:eu(),arcsin:nu(),arctan:su(),argmax:iu(),argmin:lu(),assert:m(),ceil:hu(),chop:pu(),clamp:qu(),combinations:bu(),copy:P(),correl:Ru(),cos:Uu(),count:Re(),covariance:Nn(),DataFrame:tw,diff:Gu(),distance:ua(),divide:ca(),dot:Dn(),dropMissing:En(),dropMissingPairwise:_a(),dropNaN:Kt(),dropNaNPairwise:Ma(),dropUndefined:Ca(),exp:za(),factorial:Pa(),find:Ya(),findAll:Ka(),flatten:O(),float:Ha(),floor:Xa(),identity:tc(),indexOf:be(),int:rc(),intersect:oc(),inverse:cc(),isArray:p(),isBoolean:_e(),isDataFrame:b(),isEqual:U(),isFunction:I(),isJagged:Ne(),isNested:Pe(),isNumber:q(),isObject:L(),isSeries:y(),isString:E(),isUndefined:w(),lerp:fc(),log:dc(),MathError:R(),max:se(),mean:at(),median:qc(),min:ut(),mod:wc(),mode:xc(),multiply:_n(),ndarray:G(),normal:Fc(),ones:Ec(),permutations:Ic(),pow:ht(),print:jc(),product:Oe(),random:ce().random,range:j(),remap:zc(),reshape:Qe(),reverse:ve(),round:Rc(),scale:he(),seed:ce().seed,Series:nw,set:V(),shape:_(),shuffle:Xe(),sign:Uc(),sin:Jc(),sort:H(),sqrt:lt(),std:ft(),stdev:$c(),subtract:Tn(),sum:mt(),tan:Gc(),time:vt().timeSync,timeSync:vt().timeSync,timeAsync:vt().timeAsync,transpose:oe(),union:Xc(),variance:vn(),vectorize:S(),zeros:Mn(),zip:el(),dump:function(){let t=typeof global<"u"?global:window;if(!t)throw new me.MathError("Cannot dump functions into global scope because neither `global` nor `window` exist in the current context!");Object.keys(me).forEach(e=>{try{Object.defineProperty(t,e,{configurable:!1,enumerable:!0,writable:!1,value:me[e]})}catch{t[e]=me[e]}})}};typeof Vn<"u"&&(Vn.exports=me);typeof window<"u"&&(window.JSMathTools=me)});var J=c((s_,tl)=>{tl.exports={shouldIgnoreNaNValues:!0}});var de=c((o_,rl)=>{var{assert:rw,flatten:sw,isArray:ow,isDataFrame:iw,isNumber:uw,isSeries:aw}=x();function nl(t){if(iw(t)||aw(t))return nl(t.values);rw(ow(t),"The `containsOnlyNumbers` function only works on arrays, Series, and DataFrames!");let e=sw(t);for(let n=0;n<e.length;n++)if(!uw(e[n]))return!1;return!0}rl.exports=nl});var Pn=c((i_,sl)=>{var{dropMissing:cw,flatten:lw,isArray:fw,isDataFrame:hw,isSeries:mw}=x();function Rn(t){return typeof t=="number"?t===0||t===1:hw(t)||mw(t)?Rn(t.values):fw(t)?t.length===0?!1:cw(lw(t)).every(n=>Rn(n)):!1}sl.exports=Rn});var Un=c((u_,ml)=>{var{abs:ol,apply:il,assert:ul,clamp:dw,copy:pw,divide:gw,dropNaN:qw,flatten:yw,isArray:bw,isDataFrame:ww,isNumber:al,isSeries:Nw,max:cl,median:ll,min:vw,sort:Sw,subtract:fl}=x(),xw=J(),_w=de(),Tw=Pn();function hl(t,e){if(ww(t)||Nw(t)){let a=t.copy();return a._values=hl(a._values,e),a}if(ul(bw(t),"The `clipOutliers` function only works on arrays, Series, and DataFrames!"),e=e||5,ul(al(e),"Any `maxScore` value passed into the `clipOutliers` function must be a number!"),!xw.shouldIgnoreNaNValues&&!_w(t))return il(t,()=>NaN);let n=yw(t),r=qw(n);if(Tw(r)||r.length===0)return t;let s=ll(r),o=ll(ol(fl(r,s))),i=!1;if(o===0){let a=Sw(pw(r)),l=a.filter(g=>g<s),f=a.filter(g=>g>s),h=s,d=s;if(l.length>0&&(h=cl(l)),f.length>0&&(d=vw(f)),o=(d-h)/2,o===0)return t;i=(s-h)/o>e||(d-s)/o>e}return cl(gw(ol(fl(r,s)),o))>e||i?il(t,a=>al(a)?dw(a,s-e*o,s+e*o):a):t}ml.exports=hl});var Jn=c((a_,Nl)=>{var{assert:dl,dropNaN:pl,isArray:gl,isSeries:ql,mean:yl,shape:bl,variance:wl}=x(),Ow=J();function Bn(t,e){if(ql(t))return Bn(t.values,e);if(ql(e))return Bn(t,e.values);dl(gl(t)&&gl(e)&&bl(t).length===1&&bl(e).length===1,"The `cohensd` function only works on 1-dimensional arrays and Series!"),dl(t.length===e.length,"Two arrays or Series passed into the `cohensd` function must have the same length!"),Ow.shouldIgnoreNaNValues&&(t=pl(t),e=pl(e));try{let n=yl(t),r=yl(e),s=Math.sqrt((wl(t)+wl(e))/2);return(n-r)/s}catch{return NaN}}Nl.exports=Bn});var _l=c((c_,xl)=>{var{assert:vl,DataFrame:Fw,isArray:Dw,isSeries:Ew,shape:Aw,zeros:Iw}=x();function Sl(t){if(Ew(t)){let r=new Fw(Sl(t.values));return r.index=t.index.slice(),r.columns=t.index.slice(),r}vl(Dw(t),"The `diagonalize` function only works on 1-dimensional arrays and Series!");let e=Aw(t);vl(e.length===1,"The `diagonalize` function only works on 1-dimensional arrays and Series!");let n=Iw([e[0],e[0]]);return t.forEach((r,s)=>n[s][s]=r),n}xl.exports=Sl});var Gn=c((l_,Dl)=>{var{assert:Yn,clamp:Mw,correl:Tl,DataFrame:St,dropNaNPairwise:jw,isArray:Ol,isDataFrame:xt,isJagged:Fl,isUndefined:Cw,ndarray:kw}=x(),zw=J();function $n(t){let e="@jrc03c/js-data-science-helpers/get-correlation-matrix";return Object.defineProperty(t,e,{configurable:!1,enumerable:!1,writable:!1,value:Symbol.for(e)}),t}function Ln(t,e){if(Cw(e)&&(e=t),xt(t)){let r=new St(Ln(t.values,e));return r.index=t.columns.slice(),r.columns=xt(e)?e.columns.slice():new St(e).columns.slice(),$n(r)}if(xt(e)){let r=new St(Ln(t,e.values));return r.index=xt(t)?t.columns.slice():new St(t).columns.slice(),r.columns=e.columns.slice(),$n(r)}Yn(Ol(t)&&Ol(e),"The `getCorrelationMatrix` function only works on 2-dimensional arrays and DataFrames!"),Yn(!Fl(t)&&!Fl(e),"The `getCorrelationMatrix` function only works on non-jagged 2-dimensional arrays and DataFrames!"),Yn(t.length===e.length,'The dimensions of the matrices you passed into the `getCorrelationMatrix` function aren\'t compatible! ([shape(a).join(", ")] vs. [shape(b).join(", ")]) The function expects that you\'ll be comparing the columns of two matrices where the columns are all of the same length, so please make sure that the matrices are oriented accordingly.');let n=kw([t[0].length,e[0].length]);for(let r=0;r<t[0].length;r++){let s=t.map(o=>o[r]);for(let o=0;o<e[0].length;o++){let i=e.map(u=>u[o]);zw.shouldIgnoreNaNValues?n[r][o]=Tl(...jw(s,i)):n[r][o]=Tl(s,i)}}return $n(Mw(n,-1,1))}Dl.exports=Ln});var Kn=c((f_,El)=>{function Vw(t){try{let e="@jrc03c/js-data-science-helpers/get-correlation-matrix";return t[e]===Symbol.for(e)}catch{return!1}}El.exports=Vw});var jl=c((h_,Ml)=>{var{DataFrame:Wn,isArray:Rw,isDataFrame:_t,isNumber:Al,MathError:Pw,sort:Uw}=x(),Il=Gn(),Bw=Kn();function Jw(t,e,n){n=Object.values(arguments).find(o=>Al(o))||1-1e-5;let r=(()=>{let o=Object.values(arguments).filter(i=>Rw(i)||_t(i));if(o.length===1){let i=o[0];if(Bw(i))return _t(i)?i:new Wn(i);{let u=Il(i,null);return _t(u)?u:new Wn(u)}}if(o.length===2){let i=Il(o[0],o[1]);return _t(i)?i:new Wn(i)}throw new Pw("You must pass 1 or 2 2-dimensional arrays or DataFrames into the `getHighlyCorrelatedColumns` function!")})(),s={};return r.values.forEach((o,i)=>{o.forEach((u,a)=>{if(Al(u)&&u>n){let l=r.index[i],f=r.columns[a];s[l]||(s[l]=[]),s[l].indexOf(f)<0&&s[l].push(f),s[f]||(s[f]=[]),s[f].indexOf(l)<0&&s[f].push(l)}})}),Object.keys(s).forEach(o=>{s[o]=Uw(s[o])}),s}Ml.exports=Jw});var Hn=c((m_,kl)=>{var{dropNaN:Yw,isArray:$w,isDataFrame:Lw,isNumber:Gw,isSeries:Kw,pow:Ww,sqrt:Hw,sum:Qw}=x(),Xw=J();function Cl(t){return Lw(t)||Kw(t)?Cl(t.values):Gw(t)?Math.abs(t):$w(t)?(Xw.shouldIgnoreNaNValues&&(t=Yw(t)),Hw(Qw(Ww(t,2)))):NaN}kl.exports=Cl});var Qn=c((d_,Rl)=>{var{assert:zl,DataFrame:Zw,isArray:eN,isSeries:tN,isString:nN,isUndefined:rN,set:sN,shape:oN,sort:iN}=x();function Vl(){if(arguments.length===1&&tN(arguments[0])){let{name:o,values:i}=arguments[0],u=Vl(o,i),a=new Zw(u);return a.index=arguments[0].index.slice(),a}let[t,e]=arguments;zl(nN(t),"When passing two arguments into the `getOneHotEncodings` function, the first argument must be a string representing the name of the variable being encoded!"),zl(eN(e)&&oN(e).length===1,"When passing two arguments into the `getOneHotEncodings` function, the second argument must be a 1-dimensional array!");let n={},r=t+"_"+e[0];return iN(sN(e)).filter(o=>!rN(o)).map(o=>t+"_"+o).filter(o=>o!==r).forEach(o=>{n[o]=e.map(i=>o===t+"_"+i?1:0)}),n}Rl.exports=Vl});var Ul=c((p_,Pl)=>{var{count:uN}=x();function aN(t){return uN(t).map(n=>(n.percentage=n.count/t.length,n))}Pl.exports=aN});var Bl=c((g_,cN)=>{cN.exports=[.5,.49601,.49202,.48803,.48405,.48006,.47608,.4721,.46812,.46414,.46017,.4562,.45224,.44828,.44433,.44038,.4364,.43251,.42858,.42465,.42074,.41683,.41294,.40905,.40517,.40129,.39743,.39358,.38974,.38591,.38209,.37828,.37448,.3707,.36693,.36317,.35942,.35569,.35197,.34827,.34458,.3409,.33724,.3336,.32997,.32636,.32276,.31918,.31561,.31207,.30854,.30503,.30153,.29806,.2946,.29116,.28774,.28434,.28096,.2776,.27425,.27093,.26763,.26435,.26109,.25785,.25463,.25143,.24825,.2451,.24196,.23885,.23576,.2327,.22965,.22663,.22363,.22065,.2177,.21476,.21186,.20897,.20611,.20327,.20045,.19766,.19489,.19215,.18943,.18673,.18406,.18141,.17879,.17619,.17361,.17106,.16853,.16602,.16354,.16109,.15866,.15625,.15386,.15151,.14917,.14686,.14457,.14231,.14007,.13786,.13567,.1335,.13136,.12924,.12714,.12507,.12302,.121,.119,.11702,.11507,.11314,.11123,.10935,.10749,.10565,.10383,.10204,.10027,.09853,.0968,.0951,.09342,.09176,.09012,.08851,.08692,.08534,.08379,.08226,.08076,.07927,.0778,.07636,.07493,.07353,.07215,.07078,.06944,.06811,.06681,.06552,.06426,.06301,.06178,.06057,.05938,.05821,.05705,.05592,.0548,.0537,.05262,.05155,.0505,.04947,.04846,.04746,.04648,.04551,.04457,.04363,.04272,.04182,.04093,.04006,.0392,.03836,.03754,.03673,.03593,.03515,.03438,.03362,.03288,.03216,.03144,.03074,.03005,.02938,.02872,.02807,.02743,.0268,.02619,.02559,.025,.02442,.02385,.0233,.02275,.02222,.02169,.02118,.02068,.02018,.0197,.01923,.01876,.01831,.01786,.01743,.017,.01659,.01618,.01578,.01539,.015,.01463,.01426,.0139,.01355,.01321,.01287,.01255,.01222,.01191,.0116,.0113,.01101,.01072,.01044,.01017,.0099,.00964,.00939,.00914,.00889,.00866,.00842,.0082,.00798,.00776,.00755,.00734,.00714,.00695,.00676,.00657,.00639,.00621,.00604,.00587,.0057,.00554,.00539,.00523,.00508,.00494,.0048,.00466,.00453,.0044,.00427,.00415,.00402,.00391,.00379,.00368,.00357,.00347,.00336,.00326,.00317,.00307,.00298,.00289,.0028,.00272,.00264,.00256,.00248,.0024,.00233,.00226,.00219,.00212,.00205,.00199,.00193,.00187,.00181,.00175,.00169,.00164,.00159,.00154,.00149,.00144,.00139,.00135,.00131,.00126,.00122,.00118,.00114,.00111,.00107,.00104,.001,97e-5,94e-5,9e-4,87e-5,84e-5,82e-5,79e-5,76e-5,74e-5,71e-5,69e-5,66e-5,64e-5,62e-5,6e-4,58e-5,56e-5,54e-5,52e-5,5e-4,48e-5,47e-5,45e-5,43e-5,42e-5,4e-4,39e-5,38e-5,36e-5,35e-5,34e-5,32e-5,31e-5,3e-4,29e-5,28e-5,27e-5,26e-5,25e-5,24e-5,23e-5,22e-5,22e-5,21e-5,2e-4,19e-5,19e-5,18e-5,17e-5,17e-5,16e-5,15e-5,15e-5,14e-5,14e-5,13e-5,13e-5,12e-5,12e-5,11e-5,11e-5,1e-4,1e-4,1e-4,9e-5,9e-5,8e-5,8e-5,8e-5,8e-5,7e-5,7e-5,7e-5,6e-5,6e-5,6e-5,6e-5,5e-5,5e-5,5e-5,5e-5,5e-5,4e-5,4e-5,4e-5,4e-5,4e-5,4e-5,3e-5,3e-5,3e-5,3e-5,3e-5,3e-5,3e-5,3e-5,2e-5,2e-5,2e-5,2e-5]});var Zn=c((q_,Ql)=>{var{abs:Jl,assert:lN,dropNaNPairwise:fN,flatten:Tt,isArray:Yl,isDataFrame:$l,isEqual:hN,isSeries:Ll,mean:Gl,remap:mN,round:dN,shape:Kl,sqrt:pN,std:Wl}=x(),gN=J(),Hl=Bl();function qN(t){return Jl(t)>4.1?0:Hl[dN(mN(Jl(t),0,4.1,0,Hl.length))]}function Xn(t,e){if($l(t)||Ll(t))return Xn(t.values,e);if($l(e)||Ll(e))return Xn(t,e.values);lN(Yl(t)&&Yl(e)&&hN(Kl(t),Kl(e)),"You must pass two identically-shaped arrays, Series, or DataFrames into the `pValue` function!");let[n,r]=gN.shouldIgnoreNaNValues?fN(Tt(t),Tt(e)):[Tt(t),Tt(e)];if(n.length===0||r.length===0)return NaN;let s=Gl(n),o=Gl(r),i=Wl(n),u=Wl(r),a=n.length,l=r.length,f=(s-o)/pN(i*i/a+u*u/l);return 2*qN(f)}Ql.exports=Xn});var nf=c((y_,tf)=>{var{assert:er,clamp:yN,DataFrame:Ot,dropNaNPairwise:bN,isArray:Xl,isDataFrame:Ft,isJagged:Zl,isUndefined:wN,ndarray:NN}=x(),vN=J(),ef=Zn();function tr(t){let e="@jrc03c/js-data-science-helpers/get-p-value-matrix";return Object.defineProperty(t,e,{configurable:!1,enumerable:!1,writable:!1,value:Symbol.for(e)}),t}function nr(t,e){if(wN(e)&&(e=t),Ft(t)){let r=new Ot(nr(t.values,e));return r.index=t.columns.slice(),r.columns=Ft(e)?e.columns.slice():new Ot(e).columns.slice(),tr(r)}if(Ft(e)){let r=new Ot(nr(t,e.values));return r.index=Ft(t)?t.columns.slice():new Ot(t).columns.slice(),r.columns=e.columns.slice(),tr(r)}er(Xl(t)&&Xl(e),"The `getPValueMatrix` function only works on 2-dimensional arrays and DataFrames!"),er(!Zl(t)&&!Zl(e),"The `getPValueMatrix` function only works on non-jagged 2-dimensional arrays and DataFrames!"),er(t.length===e.length,'The dimensions of the matrices you passed into the `getPValueMatrix` function aren\'t compatible! ([shape(a).join(", ")] vs. [shape(b).join(", ")]) The function expects that you\'ll be comparing the columns of two matrices where the columns are all of the same length, so please make sure that the matrices are oriented accordingly.');let n=NN([t[0].length,e[0].length]);for(let r=0;r<t[0].length;r++){let s=t.map(o=>o[r]);for(let o=0;o<e[0].length;o++){let i=e.map(u=>u[o]);vN.shouldIgnoreNaNValues?n[r][o]=ef(...bN(s,i)):n[r][o]=ef(s,i)}}return tr(yN(n,0,1))}tf.exports=nr});var af=c((b_,uf)=>{var{assert:Dt,intersect:SN,isDataFrame:rf,isSeries:sf,isUndefined:of}=x(),pe=class{constructor(e){let n=this;Dt(of(e)||e===pe.DROP_NAN_MODE||e===pe.DROP_MISSING_MODE,"The `mode` value passed into the `IndexMatcher` constructor must be undefined or one of [IndexMatcher.DROP_NAN_MODE, IndexMatcher.DROP_MISSING_MODE]! (By default, the mode is `Indexer.DROP_MISSING_MODE`.)"),n.mode=of(e)?pe.DROP_MISSING_MODE:e,n.index=null}fit(){let e=this,n=[];return Object.values(arguments).forEach(r=>{Dt(rf(r)||sf(r),"The `IndexMatcher` only works on Series and DataFrames! To drop NaN values in a pair-wise fashion from regular arrays, use the `dropNaNPairwise` function from the @jrc03c/js-math-tools library."),e.mode===pe.DROP_MISSING_MODE?n.push(r.dropMissing().index):n.push(r.dropNaN().index)}),e.index=SN(...n),e}transform(){let e=this;Dt(!!e.index,"The IndexMatcher hasn't been fitted yet! Please call the `fit` method before calling the `transform` method.");let n=Object.values(arguments).map(r=>(Dt(rf(r)||sf(r),"The `IndexMatcher` only works on Series and DataFrames! To drop NaN values in a pair-wise fashion from regular arrays, use the `dropNaNPairwise` function from the @jrc03c/js-math-tools library."),r.get(e.index,null)));return n.length===1?n[0]:n}fitAndTransform(){return this.fit(...arguments).transform(...arguments)}},Ce=pe;zt(Ce,"DROP_NAN_MODE","DROP_NAN_MODE"),zt(Ce,"DROP_MISSING_MODE","DROP_MISSING_MODE");uf.exports=Ce});var or=c((w_,lf)=>{var{apply:xN,assert:_N,count:TN,flatten:ON,float:FN,isArray:rr,isDataFrame:DN,isNumber:EN,isSeries:AN,isString:IN}=x(),cf=["null","none","nan","na","n/a","","undefined"],MN=["true","false","yes","no"];function jN(t,e){if(t===void 0&&(t="undefined"),e==="null")return null;if(e==="number"){let n=FN(t);return isNaN(n)?NaN:n}if(e==="boolean"){try{let n=t.trim().toLowerCase();if(n==="true"||n==="yes")return!0;if(n==="false"||n==="no")return!1}catch{}return null}if(e==="date"){let n=new Date(t);return n.toString()==="Invalid Date"?null:n}if(e==="object")try{let n=JSON.parse(t);return rr(n)?null:n}catch{return null}if(e==="string"){try{if(cf.indexOf(t.trim().toLowerCase())>-1)return null}catch{return null}return t}}function sr(t){if(DN(t)){let s=t.copy(),o=sr(t.values);return s.values=o.values,{type:o.type,values:s}}if(AN(t)){let s=t.copy(),o=sr(t.values);return s.values=o.values,{type:o.type,values:s}}_N(rr(t),"The `inferType` function only works on arrays, Series, and DataFrames!");let e=ON(t).map(s=>{if(s===void 0)return"null";IN(s)||(s=JSON.stringify(s));let i=s.toLowerCase().trim();if(cf.indexOf(i)>-1)return"null";if(MN.indexOf(i)>-1)return"boolean";try{let u=JSON.parse(s);return EN(u)?"number":typeof u=="object"?rr(u)?"string":"object":"string"}catch{return new Date(s).toString()!=="Invalid Date"?"date":"string"}}),r=TN(e).sort((s,o)=>o.count-s.count)[0].item;return{type:r,values:xN(t,s=>jN(s,r))}}lf.exports=sr});var ur=c((N_,pf)=>{var{assert:ir,isArray:CN,isBoolean:kN,isDataFrame:ff,isSeries:hf,int:zN,isNumber:VN,isUndefined:mf,range:df,set:RN,shape:PN,shuffle:UN}=x();pf.exports=function(){let e=Array.from(arguments),n=e.find(g=>kN(g)),r=mf(n)?!0:n,s=e.find(g=>VN(g)),o=mf(s)?.1:s;ir(o>0&&o<1,"`testSize` must be a number between 0 and 1 (exclusive on both ends)!");let i=e.filter(g=>CN(g)||ff(g)||hf(g));ir(i.length>0,"You must pass at least one dataset into the `trainTestSplit` function!");let u=i.map(g=>PN(g)[0]);ir(RN(u).length===1,`All datasets passed into the \`trainTestSplit\` function must be the same length at their shallowest dimension! The lengths of your datasets, though, are: ${u.join(", ")}`);let a=[],l=r?UN(df(0,u[0])):df(0,u[0]),f=zN((1-o)*l.length),h=l.slice(0,f),d=l.slice(f);return i.forEach(g=>{if(ff(g))a.push(g.get(h,null)),a.push(g.get(d,null));else if(hf(g))a.push(g.get(h)),a.push(g.get(d));else{let v=[],N=[];g.forEach((D,k)=>{h.indexOf(k)>-1?v.push(D):N.push(D)}),a.push(v),a.push(N)}}),a}});var At=c((v_,Nf)=>{var{add:BN,argmin:JN,assert:YN,flatten:gf,isArray:$N,isDataFrame:qf,isEqual:LN,int:GN,isNumber:KN,isSeries:yf,normal:ar,pow:WN,random:HN,range:QN,scale:XN,shape:Et,subtract:ZN,sum:ev}=x(),tv=ur();function cr(t,e){(qf(t)||yf(t))&&(t=t.values),(qf(e)||yf(e))&&(e=e.values),YN(LN(Et(t),Et(e)),"`yPred` and `yTrue` must have the same shape!");let n=gf(t),r=gf(e),s=0;return n.forEach((o,i)=>{o===r[i]&&s++}),s/n.length}function nv(t){test(`tests that the \`${t.name}\` model works correctly`,()=>{let e=ar([5,10]).map(h=>h.map(d=>d*100+ar()*100)),n=[],r=QN(0,500).map(()=>{let h=GN(HN()*e.length),d=e[h];return n.push(h),BN(d,XN(5,ar(Et(d))))}),[s,o,i,u]=tv(r,n),a=new t({k:e.length});a.fit(s),a.centroids=bf(e,a.centroids);let l=a.predict(s),f=a.predict(o);expect(cr(i,l)).toBeGreaterThan(.95),expect(cr(u,f)).toBeGreaterThan(.95)})}function rv(t){return $N(t)&&Et(t).length===2}function sv(t){return KN(t)&&parseInt(t)===t&&t>=0}function bf(t,e){return t.map(n=>e[JN(e.map(r=>wf(n,r)))])}function wf(t,e){return ev(WN(ZN(t,e),2))}Nf.exports={accuracy:cr,createGenericTest:nv,isMatrix:rv,isWholeNumber:sv,orderCentroids:bf,sse:wf}});var hr=c((S_,_f)=>{var{add:vf,argmin:ov,assert:ie,copy:iv,distance:Sf,divide:uv,isDataFrame:av,isFunction:cv,isUndefined:It,normal:lv,random:fv,range:hv,scale:mv,shuffle:dv,zeros:xf}=x(),{isMatrix:pv,isWholeNumber:lr,sse:gv}=At(),fr=class{constructor(e){ie(typeof e=="object","`config` must be an object! See the documentation for more information about the properties that the `config` object can contain."),ie(lr(e.k),"`k` must be a whole number!"),ie(lr(e.maxIterations)||It(e.maxIterations),"`maxIterations` must be a whole number or undefined!"),ie(lr(e.maxRestarts)||It(e.maxRestarts),"`maxRestarts` must be a whole number or undefined!"),ie(typeof e.tolerance=="number"||It(e.tolerance),"`tolerance` must be a number or undefined!");let n=this;n.k=e.k,n.maxRestarts=e.maxRestarts||25,n.maxIterations=e.maxIterations||100,n.tolerance=e.tolerance||1e-4,n.centroids=null,n._fitState=null}initializeCentroids(e){let n=this;return dv(e).slice(0,n.k)}fitStep(e,n){let r=this;if(ie(pv(e),"`x` must be a matrix!"),av(e)&&(e=e.values),It(n)||ie(cv(n),"If defined, `progress` must be a function!"),r._fitState){if(r._fitState.isFinished)return r}else{let a=r.initializeCentroids(e);r._fitState={currentRestart:0,currentIteration:0,currentCentroids:a,bestCentroids:a,bestScore:-1/0,isFinished:!1}}let s=r.predict(e,r._fitState.currentCentroids),o=[],i=xf(r.k);e.forEach((a,l)=>{let f=s[l];o[f]||(o[f]=xf(a.length)),o[f]=vf(o[f],a),i[f]++});let u=hv(0,r.k).map(a=>i[a]===0?vf(r._fitState.currentCentroids[parseInt(fv()*r._fitState.currentCentroids.length)],mv(.001,lv(r._fitState.currentCentroids[0].length))):uv(o[a],i[a]));if(Sf(r._fitState.currentCentroids,u)<r.tolerance?r._fitState.currentIteration=r.maxIterations-1:r._fitState.currentCentroids=u,n&&n((r._fitState.currentRestart+r._fitState.currentIteration/r.maxIterations)/r.maxRestarts,r),r._fitState.currentIteration++,r._fitState.currentIteration>=r.maxIterations){let a=r.score(e,r._fitState.currentCentroids);if(a>r._fitState.bestScore&&(r._fitState.bestScore=a,r._fitState.bestCentroids=iv(r._fitState.currentCentroids)),r._fitState.currentIteration=0,r._fitState.currentRestart++,r._fitState.currentRestart>=r.maxRestarts)r._fitState.isFinished=!0,r.centroids=r._fitState.bestCentroids,n&&n(1,r);else{let l=r.initializeCentroids(e);r._fitState.currentCentroids=l}}return r}fit(e,n){let r=this;for(r._fitState&&(r._fitState=null);!r._fitState||!r._fitState.isFinished;)r.fitStep(e,n);return r}predict(e,n){if(n=n||this.centroids,!n)throw new Error("No centroids were provided to the `predict` method, and the K-Means model hasn't been fitted yet. Please either pass centroids as a second parameter to the `predict` method or run the `fit` method first!");return e.map(s=>ov(n.map(o=>Sf(s,o))))}score(e,n){let r=this;if(n=n||r.centroids,!n)throw new Error("No centroids were provided to the `score` method, and the K-Means model hasn't been fitted yet. Please either pass centroids as a second parameter to the `score` method or run the `fit` method first!");let o=r.predict(e,n).map(i=>n[i]);return-gv(e,o)}};_f.exports=fr});var dr=c((x_,Ff)=>{var{argmin:qv,distance:Tf,divide:yv,max:bv,random:Of}=x(),wv=hr(),mr=class extends wv{initializeCentroids(e){let n=this,r=[e[parseInt(Of()*e.length)]];for(;r.length<n.k;){let s=e.map(i=>Tf(i,r[qv(r.map(u=>Tf(i,u)))])),o=yv(s,bv(s));r.push(e[o.findIndex(i=>Of()<i)])}return r}};Ff.exports=mr});var Af=c((__,Ef)=>{var{assert:$,isArray:Nv,isDataFrame:vv,isEqual:Sv,isFunction:xv,isUndefined:ge,range:_v,shape:Df}=x(),{isMatrix:Tv,isWholeNumber:pr}=At(),Ov=dr(),gr=class{constructor(e){ge(e)&&(e={}),$(typeof e=="object","`config` must be an object! See the documentation for more information about the properties that the `config` object can contain."),ge(e.ks)&&(e.ks=_v(1,16)),$(Nv(e.ks),"`ks` must be an array of whole numbers!"),e.ks.forEach(r=>{$(pr(r),"`ks` must be an array of whole numbers!")}),$(pr(e.maxIterations)||ge(e.maxIterations),"`maxIterations` must be a whole number or undefined!"),$(pr(e.maxRestarts)||ge(e.maxRestarts),"`maxRestarts` must be a whole number or undefined!"),$(typeof e.tolerance=="number"||ge(e.tolerance),"`tolerance` must be a number or undefined!");let n=this;n.ks=e.ks,n.maxRestarts=e.maxRestarts||25,n.maxIterations=e.maxIterations||100,n.tolerance=e.tolerance||1e-4,n.scoreStopRatio=e.scoreStopRatio||.85,n.modelClass=e.modelClass||Ov,n.fittedModel=null,n._fitState=null}fitStep(e,n){let r=this;if($(Tv(e),"`x` must be a matrix!"),vv(e)&&(e=e.values),ge(n)||$(xv(n),"If defined, `progress` must be a function!"),!r._fitState)r._fitState={isFinished:!1,lastScore:-1/0,currentIndex:0};else if(r._fitState.isFinished)return r;let s=r.ks[r._fitState.currentIndex],o=new r.modelClass({k:s,maxRestarts:10,maxIterations:20});o.fit(e,u=>n?n((r._fitState.currentIndex+u)/(r.ks.length+1)):null);let i=o.score(e);return i/r._fitState.lastScore>r.scoreStopRatio?(r._fitState.isFinished=!0,r._fitState.currentIndex--):(r._fitState.lastScore=i,r._fitState.currentIndex+1>=r.ks.length?r._fitState.isFinished=!0:r._fitState.currentIndex++),r._fitState.isFinished&&(r.fittedModel=new r.modelClass({k:r.ks[r._fitState.currentIndex],maxRestarts:r.maxRestarts,maxIterations:r.maxIterations}),r.fittedModel.fit(e,u=>n?n((r.ks.length+u)/(r.ks.length+1)):null),n&&n(1)),r}fit(e,n){let r=this;for(r._fitState=null;!r._fitState||!r._fitState.isFinished;)r.fitStep(e,n);return r}predict(e,n){return this.fittedModel.predict(e,n)}score(e,n){return this.fittedModel.score(e,n)}get k(){return this.fittedModel.k}set k(e){throw new Error("You can't set the k-value manually! It has to be set automatically via the `fit` method.")}get centroids(){return this.fittedModel.centroids}set centroids(e){let n=this;$(Sv(Df(e),Df(n.fittedModel.centroids)),"When assigning a new value to the `centroids` property, the new centroids must have the same shape as the old centroids!"),n.fittedModel.centroids=e}};Ef.exports=gr});var Mf=c((T_,If)=>{If.exports={KMeansMeta:Af(),KMeansNaive:hr(),KMeansPlusPlus:dr(),helpers:At()}});var qr=c((O_,Rf)=>{var{apply:Fv,assert:Dv,dropNaN:jf,isArray:Ev,isDataFrame:Av,isSeries:Iv,mean:Cf,std:kf}=x(),zf=J();function Vf(t){if(Av(t)||Iv(t)){let r=t.copy();return r.values=Vf(r.values),r}Dv(Ev(t),"The `normalize` function only works on arrays, Series, and DataFrames!");let e=(()=>zf.shouldIgnoreNaNValues?Cf(jf(t)):Cf(t))(),n=(()=>zf.shouldIgnoreNaNValues?kf(jf(t)):kf(t))();return n===0?t:Fv(t,r=>(r-e)/n)}Rf.exports=Vf});var br=c((F_,Yf)=>{var{assert:qe,dot:Pf,isArray:Uf,isSeries:yr,scale:Mv,Series:jv,shape:Bf}=x(),Jf=de();function Mt(t,e){if(yr(t)){if(yr(e))return new jv(Mt(t.values,e.values));{let n=t.copy();return n.values=Mt(t.values,e),n}}if(yr(e)){let n=e.copy();return n.values=Mt(t,e.values),n}return qe(Uf(t),"`project` only works on vectors!"),qe(Uf(e),"`project` only works on vectors!"),qe(Jf(t),"`project` only works on vectors of numbers!"),qe(Jf(e),"`project` only works on vectors of numbers!"),qe(Bf(t).length===1,"`project` only works on vectors!"),qe(Bf(e).length===1,"`project` only works on vectors!"),Mv(Pf(e,t)/Pf(e,e),e)}Yf.exports=Mt});var Wf=c((D_,Kf)=>{var{assert:$f,copy:Cv,DataFrame:kv,divide:zv,isArray:Vv,isDataFrame:Rv,isJagged:Pv,shape:Uv,subtract:Bv,transpose:Lf}=x(),Jv=de(),Yv=Hn(),$v=br();function Gf(t){if(Rv(t)){let s=new kv(Gf(t.values));return s.index=t.index.slice(),s.columns=t.columns.slice(),s}$f(Vv(t)&&!Pv(t)&&Uv(t).length===2,"`orthonormalize` only works on matrices!"),$f(Jv(t),"`orthonormalize` only works on matrices of numbers!");let e=Lf(t),n=[];e.forEach(s=>{let o=Cv(s);n.forEach(i=>{o=Bv(o,$v(o,i))}),n.push(o)});let r=n.map(s=>zv(s,Yv(s)));return Lf(r)}Kf.exports=Gf});var nh=c((E_,th)=>{var{assert:Hf,copy:Lv,correl:Gv,DataFrame:Qf,dropMissing:Kv,isArray:Wv,isDataFrame:Hv,isEqual:Qv,isJagged:Xv,isNumber:Xf,set:Zv,shape:eS,transpose:Zf}=x(),tS=Un(),nS=Qn(),rS=or();function eh(t,e,n){if(e=Xf(e)?e:7,n=Xf(n)?n:1-1e-5,Wv(t))return Hf(eS(t).length===2&&!Xv(t),"The `preprocess` function only works on non-jagged 2-dimensional arrays and DataFrames!"),eh(new Qf(t));Hf(Hv(t),"You must pass a DataFrame into the `preprocess` function!");let r={};t=t.apply(l=>{let f=rS(l.values);return r[l.name]=f.type,f.values});let s=Lv(t.columns),o=Zf(t.values),i=0,u=!1;for(;!u;){let l=o[i];for(let f=i+1;f<o.length;f++){let h=o[f];Qv(l,h)&&(s.splice(f,1),o.splice(f,1))}i++,u=i>=s.length-1}for(i=0,u=!1;!u;){let l=s[i],f=o[i];if(!f)break;let h=Kv(f);if(h.length<15){s.splice(i,1),o.splice(i,1);continue}let d=Zv(h);if(d.length===1){s.splice(i,1),o.splice(i,1);continue}let g=r[l];if(g==="string"){if(d.length<=e){let v=nS(l,f);Object.keys(v).forEach(N=>{s.push(N),o.push(v[N]),r[N]="number"}),s.splice(i,1),o.splice(i,1);continue}}else if(g==="number"){let v=tS(f);o[i]=v;let N=!1;for(let D=0;D<i;D++){let k=o[D];if(Gv(f,k)>n){s.splice(i,1),o.splice(i,1),N=!0;break}}if(N)continue}else{o.splice(i,1),s.splice(i,1);continue}i++,u=i>=s.length}let a=new Qf(Zf(o));return a.columns=s,a}th.exports=eh});var hh=c((A_,fh)=>{var{abs:sS,add:oS,assert:ke,isArray:rh,isDataFrame:sh,isEqual:iS,isSeries:oh,mean:uS,pow:ih,scale:aS,shape:uh,sign:cS,sqrt:lS,sum:ah}=x(),ch=de(),lh=(t,e)=>oS(t,aS(e,-1));function wr(t,e){if(sh(t)||oh(t))return wr(t.values,e);if(sh(e)||oh(e))return wr(t,e.values);ke(rh(t),"You must pass two same-shaped numerical arrays into the `rScore` function!"),ke(rh(e),"You must pass two same-shaped numerical arrays into the `rScore` function!"),ke(iS(uh(t),uh(e)),"You must pass two same-shaped numerical arrays into the `rScore` function!"),ke(ch(t),"You must pass two same-shaped numerical arrays into the `rScore` function!"),ke(ch(e),"You must pass two same-shaped numerical arrays into the `rScore` function!");let n=ah(ih(lh(t,e),2)),r=ah(ih(lh(t,uS(t)),2));if(r===0)return NaN;let s=1-n/r;return cS(s)*lS(sS(s))}fh.exports=wr});var qh=c((I_,gh)=>{var{argmax:mh,assert:ze,copy:fS,DataFrame:hS,dot:mS,isArray:dS,isDataFrame:pS,isEqual:dh,isJagged:gS,max:qS,min:yS,reverse:bS,shape:wS,transpose:NS}=x();function ph(t){if(dS(t)){ze(wS(t).length===2&&!gS(t),"The `sortCorrelationMatrix` function only works on 2-dimensional arrays and DataFrames!");let s=new hS(t);return s.index=s.columns.slice(),ph(s).values}ze(pS(t),"You must pass a DataFrame into the `sortCorrelationMatrix` function!"),ze(qS(t.values)<=1&&yS(t.values)>=-1,"The correlation matrix passed into the `sortCorrelationMatrix` function must not contain values less than -1 or greater than 1!"),ze(dh(t.values,NS(t.values)),"The correlation matrix passed into the `sortCorrelationMatrix` function must be symmetrical!"),ze(dh(t.index,t.columns),"The correlation matrix passed into the `sortCorrelationMatrix` function must be symmetrical! (In this case, although the values themselves are symmetrical, the row and column names differ.)");let e=fS(t.index),n=[];for(;e.length>0;)if(n.length===0){let s=mh(t.values.map(o=>mS(o,o)));n.push(e[s]),e.splice(s,1)}else{let s=t.index.indexOf(n.at(-1)),o=mh(e.map(u=>t.values[t.index.indexOf(u)][s])),i=e[o];n.push(i),e.splice(o,1)}let r=bS(n);return t.get(r,r)}gh.exports=ph});var bh=c((M_,yh)=>{var vS=qr();function SS(){return vS(...arguments)}yh.exports=SS});var Fh=c((j_,Oh)=>{var{assert:jt,DataFrame:wh,dropNaN:xS,flatten:Nh,isArray:_S,isDataFrame:Nr,isSeries:vr,mean:vh,range:TS,Series:Sh,shape:xh,stdev:_h,transpose:Th}=x(),OS=J(),Sr=class{constructor(){let e=this;e.means=[],e.stdevs=[],e.wasFittedOnAVector=!1,e.hasBeenFitted=!1}_getDataArrayAndShape(e){if(Nr(e))return[e.values,e.shape];if(vr(e)){let r=Th([e.values]);return[r,xh(r)]}jt(_S(e),"`x` must be a 1- or 2-dimensional array, DataFrame, or Series!");let n=xh(e);return jt(n.length<3,"`x` must be a 1- or 2-dimensional array, DataFrame, or Series!"),n.length===1&&(n.push(1),e=Th([e])),[e,n]}fit(e){let n=this,r=n._getDataArrayAndShape(e);e=r[0];let s=r[1];return n.wasFittedOnAVector=s.indexOf(1)>-1,n.means=[],n.stdevs=[],TS(0,s[1]).forEach(o=>{let i=e.map(u=>u[o]);if(OS.shouldIgnoreNaNValues){let u=xS(i);n.means.push(vh(u)),n.stdevs.push(_h(u))}else n.means.push(vh(i)),n.stdevs.push(_h(i))}),n.hasBeenFitted=!0,n}transform(e){let n=this;if(!n.hasBeenFitted)throw new Error("This `StandardScaler` instance hasn't been trained on any data yet! Please use the `fit` method to train it before calling the `transform` method.");if(Nr(e)){let i=new wh(n.transform(e.values));return i.columns=e.columns,i.index=e.index,i}if(vr(e)){let i=new Sh(n.transform(e.values));return i.name=e.name,i.index=e.index,i}let r=n._getDataArrayAndShape(e);e=r[0];let s=r[1];jt(s[1]===n.means.length,"The data you passed into the `transform` function doesn't have the same number of columns as the data set on which this StandardScaler was fitted!");let o=e.map(i=>i.map((u,a)=>(u-n.means[a])/n.stdevs[a]));return n.wasFittedOnAVector?Nh(o):o}untransform(e){let n=this;if(!n.hasBeenFitted)throw new Error("This `StandardScaler` instance hasn't been trained on any data yet! Please use the `fit` method to train it before calling the `transform` method.");if(Nr(e)){let i=new wh(n.untransform(e.values));return i.columns=e.columns,i.index=e.index,i}if(vr(e)){let i=new Sh(n.untransform(e.values));return i.name=e.name,i.index=e.index,i}let r=n._getDataArrayAndShape(e);e=r[0];let s=r[1];jt(s[1]===n.means.length,"The data you passed into the `untransform` function doesn't have the same number of columns as the data set on which this StandardScaler was fitted!");let o=e.map(i=>i.map((u,a)=>u*n.stdevs[a]+n.means[a]));return n.wasFittedOnAVector?Nh(o):o}};Oh.exports=Sr});var DS=c((C_,Eh)=>{var{MathError:FS}=x(),Dh={clipOutliers:Un(),cohensD:Jn(),cohensd:Jn(),common:J(),containsOnlyNumbers:de(),diagonalize:_l(),getCorrelationMatrix:Gn(),getHighlyCorrelatedColumns:jl(),getMagnitude:Hn(),getOneHotEncodings:Qn(),getPercentages:Ul(),getPValueMatrix:nf(),IndexMatcher:af(),inferType:or(),isBinary:Pn(),isCorrelationMatrix:Kn(),KMeans:Mf(),normalize:qr(),orthonormalize:Wf(),preprocess:nh(),project:br(),pValue:Zn(),rScore:hh(),sortCorrelationMatrix:qh(),standardize:bh(),StandardScaler:Fh(),trainTestSplit:ur(),dump(){let t=this,e=typeof global<"u"?global:typeof window<"u"?window:null;if(!e)throw new FS("Cannot dump functions into global scope because neither `global` nor `window` exist in the current context!");Object.keys(t).forEach(n=>{try{Object.defineProperty(e,n,{configurable:!1,enumerable:!0,writable:!1,value:t[n]})}catch{e[n]=t[n]}})}};try{window.JSDataScienceHelpers=Dh}catch{}try{Eh.exports=Dh}catch{}});DS();})();
