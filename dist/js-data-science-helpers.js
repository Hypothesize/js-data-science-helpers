(()=>{var pe=(t=>typeof require!="undefined"?require:typeof Proxy!="undefined"?new Proxy(t,{get:(e,n)=>(typeof require!="undefined"?require:e)[n]}):t)(function(t){if(typeof require!="undefined")return require.apply(this,arguments);throw new Error('Dynamic require of "'+t+'" is not supported')});var c=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports);var Y=c((t1,On)=>{var qt=class extends Error{constructor(e){typeof window<"u"?super(e):super(`

\x1B[31m`+e+`
\x1B[0m`)}};On.exports=qt});var p=c((n1,Sn)=>{var fl=Y();Sn.exports=function(t,e){if(!t)throw new fl(e)}});var g=c((r1,An)=>{function hl(t){return t===null||typeof t>"u"}An.exports=hl});var y=c((s1,En)=>{function ml(t){return t instanceof Array}En.exports=ml});var T=c((o1,Vn)=>{var Mn=p(),pl=g(),jn=y();function In(t){Mn(!pl(t),"You must pass one array into the `flatten` function!"),Mn(jn(t),"The `flatten` function only works on arrays!");let e=[];return t.forEach(function(n){jn(n)?e=e.concat(In(n)):e.push(n)}),e}Vn.exports=In});var ne=c((u1,Un)=>{var i1=y();function Cn(t,e){let n=typeof t;if(n!==typeof e)return!1;if(n==="undefined")return!0;if(n==="boolean"||n==="number"||n==="bigint"||n==="string"||n==="function")return t===e;if(n==="object"){if(t===null||e===null)return t===null&&e===null;{let s=Object.keys(t),o=Object.keys(e);if(s.length!==o.length)return!1;for(let i=0;i<s.length;i++){let u=s[i];if(!e.hasOwnProperty(u)||!Cn(t[u],e[u]))return!1}return!0}}}Un.exports=Cn});var F=c((a1,kn)=>{var Yn=p(),dl=g(),gl=y(),ql=T();function yl(t){Yn(!dl(t),"You must pass an array into the `set` function!"),Yn(gl(t),"You must pass an array into the `set` function!");let e=[],n={};return ql(t).forEach(r=>{let s=typeof r>"u"?"undefined":typeof r=="function"?r.toString():JSON.stringify(r);n[s]||e.push(r),n[s]=!0}),e}kn.exports=yl});var Ce=c((c1,_n)=>{var zn=p(),Pn=g(),Bn=y(),Fn=T(),bl=ne(),wl=F();function Nl(t,e){zn(!Pn(t),"You must pass an array and some items to count into the `count` function!"),zn(Bn(t),"You must pass an array and some items to count into the `count` function!");let n=Fn(t);return e=Pn(e)?wl(t):e,Bn(e)?Fn(e).map(function(r){let s=n.filter(o=>bl(r,o)).length;return{item:r,count:s}}):n.filter(r=>r===e).length}_n.exports=Nl});var V=c((h1,Jn)=>{var l1=p(),f1=g(),xl=y();function vl(t){function e(n,r){if(r=r||[],r.indexOf(n)>-1)return"<cyclic reference>";if(typeof n=="object"){if(n===null)return null;if(r.push(n),xl(n))return n.map(s=>e(s,r));{let s={};return Object.keys(n).forEach(o=>{s[o]=e(n[o],r)}),s}}else return n}return e(t)}Jn.exports=vl});var d=c((m1,$n)=>{function Tl(t){return typeof t=="number"&&!isNaN(t)}$n.exports=Tl});var D=c((p1,Wn)=>{var Ol=T(),Sl=d();function Al(t){try{let e=Ol(t),n=-1/0;for(let r=0;r<e.length;r++){if(!Sl(e[r]))return NaN;e[r]>n&&(n=e[r])}return n===-1/0?NaN:n}catch{return NaN}}Wn.exports=Al});var N=c((d1,Ln)=>{var Ue=p(),El=g(),Dn=y(),Ml=D();function Rn(t){Ue(!El(t),"You must pass an array into the `shape` function!"),Ue(Dn(t),"You must pass an array into the `shape` function!");let e=[t.length],n=t.map(r=>Dn(r));if(n.indexOf(!0)>-1){Ue(n.indexOf(!1)<0,"The array passed into the `shape` function has some children that are not themselves arrays!");let r=t.map(o=>o.length),s=Ml(r);r.forEach(function(o){Ue(o===s,"The array passed into the `shape` function has some children of inconsistent length!")}),e=e.concat(Rn(t[0]))}return e}Ln.exports=Rn});var j=c((g1,Gn)=>{function jl(t){return typeof t=="function"}Gn.exports=jl});var k=c((q1,Kn)=>{var yt=p(),Hn=g(),Il=y(),Vl=j();function Cl(t,e){return t<e?-1:t>e?1:0}function Ul(t,e){Hn(e)&&(e=Cl),yt(!Hn(t),"You must pass an array into the `sort` function!"),yt(Il(t),"You must pass an array into the `sort` function!"),yt(Vl(e),"The second parameter of the `sort` function must be a comparison function!");let n=t.slice();return n.sort(e),n}Kn.exports=Ul});var tr=c((y1,er)=>{var Ye=p(),Qn=V(),Yl=y(),Xn=ne(),Zn=Y(),kl=N(),ke=k();function bt(t,e,n,r){if(r instanceof e){Ye(Xn(ke(n.columns),ke(r.index)),"The index of the incoming Series must match the columns of the target DataFrame!");let s=Qn(n.values);s.push(n.columns.map(u=>r.get(u)));let o=new t(s);o.columns=n.columns;let i=!0;return o.resetIndex(i)}else if(r instanceof t){Ye(Xn(ke(n.columns),ke(r.columns)),"The columns of the incoming DataFrame must match the columns of the target DataFrame!");let s=Qn(n.values);r.values.forEach(u=>{s.push(n.columns.map(a=>{let f=r.columns.indexOf(a);return u[f]}))});let o=new t(s);o.columns=n.columns;let i=!0;return o.resetIndex(i)}else if(Yl(r)){let s=kl(r);if(s.length===1){Ye(r.length===n.columns.length,"When passing a 1-dimensional array into the `append` method, the array must have the same length as the number of columns in the target DataFrame!");let o=new e(r);return o.index=n.columns,bt(t,e,n,o)}else if(s.length===2){Ye(s[1]===n.columns.length,"When passing a 2-dimensional array into the `append` method, each row of the array must have the same length as the number of columns in the target DataFrame!");let o=new t(r);return o.columns=n.columns,bt(t,e,n,o)}else throw new Zn("When passing an array into the `append` method, the array must be 1- or 2-dimensional! If 1-dimensional, it must be as long as the number of columns in the target DataFrame. If 2-dimensional, each row must be as long as the number of columns in the target DataFrame.")}else throw new Zn("Only Series, DataFrames, and 1- or 2-dimensional arrays can be passed into the `append` method!")}er.exports=bt});var ir=c((b1,or)=>{var nr=p(),zl=j(),rr=y(),sr=g();function Pl(t,e,n,r,s){if(s=s||0,nr(zl(r),"The first parameter to the `apply` method must be a function."),nr(s===0||s===1,"The second parameter to the `apply` method (the `axis`) must be 0 or 1."),s===0){let o={},i;if(n.columns.forEach((u,a)=>{let f=new e(n.values.map(m=>m[a]));f.name=u,f.index=n.index;let l=r(f,a,n);l instanceof e?o[u]=l.values:o[u]=l,sr(i)&&(i=l instanceof e||rr(l))}),i){let u=new t(o);return u.index=n.index,u}else{let u=new e(n.columns.map(a=>o[a]));return u.index=n.columns,u}}else if(s===1){let o,i=n.values.map((u,a)=>{let f=new e(u);f.name=n.index[a],f.index=n.columns;let l=r(f,a,n);return sr(o)&&(o=l instanceof e||rr(l)),l instanceof e?l.values:l});if(o){let u=new t(i);return u.index=n.index,u.columns=n.columns,u}else{let u=new e(i);return u.index=n.index,u}}}or.exports=Pl});var R=c((w1,ur)=>{var Bl=y(),Fl=g();function _l(t){return typeof t=="object"&&!Fl(t)&&!Bl(t)}ur.exports=_l});var S=c((N1,ar)=>{function Jl(t){return typeof t=="string"}ar.exports=Jl});var hr=c((x1,fr)=>{var L=p(),cr=y(),$l=R(),Wl=S(),Dl=g(),lr=N(),Rl=V(),wt=Y(),Ll=k();function Gl(t,e,n,r,s){let o=h=>h instanceof e,i=(()=>{let h={};if(Dl(s))if(o(r)){let q=n.index.map(b=>r.get(b));L(q.length===n.index.length,"Each column of values to be assigned must have the same length as the number of rows in the target DataFrame!"),h[r.name]=q}else if($l(r))Object.keys(r).forEach(q=>{let b=r[q];if(o(b)){let E=n.index.map($=>b.get($));L(E.length===n.index.length,"Each column of values to be assigned must have the same length as the number of rows in the target DataFrame!"),h[q]=E}else if(cr(b))L(lr(b).length===1,"When using a single argument for the `assign` method, the argument must be either (1) a Series, or (2) an object consisting of key-value pairs where each key is a string representing a column name and each value is a one-dimensional array or Series!"),L(b.length===n.index.length,"Each column of values to be assigned must have the same length as the number of rows in the target DataFrame!"),h[q]=b;else throw new wt("When using a single argument for the `assign` method, the argument must be either (1) a Series, or (2) an object consisting of key-value pairs where each key is a string representing a column name and each value is a one-dimensional array or Series!")});else throw new wt("When using a single argument for the `assign` method, the argument must be either (1) a Series, or (2) an object consisting of key-value pairs where each key is a string representing a column name and each value is a one-dimensional array or Series!");else if(L(Wl(r),"When using two arguments for the `assign` method, the first argument must be a string representing a column name, and the second argument must be a one-dimensional array or Series!"),o(s)){let q=n.index.map(b=>s.get(b));L(q.length===n.index.length,"The one-dimensional array or Series to be assigned must have the same length as the number of rows in the target DataFrame!"),h[r]=q}else if(cr(s))L(lr(s).length===1,"When using two arguments for the `assign` method, the first argument must be a string representing a column name, and the second argument must be a one-dimensional array or Series!"),L(s.length===n.index.length,"The one-dimensional array or Series to be assigned must have the same length as the number of rows in the target DataFrame!"),h[r]=s;else throw new wt("When using two arguments for the `assign` method, the first argument must be a string representing a column name, and the second argument must be a one-dimensional array or Series!");return h})(),u=n.columns,a=n.index,f=Rl(n.values),l=Ll(Object.keys(i));f.forEach((h,q)=>{l.forEach(b=>{h.push(i[b][q])})});let m=new t(f);return m.columns=u.concat(l),m.index=a,m}fr.exports=Gl});var pr=c((v1,mr)=>{var Hl=V();function Kl(t,e){if(e.isEmpty)return new t;let n=new t(Hl(e.values));return n.columns=e.columns.slice(),n.index=e.index.slice(),n}mr.exports=Kl});var Nr=c((T1,wr)=>{var ze=p(),dr=y(),gr=d(),qr=S(),yr=g(),br=N();function Ql(t,e,n,r,s){yr(r)&&(r=[]),yr(s)&&(s=[]),(qr(r)||gr(r))&&(r=[r]),(qr(s)||gr(s))&&(s=[s]),ze(dr(r),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),ze(dr(s),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),ze(br(r).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),ze(br(s).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");let o,i;n.index.forEach((a,f)=>{r.indexOf(a)<0&&r.indexOf(f)<0&&(o||(o=[]),o.push(a))}),n.columns.forEach((a,f)=>{s.indexOf(a)<0&&s.indexOf(f)<0&&(i||(i=[]),i.push(a))});let u=n.get(o,i);if(u instanceof e){let a=new t;a=a.assign(u),n.index.indexOf(u.name)>-1&&(a=a.transpose()),u=a}return u}wr.exports=Ql});var de=c((O1,xr)=>{var Xl=d();function Zl(t){return Xl(t)&&parseInt(t)===t}function ef(t){return Zl(t)&&t>=0}xr.exports=ef});var Tr=c((S1,vr)=>{var Nt=p(),tf=S(),Pe=g(),nf=de(),rf=N();function sf(t,e,n,r,s,o){r=r||0,Nt(r===0||r===1,"The first parameter of the `dropMissing` method (the `axis`) must be 0 or 1."),o=o||0,Nt(nf(o),"The third parameter of the `dropMissing` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` null values)."),s=o>0?"none":s||"any",Nt(s==="any"||s==="all"||s==="none","The second parameter of the `dropMissing` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains null values, then it should be dropped; or that if 'all' of the data contains null values, then it should be dropped).");function i(f){if(o>0){let l=0;for(let m=0;m<f.length;m++){let h=f[m];if(Pe(h)&&l++,l>=o)return[]}}else if(s==="any")for(let l=0;l<f.length;l++){let m=f[l];if(Pe(m))return[]}else if(s==="all"){for(let l=0;l<f.length;l++){let m=f[l];if(!Pe(m))return f}return[]}return f}let u=n.copy(),a=Math.random().toString();if(r===0){u=u.assign(a,u.index);let f=u.values.map(i).filter(m=>m.length>0);if(rf(f).length<2)return new t;u.values=f;let l=u.get(null,a);if(Pe(l))return new t;tf(l)&&(l=[l]),l instanceof e&&(l=l.values),u.index=l,u=u.drop(null,a)}else if(r===1){let f={};if(u.columns.forEach((m,h)=>{let q=u.values.map(E=>E[h]),b=i(q);b.length>0&&(f[m]=b)}),Object.keys(f).length===0)return new t;let l=new t(f);return l.index=u.index,l}return u}vr.exports=sf});var Be=c((A1,Sr)=>{var Or=p(),of=y(),uf=g(),af=d(),cf=N();function lf(t){return Or(of(t),"The value passed into the `dropNaN` function must be a one-dimensional array!"),Or(cf(t).length===1,"The value passed into the `dropNaN` function must be a one-dimensional array"),t.filter(e=>!uf(e)&&af(e))}Sr.exports=lf});var Er=c((E1,Ar)=>{var xt=p(),ff=Be(),hf=de();function mf(t,e,n,r,s){n=n||0,xt(n===0||n===1,"The first parameter of the `dropNaN` method (the `axis`) must be 0 or 1."),s=s||0,xt(hf(s),"The third parameter of the `dropNaN` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` NaN values)."),r=s>0?"none":r||"any",xt(r==="any"||r==="all"||r==="none","The second parameter of the `dropNaN` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains NaN values, then it should be dropped; or that if 'all' of the data contains NaN values, then it should be dropped).");function o(a){let f=ff(a);return s>0?a.length-f.length<s:r==="any"?f.length===a.length:r==="all"?f.length>0:!0}let i=e.copy(),u=Math.random().toString();if(n===0){let a=i.index.filter(f=>{let l=i.get(f,null).values;return o(l)});return a.length>0?i.get(a,null):new t}else if(n===1){let a=i.columns.filter(f=>{let l=i.get(null,f).values;return o(l)});return a.length>0?i.get(null,a):new t}return i}Ar.exports=mf});var Vr=c((M1,Ir)=>{var Mr=p(),ge=T(),pf=j(),df=g();function jr(t){let e={};return ge(t).forEach((n,r)=>{e[n]=r}),e}function ie(t){return Object.keys(t).sort((e,n)=>t[e]-t[n])}function gf(t,e,n,r,s){Mr(pf(r),"The `filter` method takes a single parameter: a function that is used to filter the values."),df(s)&&(s=0),Mr(s===0||s===1,"The `axis` parameter to the `filter` method must be 0 or 1.");let o=n.copy();if(o.isEmpty)return o;let i=jr(o.index),u=jr(o.columns);if(s===0){let a=o.values.filter((f,l)=>{let m=new e(f);m.name=n.index[l],m.index=n.columns;let h=r(m,l,n);return h||delete i[o.index[l]],h});if(ge(a).length===0)return new t;if(a.length===1){let f=new e(ge(a));return f.name=ie(i)[0],f.index=ie(u),f}o.values=a,o.index=ie(i)}else if(s===1){o=o.transpose();let a=o.values.filter((f,l)=>{let m=new e(f);m.name=n.columns[l],m.index=n.index;let h=r(m,l,n);return h||delete u[o.index[l]],h});if(ge(a).length===0)return new t;if(a.length===1){let f=new e(ge(a));return f.name=ie(u)[0],f.index=ie(i),f}o.values=a,o.index=ie(u),o=o.transpose()}return o}Ir.exports=gf});var ue=c((j1,Cr)=>{function qf(t){return typeof t=="boolean"}Cr.exports=qf});var qe=c((I1,Yr)=>{var Ur=p(),yf=g(),bf=y();function wf(t){Ur(!yf(t),"You must pass an array into the `reverse` function!"),Ur(bf(t),"You must pass an array into the `reverse` function!");let e=[];for(let n=t.length-1;n>=0;n--)e.push(t[n]);return e}Yr.exports=wf});var I=c((V1,kr)=>{var vt=p(),Tt=g(),Ot=d(),Nf=qe();function xf(t,e,n=1){vt(!Tt(t)&&!Tt(e)&&!Tt(n),"You must pass two numbers and optionally a step value to the `range` function!"),vt(Ot(t)&&Ot(e)&&Ot(n),"You must pass two numbers and optionally a step value to the `range` function!"),vt(n>0,"The step value must be greater than 0! (NOTE: The step value is a magnitude; it does not indicate direction.)");let r=!1;if(t>e){r=!0;let o=t;t=e+n,e=o+n}let s=[];for(let o=t;o<e;o+=n)s.push(o);return r&&(s=Nf(s)),s}kr.exports=xf});var St=c((C1,Br)=>{var G=p(),H=y(),zr=ue(),Fe=S(),_e=g(),Je=Y(),vf=D(),Pr=I();function Tf(t,e,n,r,s,o){return n=(()=>{if(_e(n))return!1;if(zr(n))return n;throw new Je("The `hasHeaderRow` parameter of the `fromCSV` method must be a boolean!")})(),r=(()=>{if(_e(r))return!1;if(zr(r))return r;throw new Je("The `hasIndexColumn` parameter of the `fromCSV` method must be a boolean!")})(),s=(()=>{let u="The `fieldDelimiter` parameter of the `fromCSV` method must be one of:\n\n1) a single-character string (e.g., ',')\n2) an array containing two single-character strings, one each for a left delimiter and a right delimiter (e.g., ['<', '>'])";if(_e(s))return",";if(Fe(s))return G(s.length===1,u),s;if(H(s))return G(s.length===2,u),G(s[0].length===1,u),G(s[1].length===1,u),s;throw new Je(u)})(),o=(()=>{let u="The `stringDelimiter` parameter of the `fromCSV` method must be one of:\n\n1) a single-character string (e.g., '\"')\n2) an array containing two single-character strings, one each for a left delimiter and a right delimiter (e.g., ['\u201C', '\u201D'])";if(_e(o))return'"';if(Fe(o))return G(o.length===1,u),o;if(H(o))return G(o.length===2,u),G(o[0].length===1,u),G(o[1].length===1,u),o;throw new Je(u)})(),(()=>{let a=e.split(`
`).filter(q=>q.length>0).map(q=>{let b=[],E="",$=!1;for(let W=0;W<q.length;W++){let M=q[W];if(M.match(/\\/g))W++;else if(H(o)&&M===o[0])$=!0;else if(H(o)&&M===o[1])$=!1;else if(Fe(o)&&M===o)$=!$;else if(H(s)&&M===s[0]||H(s)&&M===s[1]||Fe(s)&&M===s)if($)E+=M;else{let dt=E;try{let gt=JSON.parse(dt);H(gt)?b.push(dt.trim()):b.push(gt)}catch{b.push(dt.trim())}E=""}else E+=M}if(E.length>0){let W=E;try{let M=JSON.parse(W);H(M)?b.push(W.trim()):b.push(M)}catch{b.push(W.trim())}}return b}),f=(()=>{let q=n?a.shift():Pr(0,a[0].length).map(b=>"col"+b);return r&&q.shift(),q})(),l=(()=>r?a.map(b=>b.shift()):Pr(0,a.length).map(b=>"row"+b))(),m=vf(a.map(q=>q.length)),h=new t(a.map(q=>(q.length=m,q)));return n&&(h.columns=f),r&&(h.index=l),h})()}Br.exports=Tf});var _r=c((U1,Fr)=>{var Of=p(),Sf=St(),Af=S(),Ef=g(),Mf=Y();async function jf(t,e,n,r,s,o,i){n=(()=>Ef(n)?"utf8":(Of(Af(n),"The `encoding` parameter of the `fromCSV` method must be a string (e.g., 'utf8')!"),n))();let u=await(async()=>{try{return await(await fetch(e)).text()}catch{}try{return pe("fs").readFileSync(e,n)}catch{}throw new Mf(`The path "${e}" could not be loaded!`)})();return Sf(t,u,r,s,o,i)}Fr.exports=jf});var Wr=c((Y1,$r)=>{var C=p(),$e=d(),We=S(),Jr=g(),If=F();function Vf(t,e,n){(We(e)||$e(e))&&(e=[e]),(We(n)||$e(n))&&(n=[n]);let r=If((e||[]).concat(n||[]).map(s=>typeof s));return C(r.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===1&&C(r[0]==="string"||r[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===2&&(C(r.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),C(r.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),Jr(e)||(e=e.map(s=>{if(We(s))return C(t.index.indexOf(s)>-1,`Row "${s}" does not exist!`),s;if($e(s))return C(s>=0,`Index ${s} is out of bounds!`),C(parseInt(s)===s,"Row numbers must be integers!"),C(s<t.index.length,`Index ${s} is out of bounds!`),t.index[s]})),Jr(n)||(n=n.map(s=>{if(We(s))return C(t.columns.indexOf(s)>-1,`Column "${s}" does not exist!`),s;if($e(s))return C(s>=0,`Column ${s} is out of bounds!`),C(parseInt(s)===s,"Column numbers must be integers!"),C(s<t.columns.length,`Column ${s} is out of bounds!`),t.columns[s]})),t.getSubsetByNames(e,n)}$r.exports=Vf});var Gr=c((k1,Lr)=>{var Dr=p(),Rr=S(),Cf=g(),Uf=F(),Yf=k();function kf(t){let e=t.toLowerCase(),n="";for(let s=0;s<e.length;s++){let o=e[s];o.match(/[a-z0-9]/g)?n+=o:n+=" "}let r=n.split(" ").filter(s=>s.length>0);return r[0]+r.slice(1).map(s=>s[0].toUpperCase()+s.substring(1)).join("")}function zf(t,e,n){Cf(n)?n=e.columns:Rr(n)&&(n=[n]);let r={};n.forEach(o=>{Dr(Rr(o),"You must pass either a string or a one-dimensional array of strings into the `getDummies` (AKA `oneHotEncode`) method!");let i=e.columns.indexOf(o);Dr(i>-1,`The given DataFrame does not have a column called "${o}"!`);let u=e.values.map(f=>f[i]),a=Yf(Uf(u));u.forEach(f=>{a.forEach(l=>{let m=o+"_"+kf(l.toString());r[m]||(r[m]=[]),f===l?r[m].push(1):r[m].push(0)})})});let s=new t(r);return s.index=e.index,s}Lr.exports=zf});var ns=c((z1,ts)=>{var K=p(),Hr=y(),Kr=d(),Qr=g(),Xr=de(),Zr=I(),es=N();function Pf(t,e,n){let r=t.shape;Qr(e)&&(e=Zr(0,r[0])),Qr(n)&&(n=Zr(0,r[1])),Kr(e)&&(e=[e]),Kr(n)&&(n=[n]),K(Hr(e)&&Hr(n),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),K(es(e).length===1&&es(n).length===1,"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),K(e.length>0,"The `rowIndices` array must contain at least one index."),K(n.length>0,"The `colIndices` array must contain at least one index."),e.forEach(i=>{K(Xr(i),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),K(i<t.index.length,`The row index ${i} is out of bounds.`)}),n.forEach(i=>{K(Xr(i),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),K(i<t.columns.length,`The column index ${i} is out of bounds.`)});let s=e.map(i=>t.index[i]),o=n.map(i=>t.columns[i]);return t.getSubsetByNames(s,o)}ts.exports=Pf});var us=c((P1,is)=>{var Q=p(),At=T(),rs=y(),De=S(),ss=g(),os=N();function Bf(t,e,n,r,s){ss(r)&&(r=n.index),ss(s)&&(s=n.columns),De(r)&&(r=[r]),De(s)&&(s=[s]),Q(rs(r)&&rs(s),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),Q(os(r).length===1&&os(s).length===1,"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),Q(r.length>0,"The `rows` array must contain at least one row name."),Q(s.length>0,"The `cols` array must contain at least one column name."),r.forEach(u=>{Q(De(u),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),Q(n.index.indexOf(u)>-1,`The row name "${u}" does not exist in the list of rows.`)}),s.forEach(u=>{Q(De(u),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),Q(n.columns.indexOf(u)>-1,`The column name "${u}" does not exist in the list of columns.`)});let o=r.map(u=>s.map(a=>n.values[n.index.indexOf(u)][n.columns.indexOf(a)]));if(r.length===1&&s.length===1)return At(o)[0];if(r.length===1){let u=new e(At(o));return u.name=r[0],u.index=s,u}if(s.length===1){let u=new e(At(o));return u.name=s[0],u.index=r,u}let i=new t(o);return i.columns=s,i.index=r,i}is.exports=Bf});var ye=c((B1,as)=>{var Ff=p(),_f=d();function Jf(t,e){Ff(_f(t),"The `leftPad` function only works on numbers!");let n=t.toString();for(;n.length<e;)n="0"+n;return n}as.exports=Jf});var ps=c((F1,ms)=>{var Re=p(),cs=V(),$f=y(),ls=ne(),fs=ye(),hs=Y(),Wf=N(),Le=k();function Et(t,e,n,r){if(r instanceof e){Re(ls(Le(r.index),Le(n.index)),"The index of the incoming Series must match the index of the target DataFrame!");let s=cs(n.values);n.index.forEach((i,u)=>{let a=r.get(i);s[u].push(a)});let o=new t(s);return o.columns=n.columns.concat([r.name]),o}else if(r instanceof t){Re(ls(Le(r.index),Le(n.index)),"The index of the incoming DataFrame must match the index of the target DataFrame!");let s=cs(n.values);n.index.forEach((i,u)=>{let a=r.values[r.index.indexOf(i)];s[u]=s[u].concat(a)});let o=new t(s);return o.columns=n.columns.concat(r.columns),o}else if($f(r)){let s=Wf(r);if(s.length===1){Re(r.length===n.values.length,"When passing a 1-dimensional array into the `join` method, the array must have the same length as the number of rows in the target DataFrame!");let o=new e(r);return o.index=n.index,o.name="col"+fs(n.columns.length,n.columns.length.toString().length),Et(t,e,n,o)}else if(s.length===2){Re(r.length===n.values.length,"When passing a 2-dimensional array into the `join` method, each column of the array must have the same length as the number of rows in the target DataFrame!");let o=new t(r);return o.index=n.index,o.columns=o.columns.map((i,u)=>"col"+fs(n.columns.length+u,n.columns.length.toString().length)),Et(t,e,n,o)}else throw new hs("When passing an array into the `join` method, the array must be 1- or 2-dimensional! If 1-dimensional, it must be as long as the number of rows of the target DataFrame. If 2-dimensional, each column must be as long as the number of rows in the target DataFrame.")}else throw new hs("Only Series, DataFrames, and 1- or 2-dimensional arrays can be passed into the `join` method!")}ms.exports=Et});var gs=c((_1,ds)=>{var Df=S(),be=I();function Rf(t,e,n){function r(h,q){return Df(h)&&h.length>q?h.substring(0,q-3)+"...":h}if(n.isEmpty)return console.table({}),console.log("Shape:",[0,0],`
`),n;let s=typeof window>"u"?20:10,o=parseInt(s/2),i=typeof window>"u"?Math.floor(process.stdout.columns/24)-1:10,u=parseInt(i/2),a=s>n.index.length?null:be(0,o).concat(be(n.index.length-o,n.index.length)),f=i>n.columns.length?null:be(0,u).concat(be(n.columns.length-u,n.columns.length)),l=n.get(a,f);l instanceof e&&(n.shape[0]===1?(l=new t([l.values]),l.index=n.index,l.columns=new e(n.columns).get(f).values):n.shape[1]===1&&(l=new t([l.values]).transpose(),l.index=new e(n.index).get(a).values,l.columns=n.columns)),s<=n.index.length&&(l._index.splice(o,0,"..."),l._values.splice(o,0,be(0,l.columns.length).map(h=>"..."))),i<=n.columns.length&&(l._columns.splice(u,0,"..."),l._values=l._values.map(h=>(h.splice(u,0,"..."),h)));let m=28;return l instanceof e?(l.values=l.values.map(h=>r(h,m)),l.name=r(l.name,m),l.index=l.index.map(h=>r(h,m))):(l.values=l.values.map(h=>h.map(q=>r(q,m))),l.columns=l.columns.map(h=>r(h,m)),l.index=l.index.map(h=>r(h,m))),console.table(l.toObject()),console.log("Shape:",n.shape,`
`),n}ds.exports=Rf});var ys=c((J1,qs)=>{var Lf=ye(),Gf=I();function Hf(t,e){let n=e?t:t.copy();return n.index=Gf(0,t.shape[0]).map(r=>"row"+Lf(r,(n.index.length-1).toString().length)),n}qs.exports=Hf});var w=c(($1,bs)=>{var Mt=p(),Kf=g(),jt=y(),Qf=D(),Xf=j();function Zf(t){return Mt(!Kf(t),"You must pass a function into the `vectorize` function!"),Mt(Xf(t),"You must pass a function into the `vectorize` function!"),function e(){if(Object.keys(arguments).map(r=>jt(arguments[r])).indexOf(!0)>-1){let r=[],s=Object.keys(arguments).filter(i=>jt(arguments[i])).map(i=>arguments[i].length),o=Qf(s);s.forEach(i=>{Mt(i===o,"If using arrays for all arguments to this function, then the arrays must all have equal length!")});for(let i=0;i<o;i++){let u=Object.keys(arguments).map(a=>jt(arguments[a])?arguments[a][i]:arguments[a]);r.push(e(...u))}return r}else return t(...arguments)}}bs.exports=Zf});var Ge=c((W1,ws)=>{var e0=d(),t0=w();function n0(t){try{return e0(t)?Math.floor(t):NaN}catch{return NaN}}ws.exports=t0(n0)});var _=c((D1,xs)=>{var we=p(),r0=g(),s0=y(),o0=d(),i0=T(),Ne="You must pass a natural number or a one-dimensional array of natural numbers into the `ndarray` function!";function Ns(t,e){if(e||(we(!r0(t),Ne),s0(t)||(t=[t]),t=i0(t),we(t.length>0,Ne),t.forEach(n=>{we(o0(n),Ne),we(parseInt(n)===n,Ne),we(n>=0,Ne)})),t.length===1){let n=[];for(let r=0;r<t[0];r++)n.push(void 0);return n}else{let n=[];for(let r=0;r<t[0];r++)n.push(Ns(t.slice(1),!0));return n}}xs.exports=Ns});var re=c((R1,vs)=>{var u0=w();function a0(t,e){try{return e(t)}catch{return NaN}}vs.exports=u0(a0)});var ae=c((L1,Es)=>{var xe=p(),Ts=y(),Os=d(),c0=N(),Ss=T(),l0=t=>t.reduce((e,n)=>e*n);function As(t,e){if(xe(Ts(t),"The first argument passed into the `reshape` function must be an array!"),Os(e)&&(e=[e]),xe(Ts(e),"The second argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),xe(c0(e).length===1,"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),e.forEach(o=>{xe(Os(o)&&parseInt(o)===o&&o>0,"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!")}),e.length<=1)return Ss(t);let n=Ss(t);xe(l0(e)===n.length,"The new shape doesn't match the number of values available in `x` (the first argument passed into the `reshape` function)!");let r=[],s=parseInt(n.length/e[0]);for(let o=0;o<e[0];o++){let i=n.slice(o*s,(o+1)*s);r.push(As(i,e.slice(1)))}return r}Es.exports=As});var ce=c((K1,ks)=>{var G1=_(),H1=re(),Is=g(),f0=p(),Vs=d(),Cs=V(),h0=ae(),Us=Math.pow(2,64),x=[];Ys(parseInt(Math.random()*Us));function m0(t,e){t=A(t);function n(){t+=A("0x9e3779b97f4a7c15");let s=Cs(t);return s=(s^s>>30n)*A("0xbf58476d1ce4e5b9"),s=(s^s>>27n)*A("0x94d049bb133111eb"),s^s>>31n}let r=[];for(let s=0;s<e;s++)r.push(n());return r}function A(t){return BigInt.asUintN(64,BigInt(t))}function Ms(t,e){return t=A(t),e=BigInt(e),A(A(t<<e)|A(t>>A(64n-e)))}function Ys(t){if(Is(t))return Cs(x);{f0(Vs(t),"If passing a value into the `seed` function, then that value must be an integer!");let e=m0(parseInt(t),4);x[0]=e[0],x[1]=e[1],x[2]=e[2],x[3]=e[3]}}function js(){let t=A(Ms(x[0]+x[3],23)+x[0]),e=A(x[1]<<17n);return x[2]=A(x[2]^x[0]),x[3]=A(x[3]^x[1]),x[1]=A(x[1]^x[2]),x[0]=A(x[0]^x[3]),x[2]=A(x[2]^e),x[3]=Ms(x[3],45),parseInt(t)/Us}function p0(t){if(Is(t))return js();Vs(t)&&(t=[t]);let e=[],n=1;t.forEach(r=>n*=r);for(let r=0;r<n;r++)e.push(js());return h0(e,t)}ks.exports={random:p0,seed:Ys}});var It=c((X1,Ps)=>{var zs=p(),d0=g(),g0=y(),Q1=Ge(),{random:q0}=ce();function y0(t){zs(!d0(t),"You must pass an array into the `shuffle` function!"),zs(g0(t),"You must pass an array into the `shuffle` function!");let e=[],n=t.slice();for(let r=0;r<t.length;r++){let s=parseInt(q0()*n.length);e.push(n.splice(s,1)[0])}return e}Ps.exports=y0});var _s=c((Z1,Fs)=>{var b0=p(),w0=g(),Bs=It();function N0(t,e){return w0(e)&&(e=0),b0(e===0||e===1,"The `axis` parameter to the `shuffle` must be 0, 1, or undefined."),t.get(e===0?Bs(t.index):null,e===1?Bs(t.columns):null)}Fs.exports=N0});var Rs=c((eb,Ds)=>{var{random:x0}=ce(),U=p(),v0=T(),Js=y(),Vt=ue(),Ct=d(),le=S(),$s=g(),T0=I(),Ws=N(),O0=k();function S0(t,e,n){let r=t.copy(),s=x0().toString();return r=r.assign(s,r.index),$s(e)&&(e=[s],n=[!0]),(Ct(e)||le(e))&&(e=[e],(Vt(n)||le(n))&&(n=[n])),U(Js(e),"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),U(Ws(e).length===1,"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),$s(n)&&(n=T0(0,e.length).map(o=>!0)),U(Js(n),"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),U(Ws(n).length===1,"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),U(e.length===n.length,"The arrays passed into the `sort` method must be equal in length."),e=e.map(o=>{if(U(le(o)||Ct(o),"Column references can either be column names (as strings) or column indices (as whole numbers)."),le(o)){let i=r.columns.indexOf(o);return U(i>-1,`The column "${o}" does not exist!`),i}if(Ct(o))return U(parseInt(o)===o,"Column indices must be whole numbers!"),U(o>=0,`The column index ${o} is out of bounds!`),U(o<r.columns.length,`The index ${o} is out of bounds!`),o}),n=n.map(o=>{if(U(le(o)||Vt(o),"Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),le(o)){let i=o.trim().toLowerCase();return U(i==="ascending"||i==="descending","Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),i==="ascending"}if(Vt(o))return o}),r.values=O0(r.values,(o,i)=>{let u=0;for(;o[e[u]]===i[e[u]]&&u<e.length;)u++;let a=n[u];if(o[e[u]]===i[e[u]])return 0;if(o[e[u]]<i[e[u]])return a?-1:1;if(o[e[u]]>i[e[u]])return a?1:-1}),r.index=v0(r.get(null,s).values),r=r.dropColumns(s),r}Ds.exports=S0});var Ut=c((tb,Gs)=>{var A0=ue(),E0=R(),M0=S(),Ls=g(),j0=Y();function I0(t,e){e=(()=>{if(Ls(e))return!0;if(A0(e))return e;throw new j0("The `shouldIncludeIndex` parameter of the `toCSVString` method must be a boolean!")})();let n=[""].concat(t.index);return[t.columns].concat(t.values).map((s,o)=>(e?[n[o]]:[]).concat(s).map(u=>M0(u)?JSON.stringify(u):E0(u)?JSON.stringify(JSON.stringify(u)):Ls(u)?"":u.toString()).join(",")).join(`
`)}Gs.exports=I0});var Hs=c((nb,kt)=>{var V0=Ut(),Yt=Y();function C0(t,e,n){let r=V0(t,n),s=!1,o=!1,i,u;try{let a=e;if(e.includes("/")){let l=e.split("/");a=l[l.length-1]}let f=document.createElement("a");f.href=`data:text/csv;charset=utf-8,${encodeURIComponent(r)}`,f.download=a,f.dispatchEvent(new MouseEvent("click")),s=!0}catch(a){i=a}try{let a=pe("fs"),f=pe("path");a.writeFileSync(f.resolve(e),r,"utf8"),o=!0}catch(a){u=a}if(!s&&!o)throw typeof window<"u"?new Yt(i):typeof kt<"u"?new Yt(u):new Yt("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");return t}kt.exports=C0});var zt=c((rb,Ks)=>{function U0(t,e){return JSON.stringify(t.toObject(e))}Ks.exports=U0});var Qs=c((sb,Bt)=>{var Y0=zt(),Pt=Y();function k0(t,e,n){let r=Y0(t,n),s=!1,o=!1,i,u;try{let a=e;if(e.includes("/")){let l=e.split("/");a=l[l.length-1]}let f=document.createElement("a");f.href=`data:application/json;charset=utf-8,${encodeURIComponent(r)}`,f.download=a,f.dispatchEvent(new MouseEvent("click")),s=!0}catch(a){i=a}try{let a=pe("fs"),f=pe("path");a.writeFileSync(f.resolve(e),r,"utf8"),o=!0}catch(a){u=a}if(!s&&!o)throw typeof window<"u"?new Pt(i):typeof Bt<"u"?new Pt(u):new Pt("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");return t}Bt.exports=k0});var Zs=c((ob,Xs)=>{var z0=p(),P0=g();function B0(t,e){P0(e)?e=0:z0(e===0||e===1,"The axis parameter of the `toObject` method must be undefined, 0, or 1. An axis of 0 indicates that the returned object should be organized first by rows and then by columns. An axis of 1 indicates that the returned object should be organized first by columns and then by rows.");let n={};return e===0?t.index.forEach((r,s)=>{let o={};t.columns.forEach((i,u)=>{o[i]=t.values[s][u]}),n[r]=o}):t.columns.forEach((r,s)=>{let o={};t.index.forEach((i,u)=>{o[i]=t.values[u][s]}),n[r]=o}),n}Xs.exports=B0});var X=c((ib,to)=>{var Ft=p(),F0=g(),_0=y(),J0=N(),eo=qe(),$0=_();function W0(t){Ft(!F0(t),"You must pass an array into the `transpose` function!"),Ft(_0(t),"You must pass an array into the `transpose` function!");let e=J0(t);if(Ft(e.length<=2,"I'm not smart enough to know how to transpose arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `transpose` function!"),e.length===1)return eo(t);if(e.length===2){let n=$0(eo(e));for(let r=0;r<e[0];r++)for(let s=0;s<e[1];s++)n[s][r]=t[r][s];return n}}to.exports=W0});var ro=c((ub,no)=>{var D0=p(),R0=j();function L0(t,e){D0(R0(e),"The parameter to the `apply` method must be a function.");let n=t.copy();return n.values=n.values.map((r,s)=>e(r,n.index[s])),n}no.exports=L0});var oo=c((ab,so)=>{var G0=g();function H0(t){let e=t.copy(),n=[];return e.values=e.values.filter((r,s)=>G0(r)?!1:(n.push(e.index[s]),!0)),e.index=n,e}so.exports=H0});var uo=c((cb,io)=>{var K0=d();function Q0(t,e){let n=[],r=[];e.values.forEach((o,i)=>{K0(o)&&(r.push(o),n.push(e.index[i]))});let s=new t(r);return s.name=e.name,s.index=n,s}io.exports=Q0});var co=c((lb,ao)=>{var X0=V();function Z0(t,e,n){let r=e.copy(),s=X0(r.index),o=[],i=r.values.filter((u,a)=>{let f=n(u,a,r.values);return f||o.push(r.index[a]),f});return o.forEach(u=>{s.splice(s.indexOf(u),1)}),i.length===0?(r=new t,r.name=e.name,r):(r.values=i,r.index=s,r)}ao.exports=Z0});var fo=c((fb,lo)=>{var Z=p(),eh=d(),th=S(),nh=g(),rh=F();function sh(t,e){(th(e)||eh(e))&&(e=[e]);let n=rh((e||[]).map(r=>typeof r));return Z(n.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===1&&Z(n[0]==="string"||n[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===2&&(Z(n.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),Z(n.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),nh(e)||(e=e.map(r=>{if(typeof r=="string")return Z(t.index.indexOf(r)>-1,`Index "${r}" does not exist!`),r;if(typeof r=="number")return Z(r>=0,`Index ${r} is out of bounds!`),Z(parseInt(r)===r,"Indices must be integers!"),Z(r<t.index.length,`Index ${r} is out of bounds!`),t.index[r]})),t.getSubsetByNames(e)}lo.exports=sh});var mo=c((hb,ho)=>{var ve=p(),oh=y(),ih=g(),uh=de(),ah=I(),ch=N();function lh(t,e){let n=t.shape;ih(e)&&(e=ah(0,n[0])),ve(oh(e),"The `indices` array must be 1-dimensional array of whole numbers."),ve(ch(e).length===1,"The `indices` array must be a 1-dimensional array of whole numbers."),ve(e.length>0,"The `indices` array must contain at least one index."),e.forEach(s=>{ve(uh(s),"The `indices` array must be a 1-dimensional array of whole numbers."),ve(s<t.index.length,`The row index ${s} is out of bounds.`)});let r=e.map(s=>t.index[s]);return t.getSubsetByNames(r)}ho.exports=lh});var go=c((mb,po)=>{var Te=p(),fh=y(),hh=S(),mh=g(),ph=N();function dh(t,e,n){mh(n)&&(n=e.index),Te(fh(n),"The `indices` array must be a 1-dimensional array of strings."),Te(ph(n).length===1,"The `indices` array must be a 1-dimensional array of strings."),Te(n.length>0,"The `indices` array must contain at least one index name."),n.forEach(o=>{Te(hh(o),"The `indices` array must contain only strings."),Te(e.index.indexOf(o)>-1,`The name "${o}" does not exist in the index.`)});let r=n.map(o=>e.values[e.index.indexOf(o)]);if(r.length===1)return r[0];let s=new t(r);return s.index=n,s.name=e.name,s}po.exports=dh});var bo=c((pb,yo)=>{var gh=V(),qo=I();function qh(t){let e=t.copy(),n=typeof window>"u"?20:10;if(e.index.length>n){e=e.get(qo(0,n/2).concat(qo(e.index.length-n/2,e.index.length)));let s=gh(e.index);s.splice(parseInt(s.length/2),0,"..."),e.values.push("..."),e.index.push("..."),e=e.get(s)}let r={};return e.values.forEach((s,o)=>{let i={};i[e.name]=s,r[e.index[o]]=i}),console.table(r),console.log("Shape:",t.shape,`
`),t}yo.exports=qh});var So=c((db,Oo)=>{var wo=p(),No=ue(),xo=S(),vo=g(),yh=k(),To=X();function bh(t,e,n){wo(No(n)||xo(n)||vo(n),"The `sort` method can take an optional parameter that's either a string representing a direction ('ascending' or 'descending') or a boolean representing whether or not the direction is ascending (true or false).");let r=!0;vo(n)&&(r=!0),xo(n)&&(n=n.trim().toLowerCase(),wo(n==="ascending"||n==="descending","The `sort` method can take an optional parameter that's either a string representing a direction ('ascending' or 'descending') or a boolean representing whether or not the direction is ascending (true or false)."),r=n==="ascending"),No(n)&&(r=n);let s=To([e.values,e.index]);s=To(yh(s,(i,u)=>{if(i[0]===u[0])return 0;if(i[0]<u[0])return r?-1:1;if(i[0]>u[0])return r?1:-1}));let o=new t(s[0]);return o.index=s[1],o.name=e.name,o}Oo.exports=bh});var Mo=c((gb,Eo)=>{var wh=k(),Ao=X();function Nh(t,e){let n=Ao([e.values,e.index]);n=Ao(wh(n,(s,o)=>{if(s[1]===o[1])return 0;if(s[1]<o[1])return-1;if(s[1]>o[1])return 1}));let r=new t(n[0]);return r.index=n[1],r.name=e.name,r}Eo.exports=Nh});var Io=c((qb,jo)=>{function xh(t){let e={};return e[t.name]={},t.index.forEach((n,r)=>{e[t.name][n]=t.values[r]}),e}jo.exports=xh});var zo=c((yb,ko)=>{var se=p(),vh=V(),Vo=y(),Th=S(),Oh=g(),Co=ye(),Sh=_(),Uo=I(),Yo=qe(),Ah=ro(),Eh=oo(),Mh=uo(),jh=co(),Ih=fo(),Vh=mo(),Ch=go(),Uh=bo(),Yh=So(),kh=Mo(),zh=Io(),He=N(),Ph=X();ko.exports=function(t){class e{constructor(r){let s=this;if(s.name="data",Object.defineProperty(s,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(s,"values",{configurable:!0,enumerable:!0,get(){return s._values},set(o){se(Vo(o),"The new values must be a 1-dimensional array!");let i=He(o);se(i.length===1,"The new array of values must be 1-dimensional!"),i[0]<s._index.length?s._index=s._index.slice(0,i[0]):i[0]>s._index.length&&(s._index=s._index.concat(Uo(s._index.length,i[0]).map(u=>"row"+Co(u,(o.length-1).toString().length)))),s._values=o}}),Object.defineProperty(s,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(s,"index",{configurable:!0,enumerable:!0,get(){return s._index},set(o){se(Vo(o),"The new index must be a 1-dimensional array of strings!"),se(o.length===s.shape[0],"The new index must be the same length as the old index!"),se(He(o).length===1,"The new index must be a 1-dimensional array of strings!"),o.forEach(i=>{se(Th(i),"All of the row names must be strings!")}),s._index=o}}),r){let o=He(r);se(o.length===1,"The `data` array passed into the constructor of a DataFrame must be 1-dimensional!"),s.values=r}}get shape(){return He(this.values)}get isEmpty(){return this.values.filter(s=>!Oh(s)).length===0}clear(){let r=this,s=r.copy();return s.values=Sh(s.shape),s.index=r.index,s}get(r){return Ih(this,r)}getSubsetByNames(r){return Ch(e,this,r)}getSubsetByIndices(r){return Vh(this,r)}loc(r){return this.getSubsetByNames(r)}iloc(r){return this.getSubsetByIndices(r)}reverse(){let r=this,s=new e(Yo(r.values));return s.index=Yo(r.index),s.name=r.name,s}resetIndex(){let r=this,s=r.copy();return s.index=Uo(0,r.shape[0]).map(o=>"row"+Co(o,(s.index.length-1).toString().length)),s}copy(){let r=this,s=new e(vh(r.values));return s.index=r.index.slice(),s.name=r.name,s}apply(r){return Ah(this,r)}dropMissing(r,s){return Eh(this,r,s)}dropNaN(){return Mh(e,this)}toObject(){return zh(this)}print(){return Uh(this)}sort(r){return Yh(e,this,r)}sortByIndex(){return kh(e,this)}filter(r){return jh(e,this,r)}toDataFrame(){let r=this,s=new t(Ph([r.values]));return s.columns=[r.name],s.index=r.index,s}getDummies(){return this.toDataFrame().getDummies()}oneHotEncode(){return this.getDummies()}}return e}});var $t=c((wb,Jo)=>{var P=p(),Po=Ce(),Bh=tr(),Fh=ir(),_h=hr(),Jh=pr(),$h=Nr(),Wh=Tr(),Dh=Er(),Rh=Vr(),Lh=_r(),Gh=St(),Hh=Wr(),Bo=Gr(),Kh=ns(),Qh=us(),Xh=ps(),Zh=gs(),em=ys(),tm=_s(),nm=Rs(),rm=Hs(),sm=Ut(),om=zt(),im=Qs(),um=Zs(),am=T(),Ke=y(),Fo=g(),_t=ye(),cm=_(),Jt=I(),bb=F(),fe=N(),_o=X();function Qe(t){let e="abcdefghijklmnopqrstuvwxyz1234567890",n="";for(let r=0;r<t;r++)n+=e[parseInt(Math.random()*e.length)];return n}var v=class{constructor(e){let n=this;if(Object.defineProperty(n,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(n,"values",{configurable:!0,enumerable:!0,get(){return n._values.length===0||!Fo(n._values[0])&&n._values[0].length===0?[[]]:n._values},set(r){P(Ke(r),"The new values must be a 2-dimensional array!");let s=fe(r);P(s.length===2,"The new array of values must be 2-dimensional!"),s[0]<n._index.length?n._index=n._index.slice(0,s[0]):s[0]>n._index.length&&(n._index=n._index.concat(Jt(n._index.length,s[0]).map(o=>"row"+_t(o,(s[0]-1).toString().length)))),s[1]<n._columns.length?n._columns=n._columns.slice(0,s[1]):s[1]>n._columns.length&&(n._columns=n._columns.concat(Jt(n._columns.length,s[1]).map(o=>"col"+_t(o,(s[1]-1).toString().length)))),n._values=r}}),Object.defineProperty(n,"_columns",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(n,"columns",{configurable:!0,enumerable:!0,get(){return n._columns},set(r){P(Ke(r),"The new columns list must be a 1-dimensional array of strings!"),P(n.isEmpty||r.length===n.shape[1],"The new columns list must be the same length as the old columns list!"),P(fe(r).length===1,"The new columns list must be a 1-dimensional array of strings!"),r=r.map(o=>(typeof o!="string"&&(o=JSON.stringify(o)||o.toString()),o.trim().length===0?"untitled_"+Qe(8):o.trim()));let s=(()=>{let o=Po(r),i={};return o.forEach(u=>{i[u.item]=u.count}),i})();r=r.map(o=>s[o]>1?o+"_"+Qe(8):o),n._columns=r}}),Object.defineProperty(n,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(n,"index",{configurable:!0,enumerable:!0,get(){return n._index},set(r){P(Ke(r),"The new index must be a 1-dimensional array of strings!"),P(n.isEmpty||r.length===n.shape[0],"The new index must be the same length as the old index!"),P(fe(r).length===1,"The new index must be a 1-dimensional array of strings!"),r=r.map(o=>(typeof o!="string"&&(o=JSON.stringify(o)||o.toString()),o.trim().length===0?"untitled_"+Qe(8):o.trim()));let s=(()=>{let o=Po(r),i={};return o.forEach(u=>{i[u.item]=u.count}),i})();r=r.map(o=>s[o]>1?o+"_"+Qe(8):o),n._index=r}}),P(Fo(e)||e instanceof Object,"The `data` passed into the constructor of a DataFrame must be either (1) an object where the key-value pairs are (respectively) column names and 1-dimensional arrays of values, or (2) a 2-dimensional array of values."),e)if(Ke(e)){let r=fe(e);P(r.length===2,"The `data` array passed into the constructor of a DataFrame must be 2-dimensional!"),n.values=e}else{n._columns=Object.keys(e);let r=[];n._columns.forEach(o=>{let i=e[o];r.push(i)}),n._values=_o(r);let s=fe(n.values);n._index=Jt(0,s[0]).map(o=>"row"+_t(o,(s[0]-1).toString().length))}}get shape(){return fe(this.values)}get rows(){return this.index}set rows(e){let n=this;n.index=e}get isEmpty(){return am(this.values).length===0}clear(){let e=this,n=new v(cm(e.shape));return n.columns=e.columns.slice(),n.index=e.index.slice(),n}get(e,n){return Hh(this,e,n)}getSubsetByNames(e,n){return Qh(v,B,this,e,n)}getSubsetByIndices(e,n){return Kh(this,e,n)}loc(e,n){return this.getSubsetByNames(e,n)}iloc(e,n){return this.getSubsetByIndices(e,n)}getDummies(e){return Bo(v,this,e)}oneHotEncode(e){return Bo(v,this,e)}transpose(){let e=this,n=new v(_o(e.values));return n.columns=e.index,n.index=e.columns,n}get T(){return this.transpose()}resetIndex(e){return em(this,e)}copy(){return Jh(v,this)}assign(e,n){return _h(v,B,this,e,n)}apply(e,n){return Fh(v,B,this,e,n)}map(e,n){return this.apply(e,n)}dropMissing(e,n,r){return Wh(v,B,this,e,n,r)}dropNaN(e,n,r){return Dh(v,this,e,n,r)}drop(e,n){return $h(v,B,this,e,n)}dropColumns(e){return this.drop(null,e)}dropRows(e){return this.drop(e,null)}toObject(e){return um(this,e)}toCSVString(e){return sm(this,e)}toCSV(e,n){return rm(this,e,n)}toJSON(e,n){return im(this,e,n)}toJSONString(e){return om(this,e)}print(){return Zh(v,B,this)}sort(e,n){return nm(this,e,n)}sortByIndex(){return this.sort()}filter(e,n){return Rh(v,B,this,e,n)}shuffle(e){return tm(this,e)}append(e){return Bh(v,B,this,e)}join(e){return Xh(v,B,this,e)}};v.fromCSV=function(){return Lh(v,...arguments)};v.fromCSVString=function(){return Gh(v,...arguments)};var B=zo()(v);Jo.exports={DataFrame:v,Series:B}});var Wt=c((Nb,$o)=>{var lm=d(),fm=w();function hm(t){try{return lm(t)?Math.abs(t):NaN}catch{return NaN}}$o.exports=fm(hm)});var Oe=c((xb,Wo)=>{var mm=d(),pm=w();function dm(){try{let t=0,e=Object.values(arguments);for(let n=0;n<e.length;n++){if(!mm(e[n]))return NaN;t+=e[n]}return t}catch{return NaN}}Wo.exports=pm(dm)});var Rt=c((vb,Ho)=>{var z=p(),Do=g(),Ro=y(),gm=d(),Lo=N(),Dt=X();function Go(t,e,n=0){z(!Do(t),"You must pass two arrays into the `append` function!"),z(!Do(e),"You must pass two arrays into the `append` function!"),z(Ro(t),"You must pass two arrays into the `append` function!"),z(Ro(e),"You must pass two arrays into the `append` function!"),z(gm(n),"The `axis` argument to the `append` function must be 0 or 1!"),z(n>=0&&n<2,"The `axis` argument to the `append` function must be 0 or 1!"),z(parseInt(n)===n,"The `axis` argument to the `append` function must be 0 or 1!");let r=Lo(t),s=Lo(e);z(r.length===s.length,"The two arrays passed into the `append` function must have the same number of dimensions!"),z(r.length<3&&s.length<3,"The two arrays passed into the `append` function must be 1- or 2-dimensional!");for(let o=0;o<r.length;o++)o!==n&&z(r[o]===s[o],`The two arrays passed into the \`append\` function must have the same shapes along all axes *except* the axis along which they're being appended! (${r[o]} != ${s[o]})`);if(z(n<r.length,"The axis argument you passed into the `append` function is out of bounds for the array!"),r.length===0)return[];if(r.length===1)return t.concat(e);if(r.length===2){if(n===0){let o=[];for(let i=0;i<r[0];i++)o.push(t[i]);for(let i=0;i<s[0];i++)o.push(e[i]);return o}else if(n===1)return Dt(Go(Dt(t),Dt(e),0))}}Ho.exports=Go});var Qo=c((Tb,Ko)=>{var qm=d(),ym=w();function bm(t){try{return qm(t)?Math.acos(t):NaN}catch{return NaN}}Ko.exports=ym(bm)});var Zo=c((Ob,Xo)=>{var wm=d(),Nm=w();function xm(t){try{return wm(t)?Math.asin(t):NaN}catch{return NaN}}Xo.exports=Nm(xm)});var ti=c((Sb,ei)=>{var vm=d(),Tm=w();function Om(t){try{return vm(t)?Math.atan(t):NaN}catch{return NaN}}ei.exports=Tm(Om)});var Se=c((Ab,si)=>{var Sm=p(),ni=y(),Am=j(),ri=R();function Em(t,e){Sm(ri(t)||ni(t),"You must pass (1) an object or array and (2) a function or value into the `indexOf` function!"),Am(e)||(value=e,e=o=>o===value);function n(o,i,u){if(u=u||[],u.indexOf(o)>-1)return null;if(ri(o)){u.push(o);let a=Object.keys(o);for(let f=0;f<a.length;f++){let l=a[f],m=o[l];if(i(m))return[l];let h=n(m,i,u);if(h&&h.length>0)return[l].concat(h)}}else if(ni(o)){u.push(o);for(let a=0;a<o.length;a++){let f=o[a];if(i(f))return[a];let l=n(f,i,u);if(l&&l.length>0)return[a].concat(l)}}else if(i(o))return[];return null}function r(o){try{return e(o)}catch{return!1}}let s=n(t,r);return s&&s.length>0?s:null}si.exports=Em});var ii=c((Eb,oi)=>{var Mm=Se(),jm=D();function Im(t){try{return Mm(t,jm(t))}catch{return NaN}}oi.exports=Im});var Lt=c((Mb,ui)=>{var Vm=T(),Cm=d();function Um(t){try{let e=Vm(t),n=1/0;for(let r=0;r<e.length;r++){if(!Cm(e[r]))return NaN;e[r]<n&&(n=e[r])}return n===1/0?NaN:n}catch{return NaN}}ui.exports=Um});var ci=c((jb,ai)=>{var Ym=Se(),km=Lt();function zm(t){try{return Ym(t,km(t))}catch{return NaN}}ai.exports=zm});var fi=c((Ib,li)=>{var Pm=d(),Bm=w();function Fm(t){try{return Pm(t)?Math.ceil(t):NaN}catch{return NaN}}li.exports=Bm(Fm)});var pi=c((Vb,mi)=>{var _m=g(),Jm=Wt(),$m=w(),hi=d();function Wm(t,e){try{if(!hi(t))return NaN;if(_m(e))e=1e-10;else if(!hi(e))return NaN;return Jm(t)<e?0:t}catch{return NaN}}mi.exports=$m(Wm)});var gi=c((Cb,di)=>{var Gt=d(),Dm=w();function Rm(t,e,n){try{return Gt(t)?Gt(e)?Gt(n)?t<e?e:t>n?n:t:NaN:NaN:NaN}catch{return NaN}}di.exports=Dm(Rm)});var Ae=c((Ub,qi)=>{var Lm=d(),Gm=T();function Hm(t){try{let e=Gm(t),n=0;for(let r=0;r<e.length;r++){if(!Lm(e[r]))return NaN;n+=e[r]}return n/e.length}catch{return NaN}}qi.exports=Hm});var Xe=c((Yb,yi)=>{var Km=Ae(),Qm=T(),Xm=d();function Zm(t){try{let e=Qm(t),n=Km(e),r=0;for(let s=0;s<e.length;s++){if(!Xm(e[s]))return NaN;r+=(e[s]-n)*(e[s]-n)}return r/e.length}catch{return NaN}}yi.exports=Zm});var xi=c((kb,Ni)=>{var bi=Ae(),wi=Xe();function ep(t,e){try{let n=bi(t),r=bi(e),s=Math.sqrt((wi(t)+wi(e))/2);return(n-r)/s}catch{return NaN}}Ni.exports=ep});var Si=c((zb,Oi)=>{var vi=y(),tp=d(),Ze=p();function Ti(t,e){if(Ze(vi(t),"The `combine` function only works on arrays!"),Ze(tp(e),"`r` must be a whole number!"),e>t.length)return[t];if(e<=0)return[[]];if(Ze(e===parseInt(e),"`r` must be a whole number!"),t.length<2)return t;let n=[];return t.forEach((r,s)=>{Ze(!vi(r),"It is not recommended to get combinations of arrays of arrays. Weird things happen, and I haven't figured out how to account for such a scenario yet. A possible workaround is: convert each sub-array to a string (using `JSON.stringify`), get the combinations using the array of strings, and then convert each string in each combination back to a sub-array (using `JSON.parse`).");let o=t.slice(s+1);if(o.length<e-1)return;Ti(o,e-1).forEach(u=>{n.push([r].concat(u))})}),n}Oi.exports=Ti});var Ht=c((Pb,Mi)=>{var Ai=Ae(),Ei=g();function np(t,e){try{let n=Ai(t),r=Ai(e),s=Math.max(t.length,e.length),o=0;for(let i=0;i<s;i++){if(Ei(t[i]))return NaN;if(Ei(e[i]))return NaN;o+=(t[i]-n)*(e[i]-r)}return o/t.length}catch{return NaN}}Mi.exports=np});var et=c((Bb,ji)=>{var rp=d(),sp=w();function op(t){try{return rp(t)?Math.sqrt(t):NaN}catch{return NaN}}ji.exports=sp(op)});var tt=c((Fb,Ii)=>{var ip=et(),up=Xe();function ap(t){try{return ip(up(t))}catch{return NaN}}Ii.exports=ap});var Ui=c((_b,Ci)=>{var cp=Ht(),Vi=tt();function lp(t,e){try{return cp(t,e)/(Vi(t)*Vi(e))}catch{return NaN}}Ci.exports=lp});var ki=c((Jb,Yi)=>{var fp=d(),hp=w();function mp(t){try{return fp(t)?Math.cos(t):NaN}catch{return NaN}}Yi.exports=hp(mp)});var _i=c(($b,Fi)=>{var zi=p(),Pi=T(),Bi=y(),pp=ne(),dp=g();function gp(t,e){zi(Bi(t),"You must pass two arrays into the `diff` function!"),zi(Bi(e),"You must pass two arrays into the `diff` function!");let n=Pi(t),r=Pi(e),s=[];return n.forEach(o=>{let i=r.find(u=>pp(u,o));dp(i)&&s.push(o)}),s}Fi.exports=gp});var nt=c((Wb,$i)=>{var Ji=d(),qp=w();function yp(t,e){try{return Ji(t)?Ji(e)?Math.pow(t,e):NaN:NaN}catch{return NaN}}$i.exports=qp(yp)});var rt=c((Db,Wi)=>{var bp=Oe(),wp=T();function Np(t){try{return bp(...wp(t))}catch{return NaN}}Wi.exports=Np});var Kt=c((Rb,Di)=>{var xp=d(),vp=w();function Tp(){try{let t=1,e=Object.values(arguments);for(let n=0;n<e.length;n++){if(!xp(e[n]))return NaN;t*=e[n]}return t}catch{return NaN}}Di.exports=vp(Tp)});var he=c((Lb,Ri)=>{var Op=Kt();function Sp(t,e){return Op(t,e)}Ri.exports=Sp});var Qt=c((Gb,Li)=>{var Ap=Oe(),Ep=he();function Mp(t,e){return Ap(t,Ep(e,-1))}Li.exports=Mp});var Hi=c((Hb,Gi)=>{var jp=nt(),Ip=rt(),Vp=et(),Cp=Qt();function Up(t,e){try{return Vp(Ip(jp(Cp(t,e),2)))}catch{return NaN}}Gi.exports=Up});var Qi=c((Kb,Ki)=>{var Yp=he(),kp=nt();function zp(t,e){return Yp(t,kp(e,-1))}Ki.exports=zp});var Xt=c((Xb,ru)=>{var Ee=p(),Xi=g(),Zi=y(),Pp=d(),Qb=ne(),eu=T(),tu=N(),Bp=rt(),Fp=he(),nu=X();function st(t,e){Ee(!Xi(t)&&!Xi(e),"You must pass two arrays of numbers into the `dot` function!"),Ee(Zi(t)&&Zi(e),"You must pass two arrays of numbers into the `dot` function!"),eu(t).concat(eu(e)).forEach(s=>{Ee(Pp(s),"One of the arrays you passed into the `dot` function contains non-numerical values!")});let n=tu(t),r=tu(e);if(Ee(n.length<=2&&r.length<=2,"I'm not smart enough to know how to get the dot-product of arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `dot` function!"),Ee(n[n.length-1]===r[0],`There's a dimension misalignment in the two arrays you passed into the \`dot\` function. (${n[n.length-1]} !== ${r[0]})`),n.length===1&&r.length===1)return Bp(Fp(t,e));if(n.length===1&&r.length===2)return nu(e).map(s=>st(t,s));if(n.length===2&&r.length===1)return t.map(s=>st(s,e));if(n.length===2&&r.length===2){let s=nu(e),o=[];for(let i=0;i<t.length;i++){let u=[];for(let a=0;a<s.length;a++)u.push(st(t[i],s[a]));o.push(u)}return o}}ru.exports=st});var iu=c((Zb,ou)=>{var su=p(),_p=y(),Jp=g(),$p=N();function Wp(t){return su(_p(t),"The value passed into the `dropMissing` function must be a one-dimensional array!"),su($p(t).length===1,"The value passed into the `dropMissing` function must be a one-dimensional array!"),t.filter(e=>!Jp(e))}ou.exports=Wp});var hu=c((ew,fu)=>{var uu=p(),au=g(),cu=y(),Dp=D(),lu=N();function Rp(t,e){uu(cu(t)&&cu(e),"The two items passed into the `dropMissingPairwise` function must be arrays!"),uu(lu(t).length===1&&lu(e).length===1,"The `dropMissingPairwise` function only works on one-dimensional arrays!");let n=[],r=[];for(let s=0;s<Dp([t.length,e.length]);s++)!au(t[s])&&!au(e[s])&&(n.push(t[s]),r.push(e[s]));return[n,r]}fu.exports=Rp});var bu=c((tw,yu)=>{var mu=p(),pu=g(),du=y(),gu=d(),Lp=D(),qu=N();function Gp(t,e){mu(du(t)&&du(e),"The two items passed into the `dropNaNPairwise` function must be arrays!"),mu(qu(t).length===1&&qu(e).length===1,"The `dropNaNPairwise` function only works on one-dimensional arrays!");let n=[],r=[];for(let s=0;s<Lp([t.length,e.length]);s++)!pu(t[s])&&gu(t[s])&&!pu(e[s])&&gu(e[s])&&(n.push(t[s]),r.push(e[s]));return[n,r]}yu.exports=Gp});var Nu=c((nw,wu)=>{var Hp=w(),Kp=d();function Qp(t){try{return Kp(t)?Math.exp(t):NaN}catch{return NaN}}wu.exports=Hp(Qp)});var Tu=c((rw,vu)=>{var Xp=w();function xu(t){try{return t!==parseInt(t)?NaN:t<=1?1:t*xu(t-1)}catch{return NaN}}vu.exports=Xp(xu)});var Eu=c((sw,Au)=>{var Zp=p(),Ou=y(),ed=j(),Su=R();function td(t,e){Zp(Su(t)||Ou(t),"You must pass (1) an object or array and (2) a function or value into the `find` function!"),ed(e)||(value=e,e=s=>s===value);function n(s,o,i){if(i=i||[],i.indexOf(s)>-1)return null;if(Su(s)){i.push(s);let u=Object.keys(s);for(let a=0;a<u.length;a++){let f=u[a],l=s[f];if(o(l))return l;let m=n(l,o,i);if(m)return m}}else if(Ou(s)){i.push(s);for(let u=0;u<s.length;u++){let a=s[u];if(o(a))return a;let f=n(a,o,i);if(f)return f}}else if(o(s))return s;return null}function r(s){try{return e(s)}catch{return!1}}return n(t,r)}Au.exports=td});var Vu=c((ow,Iu)=>{var nd=p(),Mu=y(),rd=j(),ju=R();function sd(t,e){nd(ju(t)||Mu(t),"You must pass (1) an object or array and (2) a function or value into the `findAll` function!"),rd(e)||(value=e,e=o=>o===value);function n(o,i,u){if(u=u||[],u.indexOf(o)>-1)return null;if(ju(o)){u.push(o);let a=Object.keys(o),f=[];for(let l=0;l<a.length;l++){let m=a[l],h=o[m],q=!1;i(h)&&(f.push(h),q=!0);let b=n(h,i,u);b&&b.length>0&&b.slice(q?1:0).forEach(E=>f.push(E))}return f}else if(Mu(o)){u.push(o);let a=[];for(let f=0;f<o.length;f++){let l=o[f],m=!1;i(l)&&(a.push(l),m=!0);let h=n(l,i,u);h&&h.length>0&&h.slice(m?1:0).forEach(q=>a.push(q))}return a}else if(i(o))return[o];return null}function r(o){try{return e(o)}catch{return!1}}let s=n(t,r);return s&&s.length>0?s:null}Iu.exports=sd});var Uu=c((iw,Cu)=>{var od=d(),id=w();function ud(t){try{let e=JSON.parse(t);return od(e)?e:NaN}catch{return NaN}}Cu.exports=id(ud)});var Zt=c((uw,Yu)=>{var ad=d(),cd=w();function ld(t){try{let e=JSON.parse(t);return ad(e)?parseInt(e):NaN}catch{return NaN}}Yu.exports=cd(ld)});var Pu=c((aw,zu)=>{var ee=p(),fd=g(),en=y(),tn=d(),ku=N(),hd=Zt();function nn(t,e){return ee(!fd(t),"You must pass an array and an index into the `getValueAt` function!"),ee(en(t),"You must pass an array and an index into the `getValueAt` function!"),ee(tn(e)||en(e),"The index passed into the `getValueAt` function must be a positive integer or a one-dimensional array of positive integers!"),en(e)&&(ee(ku(e).length===1,"The index passed into the `getValueAt` function must be a positive integer or a one-dimensional array of positive integers!"),e.forEach(n=>{ee(tn(n)&&hd(n)===n,"The index passed into the `getValueAt` function must be a positive integer or a one-dimensional array of positive integers!")}),ee(e.length<=ku(t).length,"The index passed into the `getValueAt` function has too many dimensions!")),tn(e)?(ee(e<t.length,`The index ${e} is out of bounds!`),t[e]):e.length>1?(ee(e[0]<t.length,`The index ${e[0]} is out of bounds!`),nn(t[e[0]],e.slice(1))):nn(t,e[0])}zu.exports=nn});var rn=c((fw,Bu)=>{var cw=_(),lw=re(),md=d(),pd=ae();function dd(t){md(t)&&(t=[t]);let e=[],n=1;t.forEach(r=>n*=r);for(let r=0;r<n;r++)e.push(0);return pd(e,t)}Bu.exports=dd});var _u=c((hw,Fu)=>{var ot=p(),gd=g(),qd=d(),yd=rn();function bd(t){ot(!gd(t),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),ot(qd(t),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),ot(parseInt(t)===t,"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),ot(t>0,"You must pass an integer greater than 0 (representing the size) into the `identity` function!");let e=yd([t,t]);for(let n=0;n<t;n++)e[n][n]=1;return e}Fu.exports=bd});var Du=c((mw,Wu)=>{var wd=p(),Ju=y(),Nd=j(),$u=R();function xd(t,e){wd($u(t)||Ju(t),"You must pass (1) an object or array and (2) a function or value into the `indexesOf` function!"),Nd(e)||(value=e,e=o=>o===value);function n(o,i,u){if(u=u||[],u.indexOf(o)>-1)return null;if($u(o)){u.push(o);let a=Object.keys(o),f=[];for(let l=0;l<a.length;l++){let m=a[l],h=o[m];i(h)&&f.push([m]);let q=n(h,i,u);q&&q.length>0&&q.forEach(b=>f.push([m].concat(b)))}return f}else if(Ju(o)){u.push(o);let a=[];for(let f=0;f<o.length;f++){let l=o[f];i(l)&&a.push([f]);let m=n(l,i,u);m&&m.length>0&&m.forEach(h=>a.push([f].concat(h)))}return a}else if(i(o))return[];return null}function r(o){try{return e(o)}catch{return!1}}let s=n(t,r);return s&&s.length>0?s:null}Wu.exports=xd});var sn=c((dw,Ru)=>{var pw=p(),vd=F();function Td(){return vd([...arguments])}Ru.exports=Td});var Gu=c((gw,Lu)=>{var Od=y(),Sd=T(),Ad=sn();function Ed(){let t=Object.values(arguments).map(r=>Od(r)?Sd(r):[r]),e=[];return Ad(t).forEach(r=>{for(let s=0;s<t.length;s++)if(t[s].indexOf(r)<0)return;e.push(r)}),e}Lu.exports=Ed});var un=c((yw,Qu)=>{var Me=p(),it=g(),Hu=d(),on=y(),Md=I(),jd=T(),qw=N(),Id=Ge();function Ku(t,e){if(Me(!it(t),"You must pass an array into the `slice` function!"),Me(on(t),"You must pass an array into the `slice` function!"),it(e))return t.slice();Me(on(e),"The indices passed into the `slice` function must be a one-dimensional array of integers or null values."),jd(e).forEach(s=>{Me(it(s)||Hu(s)&&Id(s)===s,"The indices passed into the `slice` function must be a one-dimensional array of integers or null values.")});let n=e[0];it(n)&&(n=Md(0,t.length)),Hu(n)&&(n=[n]);let r=[];return n.forEach(s=>{Me(s<t.length,"Index out of bounds in the `slice` function!"),s<0&&(s+=t.length);let o=t[s];on(o)?r.push(Ku(t[s],e.slice(1,e.length))):r.push(t[s])}),r}Qu.exports=Ku});var ta=c((bw,ea)=>{var J=p(),Vd=g(),Cd=y(),an=d(),Ud=T(),Yd=N(),ut=un(),kd=Xt(),Xu=Oe(),Zu=he(),cn=Rt(),te=I();function ln(t){J(!Vd(t),"You must pass a square 2D array into the `inverse` function!"),J(Cd(t),"You must pass a square 2D array into the `inverse` function!"),Ud(t).forEach(n=>J(an(n),"The array passed into the `inverse` function must contain only numbers!"));let e=Yd(t);if(J(e.length===2,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),J(e[0]===e[1],"The array passed into the `inverse` function must be exactly two-dimensional and square!"),J(e[0]>=0,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),e[0]===0)return t;if(e[0]===1)return J(t[0][0]!==0,"This matrix cannot be inverted!"),1/t[0][0];if(e[0]===2){let n=t[0][0],r=t[0][1],s=t[1][0],o=t[1][1],i=n*o-r*s;J(i!==0,"This matrix cannot be inverted!");let u=[[o,-r],[-s,n]];return Zu(u,1/i)}else if(e[0]>1){let n=(r,s)=>an(r)||an(s)?Zu(r,s):kd(r,s);for(let r=1;r<e[0]-1;r++)try{let s=ut(t,[te(0,r),te(0,r)]),o=ut(t,[te(0,r),te(r,e[0])]),i=ut(t,[te(r,e[0]),te(0,r)]),u=ut(t,[te(r,e[0]),te(r,e[0])]),a=ln(s),f=ln(Xu(u,n(-1,n(n(i,a),o)))),l=Xu(a,n(n(n(n(a,o),f),i),a)),m=n(-1,n(n(a,o),f)),h=n(-1,n(n(f,i),a)),q=f;return cn(cn(l,m,1),cn(h,q,1),0)}catch{}J(!1,"This matrix cannot be inverted!")}}ea.exports=ln});var ra=c((ww,na)=>{var zd=w(),fn=d();function Pd(t,e,n){try{return fn(t)?fn(e)?fn(n)?n*(e-t)+t:NaN:NaN:NaN}catch{return NaN}}na.exports=zd(Pd)});var ia=c((Nw,oa)=>{var sa=d(),Bd=g(),Fd=w();function _d(t,e){try{return e=Bd(e)?Math.E:e,sa(t)?sa(e)?Math.log(t)/Math.log(e):NaN:NaN}catch{return NaN}}oa.exports=Fd(_d)});var aa=c((xw,ua)=>{var je=d(),Jd=w();function $d(t,e,n,r,s){try{return je(t)?je(e)?je(n)?je(r)?je(s)?(s-r)*(t-e)/(n-e)+r:NaN:NaN:NaN:NaN:NaN}catch{return NaN}}ua.exports=Jd($d)});var la=c((Aw,ca)=>{var vw=p(),Tw=g(),Ow=y(),Sw=d(),Wd=T(),Dd=k(),Rd=Be();function Ld(t){try{let e=Wd(t),n=Rd(e);if(n.length===0)return NaN;if(n.length<e.length)return NaN;n=Dd(n);let r;return n.length%2===0?r=(n[n.length/2-1]+n[n.length/2])/2:r=n[Math.floor(n.length/2)],r}catch{return NaN}}ca.exports=Ld});var ma=c((Ew,ha)=>{var Gd=T(),Hd=Ce(),Kd=F(),fa=k();function Qd(t){try{if(t.length===0)return NaN;let e=Gd(t);if(e.length===0)return NaN;let n={},r=Kd(e);r.forEach(u=>{n[u]=Hd(e,u)});let s=fa(r,(u,a)=>n[a]-n[u]),o=s[0],i=fa(s.filter(u=>n[u]===n[o]));return i.length===1?i[0]:i}catch{return NaN}}ha.exports=Qd});var qa=c((Iw,ga)=>{var Xd=g(),Mw=_(),jw=re(),{random:pa}=ce(),Zd=ae(),eg=d();function da(){let t=pa(),e=pa();return Math.sqrt(-2*Math.log(t))*Math.cos(2*Math.PI*e)}function tg(t){if(Xd(t))return da();eg(t)&&(t=[t]);let e=[],n=1;t.forEach(r=>n*=r);for(let r=0;r<n;r++)e.push(da());return Zd(e,t)}ga.exports=tg});var ba=c((Uw,ya)=>{var Vw=_(),Cw=re(),ng=ae(),rg=d();function sg(t){rg(t)&&(t=[t]);let e=[],n=1;t.forEach(r=>n*=r);for(let r=0;r<n;r++)e.push(1);return ng(e,t)}ya.exports=sg});var xa=c((Yw,Na)=>{var wa=y(),og=d(),at=p(),ig=g();function hn(t,e){if(at(wa(t),"The `permute` function only works on arrays!"),ig(e)&&(e=t.length),at(og(e),"`r` must be a whole number!"),e>t.length)return hn(t);if(e<=0)return[[]];if(at(e===parseInt(e),"`r` must be a whole number!"),t.length<2)return t;let n=[];return t.forEach((r,s)=>{at(!wa(r),"It is not recommended to permute arrays of arrays. Weird things happen, and I haven't figured out how to account for such a scenario yet. A possible workaround is: convert each sub-array to a string (using `JSON.stringify`), get the permutations using the array of strings, and then convert each string in each combination back to a sub-array (using `JSON.parse`).");let o=t.slice(0,s),i=t.slice(s+1),u=o.concat(i);hn(u,e-1).forEach(f=>{n.push([r].concat(f))})}),n}Na.exports=hn});var Sa=c((kw,Oa)=>{var ug=y(),ag=N(),{DataFrame:va,Series:Ta}=$t();function cg(){Object.keys(arguments).forEach(t=>{let e=arguments[t];if(ug(e)){let n=ag(e);n.length===1?new Ta(e).print():n.length==2?new va(e).print():console.log(e)}else e instanceof va||e instanceof Ta?e.print():console.log(e)})}Oa.exports=cg});var Ea=c((zw,Aa)=>{var lg=d(),fg=w();function hg(t){try{return lg(t)?Math.round(t):NaN}catch{return NaN}}Aa.exports=fg(hg)});var mn=c((Pw,Ia)=>{var Ma=p(),mg=d(),ja=y(),pg=V();function dg(t,e,n){Ma(ja(t),"The first argument passed into the `setValueAt` function must be an array!"),mg(e)&&(e=[e]),Ma(ja(e),"The second argument passed into the `setValueAt` function must be an integer or an array of integers!");let r=pg(t),s=r;for(let o=0;o<e.length-1;o++)s=s[e[o]];return s[e[e.length-1]]=n,r}Ia.exports=dg});var Ca=c((Bw,Va)=>{var gg=d(),qg=w();function yg(t){try{return gg(t)?t<0?-1:t>0?1:0:NaN}catch{return NaN}}Va.exports=qg(yg)});var Ya=c((Fw,Ua)=>{var bg=d(),wg=w();function Ng(t){try{return bg(t)?Math.sin(t):NaN}catch{return NaN}}Ua.exports=wg(Ng)});var za=c((_w,ka)=>{var xg=tt();function vg(t){return xg(t)}ka.exports=vg});var Ba=c((Jw,Pa)=>{var Tg=V();function Og(t,e,n){return JSON.stringify(Tg(t),e,n)}Pa.exports=Og});var _a=c(($w,Fa)=>{var Sg=d(),Ag=w();function Eg(t){try{return Sg(t)?Math.tan(t):NaN}catch{return NaN}}Fa.exports=Ag(Eg)});var ct=c((Ww,$a)=>{var Ja=j();function Mg(t,e){assert(Ja(t),"`fn` must be a function!");let n=new Date;return e?t(...e):t(),new Date-n}async function jg(t,e){assert(Ja(t),"`fn` must be a function!");let n=new Date;return e?await t(...e):await t(),new Date-n}$a.exports={timeSync:Mg,timeAsync:jg}});var Ra=c((Dw,Da)=>{var Wa=p(),Ig=y(),Vg=j(),Cg=re(),Ug=Se(),Yg=mn(),kg=T();function zg(t,e){Wa(Ig(t),"The first argument passed into the `where` function must be an array!"),Wa(Vg(e),"The second argument passed into the `where` function must be a function!");let n=kg(t).length,r=Cg(t,e),s=[],o=0,i=!1;for(;!i;){let u=Ug(r,!0);u?(s[o]=u,r=Yg(r,u,null),o++):i=!0}return o===0?null:s}Da.exports=zg});var O=c((Rw,pn)=>{var{DataFrame:Pg,Series:Bg}=$t(),Ie={abs:Wt(),add:Oe(),append:Rt(),apply:re(),arccos:Qo(),arcsin:Zo(),arctan:ti(),argmax:ii(),argmin:ci(),assert:p(),ceil:fi(),chop:pi(),clamp:gi(),cohensd:xi(),combine:Si(),copy:V(),correl:Ui(),cos:ki(),count:Ce(),covariance:Ht(),DataFrame:Pg,diff:_i(),distance:Hi(),divide:Qi(),dot:Xt(),dropMissing:iu(),dropMissingPairwise:hu(),dropNaN:Be(),dropNaNPairwise:bu(),exp:Nu(),factorial:Tu(),find:Eu(),findAll:Vu(),flatten:T(),float:Uu(),floor:Ge(),getValueAt:Pu(),identity:_u(),indexOf:Se(),indexesOf:Du(),int:Zt(),intersect:Gu(),inverse:ta(),isArray:y(),isBoolean:ue(),isEqual:ne(),isFunction:j(),isNumber:d(),isObject:R(),isString:S(),isUndefined:g(),lerp:ra(),log:ia(),map:aa(),MathError:Y(),max:D(),mean:Ae(),median:la(),min:Lt(),mode:ma(),multiply:Kt(),ndarray:_(),normal:qa(),ones:ba(),permute:xa(),pow:nt(),print:Sa(),random:ce().random,range:I(),reshape:ae(),reverse:qe(),round:Ea(),scale:he(),seed:ce().seed,Series:Bg,set:F(),setValueAt:mn(),shape:N(),shuffle:It(),sign:Ca(),sin:Ya(),slice:un(),sort:k(),sqrt:et(),std:tt(),stdev:za(),stringify:Ba(),subtract:Qt(),sum:rt(),tan:_a(),time:ct().timeSync,timeSync:ct().timeSync,timeAsync:ct().timeAsync,transpose:X(),union:sn(),variance:Xe(),vectorize:w(),where:Ra(),zeros:rn(),dump:function(){Object.keys(Ie).forEach(t=>{try{global[t]=Ie[t]}catch{try{window[t]=Ie[t]}catch{}}})}};typeof pn<"u"&&(pn.exports=Ie);typeof window<"u"&&(window.JSMathTools=Ie)});var dn=c((Lw,La)=>{var{dropNaN:Fg,flatten:_g,isArray:Jg,set:$g,sort:Wg}=O();function Dg(t){if(typeof t=="number")return t===0||t===1;if(Jg(t)){let e=Fg(_g(t)),n=Wg($g(e));return n.length===2&&n[0]===0&&n[1]===1||n.length===1&&(n[0]===0||n[0]===1)}return!1}La.exports=Dg});var qn=c((Gw,Za)=>{var{abs:Ga,add:Rg,assert:gn,clamp:Lg,copy:Gg,dropNaN:Hg,isArray:Kg,isNumber:Qg,max:Ha,median:Ka,min:Xg,pow:Zg,scale:Xa,shape:eq,sort:tq}=O(),nq=dn(),rq=(t,e)=>Xa(t,Zg(e,-1)),Qa=(t,e)=>Rg(t,Xa(e,-1));function sq(t,e){e=e||5,gn(Qg(e),"`maxScore` must be a number!"),gn(Kg(t),"`x` must be a one-dimensional array!"),gn(eq(t).length===1,"`x` must be a one-dimensional array!");let n=Hg(t);if(nq(n))return[t,!1];if(n.length===0)return[t,!1];let r=Ka(n),s=Ka(Ga(Qa(n,r)));if(s===0){let i=tq(Gg(n)),u=i.filter(m=>m<r),a=i.filter(m=>m>r),f=r,l=r;if(u.length>0&&(f=Ha(u)),a.length>0&&(l=Xg(a)),s=(l-f)/2,s===0)return[t,!1]}return Ha(rq(Ga(Qa(n,r)),s))>e?[t.map(u=>typeof u=="number"?Lg(u,r-e*s,r+e*s):u),!0]:[t,!1]}Za.exports=sq});var oe=c((Hw,ec)=>{var{assert:oq,flatten:iq,isArray:uq,set:aq}=O();function cq(t){oq(uq(t),"The `containsOnlyNumbers` only works on arrays!");let e=iq(t),n=aq(e.map(r=>typeof r));return n.length===1&&n[0]==="number"}ec.exports=cq});var rc=c((Kw,nc)=>{var{assert:tc,isArray:lq,shape:fq,zeros:hq}=O();function mq(t){tc(lq(t),"The `diagonalize` function only works on vectors!");let e=fq(t);tc(e.length===1,"The `diagonalize` function only works on vectors!");let n=hq([e[0],e[0]]);return t.forEach((r,s)=>n[s][s]=r),n}nc.exports=mq});var uc=c((Qw,ic)=>{var{assert:lt,clamp:pq,copy:dq,correl:gq,dropMissingPairwise:qq,isArray:sc,isUndefined:yq,shape:ft,transpose:oc}=O();function bq(t,e){yq(e)&&(e=dq(t)),lt(sc(t)&&sc(e),"`getCorrelationMatrix` only works on matrices!"),lt(ft(t).length===2&&ft(e).length===2,"`getCorrelationMatrix` only works on matrices!"),lt(ft(t)[0]===ft(e)[0],"Matrix `a` and `b` must have the number of rows!");let n=[],r=oc(t),s=oc(e);return r.forEach(o=>{let i=[];s.forEach(u=>{try{let[a,f]=qq(o,u),l=pq(gq(a,f),-1,1);lt(l>=-1&&l<=1,"Uh-oh!"),i.push(l)}catch{i.push(0)}}),n.push(i)}),n}ic.exports=bq});var lc=c((Xw,cc)=>{var{assert:ht,DataFrame:wq,isEqual:ac,set:Nq,sort:xq,transpose:vq}=O(),Tq=oe();function Oq(t){ht(t instanceof wq,"You must pass a correlation matrix DataFrame into the `getHighlyCorrelatedColumns` function!"),ht(Tq(t.values),"The correlation matrix DataFrame passed into the `getHighlyCorrelatedColumns` function must contain only numbers!"),ht(ac(t.values,vq(t.values)),"The correlation matrix DataFrame passed into the `getHighlyCorrelatedColumns` function must be symmetrical!"),ht(ac(t.columns,t.index),"The correlation matrix DataFrame passed into the `getHighlyCorrelatedColumns` function must be symmetrical!");let e={};for(let n=0;n<t.index.length;n++)for(let r=0;r<t.columns.length;r++)if(n!==r){let s=t.values[n][r];if(1-s<1e-5){let o=t.index[n],i=t.columns[r];e[o]||(e[o]=[]),e[i]||(e[i]=[]),e[o].push(i),e[i].push(o)}}return Object.keys(e).forEach(n=>{e[n]=xq(Nq(e[n]))}),e}cc.exports=Oq});var yn=c((Zw,hc)=>{var{assert:fc,isArray:Sq,pow:Aq,sqrt:Eq,sum:Mq}=O(),jq=oe();function Iq(t){return fc(Sq(t),"`getMagnitude` only works on vectors!"),fc(jq(t),"`getMagnitude` only works on vectors of numbers!"),Eq(Mq(Aq(t,2)))}hc.exports=Iq});var bn=c((eN,pc)=>{var{assert:mc,isArray:Vq,isString:Cq,isUndefined:Uq,set:Yq,shape:kq,sort:zq}=O();function Pq(t,e){mc(Cq(t),"The first parameter passed into the `getOneHotEncodings` function must be a string representing the name of the variable being encoded."),mc(Vq(e)&&kq(e).length===1,"The second parameter passed into the `getOneHotEncodings` function must be a one-dimensional array of values.");let n={},r=t+"_"+e[0];return zq(Yq(e)).filter(o=>!Uq(o)).map(o=>t+"_"+o).filter(o=>o!==r).forEach(o=>{n[o]=e.map(i=>o===t+"_"+i?1:0)}),n}pc.exports=Pq});var gc=c((tN,dc)=>{var{count:Bq}=O();function Fq(t){return Bq(t).map(n=>(n.percentage=n.count/t.length,n))}dc.exports=Fq});var qc=c((nN,_q)=>{_q.exports=[.5,.49601,.49202,.48803,.48405,.48006,.47608,.4721,.46812,.46414,.46017,.4562,.45224,.44828,.44433,.44038,.4364,.43251,.42858,.42465,.42074,.41683,.41294,.40905,.40517,.40129,.39743,.39358,.38974,.38591,.38209,.37828,.37448,.3707,.36693,.36317,.35942,.35569,.35197,.34827,.34458,.3409,.33724,.3336,.32997,.32636,.32276,.31918,.31561,.31207,.30854,.30503,.30153,.29806,.2946,.29116,.28774,.28434,.28096,.2776,.27425,.27093,.26763,.26435,.26109,.25785,.25463,.25143,.24825,.2451,.24196,.23885,.23576,.2327,.22965,.22663,.22363,.22065,.2177,.21476,.21186,.20897,.20611,.20327,.20045,.19766,.19489,.19215,.18943,.18673,.18406,.18141,.17879,.17619,.17361,.17106,.16853,.16602,.16354,.16109,.15866,.15625,.15386,.15151,.14917,.14686,.14457,.14231,.14007,.13786,.13567,.1335,.13136,.12924,.12714,.12507,.12302,.121,.119,.11702,.11507,.11314,.11123,.10935,.10749,.10565,.10383,.10204,.10027,.09853,.0968,.0951,.09342,.09176,.09012,.08851,.08692,.08534,.08379,.08226,.08076,.07927,.0778,.07636,.07493,.07353,.07215,.07078,.06944,.06811,.06681,.06552,.06426,.06301,.06178,.06057,.05938,.05821,.05705,.05592,.0548,.0537,.05262,.05155,.0505,.04947,.04846,.04746,.04648,.04551,.04457,.04363,.04272,.04182,.04093,.04006,.0392,.03836,.03754,.03673,.03593,.03515,.03438,.03362,.03288,.03216,.03144,.03074,.03005,.02938,.02872,.02807,.02743,.0268,.02619,.02559,.025,.02442,.02385,.0233,.02275,.02222,.02169,.02118,.02068,.02018,.0197,.01923,.01876,.01831,.01786,.01743,.017,.01659,.01618,.01578,.01539,.015,.01463,.01426,.0139,.01355,.01321,.01287,.01255,.01222,.01191,.0116,.0113,.01101,.01072,.01044,.01017,.0099,.00964,.00939,.00914,.00889,.00866,.00842,.0082,.00798,.00776,.00755,.00734,.00714,.00695,.00676,.00657,.00639,.00621,.00604,.00587,.0057,.00554,.00539,.00523,.00508,.00494,.0048,.00466,.00453,.0044,.00427,.00415,.00402,.00391,.00379,.00368,.00357,.00347,.00336,.00326,.00317,.00307,.00298,.00289,.0028,.00272,.00264,.00256,.00248,.0024,.00233,.00226,.00219,.00212,.00205,.00199,.00193,.00187,.00181,.00175,.00169,.00164,.00159,.00154,.00149,.00144,.00139,.00135,.00131,.00126,.00122,.00118,.00114,.00111,.00107,.00104,.001,97e-5,94e-5,9e-4,87e-5,84e-5,82e-5,79e-5,76e-5,74e-5,71e-5,69e-5,66e-5,64e-5,62e-5,6e-4,58e-5,56e-5,54e-5,52e-5,5e-4,48e-5,47e-5,45e-5,43e-5,42e-5,4e-4,39e-5,38e-5,36e-5,35e-5,34e-5,32e-5,31e-5,3e-4,29e-5,28e-5,27e-5,26e-5,25e-5,24e-5,23e-5,22e-5,22e-5,21e-5,2e-4,19e-5,19e-5,18e-5,17e-5,17e-5,16e-5,15e-5,15e-5,14e-5,14e-5,13e-5,13e-5,12e-5,12e-5,11e-5,11e-5,1e-4,1e-4,1e-4,9e-5,9e-5,8e-5,8e-5,8e-5,8e-5,7e-5,7e-5,7e-5,6e-5,6e-5,6e-5,6e-5,5e-5,5e-5,5e-5,5e-5,5e-5,4e-5,4e-5,4e-5,4e-5,4e-5,4e-5,3e-5,3e-5,3e-5,3e-5,3e-5,3e-5,3e-5,3e-5,2e-5,2e-5,2e-5,2e-5]});var wn=c((rN,Tc)=>{var yc=qc(),{abs:bc,assert:mt,dropNaNPairwise:Jq,isArray:wc,map:$q,mean:Nc,round:Wq,shape:xc,sqrt:Dq,std:vc}=O();function Rq(t){return bc(t)>4.1?0:yc[Wq($q(bc(t),0,4.1,0,yc.length))]}function Lq(t,e){mt(wc(t)&&xc(t).length===1,"You must pass two one-dimensional arrays into the `pValue` (AKA `ttest`) function!"),mt(wc(e)&&xc(e).length===1,"You must pass two one-dimensional arrays into the `pValue` (AKA `ttest`) function!");let[n,r]=Jq(t,e);mt(n.length>0,"There are no numerical values in the first vector you passed into the `pValue` (AKA `ttest`) function!"),mt(r.length>0,"There are no numerical values in the second vector you passed into the `pValue` (AKA `ttest`) function!");let s=Nc(n),o=Nc(r),i=vc(n),u=vc(r),a=n.length,f=r.length,l=(s-o)/Dq(i*i/a+u*u/f);return 2*Rq(l)}Tc.exports=Lq});var jc=c((sN,Mc)=>{var Gq=wn(),{assert:Oc,clamp:Hq,copy:Kq,dropMissingPairwise:Qq,isArray:Sc,isUndefined:Xq,shape:Ac,transpose:Ec}=O();function Zq(t,e){Xq(e)&&(e=Kq(t)),Oc(Sc(t)&&Sc(e),"`getPValueMatrix` only works on matrices!"),Oc(Ac(t).length===2&&Ac(e).length===2,"`getPValueMatrix` only works on matrices!");let n=[],r=Ec(t),s=Ec(e);return r.forEach(o=>{let i=[];s.forEach(u=>{let[a,f]=Qq(o,u),l=Hq(Gq(a,f),0,1);i.push(l)}),n.push(i)}),n}Mc.exports=Zq});var Nn=c((oN,Yc)=>{var{assert:me,dot:Ic,isArray:Vc,scale:ey,shape:Cc}=O(),Uc=oe();function ty(t,e){return me(Vc(t),"`project` only works on vectors!"),me(Vc(e),"`project` only works on vectors!"),me(Uc(t),"`project` only works on vectors of numbers!"),me(Uc(e),"`project` only works on vectors of numbers!"),me(Cc(t).length===1,"`project` only works on vectors!"),me(Cc(e).length===1,"`project` only works on vectors!"),ey(Ic(e,t)/Ic(e,e),e)}Yc.exports=ty});var Bc=c((iN,Pc)=>{var{add:ny,assert:xn,copy:ry,isArray:sy,pow:oy,scale:zc,shape:iy,transpose:kc}=O(),uy=oe(),ay=yn(),cy=Nn(),ly=(t,e)=>zc(t,oy(e,-1)),fy=(t,e)=>ny(t,zc(e,-1));function hy(t){xn(sy(t),"`gramSchmidtOrthonormalize` only works on matrices!"),xn(uy(t),"`gramSchmidtOrthonormalize` only works on matrices of numbers!"),xn(iy(t).length===2,"`gramSchmidtOrthonormalize` only works on matrices!");let e=kc(t),n=[];e.forEach((s,o)=>{let i=ry(s);n.forEach(u=>{i=fy(i,cy(i,u))}),n.push(i)});let r=n.map(s=>ly(s,ay(s)));return kc(r)}Pc.exports=hy});var Tn=c((uN,Jc)=>{var{assert:Fc,count:my,float:py,isArray:vn,isNumber:dy,isString:gy,shape:qy}=O(),_c=["null","none","nan","na","n/a","","undefined"],yy=["true","false","yes","no"];function by(t,e){if(t===void 0&&(t="undefined"),e==="number"){let n=py(t);return isNaN(n)?null:n}if(e==="boolean"){try{let n=t.trim().toLowerCase();if(n==="true"||n==="yes")return!0;if(n==="false"||n==="no")return!1}catch{}return null}if(e==="date"){let n=new Date(t);return n.toString()==="Invalid Date"?null:n}if(e==="object")try{let n=JSON.parse(t);return vn(n)?null:n}catch{return null}if(e==="string"){try{if(_c.indexOf(t.trim().toLowerCase())>-1)return null}catch{return null}return t}}function wy(t){Fc(vn(t),"The `inferType` function only works on one-dimensional arrays!"),Fc(qy(t).length===1,"The `inferType` function only works on one-dimensional arrays!");let e=t.map(s=>{if(s===void 0)return"null";gy(s)||(s=JSON.stringify(s));let i=s.toLowerCase().trim();if(_c.indexOf(i)>-1)return"null";if(yy.indexOf(i)>-1)return"boolean";try{let u=JSON.parse(s);return dy(u)?"number":typeof u=="object"?vn(u)?"string":"object":"string"}catch{return new Date(s).toString()!=="Invalid Date"?"date":"string"}}),r=my(e).sort((s,o)=>o.count-s.count)[0].item;return{type:r,values:t.map(s=>by(s,r))}}Jc.exports=wy});var Dc=c((aN,Wc)=>{var{assert:$c,dropNaN:Ny,isArray:xy,mean:vy,shape:Ty,std:Oy}=O();function Sy(t){$c(xy(t),"The `normalize` function only works on vectors!"),$c(Ty(t).length===1,"The `normalize` function only works on vectors!");let e=Ny(t),n=vy(e),r=Oy(e);return r===0?t:t.map(s=>typeof s=="number"?(s-n)/r:s)}Wc.exports=Sy});var Hc=c((cN,Gc)=>{var{assert:Ay,copy:Ey,correl:My,DataFrame:Rc,dropMissing:jy,isEqual:Iy,set:Vy,transpose:Lc}=O(),Cy=qn(),Uy=bn(),Yy=Tn();function ky(t){Ay(t instanceof Rc,"You must pass a DataFrame into the `preprocess` function!");let e={};t=t.apply(u=>{let a=Yy(u.values);return e[u.name]=a.type,a.values});let n=Ey(t.columns),r=Lc(t.values),s=0,o=!1;for(;!o;){let u=r[s];for(let a=s+1;a<r.length;a++){let f=r[a];Iy(u,f)&&(n.splice(a,1),r.splice(a,1))}s++,o=s>=n.length-1}for(s=0,o=!1;!o;){let u=n[s],a=r[s];if(!a)break;let f=jy(a);if(f.length<15){n.splice(s,1),r.splice(s,1);continue}let l=Vy(f);if(l.length===1){n.splice(s,1),r.splice(s,1);continue}let m=e[u];if(m==="string"){if(l.length===f.length){n.splice(s,1),r.splice(s,1);continue}if(l.length<=7){let h=Uy(u,a);Object.keys(h).forEach(q=>{n.push(q),r.push(h[q]),e[q]="number"}),n.splice(s,1),r.splice(s,1);continue}}else if(m==="number"){let h=Cy(a)[0];r[s]=h;let q=!1;for(let b=0;b<s;b++){let E=r[b];if(My(a,E)>.99){n.splice(s,1),r.splice(s,1),q=!0;break}}if(q)continue}else{r.splice(s,1),n.splice(s,1);continue}s++,o=s>=n.length}let i=new Rc(Lc(r));return i.columns=n,i}Gc.exports=ky});var rl=c((lN,nl)=>{var{abs:zy,add:Py,assert:Ve,isArray:Kc,isEqual:By,mean:Fy,pow:Qc,scale:_y,shape:Xc,sign:Jy,sqrt:$y,sum:Zc}=O(),el=oe(),tl=(t,e)=>Py(t,_y(e,-1));function Wy(t,e){Ve(Kc(t),"You must pass two same-shaped numerical arrays into the `rScore` function!"),Ve(Kc(e),"You must pass two same-shaped numerical arrays into the `rScore` function!"),Ve(By(Xc(t),Xc(e)),"You must pass two same-shaped numerical arrays into the `rScore` function!"),Ve(el(t),"You must pass two same-shaped numerical arrays into the `rScore` function!"),Ve(el(e),"You must pass two same-shaped numerical arrays into the `rScore` function!");let n=Zc(Qc(tl(t,e),2)),r=Zc(Qc(tl(t,Fy(t)),2));if(r===0)return NaN;let s=1-n/r;return Jy(s)*$y(zy(s))}nl.exports=Wy});var al=c((fN,ul)=>{var{argmax:sl,assert:pt,copy:ol,DataFrame:Dy,isEqual:il,max:Ry,min:Ly,pow:Gy,reverse:Hy,sum:Ky,transpose:Qy}=O();function Xy(t){pt(t instanceof Dy,"You must pass a DataFrame into the `sortCorrelationMatrix` function!"),pt(il(t.values,Qy(t.values)),"The correlations matrix passed into the `sortCorrelationMatrix` function must be symmetrical!"),pt(il(t.columns,t.index),"The correlations matrix passed into the `sortCorrelationMatrix` function must be symmetrical!"),pt(Ry(t.values)<=1&&Ly(t.values)>=-1,"The correlations matrix passed into the `sortCorrelationMatrix` function must not contain values less than -1 or greater than 1!");let e=ol(t.index),n=[];for(;e.length>0;)if(n.length===0){let s=0,o=e[0];e.forEach((i,u)=>{let a=t.values[u],f=Ky(Gy(a,2));f>s&&(s=f,o=i)}),n.push(o),e.splice(e.indexOf(o),1)}else{let s=t.index.indexOf(n[n.length-1]),o=ol(t.values[s]);o[s]=-2;let i=sl(o)[0];for(;n.indexOf(t.index[i])>-1;)o[i]=-2,i=sl(o)[0];let u=t.index[i];n.push(u),e.splice(e.indexOf(u),1)}let r=Hy(n);return t.get(r,r)}ul.exports=Xy});var Zy=c((hN,ll)=>{var cl={clipOutliers:qn(),containsOnlyNumbers:oe(),diagonalize:rc(),getCorrelationMatrix:uc(),getHighlyCorrelatedColumns:lc(),getMagnitude:yn(),getOneHotEncodings:bn(),getPercentages:gc(),getPValueMatrix:jc(),gramSchmidtOrthonormalize:Bc(),inferType:Tn(),isBinary:dn(),normalize:Dc(),preprocess:Hc(),project:Nn(),pValue:wn(),rScore:rl(),sortCorrelationMatrix:al(),dump:function(){let t=this;Object.keys(t).forEach(e=>{global[e]=t[e]})}};try{window.JSDataScienceHelpers=cl}catch{}try{ll.exports=cl}catch{}});Zy();})();
