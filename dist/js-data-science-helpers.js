(()=>{var me=(t=>typeof require!="undefined"?require:typeof Proxy!="undefined"?new Proxy(t,{get:(e,n)=>(typeof require!="undefined"?require:e)[n]}):t)(function(t){if(typeof require!="undefined")return require.apply(this,arguments);throw new Error('Dynamic require of "'+t+'" is not supported')});var c=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports);var U=c((a1,An)=>{var pt=class extends Error{constructor(e){typeof window<"u"?super(e):super(`

\x1B[31m`+e+`
\x1B[0m`)}};An.exports=pt});var p=c((c1,Mn)=>{var pl=U();Mn.exports=function(t,e){if(!t)throw new pl(e)}});var y=c((l1,jn)=>{function dl(t){return t instanceof Array}jn.exports=dl});var g=c((f1,Cn)=>{function gl(t){return t===null||typeof t>"u"}Cn.exports=gl});var T=c((h1,Yn)=>{var In=p(),Vn=y(),ql=g();function Un(t){In(!ql(t),"You must pass one array into the `flatten` function!"),In(Vn(t),"The `flatten` function only works on arrays!");let e=[];return t.forEach(function(n){Vn(n)?e=e.concat(Un(n)):e.push(n)}),e}Yn.exports=Un});var re=c((m1,kn)=>{function zn(t,e){let n=typeof t;if(n!==typeof e)return!1;if(n==="undefined")return!0;if(n==="boolean"||n==="number"||n==="bigint"||n==="string"||n==="function")return t===e;if(n==="object"){if(t===null||e===null)return t===null&&e===null;{let s=Object.keys(t),o=Object.keys(e);if(s.length!==o.length)return!1;for(let i=0;i<s.length;i++){let u=s[i];if(typeof e[u]>"u"||!zn(t[u],e[u]))return!1}return!0}}}kn.exports=zn});var $=c((p1,Pn)=>{var Bn=p(),yl=T(),bl=y(),wl=g();function Nl(t){Bn(!wl(t),"You must pass an array into the `set` function!"),Bn(bl(t),"You must pass an array into the `set` function!");let e=[],n={};return yl(t).forEach(r=>{let s=typeof r>"u"?"undefined":typeof r=="function"?r.toString():JSON.stringify(r);n[s]||e.push(r),n[s]=!0}),e}Pn.exports=Nl});var Ie=c((d1,Wn)=>{var Fn=p(),_n=T(),Jn=y(),vl=re(),$n=g(),xl=$();function Tl(t,e){Fn(!$n(t),"You must pass an array and some items to count into the `count` function!"),Fn(Jn(t),"You must pass an array and some items to count into the `count` function!");let n=_n(t);return e=$n(e)?xl(t):e,Jn(e)?_n(e).map(function(r){let s=n.filter(o=>vl(r,o)).length;return{item:r,count:s}}):n.filter(r=>r===e).length}Wn.exports=Tl});var j=c((g1,Rn)=>{function Ol(t){return typeof t=="function"}Rn.exports=Ol});var W=c((q1,Dn)=>{var Sl=y(),El=g();function Al(t){return typeof t=="object"&&!El(t)&&!Sl(t)}Dn.exports=Al});var se=c((y1,Hn)=>{var Ml=p(),Ln=y(),jl=j(),Gn=W();function Cl(t,e){if(Ml(Gn(t)||Ln(t),"You must pass (1) an object or array and (2) a function or value into the `indexOf` function!"),!jl(e)){let o=e;e=i=>i===o}function n(o,i,u){if(u=u||[],u.indexOf(o)>-1)return null;if(Gn(o)){u.push(o);let a=Object.keys(o);for(let f=0;f<a.length;f++){let l=a[f],m=o[l];if(i(m))return[l];let h=n(m,i,u);if(h&&h.length>0)return[l].concat(h)}}else if(Ln(o)){u.push(o);for(let a=0;a<o.length;a++){let f=o[a];if(i(f))return[a];let l=n(f,i,u);if(l&&l.length>0)return[a].concat(l)}}else if(i(o))return[];return null}function r(o){try{return e(o)}catch{return!1}}let s=n(t,r);return s&&s.length>0?s:null}Hn.exports=Cl});var Y=c((b1,Kn)=>{var Il=se(),Vl=y();function Ul(t){function e(r,s,o){if(s=s||[],o=o||"",s.indexOf(r)>-1){let i=o.split("/").slice(o.startsWith("/")?1:0);if(i.some((a,f)=>{let l=i.slice(0,i.length-f-1),m=n;return l.forEach(h=>{m=m[h]}),m===r}))return`<reference to "${n===r?"/":"/"+Il(n,r).join("/")}">`}if(typeof r=="object"){if(r===null)return null;if(s.push(r),Vl(r))return r.map((i,u)=>e(i,s,o+"/"+u));{let i={};return Object.keys(r).forEach(u=>{i[u]=e(r[u],s,o+"/"+u)}),i}}else return r}let n=t;return e(t)}Kn.exports=Ul});var d=c((w1,Qn)=>{function Yl(t){return typeof t=="number"&&!isNaN(t)}Qn.exports=Yl});var R=c((N1,Xn)=>{var zl=T(),kl=d();function Bl(t){try{let e=zl(t),n=-1/0;for(let r=0;r<e.length;r++){if(!kl(e[r]))return NaN;e[r]>n&&(n=e[r])}return n===-1/0?NaN:n}catch{return NaN}}Xn.exports=Bl});var N=c((v1,tr)=>{var Ve=p(),Zn=y(),Pl=g(),Fl=R();function er(t){Ve(!Pl(t),"You must pass an array into the `shape` function!"),Ve(Zn(t),"You must pass an array into the `shape` function!");let e=[t.length],n=t.map(r=>Zn(r));if(n.indexOf(!0)>-1){Ve(n.indexOf(!1)<0,"The array passed into the `shape` function has some children that are not themselves arrays!");let r=t.map(o=>o.length),s=Fl(r);r.forEach(function(o){Ve(o===s,"The array passed into the `shape` function has some children of inconsistent length!")}),e=e.concat(er(t[0]))}return e}tr.exports=er});var z=c((x1,rr)=>{var dt=p(),_l=y(),Jl=j(),nr=g();function $l(t,e){return t<e?-1:t>e?1:0}function Wl(t,e){nr(e)&&(e=$l),dt(!nr(t),"You must pass an array into the `sort` function!"),dt(_l(t),"You must pass an array into the `sort` function!"),dt(Jl(e),"The second parameter of the `sort` function must be a comparison function!");let n=t.slice();return n.sort(e),n}rr.exports=Wl});var ar=c((T1,ur)=>{var sr=U(),Ue=p(),or=Y(),Rl=y(),ir=re(),Dl=N(),Ye=z();function gt(t,e,n,r){if(r instanceof e){Ue(ir(Ye(n.columns),Ye(r.index)),"The index of the incoming Series must match the columns of the target DataFrame!");let s=or(n.values);s.push(n.columns.map(u=>r.get(u)));let o=new t(s);o.columns=n.columns;let i=!0;return o.resetIndex(i)}else if(r instanceof t){Ue(ir(Ye(n.columns),Ye(r.columns)),"The columns of the incoming DataFrame must match the columns of the target DataFrame!");let s=or(n.values);r.values.forEach(u=>{s.push(n.columns.map(a=>{let f=r.columns.indexOf(a);return u[f]}))});let o=new t(s);o.columns=n.columns;let i=!0;return o.resetIndex(i)}else if(Rl(r)){let s=Dl(r);if(s.length===1){Ue(r.length===n.columns.length,"When passing a 1-dimensional array into the `append` method, the array must have the same length as the number of columns in the target DataFrame!");let o=new e(r);return o.index=n.columns,gt(t,e,n,o)}else if(s.length===2){Ue(s[1]===n.columns.length,"When passing a 2-dimensional array into the `append` method, each row of the array must have the same length as the number of columns in the target DataFrame!");let o=new t(r);return o.columns=n.columns,gt(t,e,n,o)}else throw new sr("When passing an array into the `append` method, the array must be 1- or 2-dimensional! If 1-dimensional, it must be as long as the number of columns in the target DataFrame. If 2-dimensional, each row must be as long as the number of columns in the target DataFrame.")}else throw new sr("Only Series, DataFrames, and 1- or 2-dimensional arrays can be passed into the `append` method!")}ur.exports=gt});var mr=c((O1,hr)=>{var cr=p(),lr=y(),Ll=j(),fr=g();function Gl(t,e,n,r,s){if(s=s||0,cr(Ll(r),"The first parameter to the `apply` method must be a function."),cr(s===0||s===1,"The second parameter to the `apply` method (the `axis`) must be 0 or 1."),s===0){let o={},i;if(n.columns.forEach((u,a)=>{let f=new e(n.values.map(m=>m[a]));f.name=u,f.index=n.index;let l=r(f,a,n);l instanceof e?o[u]=l.values:o[u]=l,fr(i)&&(i=l instanceof e||lr(l))}),i){let u=new t(o);return u.index=n.index,u}else{let u=new e(n.columns.map(a=>o[a]));return u.index=n.columns,u}}else if(s===1){let o,i=n.values.map((u,a)=>{let f=new e(u);f.name=n.index[a],f.index=n.columns;let l=r(f,a,n);return fr(o)&&(o=l instanceof e||lr(l)),l instanceof e?l.values:l});if(o){let u=new t(i);return u.index=n.index,u.columns=n.columns,u}else{let u=new e(i);return u.index=n.index,u}}}hr.exports=Gl});var S=c((S1,pr)=>{function Hl(t){return typeof t=="string"}pr.exports=Hl});var yr=c((E1,qr)=>{var qt=U(),D=p(),Kl=Y(),dr=y(),Ql=W(),Xl=S(),Zl=g(),gr=N(),ef=z();function tf(t,e,n,r,s){let o=h=>h instanceof e,i=(()=>{let h={};if(Zl(s))if(o(r)){let q=n.index.map(b=>r.get(b));D(q.length===n.index.length,"Each column of values to be assigned must have the same length as the number of rows in the target DataFrame!"),h[r.name]=q}else if(Ql(r))Object.keys(r).forEach(q=>{let b=r[q];if(o(b)){let A=n.index.map(_=>b.get(_));D(A.length===n.index.length,"Each column of values to be assigned must have the same length as the number of rows in the target DataFrame!"),h[q]=A}else if(dr(b))D(gr(b).length===1,"When using a single argument for the `assign` method, the argument must be either (1) a Series, or (2) an object consisting of key-value pairs where each key is a string representing a column name and each value is a one-dimensional array or Series!"),D(b.length===n.index.length,"Each column of values to be assigned must have the same length as the number of rows in the target DataFrame!"),h[q]=b;else throw new qt("When using a single argument for the `assign` method, the argument must be either (1) a Series, or (2) an object consisting of key-value pairs where each key is a string representing a column name and each value is a one-dimensional array or Series!")});else throw new qt("When using a single argument for the `assign` method, the argument must be either (1) a Series, or (2) an object consisting of key-value pairs where each key is a string representing a column name and each value is a one-dimensional array or Series!");else if(D(Xl(r),"When using two arguments for the `assign` method, the first argument must be a string representing a column name, and the second argument must be a one-dimensional array or Series!"),o(s)){let q=n.index.map(b=>s.get(b));D(q.length===n.index.length,"The one-dimensional array or Series to be assigned must have the same length as the number of rows in the target DataFrame!"),h[r]=q}else if(dr(s))D(gr(s).length===1,"When using two arguments for the `assign` method, the first argument must be a string representing a column name, and the second argument must be a one-dimensional array or Series!"),D(s.length===n.index.length,"The one-dimensional array or Series to be assigned must have the same length as the number of rows in the target DataFrame!"),h[r]=s;else throw new qt("When using two arguments for the `assign` method, the first argument must be a string representing a column name, and the second argument must be a one-dimensional array or Series!");return h})(),u=n.columns,a=n.index,f=Kl(n.values),l=ef(Object.keys(i));f.forEach((h,q)=>{l.forEach(b=>{h.push(i[b][q])})});let m=new t(f);return m.columns=u.concat(l),m.index=a,m}qr.exports=tf});var wr=c((A1,br)=>{var nf=Y();function rf(t,e){if(e.isEmpty)return new t;let n=new t(nf(e.values));return n.columns=e.columns.slice(),n.index=e.index.slice(),n}br.exports=rf});var Er=c((M1,Sr)=>{var ze=p(),Nr=y(),vr=d(),xr=S(),Tr=g(),Or=N();function sf(t,e,n,r,s){Tr(r)&&(r=[]),Tr(s)&&(s=[]),(xr(r)||vr(r))&&(r=[r]),(xr(s)||vr(s))&&(s=[s]),ze(Nr(r),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),ze(Nr(s),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),ze(Or(r).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),ze(Or(s).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");let o,i;n.index.forEach((a,f)=>{r.indexOf(a)<0&&r.indexOf(f)<0&&(o||(o=[]),o.push(a))}),n.columns.forEach((a,f)=>{s.indexOf(a)<0&&s.indexOf(f)<0&&(i||(i=[]),i.push(a))});let u=n.get(o,i);if(u instanceof e){let a=new t;a=a.assign(u),n.index.indexOf(u.name)>-1&&(a=a.transpose()),u=a}return u}Sr.exports=sf});var pe=c((j1,Ar)=>{var of=d();function uf(t){return of(t)&&parseInt(t)===t}function af(t){return uf(t)&&t>=0}Ar.exports=af});var jr=c((C1,Mr)=>{var yt=p(),cf=S(),ke=g(),lf=pe(),ff=N();function hf(t,e,n,r,s,o){r=r||0,yt(r===0||r===1,"The first parameter of the `dropMissing` method (the `axis`) must be 0 or 1."),o=o||0,yt(lf(o),"The third parameter of the `dropMissing` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` null values)."),s=o>0?"none":s||"any",yt(s==="any"||s==="all"||s==="none","The second parameter of the `dropMissing` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains null values, then it should be dropped; or that if 'all' of the data contains null values, then it should be dropped).");function i(f){if(o>0){let l=0;for(let m=0;m<f.length;m++){let h=f[m];if(ke(h)&&l++,l>=o)return[]}}else if(s==="any")for(let l=0;l<f.length;l++){let m=f[l];if(ke(m))return[]}else if(s==="all"){for(let l=0;l<f.length;l++){let m=f[l];if(!ke(m))return f}return[]}return f}let u=n.copy(),a=Math.random().toString();if(r===0){u=u.assign(a,u.index);let f=u.values.map(i).filter(m=>m.length>0);if(ff(f).length<2)return new t;u.values=f;let l=u.get(null,a);if(ke(l))return new t;cf(l)&&(l=[l]),l instanceof e&&(l=l.values),u.index=l,u=u.drop(null,a)}else if(r===1){let f={};if(u.columns.forEach((m,h)=>{let q=u.values.map(A=>A[h]),b=i(q);b.length>0&&(f[m]=b)}),Object.keys(f).length===0)return new t;let l=new t(f);return l.index=u.index,l}return u}Mr.exports=hf});var Be=c((I1,Ir)=>{var Cr=p(),mf=y(),pf=d(),df=g(),gf=N();function qf(t){return Cr(mf(t),"The value passed into the `dropNaN` function must be a one-dimensional array!"),Cr(gf(t).length===1,"The value passed into the `dropNaN` function must be a one-dimensional array"),t.filter(e=>!df(e)&&pf(e))}Ir.exports=qf});var Ur=c((V1,Vr)=>{var bt=p(),yf=Be(),bf=pe();function wf(t,e,n,r,s){n=n||0,bt(n===0||n===1,"The first parameter of the `dropNaN` method (the `axis`) must be 0 or 1."),s=s||0,bt(bf(s),"The third parameter of the `dropNaN` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` NaN values)."),r=s>0?"none":r||"any",bt(r==="any"||r==="all"||r==="none","The second parameter of the `dropNaN` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains NaN values, then it should be dropped; or that if 'all' of the data contains NaN values, then it should be dropped).");function o(u){let a=yf(u);return s>0?u.length-a.length<s:r==="any"?a.length===u.length:r==="all"?a.length>0:!0}let i=e.copy();if(n===0){let u=i.index.filter(a=>{let f=i.get(a,null).values;return o(f)});return u.length>0?i.get(u,null):new t}else if(n===1){let u=i.columns.filter(a=>{let f=i.get(null,a).values;return o(f)});return u.length>0?i.get(null,u):new t}return i}Vr.exports=wf});var Br=c((U1,kr)=>{var Yr=p(),de=T(),Nf=j(),vf=g();function zr(t){let e={};return de(t).forEach((n,r)=>{e[n]=r}),e}function oe(t){return Object.keys(t).sort((e,n)=>t[e]-t[n])}function xf(t,e,n,r,s){Yr(Nf(r),"The `filter` method takes a single parameter: a function that is used to filter the values."),vf(s)&&(s=0),Yr(s===0||s===1,"The `axis` parameter to the `filter` method must be 0 or 1.");let o=n.copy();if(o.isEmpty)return o;let i=zr(o.index),u=zr(o.columns);if(s===0){let a=o.values.filter((f,l)=>{let m=new e(f);m.name=n.index[l],m.index=n.columns;let h=r(m,l,n);return h||delete i[o.index[l]],h});if(de(a).length===0)return new t;if(a.length===1){let f=new e(de(a));return f.name=oe(i)[0],f.index=oe(u),f}o.values=a,o.index=oe(i)}else if(s===1){o=o.transpose();let a=o.values.filter((f,l)=>{let m=new e(f);m.name=n.columns[l],m.index=n.index;let h=r(m,l,n);return h||delete u[o.index[l]],h});if(de(a).length===0)return new t;if(a.length===1){let f=new e(de(a));return f.name=oe(u)[0],f.index=oe(i),f}o.values=a,o.index=oe(u),o=o.transpose()}return o}kr.exports=xf});var ie=c((Y1,Pr)=>{function Tf(t){return typeof t=="boolean"}Pr.exports=Tf});var ge=c((z1,_r)=>{var Fr=p(),Of=y(),Sf=g();function Ef(t){Fr(!Sf(t),"You must pass an array into the `reverse` function!"),Fr(Of(t),"You must pass an array into the `reverse` function!");let e=[];for(let n=t.length-1;n>=0;n--)e.push(t[n]);return e}_r.exports=Ef});var C=c((k1,Jr)=>{var wt=p(),Nt=d(),vt=g(),Af=ge();function Mf(t,e,n=1){wt(!vt(t)&&!vt(e)&&!vt(n),"You must pass two numbers and optionally a step value to the `range` function!"),wt(Nt(t)&&Nt(e)&&Nt(n),"You must pass two numbers and optionally a step value to the `range` function!"),wt(n>0,"The step value must be greater than 0! (NOTE: The step value is a magnitude; it does not indicate direction.)");let r=!1;if(t>e){r=!0;let o=t;t=e+n,e=o+n}let s=[];for(let o=t;o<e;o+=n)s.push(o);return r&&(s=Af(s)),s}Jr.exports=Mf});var xt=c((B1,Rr)=>{var Pe=U(),L=p(),G=y(),$r=ie(),Fe=S(),_e=g(),jf=R(),Wr=C();function Cf(t,e,n,r,s,o){return n=(()=>{if(_e(n))return!1;if($r(n))return n;throw new Pe("The `hasHeaderRow` parameter of the `fromCSV` method must be a boolean!")})(),r=(()=>{if(_e(r))return!1;if($r(r))return r;throw new Pe("The `hasIndexColumn` parameter of the `fromCSV` method must be a boolean!")})(),s=(()=>{let u="The `fieldDelimiter` parameter of the `fromCSV` method must be one of:\n\n1) a single-character string (e.g., ',')\n2) an array containing two single-character strings, one each for a left delimiter and a right delimiter (e.g., ['<', '>'])";if(_e(s))return",";if(Fe(s))return L(s.length===1,u),s;if(G(s))return L(s.length===2,u),L(s[0].length===1,u),L(s[1].length===1,u),s;throw new Pe(u)})(),o=(()=>{let u="The `stringDelimiter` parameter of the `fromCSV` method must be one of:\n\n1) a single-character string (e.g., '\"')\n2) an array containing two single-character strings, one each for a left delimiter and a right delimiter (e.g., ['\u201C', '\u201D'])";if(_e(o))return'"';if(Fe(o))return L(o.length===1,u),o;if(G(o))return L(o.length===2,u),L(o[0].length===1,u),L(o[1].length===1,u),o;throw new Pe(u)})(),(()=>{let a=e.split(`
`).filter(q=>q.length>0).map(q=>{let b=[],A="",_=!1;for(let J=0;J<q.length;J++){let M=q[J];if(M.match(/\\/g))J++;else if(G(o)&&M===o[0])_=!0;else if(G(o)&&M===o[1])_=!1;else if(Fe(o)&&M===o)_=!_;else if(G(s)&&M===s[0]||G(s)&&M===s[1]||Fe(s)&&M===s)if(_)A+=M;else{let ht=A;try{let mt=JSON.parse(ht);G(mt)?b.push(ht.trim()):b.push(mt)}catch{b.push(ht.trim())}A=""}else A+=M}if(A.length>0){let J=A;try{let M=JSON.parse(J);G(M)?b.push(J.trim()):b.push(M)}catch{b.push(J.trim())}}return b}),f=(()=>{let q=n?a.shift():Wr(0,a[0].length).map(b=>"col"+b);return r&&q.shift(),q})(),l=(()=>r?a.map(b=>b.shift()):Wr(0,a.length).map(b=>"row"+b))(),m=jf(a.map(q=>q.length)),h=new t(a.map(q=>(q.length=m,q)));return n&&(h.columns=f),r&&(h.index=l),h})()}Rr.exports=Cf});var Lr=c((P1,Dr)=>{var If=U(),Vf=p(),Uf=xt(),Yf=S(),zf=g();async function kf(t,e,n,r,s,o,i){n=(()=>zf(n)?"utf8":(Vf(Yf(n),"The `encoding` parameter of the `fromCSV` method must be a string (e.g., 'utf8')!"),n))();let u=await(async()=>{try{return await(await fetch(e)).text()}catch{}try{return me("fs").readFileSync(e,n)}catch{}throw new If(`The path "${e}" could not be loaded!`)})();return Uf(t,u,r,s,o,i)}Dr.exports=kf});var Kr=c((F1,Hr)=>{var I=p(),Je=d(),$e=S(),Gr=g(),Bf=$();function Pf(t,e,n){($e(e)||Je(e))&&(e=[e]),($e(n)||Je(n))&&(n=[n]);let r=Bf((e||[]).concat(n||[]).map(s=>typeof s));return I(r.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===1&&I(r[0]==="string"||r[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===2&&(I(r.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),I(r.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),Gr(e)||(e=e.map(s=>{if($e(s))return I(t.index.indexOf(s)>-1,`Row "${s}" does not exist!`),s;if(Je(s))return I(s>=0,`Index ${s} is out of bounds!`),I(parseInt(s)===s,"Row numbers must be integers!"),I(s<t.index.length,`Index ${s} is out of bounds!`),t.index[s]})),Gr(n)||(n=n.map(s=>{if($e(s))return I(t.columns.indexOf(s)>-1,`Column "${s}" does not exist!`),s;if(Je(s))return I(s>=0,`Column ${s} is out of bounds!`),I(parseInt(s)===s,"Column numbers must be integers!"),I(s<t.columns.length,`Column ${s} is out of bounds!`),t.columns[s]})),t.getSubsetByNames(e,n)}Hr.exports=Pf});var es=c((_1,Zr)=>{var Qr=p(),Xr=S(),Ff=g(),_f=$(),Jf=z();function $f(t){let e=t.toLowerCase(),n="";for(let s=0;s<e.length;s++){let o=e[s];o.match(/[a-z0-9]/g)?n+=o:n+=" "}let r=n.split(" ").filter(s=>s.length>0);return r[0]+r.slice(1).map(s=>s[0].toUpperCase()+s.substring(1)).join("")}function Wf(t,e,n){Ff(n)?n=e.columns:Xr(n)&&(n=[n]);let r={};n.forEach(o=>{Qr(Xr(o),"You must pass either a string or a one-dimensional array of strings into the `getDummies` (AKA `oneHotEncode`) method!");let i=e.columns.indexOf(o);Qr(i>-1,`The given DataFrame does not have a column called "${o}"!`);let u=e.values.map(f=>f[i]),a=Jf(_f(u));u.forEach(f=>{a.forEach(l=>{let m=o+"_"+$f(l.toString());r[m]||(r[m]=[]),f===l?r[m].push(1):r[m].push(0)})})});let s=new t(r);return s.index=e.index,s}Zr.exports=Wf});var as=c((J1,us)=>{var H=p(),ts=y(),ns=d(),rs=g(),ss=pe(),os=C(),is=N();function Rf(t,e,n){let r=t.shape;rs(e)&&(e=os(0,r[0])),rs(n)&&(n=os(0,r[1])),ns(e)&&(e=[e]),ns(n)&&(n=[n]),H(ts(e)&&ts(n),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),H(is(e).length===1&&is(n).length===1,"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),H(e.length>0,"The `rowIndices` array must contain at least one index."),H(n.length>0,"The `colIndices` array must contain at least one index."),e.forEach(i=>{H(ss(i),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),H(i<t.index.length,`The row index ${i} is out of bounds.`)}),n.forEach(i=>{H(ss(i),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),H(i<t.columns.length,`The column index ${i} is out of bounds.`)});let s=e.map(i=>t.index[i]),o=n.map(i=>t.columns[i]);return t.getSubsetByNames(s,o)}us.exports=Rf});var ms=c(($1,hs)=>{var K=p(),Tt=T(),cs=y(),We=S(),ls=g(),fs=N();function Df(t,e,n,r,s){ls(r)&&(r=n.index),ls(s)&&(s=n.columns),We(r)&&(r=[r]),We(s)&&(s=[s]),K(cs(r)&&cs(s),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),K(fs(r).length===1&&fs(s).length===1,"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),K(r.length>0,"The `rows` array must contain at least one row name."),K(s.length>0,"The `cols` array must contain at least one column name."),r.forEach(u=>{K(We(u),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),K(n.index.indexOf(u)>-1,`The row name "${u}" does not exist in the list of rows.`)}),s.forEach(u=>{K(We(u),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),K(n.columns.indexOf(u)>-1,`The column name "${u}" does not exist in the list of columns.`)});let o=r.map(u=>s.map(a=>n.values[n.index.indexOf(u)][n.columns.indexOf(a)]));if(r.length===1&&s.length===1)return Tt(o)[0];if(r.length===1){let u=new e(Tt(o));return u.name=r[0],u.index=s,u}if(s.length===1){let u=new e(Tt(o));return u.name=s[0],u.index=r,u}let i=new t(o);return i.columns=s,i.index=r,i}hs.exports=Df});var qe=c((W1,ps)=>{var Lf=p(),Gf=d();function Hf(t,e){Lf(Gf(t),"The `leftPad` function only works on numbers!");let n=t.toString();for(;n.length<e;)n="0"+n;return n}ps.exports=Hf});var ws=c((R1,bs)=>{var ds=U(),Re=p(),gs=Y(),Kf=y(),qs=re(),ys=qe(),Qf=N(),De=z();function Ot(t,e,n,r){if(r instanceof e){Re(qs(De(r.index),De(n.index)),"The index of the incoming Series must match the index of the target DataFrame!");let s=gs(n.values);n.index.forEach((i,u)=>{let a=r.get(i);s[u].push(a)});let o=new t(s);return o.columns=n.columns.concat([r.name]),o}else if(r instanceof t){Re(qs(De(r.index),De(n.index)),"The index of the incoming DataFrame must match the index of the target DataFrame!");let s=gs(n.values);n.index.forEach((i,u)=>{let a=r.values[r.index.indexOf(i)];s[u]=s[u].concat(a)});let o=new t(s);return o.columns=n.columns.concat(r.columns),o}else if(Kf(r)){let s=Qf(r);if(s.length===1){Re(r.length===n.values.length,"When passing a 1-dimensional array into the `join` method, the array must have the same length as the number of rows in the target DataFrame!");let o=new e(r);return o.index=n.index,o.name="col"+ys(n.columns.length,n.columns.length.toString().length),Ot(t,e,n,o)}else if(s.length===2){Re(r.length===n.values.length,"When passing a 2-dimensional array into the `join` method, each column of the array must have the same length as the number of rows in the target DataFrame!");let o=new t(r);return o.index=n.index,o.columns=o.columns.map((i,u)=>"col"+ys(n.columns.length+u,n.columns.length.toString().length)),Ot(t,e,n,o)}else throw new ds("When passing an array into the `join` method, the array must be 1- or 2-dimensional! If 1-dimensional, it must be as long as the number of rows of the target DataFrame. If 2-dimensional, each column must be as long as the number of rows in the target DataFrame.")}else throw new ds("Only Series, DataFrames, and 1- or 2-dimensional arrays can be passed into the `join` method!")}bs.exports=Ot});var vs=c((D1,Ns)=>{var Xf=S(),ye=C();function Zf(t,e,n){function r(h,q){return Xf(h)&&h.length>q?h.substring(0,q-3)+"...":h}if(n.isEmpty)return console.table({}),console.log("Shape:",[0,0],`
`),n;let s=typeof window>"u"?20:10,o=parseInt(s/2),i=typeof window>"u"?Math.floor(process.stdout.columns/24)-1:10,u=parseInt(i/2),a=s>n.index.length?null:ye(0,o).concat(ye(n.index.length-o,n.index.length)),f=i>n.columns.length?null:ye(0,u).concat(ye(n.columns.length-u,n.columns.length)),l=n.get(a,f);l instanceof e&&(n.shape[0]===1?(l=new t([l.values]),l.index=n.index,l.columns=new e(n.columns).get(f).values):n.shape[1]===1&&(l=new t([l.values]).transpose(),l.index=new e(n.index).get(a).values,l.columns=n.columns)),s<=n.index.length&&(l._index.splice(o,0,"..."),l._values.splice(o,0,ye(0,l.columns.length).map(()=>"..."))),i<=n.columns.length&&(l._columns.splice(u,0,"..."),l._values=l._values.map(h=>(h.splice(u,0,"..."),h)));let m=28;return l instanceof e?(l.values=l.values.map(h=>r(h,m)),l.name=r(l.name,m),l.index=l.index.map(h=>r(h,m))):(l.values=l.values.map(h=>h.map(q=>r(q,m))),l.columns=l.columns.map(h=>r(h,m)),l.index=l.index.map(h=>r(h,m))),console.table(l.toObject()),console.log("Shape:",n.shape,`
`),n}Ns.exports=Zf});var Ts=c((L1,xs)=>{var e0=qe(),t0=C();function n0(t,e){let n=e?t:t.copy();return n.index=t0(0,t.shape[0]).map(r=>"row"+e0(r,(n.index.length-1).toString().length)),n}xs.exports=n0});var ue=c((G1,Ms)=>{var be=p(),Os=T(),Ss=y(),Es=d(),r0=N(),s0=t=>t.reduce((e,n)=>e*n);function As(t,e){if(be(Ss(t),"The first argument passed into the `reshape` function must be an array!"),Es(e)&&(e=[e]),be(Ss(e),"The second argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),be(r0(e).length===1,"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),e.forEach(o=>{be(Es(o)&&parseInt(o)===o&&o>0,"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!")}),e.length<=1)return Os(t);let n=Os(t);be(s0(e)===n.length,"The new shape doesn't match the number of values available in `x` (the first argument passed into the `reshape` function)!");let r=[],s=parseInt(n.length/e[0]);for(let o=0;o<e[0];o++){let i=n.slice(o*s,(o+1)*s);r.push(As(i,e.slice(1)))}return r}Ms.exports=As});var ae=c((H1,ks)=>{var o0=p(),Is=Y(),Vs=d(),Us=g(),i0=ue(),Ys=Math.pow(2,64),v=[];zs(parseInt(Math.random()*Ys));function u0(t,e){t=E(t);function n(){t+=E("0x9e3779b97f4a7c15");let s=Is(t);return s=(s^s>>30n)*E("0xbf58476d1ce4e5b9"),s=(s^s>>27n)*E("0x94d049bb133111eb"),s^s>>31n}let r=[];for(let s=0;s<e;s++)r.push(n());return r}function E(t){return BigInt.asUintN(64,BigInt(t))}function js(t,e){return t=E(t),e=BigInt(e),E(E(t<<e)|E(t>>E(64n-e)))}function zs(t){if(Us(t))return Is(v);{o0(Vs(t),"If passing a value into the `seed` function, then that value must be an integer!");let e=u0(parseInt(t),4);v[0]=e[0],v[1]=e[1],v[2]=e[2],v[3]=e[3]}}function Cs(){let t=E(js(v[0]+v[3],23)+v[0]),e=E(v[1]<<17n);return v[2]=E(v[2]^v[0]),v[3]=E(v[3]^v[1]),v[1]=E(v[1]^v[2]),v[0]=E(v[0]^v[3]),v[2]=E(v[2]^e),v[3]=js(v[3],45),parseInt(t)/Ys}function a0(t){if(Us(t))return Cs();Vs(t)&&(t=[t]);let e=[],n=1;t.forEach(r=>n*=r);for(let r=0;r<n;r++)e.push(Cs());return i0(e,t)}ks.exports={random:a0,seed:zs}});var St=c((K1,Ps)=>{var Bs=p(),c0=y(),l0=g(),{random:f0}=ae();function h0(t){Bs(!l0(t),"You must pass an array into the `shuffle` function!"),Bs(c0(t),"You must pass an array into the `shuffle` function!");let e=[],n=t.slice();for(let r=0;r<t.length;r++){let s=parseInt(f0()*n.length);e.push(n.splice(s,1)[0])}return e}Ps.exports=h0});var Js=c((Q1,_s)=>{var m0=p(),p0=g(),Fs=St();function d0(t,e){return p0(e)&&(e=0),m0(e===0||e===1,"The `axis` parameter to the `shuffle` must be 0, 1, or undefined."),t.get(e===0?Fs(t.index):null,e===1?Fs(t.columns):null)}_s.exports=d0});var Ls=c((X1,Ds)=>{var V=p(),g0=T(),$s=y(),Et=ie(),At=d(),ce=S(),Ws=g(),q0=C(),Rs=N(),y0=z(),{random:b0}=ae();function w0(t,e,n){let r=t.copy(),s=b0().toString();return r=r.assign(s,r.index),Ws(e)&&(e=[s],n=[!0]),(At(e)||ce(e))&&(e=[e],(Et(n)||ce(n))&&(n=[n])),V($s(e),"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),V(Rs(e).length===1,"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),Ws(n)&&(n=q0(0,e.length).map(()=>!0)),V($s(n),"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),V(Rs(n).length===1,"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),V(e.length===n.length,"The arrays passed into the `sort` method must be equal in length."),e=e.map(o=>{if(V(ce(o)||At(o),"Column references can either be column names (as strings) or column indices (as whole numbers)."),ce(o)){let i=r.columns.indexOf(o);return V(i>-1,`The column "${o}" does not exist!`),i}if(At(o))return V(parseInt(o)===o,"Column indices must be whole numbers!"),V(o>=0,`The column index ${o} is out of bounds!`),V(o<r.columns.length,`The index ${o} is out of bounds!`),o}),n=n.map(o=>{if(V(ce(o)||Et(o),"Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),ce(o)){let i=o.trim().toLowerCase();return V(i==="ascending"||i==="descending","Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),i==="ascending"}if(Et(o))return o}),r.values=y0(r.values,(o,i)=>{let u=0;for(;o[e[u]]===i[e[u]]&&u<e.length;)u++;let a=n[u];if(o[e[u]]===i[e[u]])return 0;if(o[e[u]]<i[e[u]])return a?-1:1;if(o[e[u]]>i[e[u]])return a?1:-1}),r.index=g0(r.get(null,s).values),r=r.dropColumns(s),r}Ds.exports=w0});var Mt=c((Z1,Hs)=>{var N0=U(),v0=ie(),x0=W(),T0=S(),Gs=g();function O0(t,e){e=(()=>{if(Gs(e))return!0;if(v0(e))return e;throw new N0("The `shouldIncludeIndex` parameter of the `toCSVString` method must be a boolean!")})();let n=[""].concat(t.index);return[t.columns].concat(t.values).map((s,o)=>(e?[n[o]]:[]).concat(s).map(u=>T0(u)?JSON.stringify(u):x0(u)?JSON.stringify(JSON.stringify(u)):Gs(u)?"":u.toString()).join(",")).join(`
`)}Hs.exports=O0});var Ks=c((eb,Ct)=>{var jt=U(),S0=Mt();function E0(t,e,n){let r=S0(t,n),s=!1,o=!1,i,u;try{let a=e;if(e.includes("/")){let l=e.split("/");a=l[l.length-1]}let f=document.createElement("a");f.href=`data:text/csv;charset=utf-8,${encodeURIComponent(r)}`,f.download=a,f.dispatchEvent(new MouseEvent("click")),s=!0}catch(a){i=a}try{let a=me("fs"),f=me("path");a.writeFileSync(f.resolve(e),r,"utf8"),o=!0}catch(a){u=a}if(!s&&!o)throw typeof window<"u"?new jt(i):typeof Ct<"u"?new jt(u):new jt("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");return t}Ct.exports=E0});var It=c((tb,Qs)=>{function A0(t,e){return JSON.stringify(t.toObject(e))}Qs.exports=A0});var Xs=c((nb,Ut)=>{var Vt=U(),M0=It();function j0(t,e,n){let r=M0(t,n),s=!1,o=!1,i,u;try{let a=e;if(e.includes("/")){let l=e.split("/");a=l[l.length-1]}let f=document.createElement("a");f.href=`data:application/json;charset=utf-8,${encodeURIComponent(r)}`,f.download=a,f.dispatchEvent(new MouseEvent("click")),s=!0}catch(a){i=a}try{let a=me("fs"),f=me("path");a.writeFileSync(f.resolve(e),r,"utf8"),o=!0}catch(a){u=a}if(!s&&!o)throw typeof window<"u"?new Vt(i):typeof Ut<"u"?new Vt(u):new Vt("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");return t}Ut.exports=j0});var eo=c((rb,Zs)=>{var C0=p(),I0=g();function V0(t,e){I0(e)?e=0:C0(e===0||e===1,"The axis parameter of the `toObject` method must be undefined, 0, or 1. An axis of 0 indicates that the returned object should be organized first by rows and then by columns. An axis of 1 indicates that the returned object should be organized first by columns and then by rows.");let n={};return e===0?t.index.forEach((r,s)=>{let o={};t.columns.forEach((i,u)=>{o[i]=t.values[s][u]}),n[r]=o}):t.columns.forEach((r,s)=>{let o={};t.index.forEach((i,u)=>{o[i]=t.values[u][s]}),n[r]=o}),n}Zs.exports=V0});var ve=c((sb,no)=>{var we=p(),U0=T(),Y0=y(),z0=d(),k0=g(),Ne="You must pass a natural number or a one-dimensional array of natural numbers into the `ndarray` function!";function to(t,e){if(e||(we(!k0(t),Ne),Y0(t)||(t=[t]),t=U0(t),we(t.length>0,Ne),t.forEach(n=>{we(z0(n),Ne),we(parseInt(n)===n,Ne),we(n>=0,Ne)})),t.length===1){let n=[];for(let r=0;r<t[0];r++)n.push(void 0);return n}else{let n=[];for(let r=0;r<t[0];r++)n.push(to(t.slice(1),!0));return n}}no.exports=to});var Q=c((ob,so)=>{var Yt=p(),B0=y(),P0=g(),F0=ve(),ro=ge(),_0=N();function J0(t){Yt(!P0(t),"You must pass an array into the `transpose` function!"),Yt(B0(t),"You must pass an array into the `transpose` function!");let e=_0(t);if(Yt(e.length<=2,"I'm not smart enough to know how to transpose arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `transpose` function!"),e.length===1)return ro(t);if(e.length===2){let n=F0(ro(e));for(let r=0;r<e[0];r++)for(let s=0;s<e[1];s++)n[s][r]=t[r][s];return n}}so.exports=J0});var io=c((ib,oo)=>{var $0=p(),W0=j();function R0(t,e){$0(W0(e),"The parameter to the `apply` method must be a function.");let n=t.copy();return n.values=n.values.map((r,s)=>e(r,n.index[s])),n}oo.exports=R0});var ao=c((ub,uo)=>{var D0=g();function L0(t){let e=t.copy(),n=[];return e.values=e.values.filter((r,s)=>D0(r)?!1:(n.push(e.index[s]),!0)),e.index=n,e}uo.exports=L0});var lo=c((ab,co)=>{var G0=d();function H0(t,e){let n=[],r=[];e.values.forEach((o,i)=>{G0(o)&&(r.push(o),n.push(e.index[i]))});let s=new t(r);return s.name=e.name,s.index=n,s}co.exports=H0});var ho=c((cb,fo)=>{var K0=Y();function Q0(t,e,n){let r=e.copy(),s=K0(r.index),o=[],i=r.values.filter((u,a)=>{let f=n(u,a,r.values);return f||o.push(r.index[a]),f});return o.forEach(u=>{s.splice(s.indexOf(u),1)}),i.length===0?(r=new t,r.name=e.name,r):(r.values=i,r.index=s,r)}fo.exports=Q0});var po=c((lb,mo)=>{var X=p(),X0=d(),Z0=S(),eh=g(),th=$();function nh(t,e){(Z0(e)||X0(e))&&(e=[e]);let n=th((e||[]).map(r=>typeof r));return X(n.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===1&&X(n[0]==="string"||n[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===2&&(X(n.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),X(n.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),eh(e)||(e=e.map(r=>{if(typeof r=="string")return X(t.index.indexOf(r)>-1,`Index "${r}" does not exist!`),r;if(typeof r=="number")return X(r>=0,`Index ${r} is out of bounds!`),X(parseInt(r)===r,"Indices must be integers!"),X(r<t.index.length,`Index ${r} is out of bounds!`),t.index[r]})),t.getSubsetByNames(e)}mo.exports=nh});var qo=c((fb,go)=>{var xe=p(),rh=y(),sh=g(),oh=pe(),ih=C(),uh=N();function ah(t,e){let n=t.shape;sh(e)&&(e=ih(0,n[0])),xe(rh(e),"The `indices` array must be 1-dimensional array of whole numbers."),xe(uh(e).length===1,"The `indices` array must be a 1-dimensional array of whole numbers."),xe(e.length>0,"The `indices` array must contain at least one index."),e.forEach(s=>{xe(oh(s),"The `indices` array must be a 1-dimensional array of whole numbers."),xe(s<t.index.length,`The row index ${s} is out of bounds.`)});let r=e.map(s=>t.index[s]);return t.getSubsetByNames(r)}go.exports=ah});var bo=c((hb,yo)=>{var Te=p(),ch=y(),lh=S(),fh=g(),hh=N();function mh(t,e,n){fh(n)&&(n=e.index),Te(ch(n),"The `indices` array must be a 1-dimensional array of strings."),Te(hh(n).length===1,"The `indices` array must be a 1-dimensional array of strings."),Te(n.length>0,"The `indices` array must contain at least one index name."),n.forEach(o=>{Te(lh(o),"The `indices` array must contain only strings."),Te(e.index.indexOf(o)>-1,`The name "${o}" does not exist in the index.`)});let r=n.map(o=>e.values[e.index.indexOf(o)]);if(r.length===1)return r[0];let s=new t(r);return s.index=n,s.name=e.name,s}yo.exports=mh});var vo=c((mb,No)=>{var ph=Y(),wo=C();function dh(t){let e=t.copy(),n=typeof window>"u"?20:10;if(e.index.length>n){e=e.get(wo(0,n/2).concat(wo(e.index.length-n/2,e.index.length)));let s=ph(e.index);s.splice(parseInt(s.length/2),0,"..."),e.values.push("..."),e.index.push("..."),e=e.get(s)}let r={};return e.values.forEach((s,o)=>{let i={};i[e.name]=s,r[e.index[o]]=i}),console.table(r),console.log("Shape:",t.shape,`
`),t}No.exports=dh});var Mo=c((pb,Ao)=>{var xo=p(),To=ie(),Oo=S(),So=g(),gh=z(),Eo=Q();function qh(t,e,n){xo(To(n)||Oo(n)||So(n),"The `sort` method can take an optional parameter that's either a string representing a direction ('ascending' or 'descending') or a boolean representing whether or not the direction is ascending (true or false).");let r=!0;So(n)&&(r=!0),Oo(n)&&(n=n.trim().toLowerCase(),xo(n==="ascending"||n==="descending","The `sort` method can take an optional parameter that's either a string representing a direction ('ascending' or 'descending') or a boolean representing whether or not the direction is ascending (true or false)."),r=n==="ascending"),To(n)&&(r=n);let s=Eo([e.values,e.index]);s=Eo(gh(s,(i,u)=>{if(i[0]===u[0])return 0;if(i[0]<u[0])return r?-1:1;if(i[0]>u[0])return r?1:-1}));let o=new t(s[0]);return o.index=s[1],o.name=e.name,o}Ao.exports=qh});var Io=c((db,Co)=>{var yh=z(),jo=Q();function bh(t,e){let n=jo([e.values,e.index]);n=jo(yh(n,(s,o)=>{if(s[1]===o[1])return 0;if(s[1]<o[1])return-1;if(s[1]>o[1])return 1}));let r=new t(n[0]);return r.index=n[1],r.name=e.name,r}Co.exports=bh});var Uo=c((gb,Vo)=>{function wh(t){let e={};return e[t.name]={},t.index.forEach((n,r)=>{e[t.name][n]=t.values[r]}),e}Vo.exports=wh});var Fo=c((qb,Po)=>{var te=p(),Nh=Y(),Yo=y(),vh=S(),xh=g(),zo=qe(),Th=ve(),ko=C(),Bo=ge(),Oh=io(),Sh=ao(),Eh=lo(),Ah=ho(),Mh=po(),jh=qo(),Ch=bo(),Ih=vo(),Vh=Mo(),Uh=Io(),Yh=Uo(),Le=N(),zh=Q();Po.exports=function(t){class e{constructor(r){let s=this;if(s.name="data",Object.defineProperty(s,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(s,"values",{configurable:!0,enumerable:!0,get(){return s._values},set(o){te(Yo(o),"The new values must be a 1-dimensional array!");let i=Le(o);te(i.length===1,"The new array of values must be 1-dimensional!"),i[0]<s._index.length?s._index=s._index.slice(0,i[0]):i[0]>s._index.length&&(s._index=s._index.concat(ko(s._index.length,i[0]).map(u=>"row"+zo(u,(o.length-1).toString().length)))),s._values=o}}),Object.defineProperty(s,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(s,"index",{configurable:!0,enumerable:!0,get(){return s._index},set(o){te(Yo(o),"The new index must be a 1-dimensional array of strings!"),te(o.length===s.shape[0],"The new index must be the same length as the old index!"),te(Le(o).length===1,"The new index must be a 1-dimensional array of strings!"),o.forEach(i=>{te(vh(i),"All of the row names must be strings!")}),s._index=o}}),r){let o=Le(r);te(o.length===1,"The `data` array passed into the constructor of a DataFrame must be 1-dimensional!"),s.values=r}}get shape(){return Le(this.values)}get isEmpty(){return this.values.filter(s=>!xh(s)).length===0}clear(){let r=this,s=r.copy();return s.values=Th(s.shape),s.index=r.index,s}get(r){return Mh(this,r)}getSubsetByNames(r){return Ch(e,this,r)}getSubsetByIndices(r){return jh(this,r)}loc(r){return this.getSubsetByNames(r)}iloc(r){return this.getSubsetByIndices(r)}reverse(){let r=this,s=new e(Bo(r.values));return s.index=Bo(r.index),s.name=r.name,s}resetIndex(){let r=this,s=r.copy();return s.index=ko(0,r.shape[0]).map(o=>"row"+zo(o,(s.index.length-1).toString().length)),s}copy(){let r=this,s=new e(Nh(r.values));return s.index=r.index.slice(),s.name=r.name,s}apply(r){return Oh(this,r)}dropMissing(r,s){return Sh(this,r,s)}dropNaN(){return Eh(e,this)}toObject(){return Yh(this)}print(){return Ih(this)}sort(r){return Vh(e,this,r)}sortByIndex(){return Uh(e,this)}filter(r){return Ah(e,this,r)}toDataFrame(){let r=this,s=new t(zh([r.values]));return s.columns=[r.name],s.index=r.index,s}getDummies(){return this.toDataFrame().getDummies()}oneHotEncode(){return this.getDummies()}}return e}});var Bt=c((yb,Ro)=>{var B=p(),_o=Ie(),kh=ar(),Bh=mr(),Ph=yr(),Fh=wr(),_h=Er(),Jh=jr(),$h=Ur(),Wh=Br(),Rh=Lr(),Dh=xt(),Lh=Kr(),Jo=es(),Gh=as(),Hh=ms(),Kh=ws(),Qh=vs(),Xh=Ts(),Zh=Js(),em=Ls(),tm=Ks(),nm=Mt(),rm=Xs(),sm=It(),om=eo(),im=T(),Ge=y(),$o=g(),zt=qe(),um=ve(),kt=C(),le=N(),Wo=Q();function He(t){let e="abcdefghijklmnopqrstuvwxyz1234567890",n="";for(let r=0;r<t;r++)n+=e[parseInt(Math.random()*e.length)];return n}var x=class{constructor(e){let n=this;if(Object.defineProperty(n,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(n,"values",{configurable:!0,enumerable:!0,get(){return n._values.length===0||!$o(n._values[0])&&n._values[0].length===0?[[]]:n._values},set(r){B(Ge(r),"The new values must be a 2-dimensional array!");let s=le(r);B(s.length===2,"The new array of values must be 2-dimensional!"),s[0]<n._index.length?n._index=n._index.slice(0,s[0]):s[0]>n._index.length&&(n._index=n._index.concat(kt(n._index.length,s[0]).map(o=>"row"+zt(o,(s[0]-1).toString().length)))),s[1]<n._columns.length?n._columns=n._columns.slice(0,s[1]):s[1]>n._columns.length&&(n._columns=n._columns.concat(kt(n._columns.length,s[1]).map(o=>"col"+zt(o,(s[1]-1).toString().length)))),n._values=r}}),Object.defineProperty(n,"_columns",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(n,"columns",{configurable:!0,enumerable:!0,get(){return n._columns},set(r){B(Ge(r),"The new columns list must be a 1-dimensional array of strings!"),B(n.isEmpty||r.length===n.shape[1],"The new columns list must be the same length as the old columns list!"),B(le(r).length===1,"The new columns list must be a 1-dimensional array of strings!"),r=r.map(o=>(typeof o!="string"&&(o=JSON.stringify(o)||o.toString()),o.trim().length===0?"untitled_"+He(8):o.trim()));let s=(()=>{let o=_o(r),i={};return o.forEach(u=>{i[u.item]=u.count}),i})();r=r.map(o=>s[o]>1?o+"_"+He(8):o),n._columns=r}}),Object.defineProperty(n,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(n,"index",{configurable:!0,enumerable:!0,get(){return n._index},set(r){B(Ge(r),"The new index must be a 1-dimensional array of strings!"),B(n.isEmpty||r.length===n.shape[0],"The new index must be the same length as the old index!"),B(le(r).length===1,"The new index must be a 1-dimensional array of strings!"),r=r.map(o=>(typeof o!="string"&&(o=JSON.stringify(o)||o.toString()),o.trim().length===0?"untitled_"+He(8):o.trim()));let s=(()=>{let o=_o(r),i={};return o.forEach(u=>{i[u.item]=u.count}),i})();r=r.map(o=>s[o]>1?o+"_"+He(8):o),n._index=r}}),B($o(e)||e instanceof Object,"The `data` passed into the constructor of a DataFrame must be either (1) an object where the key-value pairs are (respectively) column names and 1-dimensional arrays of values, or (2) a 2-dimensional array of values."),e)if(Ge(e)){let r=le(e);B(r.length===2,"The `data` array passed into the constructor of a DataFrame must be 2-dimensional!"),n.values=e}else{n._columns=Object.keys(e);let r=[];n._columns.forEach(o=>{let i=e[o];r.push(i)}),n._values=Wo(r);let s=le(n.values);n._index=kt(0,s[0]).map(o=>"row"+zt(o,(s[0]-1).toString().length))}}get shape(){return le(this.values)}get rows(){return this.index}set rows(e){let n=this;n.index=e}get isEmpty(){return im(this.values).length===0}clear(){let e=this,n=new x(um(e.shape));return n.columns=e.columns.slice(),n.index=e.index.slice(),n}get(e,n){return Lh(this,e,n)}getSubsetByNames(e,n){return Hh(x,P,this,e,n)}getSubsetByIndices(e,n){return Gh(this,e,n)}loc(e,n){return this.getSubsetByNames(e,n)}iloc(e,n){return this.getSubsetByIndices(e,n)}getDummies(e){return Jo(x,this,e)}oneHotEncode(e){return Jo(x,this,e)}transpose(){let e=this,n=new x(Wo(e.values));return n.columns=e.index,n.index=e.columns,n}get T(){return this.transpose()}resetIndex(e){return Xh(this,e)}copy(){return Fh(x,this)}assign(e,n){return Ph(x,P,this,e,n)}apply(e,n){return Bh(x,P,this,e,n)}map(e,n){return this.apply(e,n)}dropMissing(e,n,r){return Jh(x,P,this,e,n,r)}dropNaN(e,n,r){return $h(x,this,e,n,r)}drop(e,n){return _h(x,P,this,e,n)}dropColumns(e){return this.drop(null,e)}dropRows(e){return this.drop(e,null)}toObject(e){return om(this,e)}toCSVString(e){return nm(this,e)}toCSV(e,n){return tm(this,e,n)}toJSON(e,n){return rm(this,e,n)}toJSONString(e){return sm(this,e)}print(){return Qh(x,P,this)}sort(e,n){return em(this,e,n)}sortByIndex(){return this.sort()}filter(e,n){return Wh(x,P,this,e,n)}shuffle(e){return Zh(this,e)}append(e){return kh(x,P,this,e)}join(e){return Kh(x,P,this,e)}};x.fromCSV=function(){return Rh(x,...arguments)};x.fromCSVString=function(){return Dh(x,...arguments)};var P=Fo()(x);Ro.exports={DataFrame:x,Series:P}});var w=c((bb,Do)=>{var Pt=p(),Ft=y(),am=j(),cm=g(),lm=R();function fm(t){return Pt(!cm(t),"You must pass a function into the `vectorize` function!"),Pt(am(t),"You must pass a function into the `vectorize` function!"),function e(){if(Object.keys(arguments).map(r=>Ft(arguments[r])).indexOf(!0)>-1){let r=[],s=Object.keys(arguments).filter(i=>Ft(arguments[i])).map(i=>arguments[i].length),o=lm(s);s.forEach(i=>{Pt(i===o,"If using arrays for all arguments to this function, then the arrays must all have equal length!")});for(let i=0;i<o;i++){let u=Object.keys(arguments).map(a=>Ft(arguments[a])?arguments[a][i]:arguments[a]);r.push(e(...u))}return r}else return t(...arguments)}}Do.exports=fm});var _t=c((wb,Lo)=>{var hm=d(),mm=w();function pm(t){try{return hm(t)?Math.abs(t):NaN}catch{return NaN}}Lo.exports=mm(pm)});var Oe=c((Nb,Go)=>{var dm=d(),gm=w();function qm(){try{let t=0,e=Object.values(arguments);for(let n=0;n<e.length;n++){if(!dm(e[n]))return NaN;t+=e[n]}return t}catch{return NaN}}Go.exports=gm(qm)});var $t=c((vb,Zo)=>{var k=p(),Ho=y(),ym=d(),Ko=g(),Qo=N(),Jt=Q();function Xo(t,e,n=0){k(!Ko(t),"You must pass two arrays into the `append` function!"),k(!Ko(e),"You must pass two arrays into the `append` function!"),k(Ho(t),"You must pass two arrays into the `append` function!"),k(Ho(e),"You must pass two arrays into the `append` function!"),k(ym(n),"The `axis` argument to the `append` function must be 0 or 1!"),k(n>=0&&n<2,"The `axis` argument to the `append` function must be 0 or 1!"),k(parseInt(n)===n,"The `axis` argument to the `append` function must be 0 or 1!");let r=Qo(t),s=Qo(e);k(r.length===s.length,"The two arrays passed into the `append` function must have the same number of dimensions!"),k(r.length<3&&s.length<3,"The two arrays passed into the `append` function must be 1- or 2-dimensional!");for(let o=0;o<r.length;o++)o!==n&&k(r[o]===s[o],`The two arrays passed into the \`append\` function must have the same shapes along all axes *except* the axis along which they're being appended! (${r[o]} != ${s[o]})`);if(k(n<r.length,"The axis argument you passed into the `append` function is out of bounds for the array!"),r.length===0)return[];if(r.length===1)return t.concat(e);if(r.length===2){if(n===0){let o=[];for(let i=0;i<r[0];i++)o.push(t[i]);for(let i=0;i<s[0];i++)o.push(e[i]);return o}else if(n===1)return Jt(Xo(Jt(t),Jt(e),0))}}Zo.exports=Xo});var Wt=c((xb,ei)=>{var bm=w();function wm(t,e){try{return e(t)}catch{return NaN}}ei.exports=bm(wm)});var ni=c((Tb,ti)=>{var Nm=d(),vm=w();function xm(t){try{return Nm(t)?Math.acos(t):NaN}catch{return NaN}}ti.exports=vm(xm)});var si=c((Ob,ri)=>{var Tm=d(),Om=w();function Sm(t){try{return Tm(t)?Math.asin(t):NaN}catch{return NaN}}ri.exports=Om(Sm)});var ii=c((Sb,oi)=>{var Em=d(),Am=w();function Mm(t){try{return Em(t)?Math.atan(t):NaN}catch{return NaN}}oi.exports=Am(Mm)});var ai=c((Eb,ui)=>{var jm=se(),Cm=R();function Im(t){try{let e=jm(t,Cm(t));return e?e.length===0?null:e.length===1?e[0]:e:null}catch{return NaN}}ui.exports=Im});var Rt=c((Ab,ci)=>{var Vm=T(),Um=d();function Ym(t){try{let e=Vm(t),n=1/0;for(let r=0;r<e.length;r++){if(!Um(e[r]))return NaN;e[r]<n&&(n=e[r])}return n===1/0?NaN:n}catch{return NaN}}ci.exports=Ym});var fi=c((Mb,li)=>{var zm=se(),km=Rt();function Bm(t){try{let e=zm(t,km(t));return e?e.length===0?null:e.length===1?e[0]:e:null}catch{return NaN}}li.exports=Bm});var mi=c((jb,hi)=>{var Pm=d(),Fm=w();function _m(t){try{return Pm(t)?Math.ceil(t):NaN}catch{return NaN}}hi.exports=Fm(_m)});var gi=c((Cb,di)=>{var Jm=_t(),pi=d(),$m=g(),Wm=w();function Rm(t,e){try{if(!pi(t))return NaN;if($m(e))e=1e-10;else if(!pi(e))return NaN;return Jm(t)<e?0:t}catch{return NaN}}di.exports=Wm(Rm)});var yi=c((Ib,qi)=>{var Dt=d(),Dm=w();function Lm(t,e,n){try{return Dt(t)?Dt(e)?Dt(n)?t<e?e:t>n?n:t:NaN:NaN:NaN}catch{return NaN}}qi.exports=Dm(Lm)});var Se=c((Vb,bi)=>{var Gm=T(),Hm=d();function Km(t){try{let e=Gm(t),n=0;for(let r=0;r<e.length;r++){if(!Hm(e[r]))return NaN;n+=e[r]}return n/e.length}catch{return NaN}}bi.exports=Km});var Ke=c((Ub,wi)=>{var Qm=T(),Xm=d(),Zm=Se();function ep(t){try{let e=Qm(t),n=Zm(e),r=0;for(let s=0;s<e.length;s++){if(!Xm(e[s]))return NaN;r+=(e[s]-n)*(e[s]-n)}return r/e.length}catch{return NaN}}wi.exports=ep});var Ti=c((Yb,xi)=>{var Ni=Se(),vi=Ke();function tp(t,e){try{let n=Ni(t),r=Ni(e),s=Math.sqrt((vi(t)+vi(e))/2);return(n-r)/s}catch{return NaN}}xi.exports=tp});var Ai=c((zb,Ei)=>{var Qe=p(),Oi=y(),np=d();function Si(t,e){if(Qe(Oi(t),"The `combine` function only works on arrays!"),Qe(np(e),"`r` must be a whole number!"),e>t.length)return[t];if(e<=0)return[[]];if(Qe(e===parseInt(e),"`r` must be a whole number!"),t.length<2)return t;let n=[];return t.forEach((r,s)=>{Qe(!Oi(r),"It is not recommended to get combinations of arrays of arrays. Weird things happen, and I haven't figured out how to account for such a scenario yet. A possible workaround is: convert each sub-array to a string (using `JSON.stringify`), get the combinations using the array of strings, and then convert each string in each combination back to a sub-array (using `JSON.parse`).");let o=t.slice(s+1);if(o.length<e-1)return;Si(o,e-1).forEach(u=>{n.push([r].concat(u))})}),n}Ei.exports=Si});var Lt=c((kb,Ci)=>{var Mi=g(),ji=Se();function rp(t,e){try{let n=ji(t),r=ji(e),s=Math.max(t.length,e.length),o=0;for(let i=0;i<s;i++){if(Mi(t[i]))return NaN;if(Mi(e[i]))return NaN;o+=(t[i]-n)*(e[i]-r)}return o/t.length}catch{return NaN}}Ci.exports=rp});var Xe=c((Bb,Ii)=>{var sp=d(),op=w();function ip(t){try{return sp(t)?Math.sqrt(t):NaN}catch{return NaN}}Ii.exports=op(ip)});var Ze=c((Pb,Vi)=>{var up=Xe(),ap=Ke();function cp(t){try{return up(ap(t))}catch{return NaN}}Vi.exports=cp});var zi=c((Fb,Yi)=>{var lp=Lt(),Ui=Ze();function fp(t,e){try{return lp(t,e)/(Ui(t)*Ui(e))}catch{return NaN}}Yi.exports=fp});var Bi=c((_b,ki)=>{var hp=d(),mp=w();function pp(t){try{return hp(t)?Math.cos(t):NaN}catch{return NaN}}ki.exports=mp(pp)});var $i=c((Jb,Ji)=>{var Pi=p(),Fi=T(),_i=y(),dp=re(),gp=g();function qp(t,e){Pi(_i(t),"You must pass two arrays into the `diff` function!"),Pi(_i(e),"You must pass two arrays into the `diff` function!");let n=Fi(t),r=Fi(e),s=[];return n.forEach(o=>{let i=r.find(u=>dp(u,o));gp(i)&&s.push(o)}),s}Ji.exports=qp});var et=c(($b,Ri)=>{var Wi=d(),yp=w();function bp(t,e){try{return Wi(t)?Wi(e)?Math.pow(t,e):NaN:NaN}catch{return NaN}}Ri.exports=yp(bp)});var Gt=c((Wb,Di)=>{var wp=d(),Np=w();function vp(){try{let t=1,e=Object.values(arguments);for(let n=0;n<e.length;n++){if(!wp(e[n]))return NaN;t*=e[n]}return t}catch{return NaN}}Di.exports=Np(vp)});var fe=c((Rb,Li)=>{var xp=Gt();function Tp(t,e){return xp(t,e)}Li.exports=Tp});var Ht=c((Db,Gi)=>{var Op=Oe(),Sp=fe();function Ep(t,e){return Op(t,Sp(e,-1))}Gi.exports=Ep});var tt=c((Lb,Hi)=>{var Ap=Oe(),Mp=T();function jp(t){try{return Ap(...Mp(t))}catch{return NaN}}Hi.exports=jp});var Qi=c((Gb,Ki)=>{var Cp=et(),Ip=Xe(),Vp=Ht(),Up=tt();function Yp(t,e){try{return Ip(Up(Cp(Vp(t,e),2)))}catch{return NaN}}Ki.exports=Yp});var Zi=c((Hb,Xi)=>{var zp=et(),kp=fe();function Bp(t,e){return kp(t,zp(e,-1))}Xi.exports=Bp});var Kt=c((Kb,ou)=>{var Ee=p(),eu=T(),tu=y(),Pp=d(),nu=g(),Fp=fe(),ru=N(),_p=tt(),su=Q();function nt(t,e){Ee(!nu(t)&&!nu(e),"You must pass two arrays of numbers into the `dot` function!"),Ee(tu(t)&&tu(e),"You must pass two arrays of numbers into the `dot` function!"),eu(t).concat(eu(e)).forEach(s=>{Ee(Pp(s),"One of the arrays you passed into the `dot` function contains non-numerical values!")});let n=ru(t),r=ru(e);if(Ee(n.length<=2&&r.length<=2,"I'm not smart enough to know how to get the dot-product of arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `dot` function!"),Ee(n[n.length-1]===r[0],`There's a dimension misalignment in the two arrays you passed into the \`dot\` function. (${n[n.length-1]} !== ${r[0]})`),n.length===1&&r.length===1)return _p(Fp(t,e));if(n.length===1&&r.length===2)return su(e).map(s=>nt(t,s));if(n.length===2&&r.length===1)return t.map(s=>nt(s,e));if(n.length===2&&r.length===2){let s=su(e),o=[];for(let i=0;i<t.length;i++){let u=[];for(let a=0;a<s.length;a++)u.push(nt(t[i],s[a]));o.push(u)}return o}}ou.exports=nt});var au=c((Qb,uu)=>{var iu=p(),Jp=y(),$p=g(),Wp=N();function Rp(t){return iu(Jp(t),"The value passed into the `dropMissing` function must be a one-dimensional array!"),iu(Wp(t).length===1,"The value passed into the `dropMissing` function must be a one-dimensional array!"),t.filter(e=>!$p(e))}uu.exports=Rp});var pu=c((Xb,mu)=>{var cu=p(),lu=y(),fu=g(),Dp=R(),hu=N();function Lp(t,e){cu(lu(t)&&lu(e),"The two items passed into the `dropMissingPairwise` function must be arrays!"),cu(hu(t).length===1&&hu(e).length===1,"The `dropMissingPairwise` function only works on one-dimensional arrays!");let n=[],r=[];for(let s=0;s<Dp([t.length,e.length]);s++)!fu(t[s])&&!fu(e[s])&&(n.push(t[s]),r.push(e[s]));return[n,r]}mu.exports=Lp});var Nu=c((Zb,wu)=>{var du=p(),gu=y(),qu=d(),yu=g(),Gp=R(),bu=N();function Hp(t,e){du(gu(t)&&gu(e),"The two items passed into the `dropNaNPairwise` function must be arrays!"),du(bu(t).length===1&&bu(e).length===1,"The `dropNaNPairwise` function only works on one-dimensional arrays!");let n=[],r=[];for(let s=0;s<Gp([t.length,e.length]);s++)!yu(t[s])&&qu(t[s])&&!yu(e[s])&&qu(e[s])&&(n.push(t[s]),r.push(e[s]));return[n,r]}wu.exports=Hp});var xu=c((ew,vu)=>{var Kp=d(),Qp=w();function Xp(t){try{return Kp(t)?Math.exp(t):NaN}catch{return NaN}}vu.exports=Qp(Xp)});var Su=c((tw,Ou)=>{var Zp=w();function Tu(t){try{return t!==parseInt(t)?NaN:t<=1?1:t*Tu(t-1)}catch{return NaN}}Ou.exports=Zp(Tu)});var ju=c((nw,Mu)=>{var ed=p(),Eu=y(),td=j(),Au=W();function nd(t,e){if(ed(Au(t)||Eu(t),"You must pass (1) an object or array and (2) a function or value into the `find` function!"),!td(e)){let s=e;e=o=>o===s}function n(s,o,i){if(i=i||[],i.indexOf(s)>-1)return null;if(Au(s)){i.push(s);let u=Object.keys(s);for(let a=0;a<u.length;a++){let f=u[a],l=s[f];if(o(l))return l;let m=n(l,o,i);if(m)return m}}else if(Eu(s)){i.push(s);for(let u=0;u<s.length;u++){let a=s[u];if(o(a))return a;let f=n(a,o,i);if(f)return f}}else if(o(s))return s;return null}function r(s){try{return e(s)}catch{return!1}}return n(t,r)}Mu.exports=nd});var Uu=c((rw,Vu)=>{var rd=p(),Cu=y(),sd=j(),Iu=W();function od(t,e){if(rd(Iu(t)||Cu(t),"You must pass (1) an object or array and (2) a function or value into the `findAll` function!"),!sd(e)){let o=e;e=i=>i===o}function n(o,i,u){if(u=u||[],u.indexOf(o)>-1)return null;if(Iu(o)){u.push(o);let a=Object.keys(o),f=[];for(let l=0;l<a.length;l++){let m=a[l],h=o[m],q=!1;i(h)&&(f.push(h),q=!0);let b=n(h,i,u);b&&b.length>0&&b.slice(q?1:0).forEach(A=>f.push(A))}return f}else if(Cu(o)){u.push(o);let a=[];for(let f=0;f<o.length;f++){let l=o[f],m=!1;i(l)&&(a.push(l),m=!0);let h=n(l,i,u);h&&h.length>0&&h.slice(m?1:0).forEach(q=>a.push(q))}return a}else if(i(o))return[o];return null}function r(o){try{return e(o)}catch{return!1}}let s=n(t,r);return s&&s.length>0?s:null}Vu.exports=od});var zu=c((sw,Yu)=>{var id=d(),ud=w();function ad(t){try{let e=JSON.parse(t);return id(e)?e:NaN}catch{return NaN}}Yu.exports=ud(ad)});var Qt=c((ow,ku)=>{var cd=d(),ld=w();function fd(t){try{return cd(t)?Math.floor(t):NaN}catch{return NaN}}ku.exports=ld(fd)});var Xt=c((iw,Bu)=>{var hd=d(),md=w();function pd(t){try{let e=JSON.parse(t);return hd(e)?parseInt(e):NaN}catch{return NaN}}Bu.exports=md(pd)});var _u=c((uw,Fu)=>{var Z=p(),dd=Xt(),Zt=y(),en=d(),gd=g(),Pu=N();function tn(t,e){return Z(!gd(t),"You must pass an array and an index into the `getValueAt` function!"),Z(Zt(t),"You must pass an array and an index into the `getValueAt` function!"),Z(en(e)||Zt(e),"The index passed into the `getValueAt` function must be a positive integer or a one-dimensional array of positive integers!"),Zt(e)&&(Z(Pu(e).length===1,"The index passed into the `getValueAt` function must be a positive integer or a one-dimensional array of positive integers!"),e.forEach(n=>{Z(en(n)&&dd(n)===n,"The index passed into the `getValueAt` function must be a positive integer or a one-dimensional array of positive integers!")}),Z(e.length<=Pu(t).length,"The index passed into the `getValueAt` function has too many dimensions!")),en(e)?(Z(e<t.length,`The index ${e} is out of bounds!`),t[e]):e.length>1?(Z(e[0]<t.length,`The index ${e[0]} is out of bounds!`),tn(t[e[0]],e.slice(1))):tn(t,e[0])}Fu.exports=tn});var nn=c((aw,Ju)=>{var qd=d(),yd=ue();function bd(t){qd(t)&&(t=[t]);let e=[],n=1;t.forEach(r=>n*=r);for(let r=0;r<n;r++)e.push(0);return yd(e,t)}Ju.exports=bd});var Wu=c((cw,$u)=>{var rt=p(),wd=d(),Nd=g(),vd=nn();function xd(t){rt(!Nd(t),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),rt(wd(t),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),rt(parseInt(t)===t,"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),rt(t>0,"You must pass an integer greater than 0 (representing the size) into the `identity` function!");let e=vd([t,t]);for(let n=0;n<t;n++)e[n][n]=1;return e}$u.exports=xd});var Gu=c((lw,Lu)=>{var Td=p(),Ru=y(),Od=j(),Du=W();function Sd(t,e){if(Td(Du(t)||Ru(t),"You must pass (1) an object or array and (2) a function or value into the `indexesOf` function!"),!Od(e)){let o=e;e=i=>i===o}function n(o,i,u){if(u=u||[],u.indexOf(o)>-1)return null;if(Du(o)){u.push(o);let a=Object.keys(o),f=[];for(let l=0;l<a.length;l++){let m=a[l],h=o[m];i(h)&&f.push([m]);let q=n(h,i,u);q&&q.length>0&&q.forEach(b=>f.push([m].concat(b)))}return f}else if(Ru(o)){u.push(o);let a=[];for(let f=0;f<o.length;f++){let l=o[f];i(l)&&a.push([f]);let m=n(l,i,u);m&&m.length>0&&m.forEach(h=>a.push([f].concat(h)))}return a}else if(i(o))return[];return null}function r(o){try{return e(o)}catch{return!1}}let s=n(t,r);return s&&s.length>0?s:null}Lu.exports=Sd});var rn=c((fw,Hu)=>{var Ed=$();function Ad(){return Ed([...arguments])}Hu.exports=Ad});var Qu=c((hw,Ku)=>{var Md=T(),jd=y(),Cd=rn();function Id(){let t=Object.values(arguments).map(r=>jd(r)?Md(r):[r]),e=[];return Cd(t).forEach(r=>{for(let s=0;s<t.length;s++)if(t[s].indexOf(r)<0)return;e.push(r)}),e}Ku.exports=Id});var on=c((mw,ea)=>{var Ae=p(),Vd=T(),Ud=Qt(),sn=y(),Xu=d(),st=g(),Yd=C();function Zu(t,e){if(Ae(!st(t),"You must pass an array into the `slice` function!"),Ae(sn(t),"You must pass an array into the `slice` function!"),st(e))return t.slice();Ae(sn(e),"The indices passed into the `slice` function must be a one-dimensional array of integers or null values."),Vd(e).forEach(s=>{Ae(st(s)||Xu(s)&&Ud(s)===s,"The indices passed into the `slice` function must be a one-dimensional array of integers or null values.")});let n=e[0];st(n)&&(n=Yd(0,t.length)),Xu(n)&&(n=[n]);let r=[];return n.forEach(s=>{Ae(s<t.length,"Index out of bounds in the `slice` function!"),s<0&&(s+=t.length);let o=t[s];sn(o)?r.push(Zu(t[s],e.slice(1,e.length))):r.push(t[s])}),r}ea.exports=Zu});var sa=c((pw,ra)=>{var ta=Oe(),un=$t(),F=p(),zd=Kt(),kd=T(),Bd=y(),an=d(),Pd=g(),ee=C(),na=fe(),Fd=N(),ot=on();function cn(t){F(!Pd(t),"You must pass a square 2D array into the `inverse` function!"),F(Bd(t),"You must pass a square 2D array into the `inverse` function!"),kd(t).forEach(n=>F(an(n),"The array passed into the `inverse` function must contain only numbers!"));let e=Fd(t);if(F(e.length===2,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),F(e[0]===e[1],"The array passed into the `inverse` function must be exactly two-dimensional and square!"),F(e[0]>=0,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),e[0]===0)return t;if(e[0]===1)return F(t[0][0]!==0,"This matrix cannot be inverted!"),1/t[0][0];if(e[0]===2){let n=t[0][0],r=t[0][1],s=t[1][0],o=t[1][1],i=n*o-r*s;F(i!==0,"This matrix cannot be inverted!");let u=[[o,-r],[-s,n]];return na(u,1/i)}else if(e[0]>1){let n=(r,s)=>an(r)||an(s)?na(r,s):zd(r,s);for(let r=1;r<e[0]-1;r++)try{let s=ot(t,[ee(0,r),ee(0,r)]),o=ot(t,[ee(0,r),ee(r,e[0])]),i=ot(t,[ee(r,e[0]),ee(0,r)]),u=ot(t,[ee(r,e[0]),ee(r,e[0])]),a=cn(s),f=cn(ta(u,n(-1,n(n(i,a),o)))),l=ta(a,n(n(n(n(a,o),f),i),a)),m=n(-1,n(n(a,o),f)),h=n(-1,n(n(f,i),a)),q=f;return un(un(l,m,1),un(h,q,1),0)}catch{}F(!1,"This matrix cannot be inverted!")}}ra.exports=cn});var ia=c((dw,oa)=>{var ln=d(),_d=w();function Jd(t,e,n){try{return ln(t)?ln(e)?ln(n)?n*(e-t)+t:NaN:NaN:NaN}catch{return NaN}}oa.exports=_d(Jd)});var ca=c((gw,aa)=>{var ua=d(),$d=g(),Wd=w();function Rd(t,e){try{return e=$d(e)?Math.E:e,ua(t)?ua(e)?Math.log(t)/Math.log(e):NaN:NaN}catch{return NaN}}aa.exports=Wd(Rd)});var fa=c((qw,la)=>{var Dd=Be(),Ld=T(),Gd=z();function Hd(t){try{let e=Ld(t),n=Dd(e);if(n.length===0)return NaN;if(n.length<e.length)return NaN;n=Gd(n);let r;return n.length%2===0?r=(n[n.length/2-1]+n[n.length/2])/2:r=n[Math.floor(n.length/2)],r}catch{return NaN}}la.exports=Hd});var pa=c((yw,ma)=>{var Kd=Ie(),Qd=T(),Xd=$(),ha=z();function Zd(t){try{if(t.length===0)return NaN;let e=Qd(t);if(e.length===0)return NaN;let n={},r=Xd(e);r.forEach(u=>{n[u]=Kd(e,u)});let s=ha(r,(u,a)=>n[a]-n[u]),o=s[0],i=ha(s.filter(u=>n[u]===n[o]));return i.length===1?i[0]:i}catch{return NaN}}ma.exports=Zd});var ya=c((bw,qa)=>{var eg=d(),tg=g(),ng=ue(),{random:da}=ae();function ga(){let t=da(),e=da();return Math.sqrt(-2*Math.log(t))*Math.cos(2*Math.PI*e)}function rg(t){if(tg(t))return ga();eg(t)&&(t=[t]);let e=[],n=1;t.forEach(r=>n*=r);for(let r=0;r<n;r++)e.push(ga());return ng(e,t)}qa.exports=rg});var wa=c((ww,ba)=>{var sg=d(),og=ue();function ig(t){sg(t)&&(t=[t]);let e=[],n=1;t.forEach(r=>n*=r);for(let r=0;r<n;r++)e.push(1);return og(e,t)}ba.exports=ig});var xa=c((Nw,va)=>{var it=p(),Na=y(),ug=d(),ag=g();function fn(t,e){if(it(Na(t),"The `permute` function only works on arrays!"),ag(e)&&(e=t.length),it(ug(e),"`r` must be a whole number!"),e>t.length)return fn(t);if(e<=0)return[[]];if(it(e===parseInt(e),"`r` must be a whole number!"),t.length<2)return t;let n=[];return t.forEach((r,s)=>{it(!Na(r),"It is not recommended to permute arrays of arrays. Weird things happen, and I haven't figured out how to account for such a scenario yet. A possible workaround is: convert each sub-array to a string (using `JSON.stringify`), get the permutations using the array of strings, and then convert each string in each combination back to a sub-array (using `JSON.parse`).");let o=t.slice(0,s),i=t.slice(s+1),u=o.concat(i);fn(u,e-1).forEach(f=>{n.push([r].concat(f))})}),n}va.exports=fn});var Ea=c((vw,Sa)=>{var cg=y(),lg=N(),{DataFrame:Ta,Series:Oa}=Bt();function fg(){Object.keys(arguments).forEach(t=>{let e=arguments[t];if(cg(e)){let n=lg(e);n.length===1?new Oa(e).print():n.length==2?new Ta(e).print():console.log(e)}else e instanceof Ta||e instanceof Oa?e.print():console.log(e)})}Sa.exports=fg});var Ma=c((xw,Aa)=>{var Me=d(),hg=w();function mg(t,e,n,r,s){try{return Me(t)?Me(e)?Me(n)?Me(r)?Me(s)?(s-r)*(t-e)/(n-e)+r:NaN:NaN:NaN:NaN:NaN}catch{return NaN}}Aa.exports=hg(mg)});var Ca=c((Tw,ja)=>{var pg=d(),dg=w();function gg(t){try{return pg(t)?Math.round(t):NaN}catch{return NaN}}ja.exports=dg(gg)});var hn=c((Ow,Ua)=>{var Ia=p(),qg=Y(),Va=y(),yg=d();function bg(t,e,n){Ia(Va(t),"The first argument passed into the `setValueAt` function must be an array!"),yg(e)&&(e=[e]),Ia(Va(e),"The second argument passed into the `setValueAt` function must be an integer or an array of integers!");let r=qg(t),s=r;for(let o=0;o<e.length-1;o++)s=s[e[o]];return s[e[e.length-1]]=n,r}Ua.exports=bg});var za=c((Sw,Ya)=>{var wg=d(),Ng=w();function vg(t){try{return wg(t)?t<0?-1:t>0?1:0:NaN}catch{return NaN}}Ya.exports=Ng(vg)});var Ba=c((Ew,ka)=>{var xg=d(),Tg=w();function Og(t){try{return xg(t)?Math.sin(t):NaN}catch{return NaN}}ka.exports=Tg(Og)});var Fa=c((Aw,Pa)=>{var Sg=Ze();function Eg(t){return Sg(t)}Pa.exports=Eg});var Ja=c((Mw,_a)=>{var Ag=d(),Mg=w();function jg(t){try{return Ag(t)?Math.tan(t):NaN}catch{return NaN}}_a.exports=Mg(jg)});var ut=c((jw,Ra)=>{var $a=p(),Wa=j();function Cg(t,e){$a(Wa(t),"`fn` must be a function!");let n=new Date;return e?t(...e):t(),new Date-n}async function Ig(t,e){$a(Wa(t),"`fn` must be a function!");let n=new Date;return e?await t(...e):await t(),new Date-n}Ra.exports={timeSync:Cg,timeAsync:Ig}});var Ga=c((Cw,La)=>{var Vg=Wt(),Da=p(),Ug=se(),Yg=y(),zg=j(),kg=hn();function Bg(t,e){Da(Yg(t),"The first argument passed into the `where` function must be an array!"),Da(zg(e),"The second argument passed into the `where` function must be a function!");let n=Vg(t,e),r=[],s=0,o=!1;for(;!o;){let i=Ug(n,!0);i?(r[s]=i,n=kg(n,i,null),s++):o=!0}return s===0?null:r}La.exports=Bg});var O=c((Iw,mn)=>{var{DataFrame:Pg,Series:Fg}=Bt(),je={abs:_t(),add:Oe(),append:$t(),apply:Wt(),arccos:ni(),arcsin:si(),arctan:ii(),argmax:ai(),argmin:fi(),assert:p(),ceil:mi(),chop:gi(),clamp:yi(),cohensd:Ti(),combine:Ai(),copy:Y(),correl:zi(),cos:Bi(),count:Ie(),covariance:Lt(),DataFrame:Pg,diff:$i(),distance:Qi(),divide:Zi(),dot:Kt(),dropMissing:au(),dropMissingPairwise:pu(),dropNaN:Be(),dropNaNPairwise:Nu(),exp:xu(),factorial:Su(),find:ju(),findAll:Uu(),flatten:T(),float:zu(),floor:Qt(),getValueAt:_u(),identity:Wu(),indexOf:se(),indexesOf:Gu(),int:Xt(),intersect:Qu(),inverse:sa(),isArray:y(),isBoolean:ie(),isEqual:re(),isFunction:j(),isNumber:d(),isObject:W(),isString:S(),isUndefined:g(),lerp:ia(),log:ca(),MathError:U(),max:R(),mean:Se(),median:fa(),min:Rt(),mode:pa(),multiply:Gt(),ndarray:ve(),normal:ya(),ones:wa(),permute:xa(),pow:et(),print:Ea(),random:ae().random,range:C(),remap:Ma(),reshape:ue(),reverse:ge(),round:Ca(),scale:fe(),seed:ae().seed,Series:Fg,set:$(),setValueAt:hn(),shape:N(),shuffle:St(),sign:za(),sin:Ba(),slice:on(),sort:z(),sqrt:Xe(),std:Ze(),stdev:Fa(),subtract:Ht(),sum:tt(),tan:Ja(),time:ut().timeSync,timeSync:ut().timeSync,timeAsync:ut().timeAsync,transpose:Q(),union:rn(),variance:Ke(),vectorize:w(),where:Ga(),zeros:nn(),dump:function(){Object.keys(je).forEach(t=>{try{global[t]=je[t]}catch{try{window[t]=je[t]}catch{}}})}};typeof mn<"u"&&(mn.exports=je);typeof window<"u"&&(window.JSMathTools=je)});var pn=c((Vw,Ha)=>{var{dropMissing:_g,flatten:Jg,isArray:$g,set:Wg,sort:Rg}=O();function Dg(t){if(typeof t=="number")return t===0||t===1;if($g(t)){let e=_g(Jg(t)),n=Rg(Wg(e));return n.length===2&&n[0]===0&&n[1]===1||n.length===1&&(n[0]===0||n[0]===1)}return!1}Ha.exports=Dg});var gn=c((Uw,tc)=>{var{abs:Ka,add:Lg,assert:dn,clamp:Gg,copy:Hg,dropNaN:Kg,isArray:Qg,isNumber:Xg,max:Qa,median:Xa,min:Zg,pow:eq,scale:ec,shape:tq,sort:nq}=O(),rq=pn(),sq=(t,e)=>ec(t,eq(e,-1)),Za=(t,e)=>Lg(t,ec(e,-1));function oq(t,e){e=e||5,dn(Xg(e),"`maxScore` must be a number!"),dn(Qg(t),"`x` must be a one-dimensional array!"),dn(tq(t).length===1,"`x` must be a one-dimensional array!");let n=Kg(t);if(rq(n))return{values:t,wasClipped:!1};if(n.length===0)return{values:t,wasClipped:!1};let r=Xa(n),s=Xa(Ka(Za(n,r))),o=!1;if(s===0){let u=nq(Hg(n)),a=u.filter(h=>h<r),f=u.filter(h=>h>r),l=r,m=r;if(a.length>0&&(l=Qa(a)),f.length>0&&(m=Zg(f)),s=(m-l)/2,s===0)return{values:t,wasClipped:!1};o=(r-l)/s>e||(m-r)/s>e}return Qa(sq(Ka(Za(n,r)),s))>e||o?{values:t.map(a=>typeof a=="number"?Gg(a,r-e*s,r+e*s):a),wasClipped:!0}:{values:t,wasClipped:!1}}tc.exports=oq});var ne=c((Yw,nc)=>{var{assert:iq,flatten:uq,isArray:aq,set:cq}=O();function lq(t){iq(aq(t),"The `containsOnlyNumbers` only works on arrays!");let e=uq(t),n=cq(e.map(r=>typeof r));return n.length===1&&n[0]==="number"}nc.exports=lq});var oc=c((zw,sc)=>{var{assert:rc,isArray:fq,shape:hq,zeros:mq}=O();function pq(t){rc(fq(t),"The `diagonalize` function only works on vectors!");let e=hq(t);rc(e.length===1,"The `diagonalize` function only works on vectors!");let n=mq([e[0],e[0]]);return t.forEach((r,s)=>n[s][s]=r),n}sc.exports=pq});var ac=c((kw,uc)=>{var{assert:qn,clamp:dq,copy:gq,correl:qq,dropMissingPairwise:yq,isUndefined:bq,shape:at,transpose:ic}=O();function wq(t,e){bq(e)&&(e=gq(t)),t.values&&t.columns&&t.index&&(t=t.values),e.values&&e.columns&&e.index&&(e=e.values),qn(at(t).length===2&&at(e).length===2,"`getCorrelationMatrix` only works on matrices!"),qn(at(t)[0]===at(e)[0],"Matrix `a` and `b` must have the number of rows!");let n=[],r=ic(t),s=ic(e);return r.forEach(o=>{let i=[];s.forEach(u=>{try{let[a,f]=yq(o,u),l=dq(qq(a,f),-1,1);qn(l>=-1&&l<=1,"Uh-oh!"),i.push(l)}catch{i.push(0)}}),n.push(i)}),n}uc.exports=wq});var fc=c((Bw,lc)=>{var{assert:ct,isEqual:cc,set:Nq,sort:vq,transpose:xq}=O(),Tq=ne();function Oq(t){ct(t.values&&t.index&&t.columns,"You must pass a correlation matrix DataFrame into the `getHighlyCorrelatedColumns` function!"),ct(Tq(t.values),"The correlation matrix DataFrame passed into the `getHighlyCorrelatedColumns` function must contain only numbers!"),ct(cc(t.values,xq(t.values)),"The correlation matrix DataFrame passed into the `getHighlyCorrelatedColumns` function must be symmetrical!"),ct(cc(t.columns,t.index),"The correlation matrix DataFrame passed into the `getHighlyCorrelatedColumns` function must be symmetrical!");let e={};for(let n=0;n<t.index.length;n++)for(let r=0;r<t.columns.length;r++)if(n!==r){let s=t.values[n][r];if(1-s<1e-5){let o=t.index[n],i=t.columns[r];e[o]||(e[o]=[]),e[i]||(e[i]=[]),e[o].push(i),e[i].push(o)}}return Object.keys(e).forEach(n=>{e[n]=vq(Nq(e[n]))}),e}lc.exports=Oq});var yn=c((Pw,mc)=>{var{assert:hc,isArray:Sq,pow:Eq,sqrt:Aq,sum:Mq}=O(),jq=ne();function Cq(t){return hc(Sq(t),"`getMagnitude` only works on vectors!"),hc(jq(t),"`getMagnitude` only works on vectors of numbers!"),Aq(Mq(Eq(t,2)))}mc.exports=Cq});var bn=c((Fw,dc)=>{var{assert:pc,isArray:Iq,isString:Vq,isUndefined:Uq,set:Yq,shape:zq,sort:kq}=O();function Bq(t,e){pc(Vq(t),"The first parameter passed into the `getOneHotEncodings` function must be a string representing the name of the variable being encoded."),pc(Iq(e)&&zq(e).length===1,"The second parameter passed into the `getOneHotEncodings` function must be a one-dimensional array of values.");let n={},r=t+"_"+e[0];return kq(Yq(e)).filter(o=>!Uq(o)).map(o=>t+"_"+o).filter(o=>o!==r).forEach(o=>{n[o]=e.map(i=>o===t+"_"+i?1:0)}),n}dc.exports=Bq});var qc=c((_w,gc)=>{var{count:Pq}=O();function Fq(t){return Pq(t).map(n=>(n.percentage=n.count/t.length,n))}gc.exports=Fq});var yc=c((Jw,_q)=>{_q.exports=[.5,.49601,.49202,.48803,.48405,.48006,.47608,.4721,.46812,.46414,.46017,.4562,.45224,.44828,.44433,.44038,.4364,.43251,.42858,.42465,.42074,.41683,.41294,.40905,.40517,.40129,.39743,.39358,.38974,.38591,.38209,.37828,.37448,.3707,.36693,.36317,.35942,.35569,.35197,.34827,.34458,.3409,.33724,.3336,.32997,.32636,.32276,.31918,.31561,.31207,.30854,.30503,.30153,.29806,.2946,.29116,.28774,.28434,.28096,.2776,.27425,.27093,.26763,.26435,.26109,.25785,.25463,.25143,.24825,.2451,.24196,.23885,.23576,.2327,.22965,.22663,.22363,.22065,.2177,.21476,.21186,.20897,.20611,.20327,.20045,.19766,.19489,.19215,.18943,.18673,.18406,.18141,.17879,.17619,.17361,.17106,.16853,.16602,.16354,.16109,.15866,.15625,.15386,.15151,.14917,.14686,.14457,.14231,.14007,.13786,.13567,.1335,.13136,.12924,.12714,.12507,.12302,.121,.119,.11702,.11507,.11314,.11123,.10935,.10749,.10565,.10383,.10204,.10027,.09853,.0968,.0951,.09342,.09176,.09012,.08851,.08692,.08534,.08379,.08226,.08076,.07927,.0778,.07636,.07493,.07353,.07215,.07078,.06944,.06811,.06681,.06552,.06426,.06301,.06178,.06057,.05938,.05821,.05705,.05592,.0548,.0537,.05262,.05155,.0505,.04947,.04846,.04746,.04648,.04551,.04457,.04363,.04272,.04182,.04093,.04006,.0392,.03836,.03754,.03673,.03593,.03515,.03438,.03362,.03288,.03216,.03144,.03074,.03005,.02938,.02872,.02807,.02743,.0268,.02619,.02559,.025,.02442,.02385,.0233,.02275,.02222,.02169,.02118,.02068,.02018,.0197,.01923,.01876,.01831,.01786,.01743,.017,.01659,.01618,.01578,.01539,.015,.01463,.01426,.0139,.01355,.01321,.01287,.01255,.01222,.01191,.0116,.0113,.01101,.01072,.01044,.01017,.0099,.00964,.00939,.00914,.00889,.00866,.00842,.0082,.00798,.00776,.00755,.00734,.00714,.00695,.00676,.00657,.00639,.00621,.00604,.00587,.0057,.00554,.00539,.00523,.00508,.00494,.0048,.00466,.00453,.0044,.00427,.00415,.00402,.00391,.00379,.00368,.00357,.00347,.00336,.00326,.00317,.00307,.00298,.00289,.0028,.00272,.00264,.00256,.00248,.0024,.00233,.00226,.00219,.00212,.00205,.00199,.00193,.00187,.00181,.00175,.00169,.00164,.00159,.00154,.00149,.00144,.00139,.00135,.00131,.00126,.00122,.00118,.00114,.00111,.00107,.00104,.001,97e-5,94e-5,9e-4,87e-5,84e-5,82e-5,79e-5,76e-5,74e-5,71e-5,69e-5,66e-5,64e-5,62e-5,6e-4,58e-5,56e-5,54e-5,52e-5,5e-4,48e-5,47e-5,45e-5,43e-5,42e-5,4e-4,39e-5,38e-5,36e-5,35e-5,34e-5,32e-5,31e-5,3e-4,29e-5,28e-5,27e-5,26e-5,25e-5,24e-5,23e-5,22e-5,22e-5,21e-5,2e-4,19e-5,19e-5,18e-5,17e-5,17e-5,16e-5,15e-5,15e-5,14e-5,14e-5,13e-5,13e-5,12e-5,12e-5,11e-5,11e-5,1e-4,1e-4,1e-4,9e-5,9e-5,8e-5,8e-5,8e-5,8e-5,7e-5,7e-5,7e-5,6e-5,6e-5,6e-5,6e-5,5e-5,5e-5,5e-5,5e-5,5e-5,4e-5,4e-5,4e-5,4e-5,4e-5,4e-5,3e-5,3e-5,3e-5,3e-5,3e-5,3e-5,3e-5,3e-5,2e-5,2e-5,2e-5,2e-5]});var wn=c(($w,Oc)=>{var{abs:bc,assert:lt,dropNaNPairwise:Jq,isArray:wc,mean:Nc,remap:$q,round:Wq,shape:vc,sqrt:Rq,std:xc}=O(),Tc=yc();function Dq(t){return bc(t)>4.1?0:Tc[Wq($q(bc(t),0,4.1,0,Tc.length))]}function Lq(t,e){lt(wc(t)&&vc(t).length===1,"You must pass two one-dimensional arrays into the `pValue` (AKA `ttest`) function!"),lt(wc(e)&&vc(e).length===1,"You must pass two one-dimensional arrays into the `pValue` (AKA `ttest`) function!");let[n,r]=Jq(t,e);lt(n.length>0,"There are no numerical values in the first vector you passed into the `pValue` (AKA `ttest`) function!"),lt(r.length>0,"There are no numerical values in the second vector you passed into the `pValue` (AKA `ttest`) function!");let s=Nc(n),o=Nc(r),i=xc(n),u=xc(r),a=n.length,f=r.length,l=(s-o)/Rq(i*i/a+u*u/f);return 2*Dq(l)}Oc.exports=Lq});var Cc=c((Ww,jc)=>{var{assert:Sc,clamp:Gq,copy:Hq,dropMissingPairwise:Kq,isArray:Ec,isUndefined:Qq,shape:Ac,transpose:Mc}=O(),Xq=wn();function Zq(t,e){Qq(e)&&(e=Hq(t)),Sc(Ec(t)&&Ec(e),"`getPValueMatrix` only works on matrices!"),Sc(Ac(t).length===2&&Ac(e).length===2,"`getPValueMatrix` only works on matrices!");let n=[],r=Mc(t),s=Mc(e);return r.forEach(o=>{let i=[];s.forEach(u=>{let[a,f]=Kq(o,u),l=Gq(Xq(a,f),0,1);i.push(l)}),n.push(i)}),n}jc.exports=Zq});var Nn=c((Rw,zc)=>{var{assert:he,dot:Ic,isArray:Vc,scale:ey,shape:Uc}=O(),Yc=ne();function ty(t,e){return he(Vc(t),"`project` only works on vectors!"),he(Vc(e),"`project` only works on vectors!"),he(Yc(t),"`project` only works on vectors of numbers!"),he(Yc(e),"`project` only works on vectors of numbers!"),he(Uc(t).length===1,"`project` only works on vectors!"),he(Uc(e).length===1,"`project` only works on vectors!"),ey(Ic(e,t)/Ic(e,e),e)}zc.exports=ty});var Fc=c((Dw,Pc)=>{var{add:ny,assert:vn,copy:ry,isArray:sy,pow:oy,scale:Bc,shape:iy,transpose:kc}=O(),uy=ne(),ay=yn(),cy=Nn(),ly=(t,e)=>Bc(t,oy(e,-1)),fy=(t,e)=>ny(t,Bc(e,-1));function hy(t){vn(sy(t),"`gramSchmidtOrthonormalize` only works on matrices!"),vn(uy(t),"`gramSchmidtOrthonormalize` only works on matrices of numbers!"),vn(iy(t).length===2,"`gramSchmidtOrthonormalize` only works on matrices!");let e=kc(t),n=[];e.forEach(s=>{let o=ry(s);n.forEach(i=>{o=fy(o,cy(o,i))}),n.push(o)});let r=n.map(s=>ly(s,ay(s)));return kc(r)}Pc.exports=hy});var Tn=c((Lw,$c)=>{var{assert:_c,count:my,float:py,isArray:xn,isNumber:dy,isString:gy,shape:qy}=O(),Jc=["null","none","nan","na","n/a","","undefined"],yy=["true","false","yes","no"];function by(t,e){if(t===void 0&&(t="undefined"),e==="number"){let n=py(t);return isNaN(n)?null:n}if(e==="boolean"){try{let n=t.trim().toLowerCase();if(n==="true"||n==="yes")return!0;if(n==="false"||n==="no")return!1}catch{}return null}if(e==="date"){let n=new Date(t);return n.toString()==="Invalid Date"?null:n}if(e==="object")try{let n=JSON.parse(t);return xn(n)?null:n}catch{return null}if(e==="string"){try{if(Jc.indexOf(t.trim().toLowerCase())>-1)return null}catch{return null}return t}}function wy(t){_c(xn(t),"The `inferType` function only works on one-dimensional arrays!"),_c(qy(t).length===1,"The `inferType` function only works on one-dimensional arrays!");let e=t.map(s=>{if(s===void 0)return"null";gy(s)||(s=JSON.stringify(s));let i=s.toLowerCase().trim();if(Jc.indexOf(i)>-1)return"null";if(yy.indexOf(i)>-1)return"boolean";try{let u=JSON.parse(s);return dy(u)?"number":typeof u=="object"?xn(u)?"string":"object":"string"}catch{return new Date(s).toString()!=="Invalid Date"?"date":"string"}}),r=my(e).sort((s,o)=>o.count-s.count)[0].item;return{type:r,values:t.map(s=>by(s,r))}}$c.exports=wy});var On=c((Gw,Wc)=>{var{assert:Ny,isArray:vy,shape:xy}=O();function Ty(t){Ny(vy(t),"The `isJagged` function only works on arrays!");try{return xy(t),!1}catch{return!0}}Wc.exports=Ty});var En=c((Hw,Lc)=>{var{assert:Oy,dropNaN:Sy,isArray:Ey,mean:Ay,shape:My,std:jy,transpose:Rc}=O(),Cy=On(),Dc="The `normalize` function only works on vectors, matrices, Series, or DataFrames!";function Sn(t){if(t.copy&&t.values){let s=t.copy();return s.values=Sn(s.values),s}else if(Ey(t)){Oy(!Cy(t),"The `normalize` function doesn't work on jagged arrays!");let s=My(t);if(s.length>1){if(s.length>2)throw new Error(Dc);return Rc(Rc(t).map(o=>Sn(o)))}}else throw new Error(Dc);let e=Sy(t);if(e.length===0)return t;let n=Ay(e),r=jy(e);return r===0?t:t.map(s=>typeof s=="number"?(s-n)/r:s)}Lc.exports=Sn});var Kc=c((Kw,Hc)=>{var{assert:Iy,copy:Vy,correl:Uy,DataFrame:Yy,dropMissing:zy,isEqual:ky,set:By,transpose:Gc}=O(),Py=gn(),Fy=bn(),_y=Tn();function Jy(t){Iy(t.apply&&t.columns&&t.values,"You must pass a DataFrame into the `preprocess` function!");let e={};t=t.apply(u=>{let a=_y(u.values);return e[u.name]=a.type,a.values});let n=Vy(t.columns),r=Gc(t.values),s=0,o=!1;for(;!o;){let u=r[s];for(let a=s+1;a<r.length;a++){let f=r[a];ky(u,f)&&(n.splice(a,1),r.splice(a,1))}s++,o=s>=n.length-1}for(s=0,o=!1;!o;){let u=n[s],a=r[s];if(!a)break;let f=zy(a);if(f.length<15){n.splice(s,1),r.splice(s,1);continue}let l=By(f);if(l.length===1){n.splice(s,1),r.splice(s,1);continue}let m=e[u];if(m==="string"){if(l.length<=7){let h=Fy(u,a);Object.keys(h).forEach(q=>{n.push(q),r.push(h[q]),e[q]="number"}),n.splice(s,1),r.splice(s,1);continue}}else if(m==="number"){let h=Py(a).values;r[s]=h;let q=!1;for(let b=0;b<s;b++){let A=r[b];if(Uy(a,A)>.99){n.splice(s,1),r.splice(s,1),q=!0;break}}if(q)continue}else{r.splice(s,1),n.splice(s,1);continue}s++,o=s>=n.length}let i=new Yy(Gc(r));return i.columns=n,i}Hc.exports=Jy});var sl=c((Qw,rl)=>{var{abs:$y,add:Wy,assert:Ce,isArray:Qc,isEqual:Ry,mean:Dy,pow:Xc,scale:Ly,shape:Zc,sign:Gy,sqrt:Hy,sum:el}=O(),tl=ne(),nl=(t,e)=>Wy(t,Ly(e,-1));function Ky(t,e){Ce(Qc(t),"You must pass two same-shaped numerical arrays into the `rScore` function!"),Ce(Qc(e),"You must pass two same-shaped numerical arrays into the `rScore` function!"),Ce(Ry(Zc(t),Zc(e)),"You must pass two same-shaped numerical arrays into the `rScore` function!"),Ce(tl(t),"You must pass two same-shaped numerical arrays into the `rScore` function!"),Ce(tl(e),"You must pass two same-shaped numerical arrays into the `rScore` function!");let n=el(Xc(nl(t,e),2)),r=el(Xc(nl(t,Dy(t)),2));if(r===0)return NaN;let s=1-n/r;return Gy(s)*Hy($y(s))}rl.exports=Ky});var cl=c((Xw,al)=>{var{argmax:ol,assert:ft,copy:il,isEqual:ul,max:Qy,min:Xy,pow:Zy,reverse:e1,sum:t1,transpose:n1}=O();function r1(t){ft(t.get&&t.values&&t.columns&&t.index,"You must pass a DataFrame into the `sortCorrelationMatrix` function!"),ft(ul(t.values,n1(t.values)),"The correlations matrix passed into the `sortCorrelationMatrix` function must be symmetrical!"),ft(ul(t.columns,t.index),"The correlations matrix passed into the `sortCorrelationMatrix` function must be symmetrical! (In this case, the values themselves are symmetrical, but the row and column names don't match!)"),ft(Qy(t.values)<=1&&Xy(t.values)>=-1,"The correlations matrix passed into the `sortCorrelationMatrix` function must not contain values less than -1 or greater than 1!");let e=il(t.index),n=[];for(;e.length>0;)if(n.length===0){let s=0,o=e[0];e.forEach((i,u)=>{let a=t.values[u],f=t1(Zy(a,2));f>s&&(s=f,o=i)}),n.push(o),e.splice(e.indexOf(o),1)}else{let s=t.index.indexOf(n[n.length-1]),o=il(t.values[s]);o[s]=-2;let i=ol(o);for(;n.indexOf(t.index[i])>-1;)o[i]=-2,i=ol(o);let u=t.index[i];n.push(u),e.splice(e.indexOf(u),1)}let r=e1(n);return t.get(r,r)}al.exports=r1});var fl=c((Zw,ll)=>{var s1=En();function o1(){return s1(...arguments)}ll.exports=o1});var i1=c((eN,ml)=>{var hl={clipOutliers:gn(),containsOnlyNumbers:ne(),diagonalize:oc(),getCorrelationMatrix:ac(),getHighlyCorrelatedColumns:fc(),getMagnitude:yn(),getOneHotEncodings:bn(),getPercentages:qc(),getPValueMatrix:Cc(),gramSchmidtOrthonormalize:Fc(),inferType:Tn(),isBinary:pn(),isJagged:On(),normalize:En(),preprocess:Kc(),project:Nn(),pValue:wn(),rScore:sl(),sortCorrelationMatrix:cl(),standardize:fl(),dump:function(){let t=this;Object.keys(t).forEach(e=>{global[e]=t[e]})}};try{window.JSDataScienceHelpers=hl}catch{}try{ml.exports=hl}catch{}});i1();})();
