(()=>{var Ih=Object.defineProperty;var Ah=(t,e,n)=>e in t?Ih(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n;var Nr=(t=>typeof require!="undefined"?require:typeof Proxy!="undefined"?new Proxy(t,{get:(e,n)=>(typeof require!="undefined"?require:e)[n]}):t)(function(t){if(typeof require!="undefined")return require.apply(this,arguments);throw new Error('Dynamic require of "'+t+'" is not supported')});var c=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports);var jt=(t,e,n)=>(Ah(t,typeof e!="symbol"?e+"":e,n),n);var se=c((gS,vr)=>{var Eh=new Function(`
  try {
    return this === window
  } catch(e) {}

  try {
    return typeof importScripts !== "undefined"
  } catch(e) {}

  return false
`),kt=class extends Error{constructor(e){Eh()?super(e):super(`

\x1B[31m`+e+`
\x1B[0m`)}};vr.exports=kt});var m=c((qS,wr)=>{var Mh=se();wr.exports=function(t,e){if(!t)throw new Mh(e)}});var C=c((yS,Sr)=>{function jh(t){try{return structuredClone(t)}catch{return t}}Sr.exports=jh});var d=c((bS,xr)=>{function kh(t){try{return t instanceof Array||typeof t.constructor<"u"&&t.constructor.name==="Array"}catch{return!1}}xr.exports=kh});var y=c((NS,_r)=>{function Ch(t){try{return!!t._symbol&&t._symbol===Symbol.for("@jrc03c/js-math-tools/dataframe")}catch{return!1}}_r.exports=Ch});var q=c((vS,Tr)=>{function zh(t){try{return!!t._symbol&&t._symbol===Symbol.for("@jrc03c/js-math-tools/series")}catch{return!1}}Tr.exports=zh});var T=c((wS,Fr)=>{var Rh=m(),Uh=C(),Or=d(),Ph=y(),Bh=q();function Dr(t){if(Ph(t)||Bh(t))return Dr(t.values);Rh(Or(t),"The `flatten` function only works on arrays, Series, and DataFrames!");function e(n){let r=[];return Uh(n).forEach(s=>{Or(s)?r=r.concat(e(s)):r.push(s)}),r}return e(t)}Fr.exports=Dr});var A=c((SS,Ir)=>{function Vh(t){return typeof t=="function"}Ir.exports=Vh});var g=c((xS,Ar)=>{function Jh(t){return typeof t=="number"&&!isNaN(t)}Ar.exports=Jh});var N=c((_S,Er)=>{function Yh(t){return t===null||typeof t>"u"}Er.exports=Yh});var Y=c((TS,Mr)=>{var $h=d(),Gh=N();function Lh(t){return typeof t=="object"&&!Gh(t)&&!$h(t)}Mr.exports=Lh});var be=c((OS,Cr)=>{var Wh=m(),jr=d(),Kh=y(),Hh=A(),Ct=g(),kr=Y(),Xh=q();function zt(t,e){if(Kh(t)){let i=zt(t.values,e);return i.length>0&&Ct(i[0])&&i[0]>=0&&i[0]<t.index.length&&(i[0]=t.index[i[0]]),i.length>1&&Ct(i[1])&&i[1]>=0&&i[1]<t.columns.length&&(i[1]=t.columns[i[1]]),i}if(Xh(t)){let i=zt(t.values,e);return i.length>0&&Ct(i[0])&&i[0]>=0&&i[0]<t.index.length&&(i[0]=t.index[i[0]]),i}if(Wh(kr(t)||jr(t),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `indexOf` function!"),!Hh(e)){let i=e;e=o=>o===i}function n(i,o,u){if(u=u||[],u.indexOf(i)>-1)return null;if(kr(i)){u.push(i);let a=Object.keys(i);for(let l=0;l<a.length;l++){let f=a[l],h=i[f];if(o(h))return[f];let p=n(h,o,u);if(p&&p.length>0)return[f].concat(p)}}else if(jr(i)){u.push(i);for(let a=0;a<i.length;a++){let l=i[a];if(o(l))return[a];let f=n(l,o,u);if(f&&f.length>0)return[a].concat(f)}}else if(o(i))return[];return null}function r(i){try{return e(i)}catch{return!1}}let s=n(t,r);return s&&s.length>0?s:null}Cr.exports=zt});var Rt=c((DS,zr)=>{var Qh=C(),Zh=be(),e0=d(),t0=y(),n0=q();zr.exports=function(e){function n(i,o,u){if(o=o||[],u=u||"",o.indexOf(i)>-1){let a=u.split("/").slice(u.startsWith("/")?1:0);if(a.some((f,h)=>{let p=a.slice(0,a.length-h-1),b=r;return p.forEach(S=>{b=b[S]}),b===i}))return`<reference to "${r===i?"/":"/"+Zh(r,i).join("/")}">`}return typeof i=="object"?i===null?null:(o.push(i),e0(i)?i.map((a,l)=>n(a,o,u+"/"+l)):(Object.keys(i).forEach(a=>{i[a]=n(i[a],o,u+"/"+a)}),i)):i}let r=Qh(e),s=n(r);if(t0(e)){let i=e.copy();i._values=s.values,i._columns=s.columns,i._index=s.index,s=i}if(n0(e)){let i=e.copy();i.name=s.name,i._values=s.values,i._index=s.index,s=i}return s}});var R=c((FS,Pr)=>{var Rr=C(),Ur=Rt();function r0(t,e){function n(r,s){let i=typeof r;if(i!==typeof s)return!1;if(i==="undefined")return!0;if(i==="boolean"||i==="symbol")return r===s;if(i==="number"||i==="bigint")return r.toString()==="NaN"&&s.toString()==="NaN"?!0:r===s;if(i==="string"||i==="function")return r===s;if(i==="object"){if(r===null||s===null)return r===null&&s===null;{let u=Object.keys(r),a=Object.keys(s);if(u.length!==a.length)return!1;for(let l=0;l<u.length;l++){let f=u[l];if(!n(r[f],s[f]))return!1}return!0}}}try{return n(Rr(t),Rr(e))}catch{return n(Ur(t),Ur(e))}}Pr.exports=r0});var z=c((IS,Yr)=>{var s0=m(),i0=T(),o0=d(),Br=y(),u0=A(),Vr=q(),a0=N();function Ne(t){let e="abcdefg1234567890",n="";for(;n.length<t;)n+=e[parseInt(Math.random()*e.length)];return n}var c0=Ne(256),l0=Ne(256),f0=Ne(256),h0=Ne(256),m0=Ne(256);function Jr(t){if(Br(t)||Vr(t))return Jr(t.values);s0(o0(t),"The `set` function only works on arrays, Series, and DataFrames!");let e=[],n={};return i0(t).forEach(r=>{let s=typeof r=="object"&&r===null?c0:a0(r)?l0:u0(r)?r.toString():typeof r=="symbol"?r.toString()+" - "+m0:r===1/0?f0:r===-1/0?h0:Br(r)?r.toJSONString():Vr(r)?JSON.stringify(r.toObject()):JSON.stringify(r);n[s]||e.push(r),n[s]=!0}),e}Yr.exports=Jr});var ve=c((AS,Lr)=>{var d0=m(),Ut=T(),$r=d(),p0=y(),Gr=R(),g0=A(),q0=q(),y0=z();function Pe(t,e){if(p0(t)||q0(t))return arguments.length>1?Pe(t.values,e):Pe(t.values,t.values);if(d0($r(t),"The first argument to the `count` function must be an array, Series, or DataFrame!"),g0(e))return Ut(t).filter(n=>e(n)).length;if($r(e)){let n=Ut(t);return y0(e).map(r=>({item:r,count:n.filter(s=>Gr(s,r)).length}))}else return arguments.length>1?Ut(t).filter(n=>Gr(n,e)).length:Pe(t,t)}Lr.exports=Pe});var we=c((ES,Kr)=>{var b0=m(),Wr=d(),N0=y(),v0=q();function Pt(t){if(N0(t)||v0(t))return Pt(t.values);b0(Wr(t),"The `isJagged` function only works on arrays, Series, and DataFrames!");let e=0,n=null;for(let r=0;r<t.length;r++)if(Wr(t[r])){if(e++,Pt(t[r]))return!0;if(n===null)n=t[r].length;else if(t[r].length!==n)return!0}return e>0&&e<t.length}Kr.exports=Pt});var Be=c((MS,Qr)=>{var w0=m(),Hr=d(),S0=y(),x0=q();function Xr(t){if(S0(t)||x0(t))return Xr(t.values);w0(Hr(t),"The `isNested` function only works on arrays, Series, and DataFrames!");for(let e=0;e<t.length;e++)if(Hr(t[e]))return!0;return!1}Qr.exports=Xr});var $=c((jS,es)=>{var Z=m(),_0=d(),T0=Be(),O0=g(),D0=N(),ie="You must pass a natural number or a one-dimensional array of natural numbers into the `ndarray` function!";function Zr(t){Z(!D0(t),ie),_0(t)||(t=[t]),Z(!T0(t),ie),Z(t.length>0,ie);let e=t[0];if(Z(O0(e),ie),Z(parseInt(e)===e,ie),Z(e>=0,ie),Z(e!==1/0,"We can't create an array containing an infinite number of values!"),t.length===1){let n=[];for(let r=0;r<e;r++)n.push(void 0);return n}else{let n=[];for(let r=0;r<e;r++)n.push(Zr(t.slice(1)));return n}}es.exports=Zr});var Se=c((kS,ts)=>{var F0=m(),I0=d(),A0=y(),E0=q();function Bt(t){if(A0(t)||E0(t)){let n=t.copy();return n.values=Bt(n.values),n.index=Bt(n.index),n}F0(I0(t),"The `reverse` function only works on arrays, Series, and DataFrames!");let e=[];for(let n=t.length-1;n>=0;n--)e.push(t[n]);return e}ts.exports=Bt});var j=c((CS,ns)=>{var Vt=m(),Jt=g(),Yt=N(),M0=Se();function j0(t,e,n=1){Vt(!Yt(t)&&!Yt(e)&&!Yt(n),"You must pass two numbers and optionally a step value to the `range` function!"),Vt(Jt(t)&&Jt(e)&&Jt(n),"You must pass two numbers and optionally a step value to the `range` function!"),Vt(n>0,"The step value must be greater than 0! (NOTE: The step value is a magnitude; it does not indicate direction.)");let r=!1;if(t>e){r=!0;let i=t;t=e+n,e=i+n}let s=[];for(let i=t;i<e;i+=n)s.push(i);return r&&(s=M0(s)),s}ns.exports=j0});var x=c((zS,os)=>{var k0=m(),rs=d(),C0=y(),z0=R(),R0=q(),U0=N();function ss(t){if(!rs(t))return;let e=[t.length],n=0,r=t.map(s=>{let i=ss(s);return U0(i)?i:(n++,i.length===1?i[0]:i)});return n>0?n===t.length&&r.slice(0,-1).every((i,o)=>z0(i,r[o+1]))?e.concat(r[0]):(e.push(r),e):e}function is(t){return C0(t)||R0(t)?is(t.values):(k0(rs(t),"The `shape` function only works on arrays, Series, and DataFrames!"),ss(t))}os.exports=is});var hs=c((RS,fs)=>{var us=m(),P0=d(),B0=y(),V0=we(),J0=q(),Y0=N(),as=se(),Ve=$(),cs=j(),$0=z(),G0=x();function ls(t,e,n){if(Y0(n)&&(n=0),us(n===0||n===1||n==="vertical"||n==="horizontal",'The only valid axis values for use when appending data to a DataFrame are 0, 1, "vertical", and "horizontal". Note that 0 == "horizontal" and 1 == "vertical".'),P0(e)){us(!V0(e),"The array of data you're trying to append to this DataFrame is jagged!");let r=G0(e);if(r.length===1)if(n===0){let s=t.copy();s._values.push(e);let i=Math.max(t.shape[1],r[0]);for(s._values.forEach(o=>{for(;o.length<i;)o.push(void 0)});s._index.length<s._values.length;)s._index.push("row"+s._index.length);for(;s._columns.length<i;)s._columns.push("col"+s._columns.length);return s}else{let s=Math.max(t.shape[0],r[0]),i=t.copy();for(cs(0,s).forEach(o=>{o>=i._values.length&&i._values.push(Ve(t.shape[1])),i._values[o].push(e[o])});i._index.length<i._values.length;)i._index.push("row"+i._index.length);for(;i._columns.length<i._values[0].length;)i._columns.push("col"+i._columns.length);return i}else if(r.length===2)if(n===0){let s=Math.max(...e.map(o=>o.length).concat([t.shape[1]])),i=t.copy();for(i._values=i._values.concat(e).map(o=>{for(;o.length<s;)o.push(void 0);return o});i._index.length<i._values.length;)i._index.push("row"+i._index.length);for(;i._columns.length<s;)i._columns.push("col"+i._columns.length);return i}else{let s=Math.max(...e.map(u=>u.length))+t.shape[1],i=Math.max(t.shape[0],r[0]),o=t.copy();for(cs(0,i).forEach(u=>{for(u>=o._values.length&&o._values.push(Ve(t.shape[1])),o._values[u]=o._values[u].concat(e[u]);o._values[u].length<s;)o._values[u].push(void 0)});o._index.length<o._values.length;)o._index.push("row"+o._index.length);for(;o._columns.length<s;)o._columns.push("col"+o._columns.length);return o}else throw new as("Only 1- and 2-dimensional arrays can be appended to a DataFrame!")}else if(J0(e)){let r=ls(t,e.values,n);return n===0?r.index[r.index.length-1]=r.index.indexOf(e.name)>-1?e.name+" (2)":e.name:r.columns[r.columns.length-1]=r.columns.indexOf(e.name)>-1?e.name+" (2)":e.name,r}else if(B0(e))if(n===0){let r=t.copy(),s=$0(r._columns.concat(e._columns)).length;for(r._values.forEach(i=>{for(;i.length<s;)i.push(void 0)}),e.apply(i=>{let o=i.copy(),u=[];r._columns.forEach(a=>{let l=o._index.indexOf(a);l>-1?(u.push(o._values[l]),o._values.splice(l,1),o._index.splice(l,1)):u.push(void 0)}),r._values.push(u.concat(o._values))},1),r._columns=r._columns.concat(e._columns.filter(i=>r._columns.indexOf(i)<0));r._index.length<r._values.length;){let i="row"+r._index.length;r._index.push(i+(t._index.indexOf(i)>-1?" (2)":""))}return r}else{let r=t.copy();return r._index.forEach((s,i)=>{let o=e._index.indexOf(s);o>-1?r._values[i]=r._values[i].concat(e._values[o]):r._values[i]=r._values[i].concat(Ve(e.shape[1]))}),e._index.forEach((s,i)=>{r._index.indexOf(s)<0&&(r._index.push(s),r._values.push(Ve(r._columns.length).concat(e._values[i])))}),r._columns=r._columns.concat(e._columns.map(s=>s+(r._columns.indexOf(s)>-1?" (2)":""))),r}else throw new as("Only 1- or 2-dimensional arrays, Series, and DataFrames can be appended to a DataFrame!")}fs.exports=ls});var qs=c((US,gs)=>{var ms=m(),ds=d(),L0=A(),ps=N();function W0(t,e,n,r,s){if(s=s||0,ms(L0(r),"The first parameter to the `apply` method must be a function."),ms(s===0||s===1,"The second parameter to the `apply` method (the `axis`) must be 0 or 1."),s===0){let i={},o;if(n.columns.forEach((u,a)=>{let l=new e(n.values.map(h=>h[a]));l.name=u,l.index=n.index;let f=r(l,a,n);f instanceof e?i[u]=f.values:i[u]=f,ps(o)&&(o=f instanceof e||ds(f))}),o){let u=new t(i);return u.index=n.index,u}else{let u=new e(n.columns.map(a=>i[a]));return u.index=n.columns,u}}else if(s===1){let i,o=n.values.map((u,a)=>{let l=new e(u);l.name=n.index[a],l.index=n.columns;let f=r(l,a,n);return ps(i)&&(i=f instanceof e||ds(f)),f instanceof e?f.values:f});if(i){let u=new t(o);return u.index=n.index,u.columns=n.columns,u}else{let u=new e(o);return u.index=n.index,u}}}gs.exports=W0});var E=c((PS,ys)=>{function K0(t){return typeof t=="string"}ys.exports=K0});var vs=c((BS,Ns)=>{var bs=m(),H0=d(),X0=we(),Q0=Y(),Z0=E(),em=N(),tm=se(),nm=x();function rm(t,e,n,r,s){let i=u=>u instanceof t,o=u=>u instanceof e;if(em(s)){if(i(r))return n.append(r,1);if(o(r))return n.append(r,1);if(Q0(r)){let u=Math.max(...Object.keys(r).map(a=>r[a].length));return Object.keys(r).forEach(a=>{for(;r[a].length<u;)r[a].push(void 0)}),n.append(new t(r),1)}else throw new tm("You must pass a DataFrame, Series, or object into the `assign` method!")}else{bs(Z0(r),"If passing two arguments into the `assign` method, then the first argument must be a string name!"),bs(H0(s)&&!X0(s)&&nm(s).length===1,"If passing two arguments into the `assign` method, then the second argument must be a 1-dimensional array!");let u=n.append(s,1);return u.columns[u.columns.length-1]=r,u}}Ns.exports=rm});var Ss=c((VS,ws)=>{var sm=C();function im(t,e){if(e.isEmpty)return new t;let n=new t(sm(e.values));return n.columns=e.columns.slice(),n.index=e.index.slice(),n}ws.exports=im});var Is=c((JS,Fs)=>{var Je=m(),xs=d(),_s=g(),Ts=E(),Os=N(),Ds=x();function om(t,e,n,r,s){Os(r)&&(r=[]),Os(s)&&(s=[]),(Ts(r)||_s(r))&&(r=[r]),(Ts(s)||_s(s))&&(s=[s]),Je(xs(r),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),Je(xs(s),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),Je(Ds(r).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),Je(Ds(s).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");let i,o;n.index.forEach((a,l)=>{r.indexOf(a)<0&&r.indexOf(l)<0&&(i||(i=[]),i.push(a))}),n.columns.forEach((a,l)=>{s.indexOf(a)<0&&s.indexOf(l)<0&&(o||(o=[]),o.push(a))});let u=n.get(i,o);if(u instanceof e){let a=new t;a=a.assign(u),n.index.indexOf(u.name)>-1&&(a=a.transpose()),u=a}return u}Fs.exports=om});var xe=c((YS,As)=>{var um=g();function am(t){return um(t)&&parseInt(t)===t}function cm(t){return am(t)&&t>=0}As.exports=cm});var Ms=c(($S,Es)=>{var $t=m(),lm=E(),Ye=N(),fm=xe(),hm=x();function mm(t,e,n,r,s,i){r=r||0,$t(r===0||r===1,"The first parameter of the `dropMissing` method (the `axis`) must be 0 or 1."),i=i||0,$t(fm(i),"The third parameter of the `dropMissing` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` null values)."),s=i>0?"none":s||"any",$t(s==="any"||s==="all"||s==="none","The second parameter of the `dropMissing` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains null values, then it should be dropped; or that if 'all' of the data contains null values, then it should be dropped).");function o(l){if(i>0){let f=0;for(let h=0;h<l.length;h++){let p=l[h];if(Ye(p)&&f++,f>=i)return[]}}else if(s==="any")for(let f=0;f<l.length;f++){let h=l[f];if(Ye(h))return[]}else if(s==="all"){for(let f=0;f<l.length;f++){let h=l[f];if(!Ye(h))return l}return[]}return l}let u=n.copy(),a=Math.random().toString();if(r===0){u=u.assign(a,u.index);let l=u.values.map(o).filter(h=>h.length>0);if(hm(l).length<2)return new t;u.values=l;let f=u.get(null,a);if(Ye(f))return new t;lm(f)&&(f=[f]),f instanceof e&&(f=f.values),u.index=f,u=u.drop(null,a)}else if(r===1){let l={};if(u.columns.forEach((h,p)=>{let b=u.values.map(O=>O[p]),S=o(b);S.length>0&&(l[h]=S)}),Object.keys(l).length===0)return new t;let f=new t(l);return f.index=u.index,f}return u}Es.exports=mm});var Gt=c((GS,ks)=>{var dm=m(),pm=d(),gm=y(),qm=g(),ym=q();function js(t){if(gm(t)||ym(t))return t.dropNaN(...Object.values(arguments).slice(1));dm(pm(t),"The `dropNaN` function only works on arrays, Series, and DataFrames!");let e=[];return t.forEach(n=>{try{return e.push(js(n))}catch{if(qm(n))return e.push(n)}}),e}ks.exports=js});var zs=c((LS,Cs)=>{var Lt=m(),bm=Gt(),Nm=xe();function vm(t,e,n,r,s){n=n||0,Lt(n===0||n===1,"The first parameter of the `dropNaN` method (the `axis`) must be 0 or 1."),s=s||0,Lt(Nm(s),"The third parameter of the `dropNaN` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` NaN values)."),r=s>0?"none":r||"any",Lt(r==="any"||r==="all"||r==="none","The second parameter of the `dropNaN` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains NaN values, then it should be dropped; or that if 'all' of the data contains NaN values, then it should be dropped).");function i(u){let a=bm(u);return s>0?u.length-a.length<s:r==="any"?a.length===u.length:r==="all"?a.length>0:!0}let o=e.copy();if(n===0){let u=o.index.filter(a=>{let l=o.get(a,null).values;return i(l)});return u.length>0?o.get(u,null):new t}else if(n===1){let u=o.columns.filter(a=>{let l=o.get(null,a).values;return i(l)});return u.length>0?o.get(null,u):new t}return o}Cs.exports=vm});var Bs=c((WS,Ps)=>{var Rs=m(),_e=T(),wm=A(),Sm=N();function Us(t){let e={};return _e(t).forEach((n,r)=>{e[n]=r}),e}function oe(t){return Object.keys(t).sort((e,n)=>t[e]-t[n])}function xm(t,e,n,r,s){Rs(wm(r),"The `filter` method takes a single parameter: a function that is used to filter the values."),Sm(s)&&(s=0),Rs(s===0||s===1,"The `axis` parameter to the `filter` method must be 0 or 1.");let i=n.copy();if(i.isEmpty)return i;let o=Us(i.index),u=Us(i.columns);if(s===0){let a=i.values.filter((l,f)=>{let h=new e(l);h.name=n.index[f],h.index=n.columns;let p=r(h,f,n);return p||delete o[i.index[f]],p});if(_e(a).length===0)return new t;if(a.length===1){let l=new e(_e(a));return l.name=oe(o)[0],l.index=oe(u),l}i.values=a,i.index=oe(o)}else if(s===1){i=i.transpose();let a=i.values.filter((l,f)=>{let h=new e(l);h.name=n.columns[f],h.index=n.index;let p=r(h,f,n);return p||delete u[i.index[f]],p});if(_e(a).length===0)return new t;if(a.length===1){let l=new e(_e(a));return l.name=oe(u)[0],l.index=oe(o),l}i.values=a,i.index=oe(u),i=i.transpose()}return i}Ps.exports=xm});var Ys=c((KS,Js)=>{var k=m(),$e=g(),Ge=E(),Vs=N(),_m=z();function Tm(t,e,n){(Ge(e)||$e(e))&&(e=[e]),(Ge(n)||$e(n))&&(n=[n]);let r=_m((e||[]).concat(n||[]).map(s=>typeof s));return k(r.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===1&&k(r[0]==="string"||r[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===2&&(k(r.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),k(r.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),Vs(e)||(e=e.map(s=>{if(Ge(s))return k(t.index.indexOf(s)>-1,`Row "${s}" does not exist!`),s;if($e(s))return k(s>=0,`Index ${s} is out of bounds!`),k(parseInt(s)===s,"Row numbers must be integers!"),k(s<t.index.length,`Index ${s} is out of bounds!`),t.index[s]})),Vs(n)||(n=n.map(s=>{if(Ge(s))return k(t.columns.indexOf(s)>-1,`Column "${s}" does not exist!`),s;if($e(s))return k(s>=0,`Column ${s} is out of bounds!`),k(parseInt(s)===s,"Column numbers must be integers!"),k(s<t.columns.length,`Column ${s} is out of bounds!`),t.columns[s]})),t.getSubsetByNames(e,n)}Js.exports=Tm});var G=c((HS,Gs)=>{var $s=m(),Om=d(),Dm=y(),Fm=A(),Im=q(),Am=N();function Em(t,e){try{return t<e?-1:t>e?1:0}catch{return t=typeof t=="object"&&t!==null?JSON.stringify(t):t.toString(),e=typeof e=="object"&&e!==null?JSON.stringify(e):e.toString(),t<e?-1:t>e?1:0}}function Mm(t,e){if(Am(e)&&(e=Em),Dm(t)||Im(t))return t.sort(...Object.values(arguments).slice(1));$s(Om(t),"The `sort` function only works on arrays, Series, and DataFrames!"),$s(Fm(e),"The second parameter of the `sort` function must be a comparison function!");let n=t.slice();return n.sort(e),n}Gs.exports=Mm});var Hs=c((XS,Ks)=>{var Ls=m(),Ws=E(),jm=N(),km=z(),Cm=G();function zm(t){let e=t.toLowerCase(),n="";for(let s=0;s<e.length;s++){let i=e[s];i.match(/[a-z0-9]/g)?n+=i:n+=" "}let r=n.split(" ").filter(s=>s.length>0);return r[0]+r.slice(1).map(s=>s[0].toUpperCase()+s.substring(1)).join("")}function Rm(t,e,n){jm(n)?n=e.columns:Ws(n)&&(n=[n]);let r={};n.forEach(i=>{Ls(Ws(i),"You must pass either a string or a one-dimensional array of strings into the `getDummies` (AKA `oneHotEncode`) method!");let o=e.columns.indexOf(i);Ls(o>-1,`The given DataFrame does not have a column called "${i}"!`);let u=e.values.map(l=>l[o]),a=Cm(km(u));u.forEach(l=>{a.forEach(f=>{let h=i+"_"+zm(f.toString());r[h]||(r[h]=[]),l===f?r[h].push(1):r[h].push(0)})})});let s=new t(r);return s.index=e.index,s}Ks.exports=Rm});var si=c((QS,ri)=>{var L=m(),Xs=d(),Qs=g(),Zs=N(),ei=xe(),ti=j(),ni=x();function Um(t,e,n){let r=t.shape;Zs(e)&&(e=ti(0,r[0])),Zs(n)&&(n=ti(0,r[1])),Qs(e)&&(e=[e]),Qs(n)&&(n=[n]),L(Xs(e)&&Xs(n),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),L(ni(e).length===1&&ni(n).length===1,"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),L(e.length>0,"The `rowIndices` array must contain at least one index."),L(n.length>0,"The `colIndices` array must contain at least one index."),e.forEach(o=>{L(ei(o),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),L(o<t.index.length,`The row index ${o} is out of bounds.`)}),n.forEach(o=>{L(ei(o),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),L(o<t.columns.length,`The column index ${o} is out of bounds.`)});let s=e.map(o=>t.index[o]),i=n.map(o=>t.columns[o]);return t.getSubsetByNames(s,i)}ri.exports=Um});var ci=c((ZS,ai)=>{var W=m(),Wt=T(),ii=d(),Le=E(),oi=N(),ui=x();function Pm(t,e,n,r,s){oi(r)&&(r=n.index),oi(s)&&(s=n.columns),Le(r)&&(r=[r]),Le(s)&&(s=[s]),W(ii(r)&&ii(s),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),W(ui(r).length===1&&ui(s).length===1,"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),W(r.length>0,"The `rows` array must contain at least one row name."),W(s.length>0,"The `cols` array must contain at least one column name."),r.forEach(u=>{W(Le(u),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),W(n.index.indexOf(u)>-1,`The row name "${u}" does not exist in the list of rows.`)}),s.forEach(u=>{W(Le(u),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),W(n.columns.indexOf(u)>-1,`The column name "${u}" does not exist in the list of columns.`)});let i=r.map(u=>s.map(a=>n.values[n.index.indexOf(u)][n.columns.indexOf(a)]));if(r.length===1&&s.length===1)return Wt(i)[0];if(r.length===1){let u=new e(Wt(i));return u.name=r[0],u.index=s,u}if(s.length===1){let u=new e(Wt(i));return u.name=s[0],u.index=r,u}let o=new t(i);return o.columns=s,o.index=r,o}ai.exports=Pm});var fi=c((e2,li)=>{var Bm=E(),Te=j();function Vm(t,e,n){function r(p,b){return Bm(p)&&p.length>b?p.substring(0,b-3)+"...":p}if(n.isEmpty)return console.table({}),console.log("Shape:",[0,0],`
`),n;let s=typeof window>"u"?20:10,i=parseInt(s/2),o=typeof process>"u"?10:Math.floor(process.stdout.columns/24)-1,u=parseInt(o/2),a=s>n.index.length?null:Te(0,i).concat(Te(n.index.length-i,n.index.length)),l=o>n.columns.length?null:Te(0,u).concat(Te(n.columns.length-u,n.columns.length)),f=n.get(a,l);f instanceof e&&(n.shape[0]===1?(f=new t([f.values]),f.index=n.index,f.columns=new e(n.columns).get(l).values):n.shape[1]===1&&(f=new t([f.values]).transpose(),f.index=new e(n.index).get(a).values,f.columns=n.columns)),s<=n.index.length&&(f._index.splice(i,0,"..."),f._values.splice(i,0,Te(0,f.columns.length).map(()=>"..."))),o<=n.columns.length&&(f._columns.splice(u,0,"..."),f._values=f._values.map(p=>(p.splice(u,0,"..."),p)));let h=28;return f instanceof e?(f.values=f.values.map(p=>r(p,h)),f.name=r(f.name,h),f.index=f.index.map(p=>r(p,h))):(f.values=f.values.map(p=>p.map(b=>r(b,h))),f.columns=f.columns.map(p=>r(p,h)),f.index=f.index.map(p=>r(p,h))),console.table(f.toObject()),console.log("Shape:",n.shape,`
`),n}li.exports=Vm});var We=c((t2,hi)=>{var Jm=m(),Ym=g();function $m(t,e){Jm(Ym(t),"The `leftPad` function only works on numbers!");let n=t.toString();for(;n.length<e;)n="0"+n;return n}hi.exports=$m});var di=c((n2,mi)=>{var Gm=We(),Lm=j();function Wm(t,e){let n=e?t:t.copy();return n.index=Lm(0,t.shape[0]).map(r=>"row"+Gm(r,(n.index.length-1).toString().length)),n}mi.exports=Wm});var Oe=c((r2,gi)=>{var Km=m(),Hm=T(),Xm=d(),Qm=y(),Zm=q();function pi(t){if(Qm(t)||Zm(t))return pi(t.values);Km(Xm(t),"The `product` function only works on arrays, Series, and DataFrames!");try{return t.length===0?NaN:Hm(t).reduce((e,n)=>e*n,1)}catch{return NaN}}gi.exports=pi});var Ke=c((s2,Ni)=>{var De=m(),qi=T(),yi=d(),ed=y(),bi=g(),td=q(),nd=Oe(),rd=x();function Kt(t,e){if(ed(t)||td(t))return Kt(t.values,e);if(De(yi(t),"The first argument passed into the `reshape` function must be an array!"),bi(e)&&(e=[e]),De(yi(e),"The second argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),De(rd(e).length===1,"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),e.forEach(i=>{De(bi(i)&&parseInt(i)===i&&i>0,"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!")}),e.length===0)return qi(t);let n=qi(t);if(e.length===1&&e[0]===n.length)return n;De(nd(e)===n.length,"The new shape doesn't match the number of values available in `x` (the first argument passed into the `reshape` function)!");let r=[],s=parseInt(n.length/e[0]);for(let i=0;i<e[0];i++){let o=n.slice(i*s,(i+1)*s);r.push(Kt(o,e.slice(1)))}return r}Ni.exports=Kt});var ue=c((i2,Oi)=>{var sd=m(),Si=C(),id=d(),od=g(),xi=N(),ud=$(),ad=Oe(),cd=Ke(),_i=Math.pow(2,64),_=[];Ti(parseInt(Math.random()*_i));function ld(t,e){t=I(t);function n(){t+=I("0x9e3779b97f4a7c15");let s=Si(t);return s=(s^s>>30n)*I("0xbf58476d1ce4e5b9"),s=(s^s>>27n)*I("0x94d049bb133111eb"),s^s>>31n}let r=[];for(let s=0;s<e;s++)r.push(n());return r}function I(t){return BigInt.asUintN(64,BigInt(t))}function vi(t,e){return t=I(t),e=BigInt(e),I(I(t<<e)|I(t>>I(64n-e)))}function Ti(t){if(xi(t))return Si(_);{sd(od(t),"If passing a value into the `seed` function, then that value must be an integer!");let e=ld(parseInt(t),4);_[0]=e[0],_[1]=e[1],_[2]=e[2],_[3]=e[3]}}function wi(){let t=I(vi(_[0]+_[3],23)+_[0]),e=I(_[1]<<17n);return _[2]=I(_[2]^_[0]),_[3]=I(_[3]^_[1]),_[1]=I(_[1]^_[2]),_[0]=I(_[0]^_[3]),_[2]=I(_[2]^e),_[3]=vi(_[3],45),parseInt(t)/_i}function fd(t){return xi(t)?wi():(id(t)||(t=[t]),cd(ud(ad(t)).map(wi),t))}Oi.exports={random:fd,seed:Ti}});var He=c((o2,Di)=>{var{random:hd}=ue(),md=m(),dd=d(),pd=y(),gd=q();function qd(t){if(pd(t)||gd(t))return t.shuffle(...Object.values(arguments).slice(1));md(dd(t),"The `shuffle` function only works on arrays, Series, and DataFrames!");let e=[],n=t.slice();for(let r=0;r<t.length;r++){let s=parseInt(hd()*n.length);e.push(n.splice(s,1)[0])}return e}Di.exports=qd});var Ai=c((u2,Ii)=>{var yd=m(),bd=N(),Fi=He();function Nd(t,e){return bd(e)&&(e=0),yd(e===0||e===1,"The `axis` parameter to the `shuffle` must be 0, 1, or undefined."),t.get(e===0?Fi(t.index):null,e===1?Fi(t.columns):null)}Ii.exports=Nd});var Xe=c((a2,Ei)=>{function vd(t){return typeof t=="boolean"}Ei.exports=vd});var zi=c((c2,Ci)=>{var{random:wd}=ue(),M=m(),Sd=T(),Mi=d(),Ht=Xe(),ki=A(),Qe=g(),ae=E(),Xt=N(),xd=j(),ji=x(),Qt=G();function _d(t,e,n){return ki(e)?Td(t,e,n):Od(t,e,n)}function Td(t,e,n){if(n=Xt(n)?0:n,M(ki(e),"When sorting a DataFrame using a function, the first argument to the `sort` method must be a function!"),M(Qe(n),"When sorting a DataFrame using a function, the second argument to the `sort` method must be null, undefined, 0, or 1 to indicate the axis along which the data should be sorted! An axis of 0 means that the rows will be sorted relative to each other, whereas an axis of 1 means that the columns will be sorted relative to each other."),n===0){let r=Qt(t.index,(s,i)=>e(t.get(s,null),t.get(i,null)));return t.get(r,null)}else{let r=Qt(t.columns,(s,i)=>e(t.get(null,s),t.get(null,i)));return t.get(null,r)}}function Od(t,e,n){let r=t.copy(),s=wd().toString();return r=r.assign(s,r.index),Xt(e)&&(e=[s],n=[!0]),(Qe(e)||ae(e))&&(e=[e],(Ht(n)||ae(n))&&(n=[n])),M(Mi(e),"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),M(ji(e).length===1,"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),Xt(n)&&(n=xd(0,e.length).map(()=>!0)),M(Mi(n),"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),M(ji(n).length===1,"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),M(e.length===n.length,"The arrays passed into the `sort` method must be equal in length."),e=e.map(i=>{if(M(ae(i)||Qe(i),"Column references can either be column names (as strings) or column indices (as whole numbers)."),ae(i)){let o=r.columns.indexOf(i);return M(o>-1,`The column "${i}" does not exist!`),o}if(Qe(i))return M(parseInt(i)===i,"Column indices must be whole numbers!"),M(i>=0,`The column index ${i} is out of bounds!`),M(i<r.columns.length,`The index ${i} is out of bounds!`),i}),n=n.map(i=>{if(M(ae(i)||Ht(i),"Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),ae(i)){let o=i.trim().toLowerCase();return M(o==="ascending"||o==="descending","Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),o==="ascending"}if(Ht(i))return i}),r.values=Qt(r.values,(i,o)=>{let u=0;for(;i[e[u]]===o[e[u]]&&u<e.length;)u++;let a=n[u];if(i[e[u]]===o[e[u]])return 0;if(i[e[u]]<o[e[u]])return a?-1:1;if(i[e[u]]>o[e[u]])return a?1:-1}),r.index=Sd(r.get(null,s).values),r=r.dropColumns(s),r}Ci.exports=_d});var Zt=c((l2,Ri)=>{function Dd(t,e){return JSON.stringify(t.toObject(e))}Ri.exports=Dd});var Ui=c((f2,tn)=>{var en=se(),Fd=Zt();function Id(t,e,n){let r=Fd(t,n),s=!1,i=!1,o,u;try{let a=e;if(e.includes("/")){let f=e.split("/");a=f[f.length-1]}let l=document.createElement("a");l.href=`data:application/json;charset=utf-8,${encodeURIComponent(r)}`,l.download=a,l.dispatchEvent(new MouseEvent("click")),s=!0}catch(a){o=a}try{let a=Nr("fs"),l=Nr("path");a.writeFileSync(l.resolve(e),r,"utf8"),i=!0}catch(a){u=a}if(!s&&!i)throw typeof window<"u"?new en(o):typeof tn<"u"?new en(u):new en("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");return t}tn.exports=Id});var Bi=c((h2,Pi)=>{var Ad=m(),Ed=N();function Md(t,e){Ed(e)?e=0:Ad(e===0||e===1,"The axis parameter of the `toObject` method must be undefined, 0, or 1. An axis of 0 indicates that the returned object should be organized first by rows and then by columns. An axis of 1 indicates that the returned object should be organized first by columns and then by rows.");let n={};return e===0?t.index.forEach((r,s)=>{let i={};t.columns.forEach((o,u)=>{i[o]=t.values[s][u]}),n[r]=i}):t.columns.forEach((r,s)=>{let i={};t.index.forEach((o,u)=>{i[o]=t.values[u][s]}),n[r]=i}),n}Pi.exports=Md});var ee=c((m2,Yi)=>{var Vi=m(),jd=d(),kd=y(),Cd=q(),zd=$(),Ji=Se(),Rd=x();function Ud(t){if(kd(t)||Cd(t))return t.transpose();Vi(jd(t),"The `transpose` function only works on arrays, Series, and DataFrames!");let e=Rd(t);if(Vi(e.length<=2,"I'm not smart enough to know how to transpose arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `transpose` function!"),e.length===1)return Ji(t);if(e.length===2){let n=zd(Ji(e));for(let r=0;r<e[0];r++)for(let s=0;s<e[1];s++)n[s][r]=t[r][s];return n}}Yi.exports=Ud});var Wi=c((d2,Li)=>{var $i=m(),Pd=d(),Bd=y(),Vd=Be(),Jd=q(),Yd=x();function Gi(t,e,n){if(Jd(n))return new t(e.values.concat(n.values));if(Pd(n)){let r=Yd(n);$i(r.length===1&&!Vd(r),"Only vectors can be appended to Series!");let s=e.copy();return n.forEach((i,o)=>{s._values.push(i),s._index.push("item"+(e.values.length+o))}),s}return $i(!Bd(n),"DataFrames cannot be appended to Series!"),Gi(e,[n])}Li.exports=Gi});var Hi=c((p2,Ki)=>{var $d=m(),Gd=A();function Ld(t,e){$d(Gd(e),"The parameter to the `apply` method must be a function.");let n=t.copy();return n._values=n._values.map((r,s)=>e(r,s)),n}Ki.exports=Ld});var Qi=c((g2,Xi)=>{var Wd=N();function Kd(t){let e=t.copy(),n=[];return e._values=e.values.filter((r,s)=>Wd(r)?!1:(n.push(e.index[s]),!0)),e._index=n,e}Xi.exports=Kd});var eo=c((q2,Zi)=>{var Hd=g();function Xd(t,e){let n=[],r=[];e.values.forEach((i,o)=>{Hd(i)&&(r.push(i),n.push(e.index[o]))});let s=new t(r);return s.name=e.name,s.index=n,s}Zi.exports=Xd});var no=c((y2,to)=>{var Qd=C();function Zd(t,e,n){let r=e.copy(),s=Qd(r.index),i=[],o=r.values.filter((u,a)=>{let l=n(u,a,r.values);return l||i.push(r.index[a]),l});return i.forEach(u=>{s.splice(s.indexOf(u),1)}),o.length===0?(r=new t,r.name=e.name,r):(r.values=o,r.index=s,r)}to.exports=Zd});var so=c((b2,ro)=>{var K=m(),ep=g(),tp=E(),np=N(),rp=z();function sp(t,e){(tp(e)||ep(e))&&(e=[e]);let n=rp((e||[]).map(r=>typeof r));return K(n.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===1&&K(n[0]==="string"||n[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===2&&(K(n.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),K(n.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),np(e)||(e=e.map(r=>{if(typeof r=="string")return K(t.index.indexOf(r)>-1,`Index "${r}" does not exist!`),r;if(typeof r=="number")return K(r>=0,`Index ${r} is out of bounds!`),K(parseInt(r)===r,"Indices must be integers!"),K(r<t.index.length,`Index ${r} is out of bounds!`),t.index[r]})),t.getSubsetByNames(e)}ro.exports=sp});var oo=c((N2,io)=>{var Fe=m(),ip=d(),op=N(),up=xe(),ap=j(),cp=x();function lp(t,e){let n=t.shape;op(e)&&(e=ap(0,n[0])),Fe(ip(e),"The `indices` array must be 1-dimensional array of whole numbers."),Fe(cp(e).length===1,"The `indices` array must be a 1-dimensional array of whole numbers."),Fe(e.length>0,"The `indices` array must contain at least one index."),e.forEach(s=>{Fe(up(s),"The `indices` array must be a 1-dimensional array of whole numbers."),Fe(s<t.index.length,`The row index ${s} is out of bounds.`)});let r=e.map(s=>t.index[s]);return t.getSubsetByNames(r)}io.exports=lp});var ao=c((v2,uo)=>{var Ie=m(),fp=d(),hp=E(),mp=N(),dp=x();function pp(t,e,n){mp(n)&&(n=e.index),Ie(fp(n),"The `indices` array must be a 1-dimensional array of strings."),Ie(dp(n).length===1,"The `indices` array must be a 1-dimensional array of strings."),Ie(n.length>0,"The `indices` array must contain at least one index name."),n.forEach(i=>{Ie(hp(i),"The `indices` array must contain only strings."),Ie(e.index.indexOf(i)>-1,`The name "${i}" does not exist in the index.`)});let r=n.map(i=>e.values[e.index.indexOf(i)]);if(r.length===1)return r[0];let s=new t(r);return s.index=n,s.name=e.name,s}uo.exports=pp});var fo=c((w2,lo)=>{var gp=C(),co=j();function qp(t){let e=t.copy(),n=typeof window>"u"?20:10;if(e.index.length>n){e=e.get(co(0,n/2).concat(co(e.index.length-n/2,e.index.length)));let s=gp(e.index);s.splice(parseInt(s.length/2),0,"..."),e.values.push("..."),e.index.push("..."),e=e.get(s)}let r={};return e.values.forEach((s,i)=>{let o={};o[e.name]=s,r[e.index[i]]=o}),console.table(r),console.log("Shape:",t.shape,`
`),t}lo.exports=qp});var mo=c((S2,ho)=>{var yp=He();function bp(t){let e=t.copy();return e.get(yp(e.index))}ho.exports=bp});var go=c((x2,po)=>{var Np=m(),vp=A(),wp=N(),Sp=G(),xp=ee();function _p(t,e,n){n=n||((a,l)=>a<l?-1:1),Np(wp(n)||vp(n),"You must pass undefined, null, or a comparison function as the second argument to the `sort` method!");let r=xp([e.values,e.index]),s=Sp(r,(a,l)=>n(a[0],l[0])),i=[],o=[];s.forEach(a=>{i.push(a[0]),o.push(a[1])});let u=new t;return u._values=i,u._index=o,u.name=e.name,u}po.exports=_p});var bo=c((_2,yo)=>{var Tp=G(),qo=ee();function Op(t,e){let n=qo([e.values,e.index]);n=qo(Tp(n,(s,i)=>{if(s[1]===i[1])return 0;if(s[1]<i[1])return-1;if(s[1]>i[1])return 1}));let r=new t(n[0]);return r.index=n[1],r.name=e.name,r}yo.exports=Op});var vo=c((T2,No)=>{function Dp(t){let e={};return e[t.name]={},t.index.forEach((n,r)=>{e[t.name][n]=t.values[r]}),e}No.exports=Dp});var To=c((O2,_o)=>{var V=m(),Ze=C(),nn=d(),Fp=E(),Ip=N(),wo=We(),So=j(),et=Se(),Ap=Wi(),Ep=Hi(),Mp=Qi(),jp=eo(),kp=no(),Cp=so(),zp=oo(),Rp=ao(),Up=fo(),Pp=mo(),Bp=go(),Vp=bo(),Jp=vo(),Ae=x(),Yp=ee(),xo=Symbol.for("@jrc03c/js-math-tools/series");_o.exports=function(t){class e{static[Symbol.hasInstance](r){try{return!!r._symbol&&r._symbol===xo}catch{return!1}}constructor(r){let s=this;if(s.name="data",Object.defineProperty(s,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:xo}),Object.defineProperty(s,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(s,"values",{configurable:!0,enumerable:!0,get(){return s._values},set(i){V(nn(i),"The new values must be a 1-dimensional array!");let o=Ae(i);V(o.length===1,"The new array of values must be 1-dimensional!"),o[0]<s._index.length?s._index=s._index.slice(0,o[0]):o[0]>s._index.length&&(s._index=s._index.concat(So(s._index.length,o[0]).map(u=>"item"+wo(u,(i.length-1).toString().length)))),s._values=i}}),Object.defineProperty(s,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(s,"index",{configurable:!0,enumerable:!0,get(){return s._index},set(i){V(nn(i),"The new index must be a 1-dimensional array of strings!"),V(i.length===s.shape[0],"The new index must be the same length as the old index!"),V(Ae(i).length===1,"The new index must be a 1-dimensional array of strings!"),i.forEach(o=>{V(Fp(o),"All of the row names must be strings!")}),s._index=i}}),r){if(r instanceof e)s.name=r.name,s.values=Ze(r.values),s.index=Ze(r.index);else if(nn(r)){let i=Ae(r);V(i.length===1,"When passing an array into the constructor of a Series, the array must be 1-dimensional!"),s.values=r}else if(r instanceof Object){let i=Object.keys(r);V(i.length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");let o=i[0],u=r[o];V(Ae(u).length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!"),s.name=o,s.values=u.slice()}}}get shape(){return Ae(this.values)}get length(){return this.shape[0]}get isEmpty(){return this.values.filter(s=>!Ip(s)).length===0}clear(){let s=this.copy();return s.values.forEach((i,o)=>{s.values[o]=void 0}),s}get(r){return Cp(this,r)}getSubsetByNames(r){return Rp(e,this,r)}getSubsetByIndices(r){return zp(this,r)}loc(r){return this.getSubsetByNames(r)}iloc(r){return this.getSubsetByIndices(r)}reverse(){let r=this,s=new e(et(r.values));return s.index=et(r.index),s.name=r.name,s}resetIndex(){let r=this,s=r.copy();return s.index=So(0,r.shape[0]).map(i=>"item"+wo(i,(s.index.length-1).toString().length)),s}copy(){let r=this,s=new e;return s._values=Ze(r.values),s._index=Ze(r.index),s.name=r.name,s}append(r){return Ap(e,this,r)}apply(r){return Ep(this,r)}concat(r){return this.append(r)}dropMissing(r,s){return Mp(this,r,s)}dropNaN(){return jp(e,this)}toObject(){return Jp(this)}print(){return Up(this)}shuffle(){return Pp(this)}sort(r){return Bp(e,this,r)}sortByIndex(){return Vp(e,this)}filter(r){return kp(e,this,r)}toDataFrame(){let r=this,s=new t(Yp([r.values]));return s.columns=[r.name],s.index=r.index,s}transpose(){let s=this.copy();return s.values=et(s.values),s.index=et(s.index),s}getDummies(){return this.toDataFrame().getDummies()}oneHotEncode(){return this.getDummies()}}return e}});var Me=c((D2,Eo)=>{var U=m(),rn=C(),Oo=ve(),$p=hs(),Gp=qs(),Lp=vs(),Wp=Ss(),Kp=Is(),Hp=Ms(),Xp=zs(),Qp=Bs(),Zp=Ys(),Do=Hs(),eg=si(),tg=ci(),ng=fi(),rg=di(),sg=Ai(),ig=zi(),og=Ui(),ug=Zt(),ag=Bi(),cg=T(),Ee=d(),lg=Y(),Fo=N(),sn=We(),fg=$(),on=j(),ce=x(),Io=ee(),Ao=Symbol.for("@jrc03c/js-math-tools/dataframe");function tt(t){let e="abcdefghijklmnopqrstuvwxyz1234567890",n="";for(let r=0;r<t;r++)n+=e[parseInt(Math.random()*e.length)];return n}var D=class{static[Symbol.hasInstance](e){try{return!!e._symbol&&e._symbol===Ao}catch{return!1}}constructor(e){let n=this;if(Object.defineProperty(n,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:Ao}),Object.defineProperty(n,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(n,"values",{configurable:!0,enumerable:!0,get(){return n._values.length===0||!Fo(n._values[0])&&n._values[0].length===0?[[]]:n._values},set(r){U(Ee(r),"The new values must be a 2-dimensional array!");let s=ce(r);U(s.length===2,"The new array of values must be 2-dimensional!"),s[0]<n._index.length?n._index=n._index.slice(0,s[0]):s[0]>n._index.length&&(n._index=n._index.concat(on(n._index.length,s[0]).map(i=>"row"+sn(i,(s[0]-1).toString().length)))),s[1]<n._columns.length?n._columns=n._columns.slice(0,s[1]):s[1]>n._columns.length&&(n._columns=n._columns.concat(on(n._columns.length,s[1]).map(i=>"col"+sn(i,(s[1]-1).toString().length)))),n._values=r}}),Object.defineProperty(n,"_columns",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(n,"columns",{configurable:!0,enumerable:!0,get(){return n._columns},set(r){U(Ee(r),"The new columns list must be a 1-dimensional array of strings!"),U(n.isEmpty||r.length===n.shape[1],"The new columns list must be the same length as the old columns list!"),U(ce(r).length===1,"The new columns list must be a 1-dimensional array of strings!"),r=r.map(i=>(typeof i!="string"&&(i=JSON.stringify(i)||i.toString()),i.trim().length===0?"untitled_"+tt(8):i.trim()));let s=(()=>{let i=Oo(r),o={};return i.forEach(u=>{o[u.item]=u.count}),o})();r=r.map(i=>s[i]>1?i+"_"+tt(8):i),n._columns=r}}),Object.defineProperty(n,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(n,"index",{configurable:!0,enumerable:!0,get(){return n._index},set(r){U(Ee(r),"The new index must be a 1-dimensional array of strings!"),U(n.isEmpty||r.length===n.shape[0],"The new index must be the same length as the old index!"),U(ce(r).length===1,"The new index must be a 1-dimensional array of strings!"),r=r.map(i=>(typeof i!="string"&&(i=JSON.stringify(i)||i.toString()),i.trim().length===0?"untitled_"+tt(8):i.trim()));let s=(()=>{let i=Oo(r),o={};return i.forEach(u=>{o[u.item]=u.count}),o})();r=r.map(i=>s[i]>1?i+"_"+tt(8):i),n._index=r}}),U(Fo(e)||lg(e)||Ee(e),"The `data` passed into the constructor of a DataFrame must be either (1) an object where the key-value pairs are (respectively) column names and 1-dimensional arrays of values, or (2) a 2-dimensional array of values."),e)if(e instanceof D)n.values=rn(e.values),n.columns=rn(e.columns),n.index=rn(e.index);else if(Ee(e)){let r=ce(e);U(r.length===2,"The `data` array passed into the constructor of a DataFrame must be 2-dimensional!"),n.values=e}else{n._columns=Object.keys(e);let r=[];n._columns.forEach(i=>{let o=e[i];r.push(o)}),n._values=Io(r);let s=ce(n.values);n._index=on(0,s[0]).map(i=>"row"+sn(i,(s[0]-1).toString().length))}}get shape(){return ce(this.values)}get length(){return this.shape[0]}get width(){return this.shape[1]}get rows(){return this.index}set rows(e){let n=this;n.index=e}get isEmpty(){return cg(this.values).length===0}clear(){let e=this,n=new D(fg(e.shape));return n.columns=e.columns.slice(),n.index=e.index.slice(),n}get(e,n){let r=this;if(arguments.length===0)return r;if(arguments.length===1)try{return r.get(null,e)}catch{return r.get(e,null)}return Zp(r,e,n)}getSubsetByNames(e,n){return tg(D,H,this,e,n)}getSubsetByIndices(e,n){return eg(this,e,n)}getDummies(e){return Do(D,this,e)}oneHotEncode(e){return Do(D,this,e)}transpose(){let e=this,n=new D(Io(e.values));return n.columns=e.index.slice(),n.index=e.columns.slice(),n}get T(){return this.transpose()}resetIndex(e){return rg(this,e)}copy(){return Wp(D,this)}assign(e,n){return Lp(D,H,this,e,n)}apply(e,n){return Gp(D,H,this,e,n)}dropMissing(e,n,r){return Hp(D,H,this,e,n,r)}dropNaN(e,n,r){return Xp(D,this,e,n,r)}drop(e,n){return Kp(D,H,this,e,n)}dropColumns(e){return this.drop(null,e)}dropRows(e){return this.drop(e,null)}toObject(e){return ag(this,e)}toJSONString(e){return ug(this,e)}saveAsJSON(e,n){return og(this,e,n)}print(){return ng(D,H,this)}sort(e,n){return ig(this,e,n)}sortByIndex(){return this.sort()}filter(e,n){return Qp(D,H,this,e,n)}shuffle(e){return sg(this,e)}append(e,n){return $p(this,e,n)}concat(e,n){return this.append(e,n)}join(e,n){return this.append(e,n)}toString(){let e=this;return JSON.stringify(e)}},H=To()(D);Eo.exports={DataFrame:D,Series:H}});var le=c((F2,jo)=>{var hg=m(),mg=T(),dg=d(),pg=y(),gg=q();function Mo(t){if(pg(t)||gg(t))return Mo(t.values);hg(dg(t),"The `max` function only works on arrays, Series, and DataFrames!");try{return Math.max(...mg(t))}catch{return NaN}}jo.exports=Mo});var v=c((I2,Uo)=>{var{DataFrame:ko,Series:Co}=Me(),zo=m(),je=d(),un=y(),Ro=R(),qg=A(),an=q(),yg=le(),bg=j(),nt=x();function Ng(t){return je(t)||an(t)||un(t)}function vg(t){return zo(qg(t),"You must pass a function into the `vectorize` function!"),function e(){let n,r,s=[],i=[],o=Object.keys(arguments).filter(u=>{let a=arguments[u];return je(a)?!0:an(a)?(n=!0,s.push(a),!0):un(a)?(r=!0,i.push(a),!0):!1}).map(u=>arguments[u]);if(o.slice(0,-1).forEach((u,a)=>{zo(Ro(je(u)?nt(u):u.shape,je(o[a+1])?nt(o[a+1]):o[a+1].shape),`When passing multiple arrays into the \`${t.name}\` function, all of the arrays must have the same shape!`)}),o.length>0){let u=yg(o.map(l=>l.length?l.length:l.values.length)),a=bg(0,u).map(l=>{let f=Object.keys(arguments).map(h=>{if(Ng(arguments[h])){if(je(arguments[h]))return arguments[h][l];if(an(arguments[h]))return arguments[h].values[l];if(un(arguments[h]))return arguments[h].values[l]}else return arguments[h]});return e(...f)});if(r)try{if(i.length===1&&Ro(nt(i[0]),nt(a))){let l=new ko(a);return l.index=i[0].index.slice(),l.columns=i[0].columns.slice(),l}else return new ko(a)}catch{return a}if(n)try{if(s.length===1&&s[0].length===a.length){let l=new Co(a);return l.name=s[0].name,l.index=s[0].index.slice(),l}else return new Co(a)}catch{return a}return a}else return t(...arguments)}}Uo.exports=vg});var rt=c((A2,Po)=>{var wg=g(),Sg=v();function xg(t){try{return wg(t)?Math.abs(t):NaN}catch{return NaN}}Po.exports=Sg(xg)});var st=c((E2,Bo)=>{var _g=g(),Tg=v();function Og(){try{let t=0,e=Object.values(arguments);for(let n=0;n<e.length;n++){if(!_g(e[n]))return NaN;t+=e[n]}return t}catch{return NaN}}Bo.exports=Tg(Og)});var ke=c((M2,Vo)=>{var Dg=v();function Fg(t,e){try{return e(t)}catch{return NaN}}Vo.exports=Dg(Fg)});var Yo=c((j2,Jo)=>{var Ig=g(),Ag=v();function Eg(t){try{return Ig(t)?Math.acos(t):NaN}catch{return NaN}}Jo.exports=Ag(Eg)});var Go=c((k2,$o)=>{var Mg=g(),jg=v();function kg(t){try{return Mg(t)?Math.asin(t):NaN}catch{return NaN}}$o.exports=jg(kg)});var Wo=c((C2,Lo)=>{var Cg=g(),zg=v();function Rg(t){try{return Cg(t)?Math.atan(t):NaN}catch{return NaN}}Lo.exports=zg(Rg)});var Ho=c((z2,Ko)=>{var Ug=m(),Pg=be(),Bg=d(),Vg=y(),Jg=q(),Yg=le();function cn(t){if(Vg(t)){let e=cn(t.values);return[t.index[e[0]],t.columns[e[1]]]}if(Jg(t)){let e=cn(t.values);return[t.index[e]]}Ug(Bg(t),"The `argmax` function only works on arrays, Series, and DataFrames!");try{let e=Pg(t,Yg(t));return e?e.length===0?void 0:e.length===1?e[0]:e:void 0}catch{return}}Ko.exports=cn});var it=c((R2,Qo)=>{var $g=m(),Gg=T(),Lg=d(),Wg=y(),Kg=q();function Xo(t){if(Wg(t)||Kg(t))return Xo(t.values);$g(Lg(t),"The `min` function only works on arrays, Series, and DataFrames!");try{return Math.min(...Gg(t))}catch{return NaN}}Qo.exports=Xo});var eu=c((U2,Zo)=>{var Hg=m(),Xg=be(),Qg=d(),Zg=y(),eq=q(),tq=it();function ln(t){if(Zg(t)){let e=ln(t.values);return[t.index[e[0]],t.columns[e[1]]]}if(eq(t)){let e=ln(t.values);return[t.index[e]]}Hg(Qg(t),"The `argmin` function only works on arrays, Series, and DataFrames!");try{let e=Xg(t,tq(t));return e?e.length===0?void 0:e.length===1?e[0]:e:void 0}catch{return}}Zo.exports=ln});var fn=c((P2,tu)=>{tu.exports=["null","none","nan","na","n/a","","undefined"]});var dn=c((B2,ru)=>{var nu=d(),nq=Xe(),rq=Y(),hn=N(),sq=fn();function mn(t,e){if(nu(t))return t.map(n=>mn(n,e));if(e==="null")return null;if(e==="number"){if(hn(t))return NaN;let n=parseFloat(t);return isNaN(n)?NaN:n}if(e==="boolean"){if(nq(t))return t;try{let n=(typeof t=="object"?t.toString()==="null"?"false":JSON.stringify(t):t.toString()).trim().toLowerCase();return n==="true"||n==="yes"||n==="y"?!0:n==="false"||n==="no"||n==="n"?!1:null}catch{return null}}if(e==="date"){if(t instanceof Date)return t;if(hn(t))return null;let n=new Date(t);return n.toString()==="Invalid Date"?null:n}if(e==="object"){if(rq(t))return t;try{let n=JSON.parse(t);return nu(n)?n.map(r=>mn(r,e)):n}catch{return null}}if(e==="string"){if(hn(t))return null;let n=(()=>typeof t=="object"?t===null?"null":JSON.stringify(t):t.toString())();return sq.indexOf(n.trim().toLowerCase())>-1?null:n}}ru.exports=mn});var iu=c((V2,su)=>{var iq=g(),oq=v();function uq(t){try{return iq(t)?Math.ceil(t):NaN}catch{return NaN}}su.exports=oq(uq)});var au=c((J2,uu)=>{var aq=rt(),ou=g(),cq=N(),lq=v();function fq(t,e){try{if(!ou(t))return NaN;if(cq(e))e=1e-10;else if(!ou(e))return NaN;return aq(t)<e?0:t}catch{return NaN}}uu.exports=lq(fq)});var lu=c((Y2,cu)=>{var pn=g(),hq=v();function mq(t,e,n){try{return pn(t)?pn(e)?pn(n)?t<e?e:t>n?n:t:NaN:NaN:NaN}catch{return NaN}}cu.exports=hq(mq)});var hu=c(($2,fu)=>{var gn=m(),dq=T(),pq=d(),gq=y(),qq=g(),yq=q();function qn(t,e){if(gq(t)||yq(t))return qn(t.values,e);if(gn(pq(t),"The `combinations` function only works on arrays, Series, and DataFrames!"),gn(qq(e),"`r` must be a whole number!"),t=dq(t),e>t.length)return[t];if(e<=0)return[[]];if(gn(e===parseInt(e),"`r` must be a whole number!"),t.length<2)return t;let n=[];return t.forEach((r,s)=>{let i=t.slice(s+1);if(i.length<e-1)return;qn(i,e-1).forEach(u=>{n.push([r].concat(u))})}),n}fu.exports=qn});var ot=c((G2,du)=>{var bq=m(),Nq=T(),vq=d(),wq=y(),Sq=q();function mu(t){if(wq(t)||Sq(t))return mu(t.values);bq(vq(t),"The `mean` function only works on arrays, Series, and DataFrames!");try{let e=Nq(t),n=0;return e.forEach(r=>{n+=r}),n/e.length}catch{return NaN}}du.exports=mu});var bn=c((L2,Nu)=>{var pu=m(),gu=d(),ut=g(),qu=q(),yu=ot(),bu=x();function yn(t,e){if(qu(t))return yn(t.values,e);if(qu(e))return yn(t,e.values);pu(gu(t)&&gu(e)&&bu(t).length===1&&bu(e).length===1,"The `covariance` function only works on 1-dimensional arrays and Series!"),pu(t.length===e.length,"The two arrays or Series passed into the `covariance` function must have the same length!");try{let n=yu(t),r=yu(e);if(!ut(n)||!ut(r))return NaN;let s=Math.max(t.length,e.length),i=0;for(let o=0;o<s;o++){if(!ut(t[o]))return NaN;if(!ut(e[o]))return NaN;i+=(t[o]-n)*(e[o]-r)}return i/t.length}catch{return NaN}}Nu.exports=yn});var at=c((W2,vu)=>{var xq=g(),_q=v();function Tq(t){try{return xq(t)?Math.sqrt(t):NaN}catch{return NaN}}vu.exports=_q(Tq)});var Nn=c((K2,Su)=>{var Oq=m(),Dq=T(),Fq=d(),Iq=y(),Aq=g(),Eq=q(),Mq=ot();function wu(t){if(Iq(t)||Eq(t))return wu(t.values);Oq(Fq(t),"The `variance` function only works on arrays, Series, and DataFrames!");try{let e=Dq(t),n=Mq(e),r=0;for(let s=0;s<e.length;s++){if(!Aq(e[s]))return NaN;r+=(e[s]-n)*(e[s]-n)}return r/e.length}catch{return NaN}}Su.exports=wu});var ct=c((H2,_u)=>{var jq=m(),kq=d(),Cq=y(),zq=q(),Rq=at(),Uq=Nn();function xu(t){if(Cq(t)||zq(t))return xu(t.values);jq(kq(t),"The `std` function only works on arrays, Series, and DataFrames!");try{return Rq(Uq(t))}catch{return NaN}}_u.exports=xu});var Eu=c((X2,Au)=>{var Tu=m(),Pq=bn(),Ou=d(),Du=q(),Fu=x(),Iu=ct();function vn(t,e){if(Du(t))return vn(t.values,e);if(Du(e))return vn(t,e.values);Tu(Ou(t)&&Ou(e)&&Fu(t).length===1&&Fu(e).length===1,"The `correl` function only works on 1-dimensional arrays and Series!"),Tu(t.length===e.length,"The two arrays or Series passed into the `correl` function must have the same length!");try{return Pq(t,e)/(Iu(t)*Iu(e))}catch{return NaN}}Au.exports=vn});var ju=c((Q2,Mu)=>{var Bq=g(),Vq=v();function Jq(t){try{return Bq(t)?Math.cos(t):NaN}catch{return NaN}}Mu.exports=Vq(Jq)});var Cu=c((Z2,ku)=>{ku.exports=Object.freeze({boolean:"boolean",date:"date",null:"null",number:"number",object:"object",string:"string"})});var Vu=c((ex,Bu)=>{var Yq=m(),zu=d(),Ru=y(),$q=R(),Uu=q(),Pu=z();function wn(t,e){if(Ru(t)||Uu(t))return wn(t.values,e);if(Ru(e)||Uu(e))return wn(t,e.values);Yq(zu(t)&&zu(e),"The `diff` function only works on arrays, Series, and DataFrames!");let n=Pu(t),r=Pu(e),s=[];return n.forEach(i=>{r.findIndex(o=>$q(o,i))<0&&s.push(i)}),s}Bu.exports=wn});var lt=c((tx,Yu)=>{var Ju=g(),Gq=v();function Lq(t,e){try{return Ju(t)?Ju(e)?Math.pow(t,e):NaN:NaN}catch{return NaN}}Yu.exports=Gq(Lq)});var Sn=c((nx,$u)=>{var Wq=g(),Kq=v();function Hq(){try{let t=Object.values(arguments);if(t.length===0)return NaN;let e=1;for(let n=0;n<t.length;n++){if(!Wq(t[n]))return NaN;e*=t[n]}return e}catch{return NaN}}$u.exports=Kq(Hq)});var fe=c((rx,Gu)=>{var Xq=Sn();function Qq(){return Xq(...arguments)}Gu.exports=Qq});var xn=c((sx,Lu)=>{var Zq=st(),ey=fe();function ty(t,e){return Zq(t,ey(e,-1))}Lu.exports=ty});var ft=c((ix,Ku)=>{var ny=m(),ry=T(),sy=d(),iy=y(),oy=q();function Wu(t){if(iy(t)||oy(t))return Wu(t.values);ny(sy(t),"The `sum` function only works on arrays, Series, and DataFrames!");try{return t.length===0?NaN:ry(t).reduce((e,n)=>e+n,0)}catch{return NaN}}Ku.exports=Wu});var na=c((ox,ta)=>{var uy=rt(),ay=m(),Hu=d(),Xu=y(),cy=R(),Qu=g(),Zu=q(),ly=lt(),ea=x(),fy=at(),hy=xn(),my=ft();function _n(t,e){if(Qu(t)&&Qu(e))return uy(t-e);if(Xu(t)||Zu(t))return _n(t.values,e);if(Xu(e)||Zu(e))return _n(t,e.values);Hu(t)&&Hu(e)&&ay(cy(ea(t),ea(e)),"If passing two arrays, Series, or DataFrames into the `distance` function, then those objects must have the same shape!");try{return fy(my(ly(hy(t,e),2)))}catch{return NaN}}ta.exports=_n});var sa=c((ux,ra)=>{var dy=lt(),py=fe();function gy(t,e){return py(t,dy(e,-1))}ra.exports=gy});var On=c((ax,la)=>{var{DataFrame:ia,Series:oa}=Me(),ht=m(),ua=T(),aa=d(),Tn=y(),qy=g(),mt=q(),yy=fe(),dt=x(),by=ft(),ca=ee();function X(t,e){if(Tn(t)){let s=X(t.values,e);if(dt(s).length===1){let i=new oa(s);return i.name=mt(e)?e.name:i.name,i.index=t.index.slice(),i}else{let i=new ia(s);return i.index=t.index.slice(),Tn(e)&&(i.columns=e.columns.slice()),i}}if(Tn(e)){let s=X(t,e.values);if(dt(s).length===1){let i=new oa(s);return i.name=mt(t)?t.name:i.name,i.index=e.columns.slice(),i}else{let i=new ia(s);return i.columns=e.columns.slice(),i}}if(mt(t))return X(t.values,e);if(mt(e))return X(t,e.values);ht(aa(t)&&aa(e),"The `dot` function only works on arrays, Series, and DataFrames!"),ua(t).concat(ua(e)).forEach(s=>{ht(qy(s),"One of the arrays you passed into the `dot` function contains non-numerical values!")});let n=dt(t),r=dt(e);if(ht(n.length<=2&&r.length<=2,"I'm not smart enough to know how to get the dot-product of arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `dot` function!"),ht(n[n.length-1]===r[0],`There's a dimension misalignment in the two arrays you passed into the \`dot\` function. (${n[n.length-1]} !== ${r[0]})`),n.length===1&&r.length===1)return by(yy(t,e));if(n.length===1&&r.length===2)return ca(e).map(s=>X(t,s));if(n.length===2&&r.length===1)return t.map(s=>X(s,e));if(n.length===2&&r.length===2){let s=ca(e),i=[];for(let o=0;o<t.length;o++){let u=[];for(let a=0;a<s.length;a++)u.push(X(t[o],s[a]));i.push(u)}return i}}la.exports=X});var Dn=c((cx,ha)=>{var Ny=m(),vy=d(),wy=y(),Sy=q(),xy=N();function fa(t){if(wy(t)||Sy(t))return t.dropMissing(...Object.values(arguments).slice(1));Ny(vy(t),"The `dropMissing` function only works on arrays, Series, and DataFrames!");let e=[];return t.forEach(n=>{try{return e.push(fa(n))}catch{xy(n)||e.push(n)}}),e}ha.exports=fa});var Na=c((lx,ba)=>{var ma=m(),da=d(),pa=y(),_y=R(),ga=q(),qa=N(),ya=x();function pt(t,e){if(pa(t)||ga(t))return pt(t.values,e);if(pa(e)||ga(e))return pt(t,e.values);ma(da(t)&&da(e),"The `dropMissingPairwise` function only works on arrays, Series, and DataFrames!"),ma(_y(ya(t),ya(e)),"The two arrays, Series, and/or DataFrames passed into the `dropMissingPairwise` function must have the same shape!");let n=[],r=[];for(let s=0;s<t.length;s++)try{let[i,o]=pt(t[s],e[s]);n.push(i),r.push(o)}catch{!qa(t[s])&&!qa(e[s])&&(n.push(t[s]),r.push(e[s]))}return[n,r]}ba.exports=pt});var Da=c((fx,Oa)=>{var va=m(),wa=d(),Sa=y(),Ty=R(),xa=g(),_a=q(),Ta=x();function gt(t,e){if(Sa(t)||_a(t))return gt(t.values,e);if(Sa(e)||_a(e))return gt(t,e.values);va(wa(t)&&wa(e),"The `dropNaNPairwise` only works on arrays, Series, and DataFrames!"),va(Ty(Ta(t),Ta(e)),"The two arrays, Series, and/or DataFrames passed into the `dropNaNPairwise` must have the same shape!");let n=[],r=[];for(let s=0;s<t.length;s++)try{let[i,o]=gt(t[s],e[s]);n.push(i),r.push(o)}catch{xa(t[s])&&xa(e[s])&&(n.push(t[s]),r.push(e[s]))}return[n,r]}Oa.exports=gt});var Ia=c((hx,Fa)=>{var Oy=Dn();function Dy(t){return Oy(t)}Fa.exports=Dy});var Ea=c((mx,Aa)=>{var Fy=g(),Iy=v();function Ay(t){try{return Fy(t)?Math.exp(t):NaN}catch{return NaN}}Aa.exports=Iy(Ay)});var ka=c((dx,ja)=>{var Ey=v();function Ma(t){try{return t!==parseInt(t)?NaN:t<=1?1:t*Ma(t-1)}catch{return NaN}}ja.exports=Ey(Ma)});var Ua=c((px,Ra)=>{var My=m(),jy=T(),Ca=d(),ky=y(),Cy=A(),za=Y(),zy=q();function Fn(t,e){if(ky(t))return Fn(jy(t.values),e);if(zy(t))return Fn(t.values,e);if(My(za(t)||Ca(t),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `find` function!"),!Cy(e)){let s=e;e=i=>i===s}function n(s,i,o){if(o=o||[],o.indexOf(s)>-1)return null;if(za(s)){o.push(s);let u=Object.keys(s);for(let a=0;a<u.length;a++){let l=u[a],f=s[l];if(i(f))return f;let h=n(f,i,o);if(h)return h}}else if(Ca(s)){o.push(s);for(let u=0;u<s.length;u++){let a=s[u];if(i(a))return a;let l=n(a,i,o);if(l)return l}}else if(i(s))return s;return null}function r(s){try{return e(s)}catch{return!1}}return n(t,r)}Ra.exports=Fn});var Ja=c((gx,Va)=>{var Ry=m(),Uy=T(),Pa=d(),Py=y(),By=A(),Ba=Y(),Vy=q();function In(t,e){if(Py(t))return In(Uy(t.values),e);if(Vy(t))return In(t.values,e);if(Ry(Ba(t)||Pa(t),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `findAll` function!"),!By(e)){let i=e;e=o=>o===i}function n(i,o,u){if(u=u||[],u.indexOf(i)>-1)return null;if(Ba(i)){u.push(i);let a=Object.keys(i),l=[];for(let f=0;f<a.length;f++){let h=a[f],p=i[h],b=!1;o(p)&&(l.push(p),b=!0);let S=n(p,o,u);S&&S.length>0&&S.slice(b?1:0).forEach(O=>l.push(O))}return l}else if(Pa(i)){u.push(i);let a=[];for(let l=0;l<i.length;l++){let f=i[l],h=!1;o(f)&&(a.push(f),h=!0);let p=n(f,o,u);p&&p.length>0&&p.slice(h?1:0).forEach(b=>a.push(b))}return a}else if(o(i))return[i];return null}function r(i){try{return e(i)}catch{return!1}}let s=n(t,r);return s&&s.length>0?s:null}Va.exports=In});var $a=c((qx,Ya)=>{var Jy=g(),Yy=v();function $y(t){try{if(t==="Infinity")return 1/0;if(t==="-Infinity")return-1/0;let e=JSON.parse(t);return Jy(e)?e:NaN}catch{return NaN}}Ya.exports=Yy($y)});var La=c((yx,Ga)=>{var Gy=g(),Ly=v();function Wy(t){try{return Gy(t)?Math.floor(t):NaN}catch{return NaN}}Ga.exports=Ly(Wy)});var An=c((bx,Wa)=>{var Ky=g(),Hy=Oe(),Xy=Ke();function Qy(t){Ky(t)&&(t=[t]);let e=[],n=Hy(t);for(let r=0;r<n;r++)e.push(0);return Xy(e,t)}Wa.exports=Qy});var Ha=c((Nx,Ka)=>{var qt=m(),Zy=g(),e1=N(),t1=An();function n1(t){qt(!e1(t),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),qt(Zy(t),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),qt(parseInt(t)===t,"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),qt(t>0,"You must pass an integer greater than 0 (representing the size) into the `identity` function!");let e=t1([t,t]);for(let n=0;n<t;n++)e[n][n]=1;return e}Ka.exports=n1});var Qa=c((vx,Xa)=>{Xa.exports=["true","false","yes","no"]});var ec=c((wx,Za)=>{var r1=ke(),s1=m(),i1=Qa(),o1=dn(),u1=ve(),a1=T(),En=d(),c1=y(),l1=g(),f1=q(),h1=E(),m1=fn();function yt(t){if(c1(t)){let s=t.copy(),i=yt(t.values);return s.values=i.values,{type:i.type,values:s}}if(f1(t)){let s=t.copy(),i=yt(t.values);return s.values=i.values,{type:i.type,values:s}}if(t instanceof Date)return{type:"date",value:t};if(!En(t)){let s=yt([t]);return s.value=s.values[0],delete s.values,s}s1(En(t),"The `inferType` function only works on arrays, Series, and DataFrames!");let e=a1(t).map(s=>{if(s===void 0)return"null";if(s instanceof Date)return"date";h1(s)||(s=JSON.stringify(s));let o=s.toLowerCase().trim();if(m1.indexOf(o)>-1)return"null";if(i1.indexOf(o)>-1)return"boolean";try{let u=JSON.parse(s);return l1(u)?"number":typeof u=="object"?En(u)?"string":"object":"string"}catch{return new Date(s).toString()!=="Invalid Date"?"date":"string"}}),r=u1(e).sort((s,i)=>i.count-s.count)[0].item;return{type:r,values:r1(t,s=>o1(s,r))}}Za.exports=yt});var nc=c((Sx,tc)=>{var d1=g(),p1=v();function g1(t){try{let e=JSON.parse(t);return d1(e)?parseInt(e):NaN}catch{return NaN}}tc.exports=p1(g1)});var sc=c((xx,rc)=>{var q1=m(),y1=d(),b1=y(),N1=R(),v1=q(),Mn=z();function w1(){let t=Object.values(arguments).map(n=>b1(n)||v1(n)?Mn(n.values):(q1(y1(n),"The `intersect` function only works on arrays, Series, and DataFrames!"),Mn(n)));return Mn(t).filter(n=>t.every(r=>r.findIndex(s=>N1(s,n))>-1))}rc.exports=w1});var ac=c((_x,uc)=>{var ic=st(),Q=m(),S1=On(),x1=T(),_1=d(),T1=y(),jn=g(),oc=fe(),O1=x();function bt(t){if(T1(t)){let n=t.copy();return n.values=bt(n.values),n}Q(_1(t),"The `inverse` function only works on square 2-dimensional arrays or DataFrames!"),x1(t).forEach(n=>Q(jn(n),"The array passed into the `inverse` function must contain only numbers!"));let e=O1(t);if(Q(e.length===2,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),Q(e[0]===e[1],"The array passed into the `inverse` function must be exactly two-dimensional and square!"),Q(e[0]>=0,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),e[0]===0)return t;if(e[0]===1)return Q(t[0][0]!==0,"This matrix cannot be inverted!"),1/t[0][0];if(e[0]===2){let n=t[0][0],r=t[0][1],s=t[1][0],i=t[1][1],o=n*i-r*s;Q(o!==0,"This matrix cannot be inverted!");let u=[[i,-r],[-s,n]];return oc(u,1/o)}else if(e[0]>1){let n=(r,s)=>jn(r)||jn(s)?oc(r,s):S1(r,s);for(let r=1;r<e[0]-1;r++)try{let s=t.slice(0,r).map(O=>O.slice(0,r)),i=t.slice(0,r).map(O=>O.slice(r,e[0])),o=t.slice(r,e[0]).map(O=>O.slice(0,r)),u=t.slice(r,e[0]).map(O=>O.slice(r,e[0])),a=bt(s),l=bt(ic(u,n(-1,n(n(o,a),i)))),f=ic(a,n(n(n(n(a,i),l),o),a)),h=n(-1,n(n(a,i),l)),p=n(-1,n(n(l,o),a)),b=l;return f.map((O,B)=>O.concat(h[B])).concat(p.map((O,B)=>O.concat(b[B])))}catch{}Q(!1,"This matrix cannot be inverted!")}}uc.exports=bt});var lc=c((Tx,cc)=>{var kn=g(),D1=v();function F1(t,e,n){try{return kn(t)?kn(e)?kn(n)?n*(e-t)+t:NaN:NaN:NaN}catch{return NaN}}cc.exports=D1(F1)});var mc=c((Ox,hc)=>{var fc=g(),I1=N(),A1=v();function E1(t,e){try{return e=I1(e)?Math.E:e,fc(t)?fc(e)?Math.log(t)/Math.log(e):NaN:NaN}catch{return NaN}}hc.exports=A1(E1)});var gc=c((Dx,pc)=>{var M1=m(),j1=T(),k1=d(),C1=y(),z1=q(),R1=G();function dc(t){if(C1(t)||z1(t))return dc(t.values);M1(k1(t),"The `median` function only works on arrays, Series, and DataFrames!");try{let e=R1(j1(t));return e.length===0?NaN:e.length%2===0?(e[e.length/2-1]+e[e.length/2])/2:e[parseInt(e.length/2)]}catch{return NaN}}pc.exports=dc});var bc=c((Fx,yc)=>{var qc=g(),U1=v();function P1(t,e){try{return qc(t)?qc(e)?t%e:NaN:NaN}catch{return NaN}}yc.exports=U1(P1)});var Sc=c((Ix,wc)=>{var B1=m(),V1=ve(),J1=T(),Y1=d(),$1=y(),G1=q(),L1=z(),Nc=G();function vc(t){if($1(t)||G1(t))return vc(t.values);B1(Y1(t),"The `mode` function only works on arrays, Series, and DataFrames!");try{if(t.length===0)return NaN;let e=J1(t);if(e.length===0)return NaN;let n={},r=L1(e);r.forEach(u=>{n[u]=V1(e,u)});let s=Nc(r,(u,a)=>n[a]-n[u]),i=s[0];return Nc(s.filter(u=>n[u]===n[i]))}catch{return NaN}}wc.exports=vc});var Oc=c((Ax,Tc)=>{var{random:xc}=ue(),W1=ke(),K1=N(),H1=$();function _c(){let t=xc(),e=xc();return Math.sqrt(-2*Math.log(t))*Math.cos(2*Math.PI*e)}function X1(t){return K1(t)?_c():W1(H1(t),_c)}Tc.exports=X1});var Fc=c((Ex,Dc)=>{var Q1=ke(),Z1=$();function eb(t){return Q1(Z1(t),()=>1)}Dc.exports=eb});var Ac=c((Mx,Ic)=>{var Cn=m(),tb=T(),nb=d(),rb=y(),sb=g(),ib=q(),ob=N();function Nt(t,e){if(rb(t)||ib(t))return Nt(t.values,e);if(Cn(nb(t),"The `permutations` function only works on arrays, Series, and DataFrames!"),ob(e)&&(e=t.length),Cn(sb(e),"`r` must be a whole number!"),t=tb(t),e>t.length)return Nt(t);if(e<=0)return[[]];if(Cn(e===parseInt(e),"`r` must be a whole number!"),t.length<2)return t;let n=[];return t.forEach((r,s)=>{let i=t.slice(0,s),o=t.slice(s+1),u=i.concat(o);Nt(u,e-1).forEach(l=>{n.push([r].concat(l))})}),n}Ic.exports=Nt});var Mc=c((jx,Ec)=>{var{DataFrame:ub,Series:ab}=Me(),cb=d(),lb=y(),fb=we(),hb=q(),mb=x();function db(){Object.keys(arguments).forEach(t=>{let e=arguments[t];if(cb(e))if(fb(e))console.log(e);else{let n=mb(e);n.length===1?new ab(e).print():n.length==2?new ub(e).print():console.log(e)}else lb(e)||hb(e)?e.print():console.log(e)})}Ec.exports=db});var Cc=c((kx,kc)=>{var pb=d(),gb=g(),jc=N(),qb=le(),yb=it(),bb=v(),Nb=bb(function(t,e,n,r,s){try{return[t,e,n,r,s].every(i=>gb(i))?n-e===0?NaN:(s-r)*(t-e)/(n-e)+r:NaN}catch{return NaN}});function vb(t,e,n,r,s){return pb(t)&&jc(r)&&jc(s)&&(r=e,s=n,e=yb(t),n=qb(t)),Nb(t,e,n,r,s)}kc.exports=vb});var Rc=c((Cx,zc)=>{var wb=g(),Sb=v();function xb(t){try{return wb(t)?Math.round(t):NaN}catch{return NaN}}zc.exports=Sb(xb)});var Pc=c((zx,Uc)=>{var _b=g(),Tb=v();function Ob(t){try{return _b(t)?t<0?-1:t>0?1:0:NaN}catch{return NaN}}Uc.exports=Tb(Ob)});var Vc=c((Rx,Bc)=>{var Db=g(),Fb=v();function Ib(t){try{return Db(t)?Math.sin(t):NaN}catch{return NaN}}Bc.exports=Fb(Ib)});var Yc=c((Ux,Jc)=>{var Ab=ct();function Eb(t){return Ab(t)}Jc.exports=Eb});var Gc=c((Px,$c)=>{var Mb=g(),jb=v();function kb(t){try{return Mb(t)?Math.tan(t):NaN}catch{return NaN}}$c.exports=jb(kb)});var vt=c((Bx,Kc)=>{var Lc=m(),Wc=A();function Cb(t,e){Lc(Wc(t),"`fn` must be a function!");let n=new Date;return e?t(...e):t(),new Date-n}async function zb(t,e){Lc(Wc(t),"`fn` must be a function!");let n=new Date;return e?await t(...e):await t(),new Date-n}Kc.exports={timeSync:Cb,timeAsync:zb}});var Xc=c((Vx,Hc)=>{var Rb=d(),Ub=y(),Pb=q(),Bb=z();function Vb(){return Bb([...arguments].map(t=>Rb(t)?t:Ub(t)||Pb(t)?t.values:[t]))}Hc.exports=Vb});var Zc=c((Jx,Qc)=>{var Jb=m(),Yb=d(),$b=y(),Gb=q(),Lb=N(),Wb=le(),Kb=j();function Hb(){let t=[],e=Object.values(arguments).map(n=>(($b(n)||Gb(n))&&(n=n.values),Jb(Yb(n),"The `zip` function only works on arrays, Series, and DataFrames!"),n));return Kb(0,Wb(e.map(n=>n.length))).forEach(n=>{let r=[];e.forEach(s=>{let i=s[n];r.push(Lb(i)?void 0:i)}),t.push(r)}),t}Qc.exports=Hb});var w=c((Yx,zn)=>{var{DataFrame:Xb,Series:Qb}=Me(),he={abs:rt(),add:st(),apply:ke(),arccos:Yo(),arcsin:Go(),arctan:Wo(),argmax:Ho(),argmin:eu(),assert:m(),cast:dn(),ceil:iu(),chop:au(),clamp:lu(),combinations:hu(),copy:C(),correl:Eu(),cos:ju(),count:ve(),covariance:bn(),DataFrame:Xb,dataTypes:Cu(),decycle:Rt(),diff:Vu(),distance:na(),divide:sa(),dot:On(),dropMissing:Dn(),dropMissingPairwise:Na(),dropNaN:Gt(),dropNaNPairwise:Da(),dropUndefined:Ia(),exp:Ea(),factorial:ka(),find:Ua(),findAll:Ja(),flatten:T(),float:$a(),floor:La(),identity:Ha(),indexOf:be(),inferType:ec(),int:nc(),intersect:sc(),inverse:ac(),isArray:d(),isBoolean:Xe(),isDataFrame:y(),isEqual:R(),isFunction:A(),isJagged:we(),isNested:Be(),isNumber:g(),isObject:Y(),isSeries:q(),isString:E(),isUndefined:N(),lerp:lc(),log:mc(),MathError:se(),max:le(),mean:ot(),median:gc(),min:it(),mod:bc(),mode:Sc(),multiply:Sn(),ndarray:$(),normal:Oc(),ones:Fc(),permutations:Ac(),pow:lt(),print:Mc(),product:Oe(),random:ue().random,range:j(),remap:Cc(),reshape:Ke(),reverse:Se(),round:Rc(),scale:fe(),seed:ue().seed,Series:Qb,set:z(),shape:x(),shuffle:He(),sign:Pc(),sin:Vc(),sort:G(),sqrt:at(),std:ct(),stdev:Yc(),subtract:xn(),sum:ft(),tan:Gc(),time:vt().timeSync,timeSync:vt().timeSync,timeAsync:vt().timeAsync,transpose:ee(),union:Xc(),variance:Nn(),vectorize:v(),zeros:An(),zip:Zc(),dump:function(){let t=typeof global<"u"?global:window;if(!t)throw new he.MathError("Cannot dump functions into global scope because neither `global` nor `window` exist in the current context!");Object.keys(he).forEach(e=>{try{Object.defineProperty(t,e,{configurable:!1,enumerable:!0,writable:!1,value:he[e]})}catch{t[e]=he[e]}})}};typeof zn<"u"&&(zn.exports=he);typeof window<"u"&&(window.JSMathTools=he)});var P=c(($x,el)=>{el.exports={shouldIgnoreNaNValues:!0}});var me=c((Gx,nl)=>{var{assert:Zb,flatten:eN,isArray:tN,isDataFrame:nN,isNumber:rN,isSeries:sN}=w();function tl(t){if(nN(t)||sN(t))return tl(t.values);Zb(tN(t),"The `containsOnlyNumbers` function only works on arrays, Series, and DataFrames!");let e=eN(t);for(let n=0;n<e.length;n++)if(!rN(e[n]))return!1;return!0}nl.exports=tl});var Un=c((Lx,rl)=>{var{dropMissing:iN,flatten:oN,isArray:uN,isDataFrame:aN,isSeries:cN}=w();function Rn(t){return typeof t=="number"?t===0||t===1:aN(t)||cN(t)?Rn(t.values):uN(t)?t.length===0?!1:iN(oN(t)).every(n=>Rn(n)):!1}rl.exports=Rn});var Pn=c((Wx,hl)=>{var{abs:sl,apply:il,assert:ol,clamp:lN,copy:fN,divide:hN,dropNaN:mN,flatten:dN,isArray:pN,isDataFrame:gN,isNumber:ul,isSeries:qN,max:al,median:cl,min:yN,sort:bN,subtract:ll}=w(),NN=P(),vN=me(),wN=Un();function fl(t,e){if(gN(t)||qN(t)){let a=t.copy();return a._values=fl(a._values,e),a}if(ol(pN(t),"The `clipOutliers` function only works on arrays, Series, and DataFrames!"),e=e||5,ol(ul(e),"Any `maxScore` value passed into the `clipOutliers` function must be a number!"),!NN.shouldIgnoreNaNValues&&!vN(t))return il(t,()=>NaN);let n=dN(t),r=mN(n);if(wN(r)||r.length===0)return t;let s=cl(r),i=cl(sl(ll(r,s))),o=!1;if(i===0){let a=bN(fN(r)),l=a.filter(b=>b<s),f=a.filter(b=>b>s),h=s,p=s;if(l.length>0&&(h=al(l)),f.length>0&&(p=yN(f)),i=(p-h)/2,i===0)return t;o=(s-h)/i>e||(p-s)/i>e}return al(hN(sl(ll(r,s)),i))>e||o?il(t,a=>ul(a)?lN(a,s-e*i,s+e*i):a):t}hl.exports=fl});var Vn=c((Kx,Nl)=>{var{assert:ml,dropNaN:dl,isArray:pl,isSeries:gl,mean:ql,shape:yl,variance:bl}=w(),SN=P();function Bn(t,e){if(gl(t))return Bn(t.values,e);if(gl(e))return Bn(t,e.values);ml(pl(t)&&pl(e)&&yl(t).length===1&&yl(e).length===1,"The `cohensd` function only works on 1-dimensional arrays and Series!"),ml(t.length===e.length,"Two arrays or Series passed into the `cohensd` function must have the same length!"),SN.shouldIgnoreNaNValues&&(t=dl(t),e=dl(e));try{let n=ql(t),r=ql(e),s=Math.sqrt((bl(t)+bl(e))/2);return(n-r)/s}catch{return NaN}}Nl.exports=Bn});var xl=c((Hx,Sl)=>{var{assert:vl,DataFrame:xN,isArray:_N,isSeries:TN,shape:ON,zeros:DN}=w();function wl(t){if(TN(t)){let r=new xN(wl(t.values));return r.index=t.index.slice(),r.columns=t.index.slice(),r}vl(_N(t),"The `diagonalize` function only works on 1-dimensional arrays and Series!");let e=ON(t);vl(e.length===1,"The `diagonalize` function only works on 1-dimensional arrays and Series!");let n=DN([e[0],e[0]]);return t.forEach((r,s)=>n[s][s]=r),n}Sl.exports=wl});var Gn=c((Xx,Dl)=>{var{assert:Jn,clamp:FN,correl:_l,DataFrame:wt,dropNaNPairwise:IN,isArray:Tl,isDataFrame:St,isJagged:Ol,isUndefined:AN,ndarray:EN}=w(),MN=P();function Yn(t){let e="@jrc03c/js-data-science-helpers/get-correlation-matrix";return Object.defineProperty(t,e,{configurable:!1,enumerable:!1,writable:!1,value:Symbol.for(e)}),t}function $n(t,e){if(AN(e)&&(e=t),St(t)){let r=new wt($n(t.values,e));return r.index=t.columns.slice(),r.columns=St(e)?e.columns.slice():new wt(e).columns.slice(),Yn(r)}if(St(e)){let r=new wt($n(t,e.values));return r.index=St(t)?t.columns.slice():new wt(t).columns.slice(),r.columns=e.columns.slice(),Yn(r)}Jn(Tl(t)&&Tl(e),"The `getCorrelationMatrix` function only works on 2-dimensional arrays and DataFrames!"),Jn(!Ol(t)&&!Ol(e),"The `getCorrelationMatrix` function only works on non-jagged 2-dimensional arrays and DataFrames!"),Jn(t.length===e.length,'The dimensions of the matrices you passed into the `getCorrelationMatrix` function aren\'t compatible! ([shape(a).join(", ")] vs. [shape(b).join(", ")]) The function expects that you\'ll be comparing the columns of two matrices where the columns are all of the same length, so please make sure that the matrices are oriented accordingly.');let n=EN([t[0].length,e[0].length]);for(let r=0;r<t[0].length;r++){let s=t.map(i=>i[r]);for(let i=0;i<e[0].length;i++){let o=e.map(u=>u[i]);MN.shouldIgnoreNaNValues?n[r][i]=_l(...IN(s,o)):n[r][i]=_l(s,o)}}return Yn(FN(n,-1,1))}Dl.exports=$n});var Ln=c((Qx,Fl)=>{function jN(t){try{let e="@jrc03c/js-data-science-helpers/get-correlation-matrix";return t[e]===Symbol.for(e)}catch{return!1}}Fl.exports=jN});var Ml=c((Zx,El)=>{var{DataFrame:Wn,isArray:kN,isDataFrame:xt,isNumber:Il,MathError:CN,sort:zN}=w(),Al=Gn(),RN=Ln();function UN(t,e,n){n=Object.values(arguments).find(i=>Il(i))||1-1e-5;let r=(()=>{let i=Object.values(arguments).filter(o=>kN(o)||xt(o));if(i.length===1){let o=i[0];if(RN(o))return xt(o)?o:new Wn(o);{let u=Al(o,null);return xt(u)?u:new Wn(u)}}if(i.length===2){let o=Al(i[0],i[1]);return xt(o)?o:new Wn(o)}throw new CN("You must pass 1 or 2 2-dimensional arrays or DataFrames into the `getHighlyCorrelatedColumns` function!")})(),s={};return r.values.forEach((i,o)=>{i.forEach((u,a)=>{if(Il(u)&&u>n){let l=r.index[o],f=r.columns[a];s[l]||(s[l]=[]),s[l].indexOf(f)<0&&s[l].push(f),s[f]||(s[f]=[]),s[f].indexOf(l)<0&&s[f].push(l)}})}),Object.keys(s).forEach(i=>{s[i]=zN(s[i])}),s}El.exports=UN});var Kn=c((e_,kl)=>{var{dropNaN:PN,isArray:BN,isDataFrame:VN,isNumber:JN,isSeries:YN,pow:$N,sqrt:GN,sum:LN}=w(),WN=P();function jl(t){return VN(t)||YN(t)?jl(t.values):JN(t)?Math.abs(t):BN(t)?(WN.shouldIgnoreNaNValues&&(t=PN(t)),GN(LN($N(t,2)))):NaN}kl.exports=jl});var Hn=c((t_,Rl)=>{var{assert:Cl,DataFrame:KN,isArray:HN,isSeries:XN,isString:QN,isUndefined:ZN,set:ev,shape:tv,sort:nv}=w();function zl(){if(arguments.length===1&&XN(arguments[0])){let{name:i,values:o}=arguments[0],u=zl(i,o),a=new KN(u);return a.index=arguments[0].index.slice(),a}let[t,e]=arguments;Cl(QN(t),"When passing two arguments into the `getOneHotEncodings` function, the first argument must be a string representing the name of the variable being encoded!"),Cl(HN(e)&&tv(e).length===1,"When passing two arguments into the `getOneHotEncodings` function, the second argument must be a 1-dimensional array!");let n={},r=t+"_"+e[0];return nv(ev(e)).filter(i=>!ZN(i)).map(i=>t+"_"+i).filter(i=>i!==r).forEach(i=>{n[i]=e.map(o=>i===t+"_"+o?1:0)}),n}Rl.exports=zl});var Pl=c((n_,Ul)=>{var{count:rv}=w();function sv(t){return rv(t).map(n=>(n.percentage=n.count/t.length,n))}Ul.exports=sv});var Bl=c((r_,iv)=>{iv.exports=[.5,.49601,.49202,.48803,.48405,.48006,.47608,.4721,.46812,.46414,.46017,.4562,.45224,.44828,.44433,.44038,.4364,.43251,.42858,.42465,.42074,.41683,.41294,.40905,.40517,.40129,.39743,.39358,.38974,.38591,.38209,.37828,.37448,.3707,.36693,.36317,.35942,.35569,.35197,.34827,.34458,.3409,.33724,.3336,.32997,.32636,.32276,.31918,.31561,.31207,.30854,.30503,.30153,.29806,.2946,.29116,.28774,.28434,.28096,.2776,.27425,.27093,.26763,.26435,.26109,.25785,.25463,.25143,.24825,.2451,.24196,.23885,.23576,.2327,.22965,.22663,.22363,.22065,.2177,.21476,.21186,.20897,.20611,.20327,.20045,.19766,.19489,.19215,.18943,.18673,.18406,.18141,.17879,.17619,.17361,.17106,.16853,.16602,.16354,.16109,.15866,.15625,.15386,.15151,.14917,.14686,.14457,.14231,.14007,.13786,.13567,.1335,.13136,.12924,.12714,.12507,.12302,.121,.119,.11702,.11507,.11314,.11123,.10935,.10749,.10565,.10383,.10204,.10027,.09853,.0968,.0951,.09342,.09176,.09012,.08851,.08692,.08534,.08379,.08226,.08076,.07927,.0778,.07636,.07493,.07353,.07215,.07078,.06944,.06811,.06681,.06552,.06426,.06301,.06178,.06057,.05938,.05821,.05705,.05592,.0548,.0537,.05262,.05155,.0505,.04947,.04846,.04746,.04648,.04551,.04457,.04363,.04272,.04182,.04093,.04006,.0392,.03836,.03754,.03673,.03593,.03515,.03438,.03362,.03288,.03216,.03144,.03074,.03005,.02938,.02872,.02807,.02743,.0268,.02619,.02559,.025,.02442,.02385,.0233,.02275,.02222,.02169,.02118,.02068,.02018,.0197,.01923,.01876,.01831,.01786,.01743,.017,.01659,.01618,.01578,.01539,.015,.01463,.01426,.0139,.01355,.01321,.01287,.01255,.01222,.01191,.0116,.0113,.01101,.01072,.01044,.01017,.0099,.00964,.00939,.00914,.00889,.00866,.00842,.0082,.00798,.00776,.00755,.00734,.00714,.00695,.00676,.00657,.00639,.00621,.00604,.00587,.0057,.00554,.00539,.00523,.00508,.00494,.0048,.00466,.00453,.0044,.00427,.00415,.00402,.00391,.00379,.00368,.00357,.00347,.00336,.00326,.00317,.00307,.00298,.00289,.0028,.00272,.00264,.00256,.00248,.0024,.00233,.00226,.00219,.00212,.00205,.00199,.00193,.00187,.00181,.00175,.00169,.00164,.00159,.00154,.00149,.00144,.00139,.00135,.00131,.00126,.00122,.00118,.00114,.00111,.00107,.00104,.001,97e-5,94e-5,9e-4,87e-5,84e-5,82e-5,79e-5,76e-5,74e-5,71e-5,69e-5,66e-5,64e-5,62e-5,6e-4,58e-5,56e-5,54e-5,52e-5,5e-4,48e-5,47e-5,45e-5,43e-5,42e-5,4e-4,39e-5,38e-5,36e-5,35e-5,34e-5,32e-5,31e-5,3e-4,29e-5,28e-5,27e-5,26e-5,25e-5,24e-5,23e-5,22e-5,22e-5,21e-5,2e-4,19e-5,19e-5,18e-5,17e-5,17e-5,16e-5,15e-5,15e-5,14e-5,14e-5,13e-5,13e-5,12e-5,12e-5,11e-5,11e-5,1e-4,1e-4,1e-4,9e-5,9e-5,8e-5,8e-5,8e-5,8e-5,7e-5,7e-5,7e-5,6e-5,6e-5,6e-5,6e-5,5e-5,5e-5,5e-5,5e-5,5e-5,4e-5,4e-5,4e-5,4e-5,4e-5,4e-5,3e-5,3e-5,3e-5,3e-5,3e-5,3e-5,3e-5,3e-5,2e-5,2e-5,2e-5,2e-5]});var Qn=c((s_,Hl)=>{var{abs:Vl,assert:ov,dropNaNPairwise:uv,flatten:_t,isArray:Jl,isDataFrame:Yl,isEqual:av,isSeries:$l,mean:Gl,remap:cv,round:lv,shape:Ll,sqrt:fv,std:Wl}=w(),hv=P(),Kl=Bl();function mv(t){return Vl(t)>4.1?0:Kl[lv(cv(Vl(t),0,4.1,0,Kl.length))]}function Xn(t,e){if(Yl(t)||$l(t))return Xn(t.values,e);if(Yl(e)||$l(e))return Xn(t,e.values);ov(Jl(t)&&Jl(e)&&av(Ll(t),Ll(e)),"You must pass two identically-shaped arrays, Series, or DataFrames into the `pValue` function!");let[n,r]=hv.shouldIgnoreNaNValues?uv(_t(t),_t(e)):[_t(t),_t(e)];if(n.length===0||r.length===0)return NaN;let s=Gl(n),i=Gl(r),o=Wl(n),u=Wl(r),a=n.length,l=r.length,f=(s-i)/fv(o*o/a+u*u/l);return 2*mv(f)}Hl.exports=Xn});var tf=c((i_,ef)=>{var{assert:Zn,clamp:dv,DataFrame:Tt,dropNaNPairwise:pv,isArray:Xl,isDataFrame:Ot,isJagged:Ql,isUndefined:gv,ndarray:qv}=w(),yv=P(),Zl=Qn();function er(t){let e="@jrc03c/js-data-science-helpers/get-p-value-matrix";return Object.defineProperty(t,e,{configurable:!1,enumerable:!1,writable:!1,value:Symbol.for(e)}),t}function tr(t,e){if(gv(e)&&(e=t),Ot(t)){let r=new Tt(tr(t.values,e));return r.index=t.columns.slice(),r.columns=Ot(e)?e.columns.slice():new Tt(e).columns.slice(),er(r)}if(Ot(e)){let r=new Tt(tr(t,e.values));return r.index=Ot(t)?t.columns.slice():new Tt(t).columns.slice(),r.columns=e.columns.slice(),er(r)}Zn(Xl(t)&&Xl(e),"The `getPValueMatrix` function only works on 2-dimensional arrays and DataFrames!"),Zn(!Ql(t)&&!Ql(e),"The `getPValueMatrix` function only works on non-jagged 2-dimensional arrays and DataFrames!"),Zn(t.length===e.length,'The dimensions of the matrices you passed into the `getPValueMatrix` function aren\'t compatible! ([shape(a).join(", ")] vs. [shape(b).join(", ")]) The function expects that you\'ll be comparing the columns of two matrices where the columns are all of the same length, so please make sure that the matrices are oriented accordingly.');let n=qv([t[0].length,e[0].length]);for(let r=0;r<t[0].length;r++){let s=t.map(i=>i[r]);for(let i=0;i<e[0].length;i++){let o=e.map(u=>u[i]);yv.shouldIgnoreNaNValues?n[r][i]=Zl(...pv(s,o)):n[r][i]=Zl(s,o)}}return er(dv(n,0,1))}ef.exports=tr});var uf=c((o_,of)=>{var{assert:Dt,intersect:bv,isDataFrame:nf,isSeries:rf,isUndefined:sf}=w(),de=class{constructor(e){let n=this;Dt(sf(e)||e===de.DROP_NAN_MODE||e===de.DROP_MISSING_MODE,"The `mode` value passed into the `IndexMatcher` constructor must be undefined or one of [IndexMatcher.DROP_NAN_MODE, IndexMatcher.DROP_MISSING_MODE]! (By default, the mode is `Indexer.DROP_MISSING_MODE`.)"),n.mode=sf(e)?de.DROP_MISSING_MODE:e,n.index=null}fit(){let e=this,n=[];return Object.values(arguments).forEach(r=>{Dt(nf(r)||rf(r),"The `IndexMatcher` only works on Series and DataFrames! To drop NaN values in a pair-wise fashion from regular arrays, use the `dropNaNPairwise` function from the @jrc03c/js-math-tools library."),e.mode===de.DROP_MISSING_MODE?n.push(r.dropMissing().index):n.push(r.dropNaN().index)}),e.index=bv(...n),e}transform(){let e=this;Dt(!!e.index,"The IndexMatcher hasn't been fitted yet! Please call the `fit` method before calling the `transform` method.");let n=Object.values(arguments).map(r=>(Dt(nf(r)||rf(r),"The `IndexMatcher` only works on Series and DataFrames! To drop NaN values in a pair-wise fashion from regular arrays, use the `dropNaNPairwise` function from the @jrc03c/js-math-tools library."),r.get(e.index,null)));return n.length===1?n[0]:n}fitAndTransform(){return this.fit(...arguments).transform(...arguments)}},Ce=de;jt(Ce,"DROP_NAN_MODE","DROP_NAN_MODE"),jt(Ce,"DROP_MISSING_MODE","DROP_MISSING_MODE");of.exports=Ce});var rr=c((u_,hf)=>{var{assert:nr,isArray:Nv,isBoolean:vv,isDataFrame:af,isSeries:cf,int:wv,isNumber:Sv,isUndefined:lf,range:ff,set:xv,shape:_v,shuffle:Tv}=w();hf.exports=function(){let e=Array.from(arguments),n=e.find(b=>vv(b)),r=lf(n)?!0:n,s=e.find(b=>Sv(b)),i=lf(s)?.1:s;nr(i>0&&i<1,"`testSize` must be a number between 0 and 1 (exclusive on both ends)!");let o=e.filter(b=>Nv(b)||af(b)||cf(b));nr(o.length>0,"You must pass at least one dataset into the `trainTestSplit` function!");let u=o.map(b=>_v(b)[0]);nr(xv(u).length===1,`All datasets passed into the \`trainTestSplit\` function must be the same length at their shallowest dimension! The lengths of your datasets, though, are: ${u.join(", ")}`);let a=[],l=r?Tv(ff(0,u[0])):ff(0,u[0]),f=wv((1-i)*l.length),h=l.slice(0,f),p=l.slice(f);return o.forEach(b=>{if(af(b))a.push(b.get(h,null)),a.push(b.get(p,null));else if(cf(b))a.push(b.get(h)),a.push(b.get(p));else{let S=[],O=[];b.forEach((B,F)=>{h.indexOf(F)>-1?S.push(B):O.push(B)}),a.push(S),a.push(O)}}),a}});var It=c((a_,yf)=>{var{add:Ov,argmin:Dv,assert:Fv,flatten:mf,isArray:Iv,isDataFrame:df,isEqual:Av,int:Ev,isNumber:Mv,isSeries:pf,normal:sr,pow:jv,random:kv,range:Cv,scale:zv,shape:Ft,subtract:Rv,sum:Uv}=w(),Pv=rr();function ir(t,e){(df(t)||pf(t))&&(t=t.values),(df(e)||pf(e))&&(e=e.values),Fv(Av(Ft(t),Ft(e)),"`yPred` and `yTrue` must have the same shape!");let n=mf(t),r=mf(e),s=0;return n.forEach((i,o)=>{i===r[o]&&s++}),s/n.length}function Bv(t){test(`tests that the \`${t.name}\` model works correctly`,()=>{let e=sr([5,10]).map(h=>h.map(p=>p*100+sr()*100)),n=[],r=Cv(0,500).map(()=>{let h=Ev(kv()*e.length),p=e[h];return n.push(h),Ov(p,zv(5,sr(Ft(p))))}),[s,i,o,u]=Pv(r,n),a=new t({k:e.length});a.fit(s),a.centroids=gf(e,a.centroids);let l=a.predict(s),f=a.predict(i);expect(ir(o,l)).toBeGreaterThan(.95),expect(ir(u,f)).toBeGreaterThan(.95)})}function Vv(t){return Iv(t)&&Ft(t).length===2}function Jv(t){return Mv(t)&&parseInt(t)===t&&t>=0}function gf(t,e){return t.map(n=>e[Dv(e.map(r=>qf(n,r)))])}function qf(t,e){return Uv(jv(Rv(t,e),2))}yf.exports={accuracy:ir,createGenericTest:Bv,isMatrix:Vv,isWholeNumber:Jv,orderCentroids:gf,sse:qf}});var ar=c((c_,wf)=>{var{add:bf,argmin:Yv,assert:te,copy:$v,distance:Nf,divide:Gv,isDataFrame:Lv,isFunction:Wv,isUndefined:At,normal:Kv,random:Hv,range:Xv,scale:Qv,shuffle:Zv,zeros:vf}=w(),{isMatrix:ew,isWholeNumber:or,sse:tw}=It(),ur=class{constructor(e){te(typeof e=="object","`config` must be an object! See the documentation for more information about the properties that the `config` object can contain."),te(or(e.k),"`k` must be a whole number!"),te(or(e.maxIterations)||At(e.maxIterations),"`maxIterations` must be a whole number or undefined!"),te(or(e.maxRestarts)||At(e.maxRestarts),"`maxRestarts` must be a whole number or undefined!"),te(typeof e.tolerance=="number"||At(e.tolerance),"`tolerance` must be a number or undefined!");let n=this;n.k=e.k,n.maxRestarts=e.maxRestarts||25,n.maxIterations=e.maxIterations||100,n.tolerance=e.tolerance||1e-4,n.centroids=null,n._fitState=null}initializeCentroids(e){let n=this;return Zv(e).slice(0,n.k)}fitStep(e,n){let r=this;if(te(ew(e),"`x` must be a matrix!"),Lv(e)&&(e=e.values),At(n)||te(Wv(n),"If defined, `progress` must be a function!"),r._fitState){if(r._fitState.isFinished)return r}else{let a=r.initializeCentroids(e);r._fitState={currentRestart:0,currentIteration:0,currentCentroids:a,bestCentroids:a,bestScore:-1/0,isFinished:!1}}let s=r.predict(e,r._fitState.currentCentroids),i=[],o=vf(r.k);e.forEach((a,l)=>{let f=s[l];i[f]||(i[f]=vf(a.length)),i[f]=bf(i[f],a),o[f]++});let u=Xv(0,r.k).map(a=>o[a]===0?bf(r._fitState.currentCentroids[parseInt(Hv()*r._fitState.currentCentroids.length)],Qv(.001,Kv(r._fitState.currentCentroids[0].length))):Gv(i[a],o[a]));if(Nf(r._fitState.currentCentroids,u)<r.tolerance?r._fitState.currentIteration=r.maxIterations-1:r._fitState.currentCentroids=u,n&&n((r._fitState.currentRestart+r._fitState.currentIteration/r.maxIterations)/r.maxRestarts,r),r._fitState.currentIteration++,r._fitState.currentIteration>=r.maxIterations){let a=r.score(e,r._fitState.currentCentroids);if(a>r._fitState.bestScore&&(r._fitState.bestScore=a,r._fitState.bestCentroids=$v(r._fitState.currentCentroids)),r._fitState.currentIteration=0,r._fitState.currentRestart++,r._fitState.currentRestart>=r.maxRestarts)r._fitState.isFinished=!0,r.centroids=r._fitState.bestCentroids,n&&n(1,r);else{let l=r.initializeCentroids(e);r._fitState.currentCentroids=l}}return r}fit(e,n){let r=this;for(r._fitState&&(r._fitState=null);!r._fitState||!r._fitState.isFinished;)r.fitStep(e,n);return r}predict(e,n){if(n=n||this.centroids,!n)throw new Error("No centroids were provided to the `predict` method, and the K-Means model hasn't been fitted yet. Please either pass centroids as a second parameter to the `predict` method or run the `fit` method first!");return e.map(s=>Yv(n.map(i=>Nf(s,i))))}score(e,n){let r=this;if(n=n||r.centroids,!n)throw new Error("No centroids were provided to the `score` method, and the K-Means model hasn't been fitted yet. Please either pass centroids as a second parameter to the `score` method or run the `fit` method first!");let i=r.predict(e,n).map(o=>n[o]);return-tw(e,i)}};wf.exports=ur});var lr=c((l_,_f)=>{var{argmin:nw,distance:Sf,divide:rw,max:sw,random:xf}=w(),iw=ar(),cr=class extends iw{initializeCentroids(e){let n=this,r=[e[parseInt(xf()*e.length)]];for(;r.length<n.k;){let s=e.map(o=>Sf(o,r[nw(r.map(u=>Sf(o,u)))])),i=rw(s,sw(s));r.push(e[i.findIndex(o=>xf()<o)])}return r}};_f.exports=cr});var Df=c((f_,Of)=>{var{assert:J,isArray:ow,isDataFrame:uw,isEqual:aw,isFunction:cw,isUndefined:pe,range:lw,shape:Tf}=w(),{isMatrix:fw,isWholeNumber:fr}=It(),hw=lr(),hr=class{constructor(e){pe(e)&&(e={}),J(typeof e=="object","`config` must be an object! See the documentation for more information about the properties that the `config` object can contain."),pe(e.ks)&&(e.ks=lw(1,16)),J(ow(e.ks),"`ks` must be an array of whole numbers!"),e.ks.forEach(r=>{J(fr(r),"`ks` must be an array of whole numbers!")}),J(fr(e.maxIterations)||pe(e.maxIterations),"`maxIterations` must be a whole number or undefined!"),J(fr(e.maxRestarts)||pe(e.maxRestarts),"`maxRestarts` must be a whole number or undefined!"),J(typeof e.tolerance=="number"||pe(e.tolerance),"`tolerance` must be a number or undefined!");let n=this;n.ks=e.ks,n.maxRestarts=e.maxRestarts||25,n.maxIterations=e.maxIterations||100,n.tolerance=e.tolerance||1e-4,n.scoreStopRatio=e.scoreStopRatio||.85,n.modelClass=e.modelClass||hw,n.fittedModel=null,n._fitState=null}fitStep(e,n){let r=this;if(J(fw(e),"`x` must be a matrix!"),uw(e)&&(e=e.values),pe(n)||J(cw(n),"If defined, `progress` must be a function!"),!r._fitState)r._fitState={isFinished:!1,lastScore:-1/0,currentIndex:0};else if(r._fitState.isFinished)return r;let s=r.ks[r._fitState.currentIndex],i=new r.modelClass({k:s,maxRestarts:10,maxIterations:20});i.fit(e,u=>n?n((r._fitState.currentIndex+u)/(r.ks.length+1)):null);let o=i.score(e);return o/r._fitState.lastScore>r.scoreStopRatio?(r._fitState.isFinished=!0,r._fitState.currentIndex--):(r._fitState.lastScore=o,r._fitState.currentIndex+1>=r.ks.length?r._fitState.isFinished=!0:r._fitState.currentIndex++),r._fitState.isFinished&&(r.fittedModel=new r.modelClass({k:r.ks[r._fitState.currentIndex],maxRestarts:r.maxRestarts,maxIterations:r.maxIterations}),r.fittedModel.fit(e,u=>n?n((r.ks.length+u)/(r.ks.length+1)):null),n&&n(1)),r}fit(e,n){let r=this;for(r._fitState=null;!r._fitState||!r._fitState.isFinished;)r.fitStep(e,n);return r}predict(e,n){return this.fittedModel.predict(e,n)}score(e,n){return this.fittedModel.score(e,n)}get k(){return this.fittedModel.k}set k(e){throw new Error("You can't set the k-value manually! It has to be set automatically via the `fit` method.")}get centroids(){return this.fittedModel.centroids}set centroids(e){let n=this;J(aw(Tf(e),Tf(n.fittedModel.centroids)),"When assigning a new value to the `centroids` property, the new centroids must have the same shape as the old centroids!"),n.fittedModel.centroids=e}};Of.exports=hr});var If=c((h_,Ff)=>{Ff.exports={KMeansMeta:Df(),KMeansNaive:ar(),KMeansPlusPlus:lr(),helpers:It()}});var mr=c((m_,Cf)=>{var{apply:mw,assert:dw,dropNaN:Af,isArray:pw,isDataFrame:gw,isSeries:qw,mean:Ef,std:Mf}=w(),jf=P();function kf(t){if(gw(t)||qw(t)){let r=t.copy();return r.values=kf(r.values),r}dw(pw(t),"The `normalize` function only works on arrays, Series, and DataFrames!");let e=(()=>jf.shouldIgnoreNaNValues?Ef(Af(t)):Ef(t))(),n=(()=>jf.shouldIgnoreNaNValues?Mf(Af(t)):Mf(t))();return n===0?t:mw(t,r=>(r-e)/n)}Cf.exports=kf});var pr=c((d_,Bf)=>{var{assert:ge,dot:zf,isArray:Rf,isSeries:dr,scale:yw,Series:bw,shape:Uf}=w(),Pf=me();function Et(t,e){if(dr(t)){if(dr(e))return new bw(Et(t.values,e.values));{let n=t.copy();return n.values=Et(t.values,e),n}}if(dr(e)){let n=e.copy();return n.values=Et(t,e.values),n}return ge(Rf(t),"`project` only works on vectors!"),ge(Rf(e),"`project` only works on vectors!"),ge(Pf(t),"`project` only works on vectors of numbers!"),ge(Pf(e),"`project` only works on vectors of numbers!"),ge(Uf(t).length===1,"`project` only works on vectors!"),ge(Uf(e).length===1,"`project` only works on vectors!"),yw(zf(e,t)/zf(e,e),e)}Bf.exports=Et});var Gf=c((p_,$f)=>{var{assert:Vf,copy:Nw,DataFrame:vw,divide:ww,isArray:Sw,isDataFrame:xw,isJagged:_w,shape:Tw,subtract:Ow,transpose:Jf}=w(),Dw=me(),Fw=Kn(),Iw=pr();function Yf(t){if(xw(t)){let s=new vw(Yf(t.values));return s.index=t.index.slice(),s.columns=t.columns.slice(),s}Vf(Sw(t)&&!_w(t)&&Tw(t).length===2,"`orthonormalize` only works on matrices!"),Vf(Dw(t),"`orthonormalize` only works on matrices of numbers!");let e=Jf(t),n=[];e.forEach(s=>{let i=Nw(s);n.forEach(o=>{i=Ow(i,Iw(i,o))}),n.push(i)});let r=n.map(s=>ww(s,Fw(s)));return Jf(r)}$f.exports=Yf});var Zf=c((g_,Qf)=>{var{assert:qe,correl:Aw,DataFrame:Lf,dropMissing:Ew,inferType:Wf,isArray:Mw,isDataFrame:jw,isEqual:kw,isFunction:Cw,isJagged:zw,isNumber:ze,isUndefined:Rw,set:Uw,shape:Pw}=w(),Bw=Pn(),Vw=Hn(),Kf=(t,e)=>t.map(n=>n[e]),Hf=t=>ze(t)&&(parseInt(t)===t||t===1/0);function Xf(t,e){e=e||{};let n=ze(e.maxUniqueStrings)?e.maxUniqueStrings:7,r=ze(e.minNonMissingValues)?e.minNonMissingValues:15,s=ze(e.maxCorrelationThreshold)?e.maxCorrelationThreshold:1-1e-5,i=e.progress||null;if(Mw(t))return qe(Pw(t).length===2&&!zw(t),"The `preprocess` function only works on non-jagged 2-dimensional arrays and DataFrames!"),Xf(new Lf(t));qe(jw(t),"You must pass a DataFrame into the `preprocess` function!"),qe(Hf(n),"`maxUniqueStrings` must be a whole number!"),qe(Hf(r),"`minNonMissingValues` must be a whole number!"),qe(ze(s),"`maxCorrelationThreshold` must be a number!"),Rw(i)||qe(Cw(i),"If defined, `progress` must be a function!");let o={},u={},a={},l=t.values;t.columns.forEach((h,p)=>{if(u[h])return;let b=Kf(l,p),S=(()=>{if(o[h])return o[h];{let F=Wf(b);return F.type==="date"&&(F.values=F.values.map(ne=>ne-0)),o[h]=F,F}})();if(S.type==="null"||S.type==="object"){u[h]=!0;return}let O=Ew(S.values);if(O.length<=r){u[h]=!0;return}let B=Uw(O);if(B.length<2){u[h]=!0;return}if(S.type==="string"&&B.length<=n){let F=Vw(h,S.values);Object.keys(F).forEach(ne=>{a[ne]=F[ne]}),u[h]=!0;return}S.type==="number"&&(S.values=Bw(S.values)),t.columns.slice(p+1).forEach((F,ne)=>{if(u[F])return;let Dh=Kf(l,p+ne+1),ye=(()=>{if(o[F])return o[F];{let re=Wf(Dh);return re.type==="date"&&(re.values=re.values.map(Fh=>Fh-0)),o[F]=re,re}})();if(ye.type===S.type){if(ye.type==="number"&&Aw(ye.values,S.values)>s){u[F]=!0;return}if(ye.type==="string"&&kw(ye.values,S.values)){u[F]=!0;return}}}),a[h]=S.values,i&&i(p/t.columns.length)});let f=new Lf(a);return f.index=t.index.slice(),f}Qf.exports=Xf});var ch=c((q_,ah)=>{var{abs:Jw,add:Yw,assert:Re,isArray:eh,isDataFrame:th,isEqual:$w,isSeries:nh,mean:Gw,pow:rh,scale:Lw,shape:sh,sign:Ww,sqrt:Kw,sum:ih}=w(),oh=me(),uh=(t,e)=>Yw(t,Lw(e,-1));function gr(t,e){if(th(t)||nh(t))return gr(t.values,e);if(th(e)||nh(e))return gr(t,e.values);Re(eh(t),"You must pass two same-shaped numerical arrays into the `rScore` function!"),Re(eh(e),"You must pass two same-shaped numerical arrays into the `rScore` function!"),Re($w(sh(t),sh(e)),"You must pass two same-shaped numerical arrays into the `rScore` function!"),Re(oh(t),"You must pass two same-shaped numerical arrays into the `rScore` function!"),Re(oh(e),"You must pass two same-shaped numerical arrays into the `rScore` function!");let n=ih(rh(uh(t,e),2)),r=ih(rh(uh(t,Gw(t)),2));if(r===0)return NaN;let s=1-n/r;return Ww(s)*Kw(Jw(s))}ah.exports=gr});var dh=c((y_,mh)=>{var{argmax:lh,assert:Ue,copy:Hw,DataFrame:Xw,dot:Qw,isArray:Zw,isDataFrame:eS,isEqual:fh,isJagged:tS,max:nS,min:rS,reverse:sS,shape:iS,transpose:oS}=w();function hh(t){if(Zw(t)){Ue(iS(t).length===2&&!tS(t),"The `sortCorrelationMatrix` function only works on 2-dimensional arrays and DataFrames!");let s=new Xw(t);return s.index=s.columns.slice(),hh(s).values}Ue(eS(t),"You must pass a DataFrame into the `sortCorrelationMatrix` function!"),Ue(nS(t.values)<=1&&rS(t.values)>=-1,"The correlation matrix passed into the `sortCorrelationMatrix` function must not contain values less than -1 or greater than 1!"),Ue(fh(t.values,oS(t.values)),"The correlation matrix passed into the `sortCorrelationMatrix` function must be symmetrical!"),Ue(fh(t.index,t.columns),"The correlation matrix passed into the `sortCorrelationMatrix` function must be symmetrical! (In this case, although the values themselves are symmetrical, the row and column names differ.)");let e=Hw(t.index),n=[];for(;e.length>0;)if(n.length===0){let s=lh(t.values.map(i=>Qw(i,i)));n.push(e[s]),e.splice(s,1)}else{let s=t.index.indexOf(n.at(-1)),i=lh(e.map(u=>t.values[t.index.indexOf(u)][s])),o=e[i];n.push(o),e.splice(i,1)}let r=sS(n);return t.get(r,r)}mh.exports=hh});var gh=c((b_,ph)=>{var uS=mr();function aS(){return uS(...arguments)}ph.exports=aS});var _h=c((N_,xh)=>{var{assert:Mt,DataFrame:qh,dropNaN:cS,flatten:yh,isArray:lS,isDataFrame:qr,isSeries:yr,mean:bh,range:fS,Series:Nh,shape:vh,stdev:wh,transpose:Sh}=w(),hS=P(),br=class{constructor(){let e=this;e.means=[],e.stdevs=[],e.wasFittedOnAVector=!1,e.hasBeenFitted=!1}_getDataArrayAndShape(e){if(qr(e))return[e.values,e.shape];if(yr(e)){let r=Sh([e.values]);return[r,vh(r)]}Mt(lS(e),"`x` must be a 1- or 2-dimensional array, DataFrame, or Series!");let n=vh(e);return Mt(n.length<3,"`x` must be a 1- or 2-dimensional array, DataFrame, or Series!"),n.length===1&&(n.push(1),e=Sh([e])),[e,n]}fit(e){let n=this,r=n._getDataArrayAndShape(e);e=r[0];let s=r[1];return n.wasFittedOnAVector=s.indexOf(1)>-1,n.means=[],n.stdevs=[],fS(0,s[1]).forEach(i=>{let o=e.map(u=>u[i]);if(hS.shouldIgnoreNaNValues){let u=cS(o);n.means.push(bh(u)),n.stdevs.push(wh(u))}else n.means.push(bh(o)),n.stdevs.push(wh(o))}),n.hasBeenFitted=!0,n}transform(e){let n=this;if(!n.hasBeenFitted)throw new Error("This `StandardScaler` instance hasn't been trained on any data yet! Please use the `fit` method to train it before calling the `transform` method.");if(qr(e)){let o=new qh(n.transform(e.values));return o.columns=e.columns,o.index=e.index,o}if(yr(e)){let o=new Nh(n.transform(e.values));return o.name=e.name,o.index=e.index,o}let r=n._getDataArrayAndShape(e);e=r[0];let s=r[1];Mt(s[1]===n.means.length,"The data you passed into the `transform` function doesn't have the same number of columns as the data set on which this StandardScaler was fitted!");let i=e.map(o=>o.map((u,a)=>(u-n.means[a])/n.stdevs[a]));return n.wasFittedOnAVector?yh(i):i}untransform(e){let n=this;if(!n.hasBeenFitted)throw new Error("This `StandardScaler` instance hasn't been trained on any data yet! Please use the `fit` method to train it before calling the `transform` method.");if(qr(e)){let o=new qh(n.untransform(e.values));return o.columns=e.columns,o.index=e.index,o}if(yr(e)){let o=new Nh(n.untransform(e.values));return o.name=e.name,o.index=e.index,o}let r=n._getDataArrayAndShape(e);e=r[0];let s=r[1];Mt(s[1]===n.means.length,"The data you passed into the `untransform` function doesn't have the same number of columns as the data set on which this StandardScaler was fitted!");let i=e.map(o=>o.map((u,a)=>u*n.stdevs[a]+n.means[a]));return n.wasFittedOnAVector?yh(i):i}};xh.exports=br});var dS=c((v_,Oh)=>{var{MathError:mS}=w(),Th={clipOutliers:Pn(),cohensD:Vn(),cohensd:Vn(),common:P(),containsOnlyNumbers:me(),diagonalize:xl(),getCorrelationMatrix:Gn(),getHighlyCorrelatedColumns:Ml(),getMagnitude:Kn(),getOneHotEncodings:Hn(),getPercentages:Pl(),getPValueMatrix:tf(),IndexMatcher:uf(),isBinary:Un(),isCorrelationMatrix:Ln(),KMeans:If(),normalize:mr(),orthonormalize:Gf(),preprocess:Zf(),project:pr(),pValue:Qn(),rScore:ch(),sortCorrelationMatrix:dh(),standardize:gh(),StandardScaler:_h(),trainTestSplit:rr(),dump(){let t=this,e=typeof global<"u"?global:typeof window<"u"?window:null;if(!e)throw new mS("Cannot dump functions into global scope because neither `global` nor `window` exist in the current context!");Object.keys(t).forEach(n=>{try{Object.defineProperty(e,n,{configurable:!1,enumerable:!0,writable:!1,value:t[n]})}catch{e[n]=t[n]}})}};try{window.JSDataScienceHelpers=Th}catch{}try{Oh.exports=Th}catch{}});dS();})();
