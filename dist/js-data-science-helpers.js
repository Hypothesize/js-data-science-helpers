(()=>{var xh=Object.defineProperty;var _h=(t,e,n)=>e in t?xh(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n;var gr=(t=>typeof require!="undefined"?require:typeof Proxy!="undefined"?new Proxy(t,{get:(e,n)=>(typeof require!="undefined"?require:e)[n]}):t)(function(t){if(typeof require!="undefined")return require.apply(this,arguments);throw new Error('Dynamic require of "'+t+'" is not supported')});var c=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports);var It=(t,e,n)=>(_h(t,typeof e!="symbol"?e+"":e,n),n);var te=c((uS,qr)=>{var Th=new Function(`
  try {
    return this === window
  } catch(e) {}

  try {
    return typeof importScripts !== "undefined"
  } catch(e) {}

  return false
`),At=class extends Error{constructor(e){Th()?super(e):super(`

\x1B[31m`+e+`
\x1B[0m`)}};qr.exports=At});var h=c((aS,yr)=>{var Oh=te();yr.exports=function(t,e){if(!t)throw new Oh(e)}});var C=c((cS,br)=>{function Dh(t){try{return structuredClone(t)}catch{return t}}br.exports=Dh});var d=c((lS,Nr)=>{function Fh(t){try{return t instanceof Array||typeof t.constructor<"u"&&t.constructor.name==="Array"}catch{return!1}}Nr.exports=Fh});var y=c((fS,wr)=>{function Ih(t){try{return!!t._symbol&&t._symbol===Symbol.for("@jrc03c/js-math-tools/dataframe")}catch{return!1}}wr.exports=Ih});var q=c((hS,vr)=>{function Ah(t){try{return!!t._symbol&&t._symbol===Symbol.for("@jrc03c/js-math-tools/series")}catch{return!1}}vr.exports=Ah});var _=c((mS,_r)=>{var Eh=h(),Mh=C(),Sr=d(),jh=y(),Ch=q();function xr(t){if(jh(t)||Ch(t))return xr(t.values);Eh(Sr(t),"The `flatten` function only works on arrays, Series, and DataFrames!");function e(n){let r=[];return Mh(n).forEach(s=>{Sr(s)?r=r.concat(e(s)):r.push(s)}),r}return e(t)}_r.exports=xr});var F=c((dS,Tr)=>{function kh(t){return typeof t=="function"}Tr.exports=kh});var g=c((pS,Or)=>{function zh(t){return typeof t=="number"&&!isNaN(t)}Or.exports=zh});var N=c((gS,Dr)=>{function Rh(t){return t===null||typeof t>"u"}Dr.exports=Rh});var V=c((qS,Fr)=>{var Uh=d(),Ph=N();function Bh(t){return typeof t=="object"&&!Ph(t)&&!Uh(t)}Fr.exports=Bh});var pe=c((yS,Er)=>{var Vh=h(),Ir=d(),Jh=y(),Yh=F(),Et=g(),Ar=V(),$h=q();function Mt(t,e){if(Jh(t)){let i=Mt(t.values,e);return i.length>0&&Et(i[0])&&i[0]>=0&&i[0]<t.index.length&&(i[0]=t.index[i[0]]),i.length>1&&Et(i[1])&&i[1]>=0&&i[1]<t.columns.length&&(i[1]=t.columns[i[1]]),i}if($h(t)){let i=Mt(t.values,e);return i.length>0&&Et(i[0])&&i[0]>=0&&i[0]<t.index.length&&(i[0]=t.index[i[0]]),i}if(Vh(Ar(t)||Ir(t),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `indexOf` function!"),!Yh(e)){let i=e;e=o=>o===i}function n(i,o,u){if(u=u||[],u.indexOf(i)>-1)return null;if(Ar(i)){u.push(i);let a=Object.keys(i);for(let l=0;l<a.length;l++){let f=a[l],m=i[f];if(o(m))return[f];let p=n(m,o,u);if(p&&p.length>0)return[f].concat(p)}}else if(Ir(i)){u.push(i);for(let a=0;a<i.length;a++){let l=i[a];if(o(l))return[a];let f=n(l,o,u);if(f&&f.length>0)return[a].concat(f)}}else if(o(i))return[];return null}function r(i){try{return e(i)}catch{return!1}}let s=n(t,r);return s&&s.length>0?s:null}Er.exports=Mt});var jt=c((bS,Mr)=>{var Gh=C(),Lh=pe(),Wh=d(),Kh=y(),Hh=q();Mr.exports=function(e){function n(i,o,u){if(o=o||[],u=u||"",o.indexOf(i)>-1){let a=u.split("/").slice(u.startsWith("/")?1:0);if(a.some((f,m)=>{let p=a.slice(0,a.length-m-1),b=r;return p.forEach(M=>{b=b[M]}),b===i}))return`<reference to "${r===i?"/":"/"+Lh(r,i).join("/")}">`}return typeof i=="object"?i===null?null:(o.push(i),Wh(i)?i.map((a,l)=>n(a,o,u+"/"+l)):(Object.keys(i).forEach(a=>{i[a]=n(i[a],o,u+"/"+a)}),i)):i}let r=Gh(e),s=n(r);if(Kh(e)){let i=e.copy();i._values=s.values,i._columns=s.columns,i._index=s.index,s=i}if(Hh(e)){let i=e.copy();i.name=s.name,i._values=s.values,i._index=s.index,s=i}return s}});var z=c((NS,kr)=>{var jr=C(),Cr=jt();function Xh(t,e){function n(r,s){let i=typeof r;if(i!==typeof s)return!1;if(i==="undefined")return!0;if(i==="boolean"||i==="symbol")return r===s;if(i==="number"||i==="bigint")return r.toString()==="NaN"&&s.toString()==="NaN"?!0:r===s;if(i==="string"||i==="function")return r===s;if(i==="object"){if(r===null||s===null)return r===null&&s===null;{let u=Object.keys(r),a=Object.keys(s);if(u.length!==a.length)return!1;for(let l=0;l<u.length;l++){let f=u[l];if(!n(r[f],s[f]))return!1}return!0}}}try{return n(jr(t),jr(e))}catch{return n(Cr(t),Cr(e))}}kr.exports=Xh});var k=c((wS,Pr)=>{var Qh=h(),Zh=_(),e0=d(),zr=y(),t0=F(),Rr=q(),n0=N();function ge(t){let e="abcdefg1234567890",n="";for(;n.length<t;)n+=e[parseInt(Math.random()*e.length)];return n}var r0=ge(256),s0=ge(256),i0=ge(256),o0=ge(256),u0=ge(256);function Ur(t){if(zr(t)||Rr(t))return Ur(t.values);Qh(e0(t),"The `set` function only works on arrays, Series, and DataFrames!");let e=[],n={};return Zh(t).forEach(r=>{let s=typeof r=="object"&&r===null?r0:n0(r)?s0:t0(r)?r.toString():typeof r=="symbol"?r.toString()+" - "+u0:r===1/0?i0:r===-1/0?o0:zr(r)?r.toJSONString():Rr(r)?JSON.stringify(r.toObject()):JSON.stringify(r);n[s]||e.push(r),n[s]=!0}),e}Pr.exports=Ur});var qe=c((vS,Jr)=>{var a0=h(),Ct=_(),Br=d(),c0=y(),Vr=z(),l0=F(),f0=q(),h0=k();function ke(t,e){if(c0(t)||f0(t))return arguments.length>1?ke(t.values,e):ke(t.values,t.values);if(a0(Br(t),"The first argument to the `count` function must be an array, Series, or DataFrame!"),l0(e))return Ct(t).filter(n=>e(n)).length;if(Br(e)){let n=Ct(t);return h0(e).map(r=>({item:r,count:n.filter(s=>Vr(s,r)).length}))}else return arguments.length>1?Ct(t).filter(n=>Vr(n,e)).length:ke(t,t)}Jr.exports=ke});var ye=c((SS,$r)=>{var m0=h(),Yr=d(),d0=y(),p0=q();function kt(t){if(d0(t)||p0(t))return kt(t.values);m0(Yr(t),"The `isJagged` function only works on arrays, Series, and DataFrames!");let e=0,n=null;for(let r=0;r<t.length;r++)if(Yr(t[r])){if(e++,kt(t[r]))return!0;if(n===null)n=t[r].length;else if(t[r].length!==n)return!0}return e>0&&e<t.length}$r.exports=kt});var ze=c((xS,Wr)=>{var g0=h(),Gr=d(),q0=y(),y0=q();function Lr(t){if(q0(t)||y0(t))return Lr(t.values);g0(Gr(t),"The `isNested` function only works on arrays, Series, and DataFrames!");for(let e=0;e<t.length;e++)if(Gr(t[e]))return!0;return!1}Wr.exports=Lr});var J=c((_S,Hr)=>{var X=h(),b0=d(),N0=ze(),w0=g(),v0=N(),ne="You must pass a natural number or a one-dimensional array of natural numbers into the `ndarray` function!";function Kr(t){X(!v0(t),ne),b0(t)||(t=[t]),X(!N0(t),ne),X(t.length>0,ne);let e=t[0];if(X(w0(e),ne),X(parseInt(e)===e,ne),X(e>=0,ne),X(e!==1/0,"We can't create an array containing an infinite number of values!"),t.length===1){let n=[];for(let r=0;r<e;r++)n.push(void 0);return n}else{let n=[];for(let r=0;r<e;r++)n.push(Kr(t.slice(1)));return n}}Hr.exports=Kr});var be=c((TS,Xr)=>{var S0=h(),x0=d(),_0=y(),T0=q();function zt(t){if(_0(t)||T0(t)){let n=t.copy();return n.values=zt(n.values),n.index=zt(n.index),n}S0(x0(t),"The `reverse` function only works on arrays, Series, and DataFrames!");let e=[];for(let n=t.length-1;n>=0;n--)e.push(t[n]);return e}Xr.exports=zt});var E=c((OS,Qr)=>{var Rt=h(),Ut=g(),Pt=N(),O0=be();function D0(t,e,n=1){Rt(!Pt(t)&&!Pt(e)&&!Pt(n),"You must pass two numbers and optionally a step value to the `range` function!"),Rt(Ut(t)&&Ut(e)&&Ut(n),"You must pass two numbers and optionally a step value to the `range` function!"),Rt(n>0,"The step value must be greater than 0! (NOTE: The step value is a magnitude; it does not indicate direction.)");let r=!1;if(t>e){r=!0;let i=t;t=e+n,e=i+n}let s=[];for(let i=t;i<e;i+=n)s.push(i);return r&&(s=O0(s)),s}Qr.exports=D0});var S=c((DS,ns)=>{var F0=h(),Zr=d(),I0=y(),A0=z(),E0=q(),M0=N();function es(t){if(!Zr(t))return;let e=[t.length],n=0,r=t.map(s=>{let i=es(s);return M0(i)?i:(n++,i.length===1?i[0]:i)});return n>0?n===t.length&&r.slice(0,-1).every((i,o)=>A0(i,r[o+1]))?e.concat(r[0]):(e.push(r),e):e}function ts(t){return I0(t)||E0(t)?ts(t.values):(F0(Zr(t),"The `shape` function only works on arrays, Series, and DataFrames!"),es(t))}ns.exports=ts});var as=c((FS,us)=>{var rs=h(),j0=d(),C0=y(),k0=ye(),z0=q(),R0=N(),ss=te(),Re=J(),is=E(),U0=k(),P0=S();function os(t,e,n){if(R0(n)&&(n=0),rs(n===0||n===1||n==="vertical"||n==="horizontal",'The only valid axis values for use when appending data to a DataFrame are 0, 1, "vertical", and "horizontal". Note that 0 == "horizontal" and 1 == "vertical".'),j0(e)){rs(!k0(e),"The array of data you're trying to append to this DataFrame is jagged!");let r=P0(e);if(r.length===1)if(n===0){let s=t.copy();s._values.push(e);let i=Math.max(t.shape[1],r[0]);for(s._values.forEach(o=>{for(;o.length<i;)o.push(void 0)});s._index.length<s._values.length;)s._index.push("row"+s._index.length);for(;s._columns.length<i;)s._columns.push("col"+s._columns.length);return s}else{let s=Math.max(t.shape[0],r[0]),i=t.copy();for(is(0,s).forEach(o=>{o>=i._values.length&&i._values.push(Re(t.shape[1])),i._values[o].push(e[o])});i._index.length<i._values.length;)i._index.push("row"+i._index.length);for(;i._columns.length<i._values[0].length;)i._columns.push("col"+i._columns.length);return i}else if(r.length===2)if(n===0){let s=Math.max(...e.map(o=>o.length).concat([t.shape[1]])),i=t.copy();for(i._values=i._values.concat(e).map(o=>{for(;o.length<s;)o.push(void 0);return o});i._index.length<i._values.length;)i._index.push("row"+i._index.length);for(;i._columns.length<s;)i._columns.push("col"+i._columns.length);return i}else{let s=Math.max(...e.map(u=>u.length))+t.shape[1],i=Math.max(t.shape[0],r[0]),o=t.copy();for(is(0,i).forEach(u=>{for(u>=o._values.length&&o._values.push(Re(t.shape[1])),o._values[u]=o._values[u].concat(e[u]);o._values[u].length<s;)o._values[u].push(void 0)});o._index.length<o._values.length;)o._index.push("row"+o._index.length);for(;o._columns.length<s;)o._columns.push("col"+o._columns.length);return o}else throw new ss("Only 1- and 2-dimensional arrays can be appended to a DataFrame!")}else if(z0(e)){let r=os(t,e.values,n);return n===0?r.index[r.index.length-1]=r.index.indexOf(e.name)>-1?e.name+" (2)":e.name:r.columns[r.columns.length-1]=r.columns.indexOf(e.name)>-1?e.name+" (2)":e.name,r}else if(C0(e))if(n===0){let r=t.copy(),s=U0(r._columns.concat(e._columns)).length;for(r._values.forEach(i=>{for(;i.length<s;)i.push(void 0)}),e.apply(i=>{let o=i.copy(),u=[];r._columns.forEach(a=>{let l=o._index.indexOf(a);l>-1?(u.push(o._values[l]),o._values.splice(l,1),o._index.splice(l,1)):u.push(void 0)}),r._values.push(u.concat(o._values))},1),r._columns=r._columns.concat(e._columns.filter(i=>r._columns.indexOf(i)<0));r._index.length<r._values.length;){let i="row"+r._index.length;r._index.push(i+(t._index.indexOf(i)>-1?" (2)":""))}return r}else{let r=t.copy();return r._index.forEach((s,i)=>{let o=e._index.indexOf(s);o>-1?r._values[i]=r._values[i].concat(e._values[o]):r._values[i]=r._values[i].concat(Re(e.shape[1]))}),e._index.forEach((s,i)=>{r._index.indexOf(s)<0&&(r._index.push(s),r._values.push(Re(r._columns.length).concat(e._values[i])))}),r._columns=r._columns.concat(e._columns.map(s=>s+(r._columns.indexOf(s)>-1?" (2)":""))),r}else throw new ss("Only 1- or 2-dimensional arrays, Series, and DataFrames can be appended to a DataFrame!")}us.exports=os});var ms=c((IS,hs)=>{var cs=h(),ls=d(),B0=F(),fs=N();function V0(t,e,n,r,s){if(s=s||0,cs(B0(r),"The first parameter to the `apply` method must be a function."),cs(s===0||s===1,"The second parameter to the `apply` method (the `axis`) must be 0 or 1."),s===0){let i={},o;if(n.columns.forEach((u,a)=>{let l=new e(n.values.map(m=>m[a]));l.name=u,l.index=n.index;let f=r(l,a,n);f instanceof e?i[u]=f.values:i[u]=f,fs(o)&&(o=f instanceof e||ls(f))}),o){let u=new t(i);return u.index=n.index,u}else{let u=new e(n.columns.map(a=>i[a]));return u.index=n.columns,u}}else if(s===1){let i,o=n.values.map((u,a)=>{let l=new e(u);l.name=n.index[a],l.index=n.columns;let f=r(l,a,n);return fs(i)&&(i=f instanceof e||ls(f)),f instanceof e?f.values:f});if(i){let u=new t(o);return u.index=n.index,u.columns=n.columns,u}else{let u=new e(o);return u.index=n.index,u}}}hs.exports=V0});var I=c((AS,ds)=>{function J0(t){return typeof t=="string"}ds.exports=J0});var qs=c((ES,gs)=>{var ps=h(),Y0=d(),$0=ye(),G0=V(),L0=I(),W0=N(),K0=te(),H0=S();function X0(t,e,n,r,s){let i=u=>u instanceof t,o=u=>u instanceof e;if(W0(s)){if(i(r))return n.append(r,1);if(o(r))return n.append(r,1);if(G0(r)){let u=Math.max(...Object.keys(r).map(a=>r[a].length));return Object.keys(r).forEach(a=>{for(;r[a].length<u;)r[a].push(void 0)}),n.append(new t(r),1)}else throw new K0("You must pass a DataFrame, Series, or object into the `assign` method!")}else{ps(L0(r),"If passing two arguments into the `assign` method, then the first argument must be a string name!"),ps(Y0(s)&&!$0(s)&&H0(s).length===1,"If passing two arguments into the `assign` method, then the second argument must be a 1-dimensional array!");let u=n.append(s,1);return u.columns[u.columns.length-1]=r,u}}gs.exports=X0});var bs=c((MS,ys)=>{var Q0=C();function Z0(t,e){if(e.isEmpty)return new t;let n=new t(Q0(e.values));return n.columns=e.columns.slice(),n.index=e.index.slice(),n}ys.exports=Z0});var Ts=c((jS,_s)=>{var Ue=h(),Ns=d(),ws=g(),vs=I(),Ss=N(),xs=S();function em(t,e,n,r,s){Ss(r)&&(r=[]),Ss(s)&&(s=[]),(vs(r)||ws(r))&&(r=[r]),(vs(s)||ws(s))&&(s=[s]),Ue(Ns(r),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),Ue(Ns(s),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),Ue(xs(r).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),Ue(xs(s).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");let i,o;n.index.forEach((a,l)=>{r.indexOf(a)<0&&r.indexOf(l)<0&&(i||(i=[]),i.push(a))}),n.columns.forEach((a,l)=>{s.indexOf(a)<0&&s.indexOf(l)<0&&(o||(o=[]),o.push(a))});let u=n.get(i,o);if(u instanceof e){let a=new t;a=a.assign(u),n.index.indexOf(u.name)>-1&&(a=a.transpose()),u=a}return u}_s.exports=em});var Ne=c((CS,Os)=>{var tm=g();function nm(t){return tm(t)&&parseInt(t)===t}function rm(t){return nm(t)&&t>=0}Os.exports=rm});var Fs=c((kS,Ds)=>{var Bt=h(),sm=I(),Pe=N(),im=Ne(),om=S();function um(t,e,n,r,s,i){r=r||0,Bt(r===0||r===1,"The first parameter of the `dropMissing` method (the `axis`) must be 0 or 1."),i=i||0,Bt(im(i),"The third parameter of the `dropMissing` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` null values)."),s=i>0?"none":s||"any",Bt(s==="any"||s==="all"||s==="none","The second parameter of the `dropMissing` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains null values, then it should be dropped; or that if 'all' of the data contains null values, then it should be dropped).");function o(l){if(i>0){let f=0;for(let m=0;m<l.length;m++){let p=l[m];if(Pe(p)&&f++,f>=i)return[]}}else if(s==="any")for(let f=0;f<l.length;f++){let m=l[f];if(Pe(m))return[]}else if(s==="all"){for(let f=0;f<l.length;f++){let m=l[f];if(!Pe(m))return l}return[]}return l}let u=n.copy(),a=Math.random().toString();if(r===0){u=u.assign(a,u.index);let l=u.values.map(o).filter(m=>m.length>0);if(om(l).length<2)return new t;u.values=l;let f=u.get(null,a);if(Pe(f))return new t;sm(f)&&(f=[f]),f instanceof e&&(f=f.values),u.index=f,u=u.drop(null,a)}else if(r===1){let l={};if(u.columns.forEach((m,p)=>{let b=u.values.map(O=>O[p]),M=o(b);M.length>0&&(l[m]=M)}),Object.keys(l).length===0)return new t;let f=new t(l);return f.index=u.index,f}return u}Ds.exports=um});var Vt=c((zS,As)=>{var am=h(),cm=d(),lm=y(),fm=g(),hm=q();function Is(t){if(lm(t)||hm(t))return t.dropNaN(...Object.values(arguments).slice(1));am(cm(t),"The `dropNaN` function only works on arrays, Series, and DataFrames!");let e=[];return t.forEach(n=>{try{return e.push(Is(n))}catch{if(fm(n))return e.push(n)}}),e}As.exports=Is});var Ms=c((RS,Es)=>{var Jt=h(),mm=Vt(),dm=Ne();function pm(t,e,n,r,s){n=n||0,Jt(n===0||n===1,"The first parameter of the `dropNaN` method (the `axis`) must be 0 or 1."),s=s||0,Jt(dm(s),"The third parameter of the `dropNaN` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` NaN values)."),r=s>0?"none":r||"any",Jt(r==="any"||r==="all"||r==="none","The second parameter of the `dropNaN` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains NaN values, then it should be dropped; or that if 'all' of the data contains NaN values, then it should be dropped).");function i(u){let a=mm(u);return s>0?u.length-a.length<s:r==="any"?a.length===u.length:r==="all"?a.length>0:!0}let o=e.copy();if(n===0){let u=o.index.filter(a=>{let l=o.get(a,null).values;return i(l)});return u.length>0?o.get(u,null):new t}else if(n===1){let u=o.columns.filter(a=>{let l=o.get(null,a).values;return i(l)});return u.length>0?o.get(null,u):new t}return o}Es.exports=pm});var zs=c((US,ks)=>{var js=h(),we=_(),gm=F(),qm=N();function Cs(t){let e={};return we(t).forEach((n,r)=>{e[n]=r}),e}function re(t){return Object.keys(t).sort((e,n)=>t[e]-t[n])}function ym(t,e,n,r,s){js(gm(r),"The `filter` method takes a single parameter: a function that is used to filter the values."),qm(s)&&(s=0),js(s===0||s===1,"The `axis` parameter to the `filter` method must be 0 or 1.");let i=n.copy();if(i.isEmpty)return i;let o=Cs(i.index),u=Cs(i.columns);if(s===0){let a=i.values.filter((l,f)=>{let m=new e(l);m.name=n.index[f],m.index=n.columns;let p=r(m,f,n);return p||delete o[i.index[f]],p});if(we(a).length===0)return new t;if(a.length===1){let l=new e(we(a));return l.name=re(o)[0],l.index=re(u),l}i.values=a,i.index=re(o)}else if(s===1){i=i.transpose();let a=i.values.filter((l,f)=>{let m=new e(l);m.name=n.columns[f],m.index=n.index;let p=r(m,f,n);return p||delete u[i.index[f]],p});if(we(a).length===0)return new t;if(a.length===1){let l=new e(we(a));return l.name=re(u)[0],l.index=re(o),l}i.values=a,i.index=re(u),i=i.transpose()}return i}ks.exports=ym});var Ps=c((PS,Us)=>{var j=h(),Be=g(),Ve=I(),Rs=N(),bm=k();function Nm(t,e,n){(Ve(e)||Be(e))&&(e=[e]),(Ve(n)||Be(n))&&(n=[n]);let r=bm((e||[]).concat(n||[]).map(s=>typeof s));return j(r.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===1&&j(r[0]==="string"||r[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===2&&(j(r.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),j(r.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),Rs(e)||(e=e.map(s=>{if(Ve(s))return j(t.index.indexOf(s)>-1,`Row "${s}" does not exist!`),s;if(Be(s))return j(s>=0,`Index ${s} is out of bounds!`),j(parseInt(s)===s,"Row numbers must be integers!"),j(s<t.index.length,`Index ${s} is out of bounds!`),t.index[s]})),Rs(n)||(n=n.map(s=>{if(Ve(s))return j(t.columns.indexOf(s)>-1,`Column "${s}" does not exist!`),s;if(Be(s))return j(s>=0,`Column ${s} is out of bounds!`),j(parseInt(s)===s,"Column numbers must be integers!"),j(s<t.columns.length,`Column ${s} is out of bounds!`),t.columns[s]})),t.getSubsetByNames(e,n)}Us.exports=Nm});var Y=c((BS,Vs)=>{var Bs=h(),wm=d(),vm=y(),Sm=F(),xm=q(),_m=N();function Tm(t,e){try{return t<e?-1:t>e?1:0}catch{return t=typeof t=="object"&&t!==null?JSON.stringify(t):t.toString(),e=typeof e=="object"&&e!==null?JSON.stringify(e):e.toString(),t<e?-1:t>e?1:0}}function Om(t,e){if(_m(e)&&(e=Tm),vm(t)||xm(t))return t.sort(...Object.values(arguments).slice(1));Bs(wm(t),"The `sort` function only works on arrays, Series, and DataFrames!"),Bs(Sm(e),"The second parameter of the `sort` function must be a comparison function!");let n=t.slice();return n.sort(e),n}Vs.exports=Om});var Gs=c((VS,$s)=>{var Js=h(),Ys=I(),Dm=N(),Fm=k(),Im=Y();function Am(t){let e=t.toLowerCase(),n="";for(let s=0;s<e.length;s++){let i=e[s];i.match(/[a-z0-9]/g)?n+=i:n+=" "}let r=n.split(" ").filter(s=>s.length>0);return r[0]+r.slice(1).map(s=>s[0].toUpperCase()+s.substring(1)).join("")}function Em(t,e,n){Dm(n)?n=e.columns:Ys(n)&&(n=[n]);let r={};n.forEach(i=>{Js(Ys(i),"You must pass either a string or a one-dimensional array of strings into the `getDummies` (AKA `oneHotEncode`) method!");let o=e.columns.indexOf(i);Js(o>-1,`The given DataFrame does not have a column called "${i}"!`);let u=e.values.map(l=>l[o]),a=Im(Fm(u));u.forEach(l=>{a.forEach(f=>{let m=i+"_"+Am(f.toString());r[m]||(r[m]=[]),l===f?r[m].push(1):r[m].push(0)})})});let s=new t(r);return s.index=e.index,s}$s.exports=Em});var ei=c((JS,Zs)=>{var $=h(),Ls=d(),Ws=g(),Ks=N(),Hs=Ne(),Xs=E(),Qs=S();function Mm(t,e,n){let r=t.shape;Ks(e)&&(e=Xs(0,r[0])),Ks(n)&&(n=Xs(0,r[1])),Ws(e)&&(e=[e]),Ws(n)&&(n=[n]),$(Ls(e)&&Ls(n),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),$(Qs(e).length===1&&Qs(n).length===1,"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),$(e.length>0,"The `rowIndices` array must contain at least one index."),$(n.length>0,"The `colIndices` array must contain at least one index."),e.forEach(o=>{$(Hs(o),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),$(o<t.index.length,`The row index ${o} is out of bounds.`)}),n.forEach(o=>{$(Hs(o),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),$(o<t.columns.length,`The column index ${o} is out of bounds.`)});let s=e.map(o=>t.index[o]),i=n.map(o=>t.columns[o]);return t.getSubsetByNames(s,i)}Zs.exports=Mm});var ii=c((YS,si)=>{var G=h(),Yt=_(),ti=d(),Je=I(),ni=N(),ri=S();function jm(t,e,n,r,s){ni(r)&&(r=n.index),ni(s)&&(s=n.columns),Je(r)&&(r=[r]),Je(s)&&(s=[s]),G(ti(r)&&ti(s),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),G(ri(r).length===1&&ri(s).length===1,"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),G(r.length>0,"The `rows` array must contain at least one row name."),G(s.length>0,"The `cols` array must contain at least one column name."),r.forEach(u=>{G(Je(u),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),G(n.index.indexOf(u)>-1,`The row name "${u}" does not exist in the list of rows.`)}),s.forEach(u=>{G(Je(u),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),G(n.columns.indexOf(u)>-1,`The column name "${u}" does not exist in the list of columns.`)});let i=r.map(u=>s.map(a=>n.values[n.index.indexOf(u)][n.columns.indexOf(a)]));if(r.length===1&&s.length===1)return Yt(i)[0];if(r.length===1){let u=new e(Yt(i));return u.name=r[0],u.index=s,u}if(s.length===1){let u=new e(Yt(i));return u.name=s[0],u.index=r,u}let o=new t(i);return o.columns=s,o.index=r,o}si.exports=jm});var ui=c(($S,oi)=>{var Cm=I(),ve=E();function km(t,e,n){function r(p,b){return Cm(p)&&p.length>b?p.substring(0,b-3)+"...":p}if(n.isEmpty)return console.table({}),console.log("Shape:",[0,0],`
`),n;let s=typeof window>"u"?20:10,i=parseInt(s/2),o=typeof process>"u"?10:Math.floor(process.stdout.columns/24)-1,u=parseInt(o/2),a=s>n.index.length?null:ve(0,i).concat(ve(n.index.length-i,n.index.length)),l=o>n.columns.length?null:ve(0,u).concat(ve(n.columns.length-u,n.columns.length)),f=n.get(a,l);f instanceof e&&(n.shape[0]===1?(f=new t([f.values]),f.index=n.index,f.columns=new e(n.columns).get(l).values):n.shape[1]===1&&(f=new t([f.values]).transpose(),f.index=new e(n.index).get(a).values,f.columns=n.columns)),s<=n.index.length&&(f._index.splice(i,0,"..."),f._values.splice(i,0,ve(0,f.columns.length).map(()=>"..."))),o<=n.columns.length&&(f._columns.splice(u,0,"..."),f._values=f._values.map(p=>(p.splice(u,0,"..."),p)));let m=28;return f instanceof e?(f.values=f.values.map(p=>r(p,m)),f.name=r(f.name,m),f.index=f.index.map(p=>r(p,m))):(f.values=f.values.map(p=>p.map(b=>r(b,m))),f.columns=f.columns.map(p=>r(p,m)),f.index=f.index.map(p=>r(p,m))),console.table(f.toObject()),console.log("Shape:",n.shape,`
`),n}oi.exports=km});var Ye=c((GS,ai)=>{var zm=h(),Rm=g();function Um(t,e){zm(Rm(t),"The `leftPad` function only works on numbers!");let n=t.toString();for(;n.length<e;)n="0"+n;return n}ai.exports=Um});var li=c((LS,ci)=>{var Pm=Ye(),Bm=E();function Vm(t,e){let n=e?t:t.copy();return n.index=Bm(0,t.shape[0]).map(r=>"row"+Pm(r,(n.index.length-1).toString().length)),n}ci.exports=Vm});var Se=c((WS,hi)=>{var Jm=h(),Ym=_(),$m=d(),Gm=y(),Lm=q();function fi(t){if(Gm(t)||Lm(t))return fi(t.values);Jm($m(t),"The `product` function only works on arrays, Series, and DataFrames!");try{return t.length===0?NaN:Ym(t).reduce((e,n)=>e*n,1)}catch{return NaN}}hi.exports=fi});var $e=c((KS,gi)=>{var xe=h(),mi=_(),di=d(),Wm=y(),pi=g(),Km=q(),Hm=Se(),Xm=S();function $t(t,e){if(Wm(t)||Km(t))return $t(t.values,e);if(xe(di(t),"The first argument passed into the `reshape` function must be an array!"),pi(e)&&(e=[e]),xe(di(e),"The second argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),xe(Xm(e).length===1,"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),e.forEach(i=>{xe(pi(i)&&parseInt(i)===i&&i>0,"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!")}),e.length===0)return mi(t);let n=mi(t);if(e.length===1&&e[0]===n.length)return n;xe(Hm(e)===n.length,"The new shape doesn't match the number of values available in `x` (the first argument passed into the `reshape` function)!");let r=[],s=parseInt(n.length/e[0]);for(let i=0;i<e[0];i++){let o=n.slice(i*s,(i+1)*s);r.push($t(o,e.slice(1)))}return r}gi.exports=$t});var se=c((HS,Si)=>{var Qm=h(),bi=C(),Zm=d(),ed=g(),Ni=N(),td=J(),nd=Se(),rd=$e(),wi=Math.pow(2,64),x=[];vi(parseInt(Math.random()*wi));function sd(t,e){t=D(t);function n(){t+=D("0x9e3779b97f4a7c15");let s=bi(t);return s=(s^s>>30n)*D("0xbf58476d1ce4e5b9"),s=(s^s>>27n)*D("0x94d049bb133111eb"),s^s>>31n}let r=[];for(let s=0;s<e;s++)r.push(n());return r}function D(t){return BigInt.asUintN(64,BigInt(t))}function qi(t,e){return t=D(t),e=BigInt(e),D(D(t<<e)|D(t>>D(64n-e)))}function vi(t){if(Ni(t))return bi(x);{Qm(ed(t),"If passing a value into the `seed` function, then that value must be an integer!");let e=sd(parseInt(t),4);x[0]=e[0],x[1]=e[1],x[2]=e[2],x[3]=e[3]}}function yi(){let t=D(qi(x[0]+x[3],23)+x[0]),e=D(x[1]<<17n);return x[2]=D(x[2]^x[0]),x[3]=D(x[3]^x[1]),x[1]=D(x[1]^x[2]),x[0]=D(x[0]^x[3]),x[2]=D(x[2]^e),x[3]=qi(x[3],45),parseInt(t)/wi}function id(t){return Ni(t)?yi():(Zm(t)||(t=[t]),rd(td(nd(t)).map(yi),t))}Si.exports={random:id,seed:vi}});var Ge=c((XS,xi)=>{var{random:od}=se(),ud=h(),ad=d(),cd=y(),ld=q();function fd(t){if(cd(t)||ld(t))return t.shuffle(...Object.values(arguments).slice(1));ud(ad(t),"The `shuffle` function only works on arrays, Series, and DataFrames!");let e=[],n=t.slice();for(let r=0;r<t.length;r++){let s=parseInt(od()*n.length);e.push(n.splice(s,1)[0])}return e}xi.exports=fd});var Oi=c((QS,Ti)=>{var hd=h(),md=N(),_i=Ge();function dd(t,e){return md(e)&&(e=0),hd(e===0||e===1,"The `axis` parameter to the `shuffle` must be 0, 1, or undefined."),t.get(e===0?_i(t.index):null,e===1?_i(t.columns):null)}Ti.exports=dd});var Le=c((ZS,Di)=>{function pd(t){return typeof t=="boolean"}Di.exports=pd});var Mi=c((e2,Ei)=>{var{random:gd}=se(),A=h(),qd=_(),Fi=d(),Gt=Le(),Ai=F(),We=g(),ie=I(),Lt=N(),yd=E(),Ii=S(),Wt=Y();function bd(t,e,n){return Ai(e)?Nd(t,e,n):wd(t,e,n)}function Nd(t,e,n){if(n=Lt(n)?0:n,A(Ai(e),"When sorting a DataFrame using a function, the first argument to the `sort` method must be a function!"),A(We(n),"When sorting a DataFrame using a function, the second argument to the `sort` method must be null, undefined, 0, or 1 to indicate the axis along which the data should be sorted! An axis of 0 means that the rows will be sorted relative to each other, whereas an axis of 1 means that the columns will be sorted relative to each other."),n===0){let r=Wt(t.index,(s,i)=>e(t.get(s,null),t.get(i,null)));return t.get(r,null)}else{let r=Wt(t.columns,(s,i)=>e(t.get(null,s),t.get(null,i)));return t.get(null,r)}}function wd(t,e,n){let r=t.copy(),s=gd().toString();return r=r.assign(s,r.index),Lt(e)&&(e=[s],n=[!0]),(We(e)||ie(e))&&(e=[e],(Gt(n)||ie(n))&&(n=[n])),A(Fi(e),"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),A(Ii(e).length===1,"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),Lt(n)&&(n=yd(0,e.length).map(()=>!0)),A(Fi(n),"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),A(Ii(n).length===1,"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),A(e.length===n.length,"The arrays passed into the `sort` method must be equal in length."),e=e.map(i=>{if(A(ie(i)||We(i),"Column references can either be column names (as strings) or column indices (as whole numbers)."),ie(i)){let o=r.columns.indexOf(i);return A(o>-1,`The column "${i}" does not exist!`),o}if(We(i))return A(parseInt(i)===i,"Column indices must be whole numbers!"),A(i>=0,`The column index ${i} is out of bounds!`),A(i<r.columns.length,`The index ${i} is out of bounds!`),i}),n=n.map(i=>{if(A(ie(i)||Gt(i),"Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),ie(i)){let o=i.trim().toLowerCase();return A(o==="ascending"||o==="descending","Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),o==="ascending"}if(Gt(i))return i}),r.values=Wt(r.values,(i,o)=>{let u=0;for(;i[e[u]]===o[e[u]]&&u<e.length;)u++;let a=n[u];if(i[e[u]]===o[e[u]])return 0;if(i[e[u]]<o[e[u]])return a?-1:1;if(i[e[u]]>o[e[u]])return a?1:-1}),r.index=qd(r.get(null,s).values),r=r.dropColumns(s),r}Ei.exports=bd});var Kt=c((t2,ji)=>{function vd(t,e){return JSON.stringify(t.toObject(e))}ji.exports=vd});var Ci=c((n2,Xt)=>{var Ht=te(),Sd=Kt();function xd(t,e,n){let r=Sd(t,n),s=!1,i=!1,o,u;try{let a=e;if(e.includes("/")){let f=e.split("/");a=f[f.length-1]}let l=document.createElement("a");l.href=`data:application/json;charset=utf-8,${encodeURIComponent(r)}`,l.download=a,l.dispatchEvent(new MouseEvent("click")),s=!0}catch(a){o=a}try{let a=gr("fs"),l=gr("path");a.writeFileSync(l.resolve(e),r,"utf8"),i=!0}catch(a){u=a}if(!s&&!i)throw typeof window<"u"?new Ht(o):typeof Xt<"u"?new Ht(u):new Ht("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");return t}Xt.exports=xd});var zi=c((r2,ki)=>{var _d=h(),Td=N();function Od(t,e){Td(e)?e=0:_d(e===0||e===1,"The axis parameter of the `toObject` method must be undefined, 0, or 1. An axis of 0 indicates that the returned object should be organized first by rows and then by columns. An axis of 1 indicates that the returned object should be organized first by columns and then by rows.");let n={};return e===0?t.index.forEach((r,s)=>{let i={};t.columns.forEach((o,u)=>{i[o]=t.values[s][u]}),n[r]=i}):t.columns.forEach((r,s)=>{let i={};t.index.forEach((o,u)=>{i[o]=t.values[u][s]}),n[r]=i}),n}ki.exports=Od});var Q=c((s2,Pi)=>{var Ri=h(),Dd=d(),Fd=y(),Id=q(),Ad=J(),Ui=be(),Ed=S();function Md(t){if(Fd(t)||Id(t))return t.transpose();Ri(Dd(t),"The `transpose` function only works on arrays, Series, and DataFrames!");let e=Ed(t);if(Ri(e.length<=2,"I'm not smart enough to know how to transpose arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `transpose` function!"),e.length===1)return Ui(t);if(e.length===2){let n=Ad(Ui(e));for(let r=0;r<e[0];r++)for(let s=0;s<e[1];s++)n[s][r]=t[r][s];return n}}Pi.exports=Md});var Yi=c((i2,Ji)=>{var Bi=h(),jd=d(),Cd=y(),kd=ze(),zd=q(),Rd=S();function Vi(t,e,n){if(zd(n))return new t(e.values.concat(n.values));if(jd(n)){let r=Rd(n);Bi(r.length===1&&!kd(r),"Only vectors can be appended to Series!");let s=e.copy();return n.forEach((i,o)=>{s._values.push(i),s._index.push("item"+(e.values.length+o))}),s}return Bi(!Cd(n),"DataFrames cannot be appended to Series!"),Vi(e,[n])}Ji.exports=Vi});var Gi=c((o2,$i)=>{var Ud=h(),Pd=F();function Bd(t,e){Ud(Pd(e),"The parameter to the `apply` method must be a function.");let n=t.copy();return n._values=n._values.map((r,s)=>e(r,s)),n}$i.exports=Bd});var Wi=c((u2,Li)=>{var Vd=N();function Jd(t){let e=t.copy(),n=[];return e._values=e.values.filter((r,s)=>Vd(r)?!1:(n.push(e.index[s]),!0)),e._index=n,e}Li.exports=Jd});var Hi=c((a2,Ki)=>{var Yd=g();function $d(t,e){let n=[],r=[];e.values.forEach((i,o)=>{Yd(i)&&(r.push(i),n.push(e.index[o]))});let s=new t(r);return s.name=e.name,s.index=n,s}Ki.exports=$d});var Qi=c((c2,Xi)=>{var Gd=C();function Ld(t,e,n){let r=e.copy(),s=Gd(r.index),i=[],o=r.values.filter((u,a)=>{let l=n(u,a,r.values);return l||i.push(r.index[a]),l});return i.forEach(u=>{s.splice(s.indexOf(u),1)}),o.length===0?(r=new t,r.name=e.name,r):(r.values=o,r.index=s,r)}Xi.exports=Ld});var eo=c((l2,Zi)=>{var L=h(),Wd=g(),Kd=I(),Hd=N(),Xd=k();function Qd(t,e){(Kd(e)||Wd(e))&&(e=[e]);let n=Xd((e||[]).map(r=>typeof r));return L(n.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===1&&L(n[0]==="string"||n[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===2&&(L(n.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),L(n.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),Hd(e)||(e=e.map(r=>{if(typeof r=="string")return L(t.index.indexOf(r)>-1,`Index "${r}" does not exist!`),r;if(typeof r=="number")return L(r>=0,`Index ${r} is out of bounds!`),L(parseInt(r)===r,"Indices must be integers!"),L(r<t.index.length,`Index ${r} is out of bounds!`),t.index[r]})),t.getSubsetByNames(e)}Zi.exports=Qd});var no=c((f2,to)=>{var _e=h(),Zd=d(),ep=N(),tp=Ne(),np=E(),rp=S();function sp(t,e){let n=t.shape;ep(e)&&(e=np(0,n[0])),_e(Zd(e),"The `indices` array must be 1-dimensional array of whole numbers."),_e(rp(e).length===1,"The `indices` array must be a 1-dimensional array of whole numbers."),_e(e.length>0,"The `indices` array must contain at least one index."),e.forEach(s=>{_e(tp(s),"The `indices` array must be a 1-dimensional array of whole numbers."),_e(s<t.index.length,`The row index ${s} is out of bounds.`)});let r=e.map(s=>t.index[s]);return t.getSubsetByNames(r)}to.exports=sp});var so=c((h2,ro)=>{var Te=h(),ip=d(),op=I(),up=N(),ap=S();function cp(t,e,n){up(n)&&(n=e.index),Te(ip(n),"The `indices` array must be a 1-dimensional array of strings."),Te(ap(n).length===1,"The `indices` array must be a 1-dimensional array of strings."),Te(n.length>0,"The `indices` array must contain at least one index name."),n.forEach(i=>{Te(op(i),"The `indices` array must contain only strings."),Te(e.index.indexOf(i)>-1,`The name "${i}" does not exist in the index.`)});let r=n.map(i=>e.values[e.index.indexOf(i)]);if(r.length===1)return r[0];let s=new t(r);return s.index=n,s.name=e.name,s}ro.exports=cp});var uo=c((m2,oo)=>{var lp=C(),io=E();function fp(t){let e=t.copy(),n=typeof window>"u"?20:10;if(e.index.length>n){e=e.get(io(0,n/2).concat(io(e.index.length-n/2,e.index.length)));let s=lp(e.index);s.splice(parseInt(s.length/2),0,"..."),e.values.push("..."),e.index.push("..."),e=e.get(s)}let r={};return e.values.forEach((s,i)=>{let o={};o[e.name]=s,r[e.index[i]]=o}),console.table(r),console.log("Shape:",t.shape,`
`),t}oo.exports=fp});var co=c((d2,ao)=>{var hp=Ge();function mp(t){let e=t.copy();return e.get(hp(e.index))}ao.exports=mp});var fo=c((p2,lo)=>{var dp=h(),pp=F(),gp=N(),qp=Y(),yp=Q();function bp(t,e,n){n=n||((a,l)=>a<l?-1:1),dp(gp(n)||pp(n),"You must pass undefined, null, or a comparison function as the second argument to the `sort` method!");let r=yp([e.values,e.index]),s=qp(r,(a,l)=>n(a[0],l[0])),i=[],o=[];s.forEach(a=>{i.push(a[0]),o.push(a[1])});let u=new t;return u._values=i,u._index=o,u.name=e.name,u}lo.exports=bp});var po=c((g2,mo)=>{var Np=Y(),ho=Q();function wp(t,e){let n=ho([e.values,e.index]);n=ho(Np(n,(s,i)=>{if(s[1]===i[1])return 0;if(s[1]<i[1])return-1;if(s[1]>i[1])return 1}));let r=new t(n[0]);return r.index=n[1],r.name=e.name,r}mo.exports=wp});var qo=c((q2,go)=>{function vp(t){let e={};return e[t.name]={},t.index.forEach((n,r)=>{e[t.name][n]=t.values[r]}),e}go.exports=vp});var vo=c((y2,wo)=>{var P=h(),Ke=C(),Qt=d(),Sp=I(),xp=N(),yo=Ye(),bo=E(),He=be(),_p=Yi(),Tp=Gi(),Op=Wi(),Dp=Hi(),Fp=Qi(),Ip=eo(),Ap=no(),Ep=so(),Mp=uo(),jp=co(),Cp=fo(),kp=po(),zp=qo(),Oe=S(),Rp=Q(),No=Symbol.for("@jrc03c/js-math-tools/series");wo.exports=function(t){class e{static[Symbol.hasInstance](r){try{return!!r._symbol&&r._symbol===No}catch{return!1}}constructor(r){let s=this;if(s.name="data",Object.defineProperty(s,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:No}),Object.defineProperty(s,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(s,"values",{configurable:!0,enumerable:!0,get(){return s._values},set(i){P(Qt(i),"The new values must be a 1-dimensional array!");let o=Oe(i);P(o.length===1,"The new array of values must be 1-dimensional!"),o[0]<s._index.length?s._index=s._index.slice(0,o[0]):o[0]>s._index.length&&(s._index=s._index.concat(bo(s._index.length,o[0]).map(u=>"item"+yo(u,(i.length-1).toString().length)))),s._values=i}}),Object.defineProperty(s,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(s,"index",{configurable:!0,enumerable:!0,get(){return s._index},set(i){P(Qt(i),"The new index must be a 1-dimensional array of strings!"),P(i.length===s.shape[0],"The new index must be the same length as the old index!"),P(Oe(i).length===1,"The new index must be a 1-dimensional array of strings!"),i.forEach(o=>{P(Sp(o),"All of the row names must be strings!")}),s._index=i}}),r){if(r instanceof e)s.name=r.name,s.values=Ke(r.values),s.index=Ke(r.index);else if(Qt(r)){let i=Oe(r);P(i.length===1,"When passing an array into the constructor of a Series, the array must be 1-dimensional!"),s.values=r}else if(r instanceof Object){let i=Object.keys(r);P(i.length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");let o=i[0],u=r[o];P(Oe(u).length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!"),s.name=o,s.values=u.slice()}}}get shape(){return Oe(this.values)}get length(){return this.shape[0]}get isEmpty(){return this.values.filter(s=>!xp(s)).length===0}clear(){let s=this.copy();return s.values.forEach((i,o)=>{s.values[o]=void 0}),s}get(r){return Ip(this,r)}getSubsetByNames(r){return Ep(e,this,r)}getSubsetByIndices(r){return Ap(this,r)}loc(r){return this.getSubsetByNames(r)}iloc(r){return this.getSubsetByIndices(r)}reverse(){let r=this,s=new e(He(r.values));return s.index=He(r.index),s.name=r.name,s}resetIndex(){let r=this,s=r.copy();return s.index=bo(0,r.shape[0]).map(i=>"item"+yo(i,(s.index.length-1).toString().length)),s}copy(){let r=this,s=new e;return s._values=Ke(r.values),s._index=Ke(r.index),s.name=r.name,s}append(r){return _p(e,this,r)}apply(r){return Tp(this,r)}concat(r){return this.append(r)}dropMissing(r,s){return Op(this,r,s)}dropNaN(){return Dp(e,this)}toObject(){return zp(this)}print(){return Mp(this)}shuffle(){return jp(this)}sort(r){return Cp(e,this,r)}sortByIndex(){return kp(e,this)}filter(r){return Fp(e,this,r)}toDataFrame(){let r=this,s=new t(Rp([r.values]));return s.columns=[r.name],s.index=r.index,s}transpose(){let s=this.copy();return s.values=He(s.values),s.index=He(s.index),s}getDummies(){return this.toDataFrame().getDummies()}oneHotEncode(){return this.getDummies()}}return e}});var Fe=c((b2,Do)=>{var R=h(),Zt=C(),So=qe(),Up=as(),Pp=ms(),Bp=qs(),Vp=bs(),Jp=Ts(),Yp=Fs(),$p=Ms(),Gp=zs(),Lp=Ps(),xo=Gs(),Wp=ei(),Kp=ii(),Hp=ui(),Xp=li(),Qp=Oi(),Zp=Mi(),eg=Ci(),tg=Kt(),ng=zi(),rg=_(),De=d(),sg=V(),_o=N(),en=Ye(),ig=J(),tn=E(),oe=S(),To=Q(),Oo=Symbol.for("@jrc03c/js-math-tools/dataframe");function Xe(t){let e="abcdefghijklmnopqrstuvwxyz1234567890",n="";for(let r=0;r<t;r++)n+=e[parseInt(Math.random()*e.length)];return n}var T=class{static[Symbol.hasInstance](e){try{return!!e._symbol&&e._symbol===Oo}catch{return!1}}constructor(e){let n=this;if(Object.defineProperty(n,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:Oo}),Object.defineProperty(n,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(n,"values",{configurable:!0,enumerable:!0,get(){return n._values.length===0||!_o(n._values[0])&&n._values[0].length===0?[[]]:n._values},set(r){R(De(r),"The new values must be a 2-dimensional array!");let s=oe(r);R(s.length===2,"The new array of values must be 2-dimensional!"),s[0]<n._index.length?n._index=n._index.slice(0,s[0]):s[0]>n._index.length&&(n._index=n._index.concat(tn(n._index.length,s[0]).map(i=>"row"+en(i,(s[0]-1).toString().length)))),s[1]<n._columns.length?n._columns=n._columns.slice(0,s[1]):s[1]>n._columns.length&&(n._columns=n._columns.concat(tn(n._columns.length,s[1]).map(i=>"col"+en(i,(s[1]-1).toString().length)))),n._values=r}}),Object.defineProperty(n,"_columns",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(n,"columns",{configurable:!0,enumerable:!0,get(){return n._columns},set(r){R(De(r),"The new columns list must be a 1-dimensional array of strings!"),R(n.isEmpty||r.length===n.shape[1],"The new columns list must be the same length as the old columns list!"),R(oe(r).length===1,"The new columns list must be a 1-dimensional array of strings!"),r=r.map(i=>(typeof i!="string"&&(i=JSON.stringify(i)||i.toString()),i.trim().length===0?"untitled_"+Xe(8):i.trim()));let s=(()=>{let i=So(r),o={};return i.forEach(u=>{o[u.item]=u.count}),o})();r=r.map(i=>s[i]>1?i+"_"+Xe(8):i),n._columns=r}}),Object.defineProperty(n,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(n,"index",{configurable:!0,enumerable:!0,get(){return n._index},set(r){R(De(r),"The new index must be a 1-dimensional array of strings!"),R(n.isEmpty||r.length===n.shape[0],"The new index must be the same length as the old index!"),R(oe(r).length===1,"The new index must be a 1-dimensional array of strings!"),r=r.map(i=>(typeof i!="string"&&(i=JSON.stringify(i)||i.toString()),i.trim().length===0?"untitled_"+Xe(8):i.trim()));let s=(()=>{let i=So(r),o={};return i.forEach(u=>{o[u.item]=u.count}),o})();r=r.map(i=>s[i]>1?i+"_"+Xe(8):i),n._index=r}}),R(_o(e)||sg(e)||De(e),"The `data` passed into the constructor of a DataFrame must be either (1) an object where the key-value pairs are (respectively) column names and 1-dimensional arrays of values, or (2) a 2-dimensional array of values."),e)if(e instanceof T)n.values=Zt(e.values),n.columns=Zt(e.columns),n.index=Zt(e.index);else if(De(e)){let r=oe(e);R(r.length===2,"The `data` array passed into the constructor of a DataFrame must be 2-dimensional!"),n.values=e}else{n._columns=Object.keys(e);let r=[];n._columns.forEach(i=>{let o=e[i];r.push(o)}),n._values=To(r);let s=oe(n.values);n._index=tn(0,s[0]).map(i=>"row"+en(i,(s[0]-1).toString().length))}}get shape(){return oe(this.values)}get length(){return this.shape[0]}get width(){return this.shape[1]}get rows(){return this.index}set rows(e){let n=this;n.index=e}get isEmpty(){return rg(this.values).length===0}clear(){let e=this,n=new T(ig(e.shape));return n.columns=e.columns.slice(),n.index=e.index.slice(),n}get(e,n){let r=this;if(arguments.length===0)return r;if(arguments.length===1)try{return r.get(null,e)}catch{return r.get(e,null)}return Lp(r,e,n)}getSubsetByNames(e,n){return Kp(T,W,this,e,n)}getSubsetByIndices(e,n){return Wp(this,e,n)}getDummies(e){return xo(T,this,e)}oneHotEncode(e){return xo(T,this,e)}transpose(){let e=this,n=new T(To(e.values));return n.columns=e.index.slice(),n.index=e.columns.slice(),n}get T(){return this.transpose()}resetIndex(e){return Xp(this,e)}copy(){return Vp(T,this)}assign(e,n){return Bp(T,W,this,e,n)}apply(e,n){return Pp(T,W,this,e,n)}dropMissing(e,n,r){return Yp(T,W,this,e,n,r)}dropNaN(e,n,r){return $p(T,this,e,n,r)}drop(e,n){return Jp(T,W,this,e,n)}dropColumns(e){return this.drop(null,e)}dropRows(e){return this.drop(e,null)}toObject(e){return ng(this,e)}toJSONString(e){return tg(this,e)}saveAsJSON(e,n){return eg(this,e,n)}print(){return Hp(T,W,this)}sort(e,n){return Zp(this,e,n)}sortByIndex(){return this.sort()}filter(e,n){return Gp(T,W,this,e,n)}shuffle(e){return Qp(this,e)}append(e,n){return Up(this,e,n)}concat(e,n){return this.append(e,n)}join(e,n){return this.append(e,n)}toString(){let e=this;return JSON.stringify(e)}},W=vo()(T);Do.exports={DataFrame:T,Series:W}});var ue=c((N2,Io)=>{var og=h(),ug=_(),ag=d(),cg=y(),lg=q();function Fo(t){if(cg(t)||lg(t))return Fo(t.values);og(ag(t),"The `max` function only works on arrays, Series, and DataFrames!");try{return Math.max(...ug(t))}catch{return NaN}}Io.exports=Fo});var w=c((w2,Co)=>{var{DataFrame:Ao,Series:Eo}=Fe(),Mo=h(),Ie=d(),nn=y(),jo=z(),fg=F(),rn=q(),hg=ue(),mg=E(),Qe=S();function dg(t){return Ie(t)||rn(t)||nn(t)}function pg(t){return Mo(fg(t),"You must pass a function into the `vectorize` function!"),function e(){let n,r,s=[],i=[],o=Object.keys(arguments).filter(u=>{let a=arguments[u];return Ie(a)?!0:rn(a)?(n=!0,s.push(a),!0):nn(a)?(r=!0,i.push(a),!0):!1}).map(u=>arguments[u]);if(o.slice(0,-1).forEach((u,a)=>{Mo(jo(Ie(u)?Qe(u):u.shape,Ie(o[a+1])?Qe(o[a+1]):o[a+1].shape),`When passing multiple arrays into the \`${t.name}\` function, all of the arrays must have the same shape!`)}),o.length>0){let u=hg(o.map(l=>l.length?l.length:l.values.length)),a=mg(0,u).map(l=>{let f=Object.keys(arguments).map(m=>{if(dg(arguments[m])){if(Ie(arguments[m]))return arguments[m][l];if(rn(arguments[m]))return arguments[m].values[l];if(nn(arguments[m]))return arguments[m].values[l]}else return arguments[m]});return e(...f)});if(r)try{if(i.length===1&&jo(Qe(i[0]),Qe(a))){let l=new Ao(a);return l.index=i[0].index.slice(),l.columns=i[0].columns.slice(),l}else return new Ao(a)}catch{return a}if(n)try{if(s.length===1&&s[0].length===a.length){let l=new Eo(a);return l.name=s[0].name,l.index=s[0].index.slice(),l}else return new Eo(a)}catch{return a}return a}else return t(...arguments)}}Co.exports=pg});var Ze=c((v2,ko)=>{var gg=g(),qg=w();function yg(t){try{return gg(t)?Math.abs(t):NaN}catch{return NaN}}ko.exports=qg(yg)});var et=c((S2,zo)=>{var bg=g(),Ng=w();function wg(){try{let t=0,e=Object.values(arguments);for(let n=0;n<e.length;n++){if(!bg(e[n]))return NaN;t+=e[n]}return t}catch{return NaN}}zo.exports=Ng(wg)});var Ae=c((x2,Ro)=>{var vg=w();function Sg(t,e){try{return e(t)}catch{return NaN}}Ro.exports=vg(Sg)});var Po=c((_2,Uo)=>{var xg=g(),_g=w();function Tg(t){try{return xg(t)?Math.acos(t):NaN}catch{return NaN}}Uo.exports=_g(Tg)});var Vo=c((T2,Bo)=>{var Og=g(),Dg=w();function Fg(t){try{return Og(t)?Math.asin(t):NaN}catch{return NaN}}Bo.exports=Dg(Fg)});var Yo=c((O2,Jo)=>{var Ig=g(),Ag=w();function Eg(t){try{return Ig(t)?Math.atan(t):NaN}catch{return NaN}}Jo.exports=Ag(Eg)});var Go=c((D2,$o)=>{var Mg=h(),jg=pe(),Cg=d(),kg=y(),zg=q(),Rg=ue();function sn(t){if(kg(t)){let e=sn(t.values);return[t.index[e[0]],t.columns[e[1]]]}if(zg(t)){let e=sn(t.values);return[t.index[e]]}Mg(Cg(t),"The `argmax` function only works on arrays, Series, and DataFrames!");try{let e=jg(t,Rg(t));return e?e.length===0?void 0:e.length===1?e[0]:e:void 0}catch{return}}$o.exports=sn});var tt=c((F2,Wo)=>{var Ug=h(),Pg=_(),Bg=d(),Vg=y(),Jg=q();function Lo(t){if(Vg(t)||Jg(t))return Lo(t.values);Ug(Bg(t),"The `min` function only works on arrays, Series, and DataFrames!");try{return Math.min(...Pg(t))}catch{return NaN}}Wo.exports=Lo});var Ho=c((I2,Ko)=>{var Yg=h(),$g=pe(),Gg=d(),Lg=y(),Wg=q(),Kg=tt();function on(t){if(Lg(t)){let e=on(t.values);return[t.index[e[0]],t.columns[e[1]]]}if(Wg(t)){let e=on(t.values);return[t.index[e]]}Yg(Gg(t),"The `argmin` function only works on arrays, Series, and DataFrames!");try{let e=$g(t,Kg(t));return e?e.length===0?void 0:e.length===1?e[0]:e:void 0}catch{return}}Ko.exports=on});var un=c((A2,Xo)=>{Xo.exports=["null","none","nan","na","n/a","","undefined"]});var ln=c((E2,Zo)=>{var Qo=d(),Hg=Le(),Xg=V(),an=N(),Qg=un();function cn(t,e){if(Qo(t))return t.map(n=>cn(n,e));if(e==="null")return null;if(e==="number"){if(an(t))return NaN;let n=parseFloat(t);return isNaN(n)?NaN:n}if(e==="boolean"){if(Hg(t))return t;try{let n=(typeof t=="object"?t.toString()==="null"?"false":JSON.stringify(t):t.toString()).trim().toLowerCase();return n==="true"||n==="yes"||n==="y"?!0:n==="false"||n==="no"||n==="n"?!1:null}catch{return null}}if(e==="date"){if(t instanceof Date)return t;if(an(t))return null;let n=new Date(t);return n.toString()==="Invalid Date"?null:n}if(e==="object"){if(Xg(t))return t;try{let n=JSON.parse(t);return Qo(n)?n.map(r=>cn(r,e)):n}catch{return null}}if(e==="string"){if(an(t))return null;let n=(()=>typeof t=="object"?t===null?"null":JSON.stringify(t):t.toString())();return Qg.indexOf(n.trim().toLowerCase())>-1?null:n}}Zo.exports=cn});var tu=c((M2,eu)=>{var Zg=g(),eq=w();function tq(t){try{return Zg(t)?Math.ceil(t):NaN}catch{return NaN}}eu.exports=eq(tq)});var su=c((j2,ru)=>{var nq=Ze(),nu=g(),rq=N(),sq=w();function iq(t,e){try{if(!nu(t))return NaN;if(rq(e))e=1e-10;else if(!nu(e))return NaN;return nq(t)<e?0:t}catch{return NaN}}ru.exports=sq(iq)});var ou=c((C2,iu)=>{var fn=g(),oq=w();function uq(t,e,n){try{return fn(t)?fn(e)?fn(n)?t<e?e:t>n?n:t:NaN:NaN:NaN}catch{return NaN}}iu.exports=oq(uq)});var au=c((k2,uu)=>{var hn=h(),aq=_(),cq=d(),lq=y(),fq=g(),hq=q();function mn(t,e){if(lq(t)||hq(t))return mn(t.values,e);if(hn(cq(t),"The `combinations` function only works on arrays, Series, and DataFrames!"),hn(fq(e),"`r` must be a whole number!"),t=aq(t),e>t.length)return[t];if(e<=0)return[[]];if(hn(e===parseInt(e),"`r` must be a whole number!"),t.length<2)return t;let n=[];return t.forEach((r,s)=>{let i=t.slice(s+1);if(i.length<e-1)return;mn(i,e-1).forEach(u=>{n.push([r].concat(u))})}),n}uu.exports=mn});var nt=c((z2,lu)=>{var mq=h(),dq=_(),pq=d(),gq=y(),qq=q();function cu(t){if(gq(t)||qq(t))return cu(t.values);mq(pq(t),"The `mean` function only works on arrays, Series, and DataFrames!");try{let e=dq(t),n=0;return e.forEach(r=>{n+=r}),n/e.length}catch{return NaN}}lu.exports=cu});var pn=c((R2,gu)=>{var fu=h(),hu=d(),rt=g(),mu=q(),du=nt(),pu=S();function dn(t,e){if(mu(t))return dn(t.values,e);if(mu(e))return dn(t,e.values);fu(hu(t)&&hu(e)&&pu(t).length===1&&pu(e).length===1,"The `covariance` function only works on 1-dimensional arrays and Series!"),fu(t.length===e.length,"The two arrays or Series passed into the `covariance` function must have the same length!");try{let n=du(t),r=du(e);if(!rt(n)||!rt(r))return NaN;let s=Math.max(t.length,e.length),i=0;for(let o=0;o<s;o++){if(!rt(t[o]))return NaN;if(!rt(e[o]))return NaN;i+=(t[o]-n)*(e[o]-r)}return i/t.length}catch{return NaN}}gu.exports=dn});var st=c((U2,qu)=>{var yq=g(),bq=w();function Nq(t){try{return yq(t)?Math.sqrt(t):NaN}catch{return NaN}}qu.exports=bq(Nq)});var gn=c((P2,bu)=>{var wq=h(),vq=_(),Sq=d(),xq=y(),_q=g(),Tq=q(),Oq=nt();function yu(t){if(xq(t)||Tq(t))return yu(t.values);wq(Sq(t),"The `variance` function only works on arrays, Series, and DataFrames!");try{let e=vq(t),n=Oq(e),r=0;for(let s=0;s<e.length;s++){if(!_q(e[s]))return NaN;r+=(e[s]-n)*(e[s]-n)}return r/e.length}catch{return NaN}}bu.exports=yu});var it=c((B2,wu)=>{var Dq=h(),Fq=d(),Iq=y(),Aq=q(),Eq=st(),Mq=gn();function Nu(t){if(Iq(t)||Aq(t))return Nu(t.values);Dq(Fq(t),"The `std` function only works on arrays, Series, and DataFrames!");try{return Eq(Mq(t))}catch{return NaN}}wu.exports=Nu});var Du=c((V2,Ou)=>{var vu=h(),jq=pn(),Su=d(),xu=q(),_u=S(),Tu=it();function qn(t,e){if(xu(t))return qn(t.values,e);if(xu(e))return qn(t,e.values);vu(Su(t)&&Su(e)&&_u(t).length===1&&_u(e).length===1,"The `correl` function only works on 1-dimensional arrays and Series!"),vu(t.length===e.length,"The two arrays or Series passed into the `correl` function must have the same length!");try{return jq(t,e)/(Tu(t)*Tu(e))}catch{return NaN}}Ou.exports=qn});var Iu=c((J2,Fu)=>{var Cq=g(),kq=w();function zq(t){try{return Cq(t)?Math.cos(t):NaN}catch{return NaN}}Fu.exports=kq(zq)});var Eu=c((Y2,Au)=>{Au.exports=Object.freeze({boolean:"boolean",date:"date",null:"null",number:"number",object:"object",string:"string"})});var Ru=c(($2,zu)=>{var Rq=h(),Mu=d(),ju=y(),Uq=z(),Cu=q(),ku=k();function yn(t,e){if(ju(t)||Cu(t))return yn(t.values,e);if(ju(e)||Cu(e))return yn(t,e.values);Rq(Mu(t)&&Mu(e),"The `diff` function only works on arrays, Series, and DataFrames!");let n=ku(t),r=ku(e),s=[];return n.forEach(i=>{r.findIndex(o=>Uq(o,i))<0&&s.push(i)}),s}zu.exports=yn});var ot=c((G2,Pu)=>{var Uu=g(),Pq=w();function Bq(t,e){try{return Uu(t)?Uu(e)?Math.pow(t,e):NaN:NaN}catch{return NaN}}Pu.exports=Pq(Bq)});var bn=c((L2,Bu)=>{var Vq=g(),Jq=w();function Yq(){try{let t=Object.values(arguments);if(t.length===0)return NaN;let e=1;for(let n=0;n<t.length;n++){if(!Vq(t[n]))return NaN;e*=t[n]}return e}catch{return NaN}}Bu.exports=Jq(Yq)});var ae=c((W2,Vu)=>{var $q=bn();function Gq(){return $q(...arguments)}Vu.exports=Gq});var Nn=c((K2,Ju)=>{var Lq=et(),Wq=ae();function Kq(t,e){return Lq(t,Wq(e,-1))}Ju.exports=Kq});var ut=c((H2,$u)=>{var Hq=h(),Xq=_(),Qq=d(),Zq=y(),ey=q();function Yu(t){if(Zq(t)||ey(t))return Yu(t.values);Hq(Qq(t),"The `sum` function only works on arrays, Series, and DataFrames!");try{return t.length===0?NaN:Xq(t).reduce((e,n)=>e+n,0)}catch{return NaN}}$u.exports=Yu});var Qu=c((X2,Xu)=>{var ty=Ze(),ny=h(),Gu=d(),Lu=y(),ry=z(),Wu=g(),Ku=q(),sy=ot(),Hu=S(),iy=st(),oy=Nn(),uy=ut();function wn(t,e){if(Wu(t)&&Wu(e))return ty(t-e);if(Lu(t)||Ku(t))return wn(t.values,e);if(Lu(e)||Ku(e))return wn(t,e.values);Gu(t)&&Gu(e)&&ny(ry(Hu(t),Hu(e)),"If passing two arrays, Series, or DataFrames into the `distance` function, then those objects must have the same shape!");try{return iy(uy(sy(oy(t,e),2)))}catch{return NaN}}Xu.exports=wn});var ea=c((Q2,Zu)=>{var ay=ot(),cy=ae();function ly(t,e){return cy(t,ay(e,-1))}Zu.exports=ly});var Sn=c((Z2,oa)=>{var{DataFrame:ta,Series:na}=Fe(),at=h(),ra=_(),sa=d(),vn=y(),fy=g(),ct=q(),hy=ae(),lt=S(),my=ut(),ia=Q();function K(t,e){if(vn(t)){let s=K(t.values,e);if(lt(s).length===1){let i=new na(s);return i.name=ct(e)?e.name:i.name,i.index=t.index.slice(),i}else{let i=new ta(s);return i.index=t.index.slice(),vn(e)&&(i.columns=e.columns.slice()),i}}if(vn(e)){let s=K(t,e.values);if(lt(s).length===1){let i=new na(s);return i.name=ct(t)?t.name:i.name,i.index=e.columns.slice(),i}else{let i=new ta(s);return i.columns=e.columns.slice(),i}}if(ct(t))return K(t.values,e);if(ct(e))return K(t,e.values);at(sa(t)&&sa(e),"The `dot` function only works on arrays, Series, and DataFrames!"),ra(t).concat(ra(e)).forEach(s=>{at(fy(s),"One of the arrays you passed into the `dot` function contains non-numerical values!")});let n=lt(t),r=lt(e);if(at(n.length<=2&&r.length<=2,"I'm not smart enough to know how to get the dot-product of arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `dot` function!"),at(n[n.length-1]===r[0],`There's a dimension misalignment in the two arrays you passed into the \`dot\` function. (${n[n.length-1]} !== ${r[0]})`),n.length===1&&r.length===1)return my(hy(t,e));if(n.length===1&&r.length===2)return ia(e).map(s=>K(t,s));if(n.length===2&&r.length===1)return t.map(s=>K(s,e));if(n.length===2&&r.length===2){let s=ia(e),i=[];for(let o=0;o<t.length;o++){let u=[];for(let a=0;a<s.length;a++)u.push(K(t[o],s[a]));i.push(u)}return i}}oa.exports=K});var xn=c((ex,aa)=>{var dy=h(),py=d(),gy=y(),qy=q(),yy=N();function ua(t){if(gy(t)||qy(t))return t.dropMissing(...Object.values(arguments).slice(1));dy(py(t),"The `dropMissing` function only works on arrays, Series, and DataFrames!");let e=[];return t.forEach(n=>{try{return e.push(ua(n))}catch{yy(n)||e.push(n)}}),e}aa.exports=ua});var ga=c((tx,pa)=>{var ca=h(),la=d(),fa=y(),by=z(),ha=q(),ma=N(),da=S();function ft(t,e){if(fa(t)||ha(t))return ft(t.values,e);if(fa(e)||ha(e))return ft(t,e.values);ca(la(t)&&la(e),"The `dropMissingPairwise` function only works on arrays, Series, and DataFrames!"),ca(by(da(t),da(e)),"The two arrays, Series, and/or DataFrames passed into the `dropMissingPairwise` function must have the same shape!");let n=[],r=[];for(let s=0;s<t.length;s++)try{let[i,o]=ft(t[s],e[s]);n.push(i),r.push(o)}catch{!ma(t[s])&&!ma(e[s])&&(n.push(t[s]),r.push(e[s]))}return[n,r]}pa.exports=ft});var xa=c((nx,Sa)=>{var qa=h(),ya=d(),ba=y(),Ny=z(),Na=g(),wa=q(),va=S();function ht(t,e){if(ba(t)||wa(t))return ht(t.values,e);if(ba(e)||wa(e))return ht(t,e.values);qa(ya(t)&&ya(e),"The `dropNaNPairwise` only works on arrays, Series, and DataFrames!"),qa(Ny(va(t),va(e)),"The two arrays, Series, and/or DataFrames passed into the `dropNaNPairwise` must have the same shape!");let n=[],r=[];for(let s=0;s<t.length;s++)try{let[i,o]=ht(t[s],e[s]);n.push(i),r.push(o)}catch{Na(t[s])&&Na(e[s])&&(n.push(t[s]),r.push(e[s]))}return[n,r]}Sa.exports=ht});var Ta=c((rx,_a)=>{var wy=xn();function vy(t){return wy(t)}_a.exports=vy});var Da=c((sx,Oa)=>{var Sy=g(),xy=w();function _y(t){try{return Sy(t)?Math.exp(t):NaN}catch{return NaN}}Oa.exports=xy(_y)});var Aa=c((ix,Ia)=>{var Ty=w();function Fa(t){try{return t!==parseInt(t)?NaN:t<=1?1:t*Fa(t-1)}catch{return NaN}}Ia.exports=Ty(Fa)});var Ca=c((ox,ja)=>{var Oy=h(),Dy=_(),Ea=d(),Fy=y(),Iy=F(),Ma=V(),Ay=q();function _n(t,e){if(Fy(t))return _n(Dy(t.values),e);if(Ay(t))return _n(t.values,e);if(Oy(Ma(t)||Ea(t),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `find` function!"),!Iy(e)){let s=e;e=i=>i===s}function n(s,i,o){if(o=o||[],o.indexOf(s)>-1)return null;if(Ma(s)){o.push(s);let u=Object.keys(s);for(let a=0;a<u.length;a++){let l=u[a],f=s[l];if(i(f))return f;let m=n(f,i,o);if(m)return m}}else if(Ea(s)){o.push(s);for(let u=0;u<s.length;u++){let a=s[u];if(i(a))return a;let l=n(a,i,o);if(l)return l}}else if(i(s))return s;return null}function r(s){try{return e(s)}catch{return!1}}return n(t,r)}ja.exports=_n});var Ua=c((ux,Ra)=>{var Ey=h(),My=_(),ka=d(),jy=y(),Cy=F(),za=V(),ky=q();function Tn(t,e){if(jy(t))return Tn(My(t.values),e);if(ky(t))return Tn(t.values,e);if(Ey(za(t)||ka(t),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `findAll` function!"),!Cy(e)){let i=e;e=o=>o===i}function n(i,o,u){if(u=u||[],u.indexOf(i)>-1)return null;if(za(i)){u.push(i);let a=Object.keys(i),l=[];for(let f=0;f<a.length;f++){let m=a[f],p=i[m],b=!1;o(p)&&(l.push(p),b=!0);let M=n(p,o,u);M&&M.length>0&&M.slice(b?1:0).forEach(O=>l.push(O))}return l}else if(ka(i)){u.push(i);let a=[];for(let l=0;l<i.length;l++){let f=i[l],m=!1;o(f)&&(a.push(f),m=!0);let p=n(f,o,u);p&&p.length>0&&p.slice(m?1:0).forEach(b=>a.push(b))}return a}else if(o(i))return[i];return null}function r(i){try{return e(i)}catch{return!1}}let s=n(t,r);return s&&s.length>0?s:null}Ra.exports=Tn});var Ba=c((ax,Pa)=>{var zy=g(),Ry=w();function Uy(t){try{if(t==="Infinity")return 1/0;if(t==="-Infinity")return-1/0;let e=JSON.parse(t);return zy(e)?e:NaN}catch{return NaN}}Pa.exports=Ry(Uy)});var Ja=c((cx,Va)=>{var Py=g(),By=w();function Vy(t){try{return Py(t)?Math.floor(t):NaN}catch{return NaN}}Va.exports=By(Vy)});var On=c((lx,Ya)=>{var Jy=g(),Yy=Se(),$y=$e();function Gy(t){Jy(t)&&(t=[t]);let e=[],n=Yy(t);for(let r=0;r<n;r++)e.push(0);return $y(e,t)}Ya.exports=Gy});var Ga=c((fx,$a)=>{var mt=h(),Ly=g(),Wy=N(),Ky=On();function Hy(t){mt(!Wy(t),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),mt(Ly(t),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),mt(parseInt(t)===t,"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),mt(t>0,"You must pass an integer greater than 0 (representing the size) into the `identity` function!");let e=Ky([t,t]);for(let n=0;n<t;n++)e[n][n]=1;return e}$a.exports=Hy});var Wa=c((hx,La)=>{La.exports=["true","false","yes","no"]});var Ha=c((mx,Ka)=>{var Xy=Ae(),Qy=h(),Zy=Wa(),e1=ln(),t1=qe(),n1=_(),Dn=d(),r1=y(),s1=g(),i1=q(),o1=I(),u1=un();function dt(t){if(r1(t)){let s=t.copy(),i=dt(t.values);return s.values=i.values,{type:i.type,values:s}}if(i1(t)){let s=t.copy(),i=dt(t.values);return s.values=i.values,{type:i.type,values:s}}if(t instanceof Date)return{type:"date",value:t};if(!Dn(t)){let s=dt([t]);return s.value=s.values[0],delete s.values,s}Qy(Dn(t),"The `inferType` function only works on arrays, Series, and DataFrames!");let e=n1(t).map(s=>{if(s===void 0)return"null";if(s instanceof Date)return"date";o1(s)||(s=JSON.stringify(s));let o=s.toLowerCase().trim();if(u1.indexOf(o)>-1)return"null";if(Zy.indexOf(o)>-1)return"boolean";try{let u=JSON.parse(s);return s1(u)?"number":typeof u=="object"?Dn(u)?"string":"object":"string"}catch{return new Date(s).toString()!=="Invalid Date"?"date":"string"}}),r=t1(e).sort((s,i)=>i.count-s.count)[0].item;return{type:r,values:Xy(t,s=>e1(s,r))}}Ka.exports=dt});var Qa=c((dx,Xa)=>{var a1=g(),c1=w();function l1(t){try{let e=JSON.parse(t);return a1(e)?parseInt(e):NaN}catch{return NaN}}Xa.exports=c1(l1)});var ec=c((px,Za)=>{var f1=h(),h1=d(),m1=y(),d1=z(),p1=q(),Fn=k();function g1(){let t=Object.values(arguments).map(n=>m1(n)||p1(n)?Fn(n.values):(f1(h1(n),"The `intersect` function only works on arrays, Series, and DataFrames!"),Fn(n)));return Fn(t).filter(n=>t.every(r=>r.findIndex(s=>d1(s,n))>-1))}Za.exports=g1});var sc=c((gx,rc)=>{var tc=et(),H=h(),q1=Sn(),y1=_(),b1=d(),N1=y(),In=g(),nc=ae(),w1=S();function pt(t){if(N1(t)){let n=t.copy();return n.values=pt(n.values),n}H(b1(t),"The `inverse` function only works on square 2-dimensional arrays or DataFrames!"),y1(t).forEach(n=>H(In(n),"The array passed into the `inverse` function must contain only numbers!"));let e=w1(t);if(H(e.length===2,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),H(e[0]===e[1],"The array passed into the `inverse` function must be exactly two-dimensional and square!"),H(e[0]>=0,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),e[0]===0)return t;if(e[0]===1)return H(t[0][0]!==0,"This matrix cannot be inverted!"),1/t[0][0];if(e[0]===2){let n=t[0][0],r=t[0][1],s=t[1][0],i=t[1][1],o=n*i-r*s;H(o!==0,"This matrix cannot be inverted!");let u=[[i,-r],[-s,n]];return nc(u,1/o)}else if(e[0]>1){let n=(r,s)=>In(r)||In(s)?nc(r,s):q1(r,s);for(let r=1;r<e[0]-1;r++)try{let s=t.slice(0,r).map(O=>O.slice(0,r)),i=t.slice(0,r).map(O=>O.slice(r,e[0])),o=t.slice(r,e[0]).map(O=>O.slice(0,r)),u=t.slice(r,e[0]).map(O=>O.slice(r,e[0])),a=pt(s),l=pt(tc(u,n(-1,n(n(o,a),i)))),f=tc(a,n(n(n(n(a,i),l),o),a)),m=n(-1,n(n(a,i),l)),p=n(-1,n(n(l,o),a)),b=l;return f.map((O,ee)=>O.concat(m[ee])).concat(p.map((O,ee)=>O.concat(b[ee])))}catch{}H(!1,"This matrix cannot be inverted!")}}rc.exports=pt});var oc=c((qx,ic)=>{var v1=new Function(`
    try {
      return this === window
    } catch(e) {}

    try {
      return !!importScripts
    } catch(e){}

    return false
  `);ic.exports=v1});var ac=c((yx,uc)=>{var An=g(),S1=w();function x1(t,e,n){try{return An(t)?An(e)?An(n)?n*(e-t)+t:NaN:NaN:NaN}catch{return NaN}}uc.exports=S1(x1)});var fc=c((bx,lc)=>{var cc=g(),_1=N(),T1=w();function O1(t,e){try{return e=_1(e)?Math.E:e,cc(t)?cc(e)?Math.log(t)/Math.log(e):NaN:NaN}catch{return NaN}}lc.exports=T1(O1)});var dc=c((Nx,mc)=>{var D1=h(),F1=_(),I1=d(),A1=y(),E1=q(),M1=Y();function hc(t){if(A1(t)||E1(t))return hc(t.values);D1(I1(t),"The `median` function only works on arrays, Series, and DataFrames!");try{let e=M1(F1(t));return e.length===0?NaN:e.length%2===0?(e[e.length/2-1]+e[e.length/2])/2:e[parseInt(e.length/2)]}catch{return NaN}}mc.exports=hc});var qc=c((wx,gc)=>{var pc=g(),j1=w();function C1(t,e){try{return pc(t)?pc(e)?t%e:NaN:NaN}catch{return NaN}}gc.exports=j1(C1)});var wc=c((vx,Nc)=>{var k1=h(),z1=qe(),R1=_(),U1=d(),P1=y(),B1=q(),V1=k(),yc=Y();function bc(t){if(P1(t)||B1(t))return bc(t.values);k1(U1(t),"The `mode` function only works on arrays, Series, and DataFrames!");try{if(t.length===0)return NaN;let e=R1(t);if(e.length===0)return NaN;let n={},r=V1(e);r.forEach(u=>{n[u]=z1(e,u)});let s=yc(r,(u,a)=>n[a]-n[u]),i=s[0];return yc(s.filter(u=>n[u]===n[i]))}catch{return NaN}}Nc.exports=bc});var _c=c((Sx,xc)=>{var{random:vc}=se(),J1=Ae(),Y1=N(),$1=J();function Sc(){let t=vc(),e=vc();return Math.sqrt(-2*Math.log(t))*Math.cos(2*Math.PI*e)}function G1(t){return Y1(t)?Sc():J1($1(t),Sc)}xc.exports=G1});var Oc=c((xx,Tc)=>{var L1=Ae(),W1=J();function K1(t){return L1(W1(t),()=>1)}Tc.exports=K1});var Fc=c((_x,Dc)=>{var En=h(),H1=_(),X1=d(),Q1=y(),Z1=g(),eb=q(),tb=N();function gt(t,e){if(Q1(t)||eb(t))return gt(t.values,e);if(En(X1(t),"The `permutations` function only works on arrays, Series, and DataFrames!"),tb(e)&&(e=t.length),En(Z1(e),"`r` must be a whole number!"),t=H1(t),e>t.length)return gt(t);if(e<=0)return[[]];if(En(e===parseInt(e),"`r` must be a whole number!"),t.length<2)return t;let n=[];return t.forEach((r,s)=>{let i=t.slice(0,s),o=t.slice(s+1),u=i.concat(o);gt(u,e-1).forEach(l=>{n.push([r].concat(l))})}),n}Dc.exports=gt});var Ac=c((Tx,Ic)=>{var{DataFrame:nb,Series:rb}=Fe(),sb=d(),ib=y(),ob=ye(),ub=q(),ab=S();function cb(){Object.keys(arguments).forEach(t=>{let e=arguments[t];if(sb(e))if(ob(e))console.log(e);else{let n=ab(e);n.length===1?new rb(e).print():n.length==2?new nb(e).print():console.log(e)}else ib(e)||ub(e)?e.print():console.log(e)})}Ic.exports=cb});var jc=c((Ox,Mc)=>{var lb=d(),fb=g(),Ec=N(),hb=ue(),mb=tt(),db=w(),pb=db(function(t,e,n,r,s){try{return[t,e,n,r,s].every(i=>fb(i))?n-e===0?NaN:(s-r)*(t-e)/(n-e)+r:NaN}catch{return NaN}});function gb(t,e,n,r,s){return lb(t)&&Ec(r)&&Ec(s)&&(r=e,s=n,e=mb(t),n=hb(t)),pb(t,e,n,r,s)}Mc.exports=gb});var kc=c((Dx,Cc)=>{var qb=g(),yb=w();function bb(t){try{return qb(t)?Math.round(t):NaN}catch{return NaN}}Cc.exports=yb(bb)});var Rc=c((Fx,zc)=>{var Nb=g(),wb=w();function vb(t){try{return Nb(t)?t<0?-1:t>0?1:0:NaN}catch{return NaN}}zc.exports=wb(vb)});var Pc=c((Ix,Uc)=>{var Sb=g(),xb=w();function _b(t){try{return Sb(t)?Math.sin(t):NaN}catch{return NaN}}Uc.exports=xb(_b)});var Vc=c((Ax,Bc)=>{var Tb=it();function Ob(t){return Tb(t)}Bc.exports=Ob});var Yc=c((Ex,Jc)=>{var Db=g(),Fb=w();function Ib(t){try{return Db(t)?Math.tan(t):NaN}catch{return NaN}}Jc.exports=Fb(Ib)});var qt=c((Mx,Lc)=>{var $c=h(),Gc=F();function Ab(t,e){$c(Gc(t),"`fn` must be a function!");let n=new Date;return e?t(...e):t(),new Date-n}async function Eb(t,e){$c(Gc(t),"`fn` must be a function!");let n=new Date;return e?await t(...e):await t(),new Date-n}Lc.exports={timeSync:Ab,timeAsync:Eb}});var Kc=c((jx,Wc)=>{var Mb=d(),jb=y(),Cb=q(),kb=k();function zb(){return kb([...arguments].map(t=>Mb(t)?t:jb(t)||Cb(t)?t.values:[t]))}Wc.exports=zb});var Xc=c((Cx,Hc)=>{var Rb=h(),Ub=d(),Pb=y(),Bb=q(),Vb=N(),Jb=ue(),Yb=E();function $b(){let t=[],e=Object.values(arguments).map(n=>((Pb(n)||Bb(n))&&(n=n.values),Rb(Ub(n),"The `zip` function only works on arrays, Series, and DataFrames!"),n));return Yb(0,Jb(e.map(n=>n.length))).forEach(n=>{let r=[];e.forEach(s=>{let i=s[n];r.push(Vb(i)?void 0:i)}),t.push(r)}),t}Hc.exports=$b});var v=c((kx,Mn)=>{var{DataFrame:Gb,Series:Lb}=Fe(),ce={abs:Ze(),add:et(),apply:Ae(),arccos:Po(),arcsin:Vo(),arctan:Yo(),argmax:Go(),argmin:Ho(),assert:h(),cast:ln(),ceil:tu(),chop:su(),clamp:ou(),combinations:au(),copy:C(),correl:Du(),cos:Iu(),count:qe(),covariance:pn(),DataFrame:Gb,dataTypes:Eu(),decycle:jt(),diff:Ru(),distance:Qu(),divide:ea(),dot:Sn(),dropMissing:xn(),dropMissingPairwise:ga(),dropNaN:Vt(),dropNaNPairwise:xa(),dropUndefined:Ta(),exp:Da(),factorial:Aa(),find:Ca(),findAll:Ua(),flatten:_(),float:Ba(),floor:Ja(),identity:Ga(),indexOf:pe(),inferType:Ha(),int:Qa(),intersect:ec(),inverse:sc(),isArray:d(),isBoolean:Le(),isBrowser:oc(),isDataFrame:y(),isEqual:z(),isFunction:F(),isJagged:ye(),isNested:ze(),isNumber:g(),isObject:V(),isSeries:q(),isString:I(),isUndefined:N(),lerp:ac(),log:fc(),MathError:te(),max:ue(),mean:nt(),median:dc(),min:tt(),mod:qc(),mode:wc(),multiply:bn(),ndarray:J(),normal:_c(),ones:Oc(),permutations:Fc(),pow:ot(),print:Ac(),product:Se(),random:se().random,range:E(),remap:jc(),reshape:$e(),reverse:be(),round:kc(),scale:ae(),seed:se().seed,Series:Lb,set:k(),shape:S(),shuffle:Ge(),sign:Rc(),sin:Pc(),sort:Y(),sqrt:st(),std:it(),stdev:Vc(),subtract:Nn(),sum:ut(),tan:Yc(),time:qt().timeSync,timeSync:qt().timeSync,timeAsync:qt().timeAsync,transpose:Q(),union:Kc(),variance:gn(),vectorize:w(),zeros:On(),zip:Xc(),dump:function(){let t=typeof global<"u"?global:window;if(!t)throw new ce.MathError("Cannot dump functions into global scope because neither `global` nor `window` exist in the current context!");Object.keys(ce).forEach(e=>{try{Object.defineProperty(t,e,{configurable:!1,enumerable:!0,writable:!1,value:ce[e]})}catch{t[e]=ce[e]}})}};typeof Mn<"u"&&(Mn.exports=ce);typeof window<"u"&&(window.JSMathTools=ce)});var U=c((zx,Qc)=>{Qc.exports={shouldIgnoreNaNValues:!0}});var le=c((Rx,el)=>{var{assert:Wb,flatten:Kb,isArray:Hb,isDataFrame:Xb,isNumber:Qb,isSeries:Zb}=v();function Zc(t){if(Xb(t)||Zb(t))return Zc(t.values);Wb(Hb(t),"The `containsOnlyNumbers` function only works on arrays, Series, and DataFrames!");let e=Kb(t);for(let n=0;n<e.length;n++)if(!Qb(e[n]))return!1;return!0}el.exports=Zc});var Cn=c((Ux,tl)=>{var{dropMissing:eN,flatten:tN,isArray:nN,isDataFrame:rN,isSeries:sN}=v();function jn(t){return typeof t=="number"?t===0||t===1:rN(t)||sN(t)?jn(t.values):nN(t)?t.length===0?!1:eN(tN(t)).every(n=>jn(n)):!1}tl.exports=jn});var kn=c((Px,ll)=>{var{abs:nl,apply:rl,assert:sl,clamp:iN,copy:oN,divide:uN,dropNaN:aN,flatten:cN,isArray:lN,isDataFrame:fN,isNumber:il,isSeries:hN,max:ol,median:ul,min:mN,sort:dN,subtract:al}=v(),pN=U(),gN=le(),qN=Cn();function cl(t,e){if(fN(t)||hN(t)){let a=t.copy();return a._values=cl(a._values,e),a}if(sl(lN(t),"The `clipOutliers` function only works on arrays, Series, and DataFrames!"),e=e||5,sl(il(e),"Any `maxScore` value passed into the `clipOutliers` function must be a number!"),!pN.shouldIgnoreNaNValues&&!gN(t))return rl(t,()=>NaN);let n=cN(t),r=aN(n);if(qN(r)||r.length===0)return t;let s=ul(r),i=ul(nl(al(r,s))),o=!1;if(i===0){let a=dN(oN(r)),l=a.filter(b=>b<s),f=a.filter(b=>b>s),m=s,p=s;if(l.length>0&&(m=ol(l)),f.length>0&&(p=mN(f)),i=(p-m)/2,i===0)return t;o=(s-m)/i>e||(p-s)/i>e}return ol(uN(nl(al(r,s)),i))>e||o?rl(t,a=>il(a)?iN(a,s-e*i,s+e*i):a):t}ll.exports=cl});var Rn=c((Bx,yl)=>{var{assert:fl,dropNaN:hl,isArray:ml,isSeries:dl,mean:pl,shape:gl,variance:ql}=v(),yN=U();function zn(t,e){if(dl(t))return zn(t.values,e);if(dl(e))return zn(t,e.values);fl(ml(t)&&ml(e)&&gl(t).length===1&&gl(e).length===1,"The `cohensd` function only works on 1-dimensional arrays and Series!"),fl(t.length===e.length,"Two arrays or Series passed into the `cohensd` function must have the same length!"),yN.shouldIgnoreNaNValues&&(t=hl(t),e=hl(e));try{let n=pl(t),r=pl(e),s=Math.sqrt((ql(t)+ql(e))/2);return(n-r)/s}catch{return NaN}}yl.exports=zn});var vl=c((Vx,wl)=>{var{assert:bl,DataFrame:bN,isArray:NN,isSeries:wN,shape:vN,zeros:SN}=v();function Nl(t){if(wN(t)){let r=new bN(Nl(t.values));return r.index=t.index.slice(),r.columns=t.index.slice(),r}bl(NN(t),"The `diagonalize` function only works on 1-dimensional arrays and Series!");let e=vN(t);bl(e.length===1,"The `diagonalize` function only works on 1-dimensional arrays and Series!");let n=SN([e[0],e[0]]);return t.forEach((r,s)=>n[s][s]=r),n}wl.exports=Nl});var Vn=c((Jx,Tl)=>{var{assert:Un,clamp:xN,correl:Sl,DataFrame:yt,dropNaNPairwise:_N,isArray:xl,isDataFrame:bt,isJagged:_l,isUndefined:TN,ndarray:ON}=v(),DN=U();function Pn(t){let e="@jrc03c/js-data-science-helpers/get-correlation-matrix";return Object.defineProperty(t,e,{configurable:!1,enumerable:!1,writable:!1,value:Symbol.for(e)}),t}function Bn(t,e){if(TN(e)&&(e=t),bt(t)){let r=new yt(Bn(t.values,e));return r.index=t.columns.slice(),r.columns=bt(e)?e.columns.slice():new yt(e).columns.slice(),Pn(r)}if(bt(e)){let r=new yt(Bn(t,e.values));return r.index=bt(t)?t.columns.slice():new yt(t).columns.slice(),r.columns=e.columns.slice(),Pn(r)}Un(xl(t)&&xl(e),"The `getCorrelationMatrix` function only works on 2-dimensional arrays and DataFrames!"),Un(!_l(t)&&!_l(e),"The `getCorrelationMatrix` function only works on non-jagged 2-dimensional arrays and DataFrames!"),Un(t.length===e.length,'The dimensions of the matrices you passed into the `getCorrelationMatrix` function aren\'t compatible! ([shape(a).join(", ")] vs. [shape(b).join(", ")]) The function expects that you\'ll be comparing the columns of two matrices where the columns are all of the same length, so please make sure that the matrices are oriented accordingly.');let n=ON([t[0].length,e[0].length]);for(let r=0;r<t[0].length;r++){let s=t.map(i=>i[r]);for(let i=0;i<e[0].length;i++){let o=e.map(u=>u[i]);DN.shouldIgnoreNaNValues?n[r][i]=Sl(..._N(s,o)):n[r][i]=Sl(s,o)}}return Pn(xN(n,-1,1))}Tl.exports=Bn});var Jn=c((Yx,Ol)=>{function FN(t){try{let e="@jrc03c/js-data-science-helpers/get-correlation-matrix";return t[e]===Symbol.for(e)}catch{return!1}}Ol.exports=FN});var Al=c(($x,Il)=>{var{DataFrame:Yn,isArray:IN,isDataFrame:Nt,isNumber:Dl,MathError:AN,sort:EN}=v(),Fl=Vn(),MN=Jn();function jN(t,e,n){n=Object.values(arguments).find(i=>Dl(i))||1-1e-5;let r=(()=>{let i=Object.values(arguments).filter(o=>IN(o)||Nt(o));if(i.length===1){let o=i[0];if(MN(o))return Nt(o)?o:new Yn(o);{let u=Fl(o,null);return Nt(u)?u:new Yn(u)}}if(i.length===2){let o=Fl(i[0],i[1]);return Nt(o)?o:new Yn(o)}throw new AN("You must pass 1 or 2 2-dimensional arrays or DataFrames into the `getHighlyCorrelatedColumns` function!")})(),s={};return r.values.forEach((i,o)=>{i.forEach((u,a)=>{if(Dl(u)&&u>n){let l=r.index[o],f=r.columns[a];s[l]||(s[l]=[]),s[l].indexOf(f)<0&&s[l].push(f),s[f]||(s[f]=[]),s[f].indexOf(l)<0&&s[f].push(l)}})}),Object.keys(s).forEach(i=>{s[i]=EN(s[i])}),s}Il.exports=jN});var $n=c((Gx,Ml)=>{var{dropNaN:CN,isArray:kN,isDataFrame:zN,isNumber:RN,isSeries:UN,pow:PN,sqrt:BN,sum:VN}=v(),JN=U();function El(t){return zN(t)||UN(t)?El(t.values):RN(t)?Math.abs(t):kN(t)?(JN.shouldIgnoreNaNValues&&(t=CN(t)),BN(VN(PN(t,2)))):NaN}Ml.exports=El});var Gn=c((Lx,kl)=>{var{assert:jl,DataFrame:YN,isArray:$N,isSeries:GN,isString:LN,isUndefined:WN,set:KN,shape:HN,sort:XN}=v();function Cl(){if(arguments.length===1&&GN(arguments[0])){let{name:i,values:o}=arguments[0],u=Cl(i,o),a=new YN(u);return a.index=arguments[0].index.slice(),a}let[t,e]=arguments;jl(LN(t),"When passing two arguments into the `getOneHotEncodings` function, the first argument must be a string representing the name of the variable being encoded!"),jl($N(e)&&HN(e).length===1,"When passing two arguments into the `getOneHotEncodings` function, the second argument must be a 1-dimensional array!");let n={},r=t+"_"+e[0];return XN(KN(e)).filter(i=>!WN(i)).map(i=>t+"_"+i).filter(i=>i!==r).forEach(i=>{n[i]=e.map(o=>i===t+"_"+o?1:0)}),n}kl.exports=Cl});var Rl=c((Wx,zl)=>{var{count:QN}=v();function ZN(t){return QN(t).map(n=>(n.percentage=n.count/t.length,n))}zl.exports=ZN});var Ul=c((Kx,ew)=>{ew.exports=[.5,.49601,.49202,.48803,.48405,.48006,.47608,.4721,.46812,.46414,.46017,.4562,.45224,.44828,.44433,.44038,.4364,.43251,.42858,.42465,.42074,.41683,.41294,.40905,.40517,.40129,.39743,.39358,.38974,.38591,.38209,.37828,.37448,.3707,.36693,.36317,.35942,.35569,.35197,.34827,.34458,.3409,.33724,.3336,.32997,.32636,.32276,.31918,.31561,.31207,.30854,.30503,.30153,.29806,.2946,.29116,.28774,.28434,.28096,.2776,.27425,.27093,.26763,.26435,.26109,.25785,.25463,.25143,.24825,.2451,.24196,.23885,.23576,.2327,.22965,.22663,.22363,.22065,.2177,.21476,.21186,.20897,.20611,.20327,.20045,.19766,.19489,.19215,.18943,.18673,.18406,.18141,.17879,.17619,.17361,.17106,.16853,.16602,.16354,.16109,.15866,.15625,.15386,.15151,.14917,.14686,.14457,.14231,.14007,.13786,.13567,.1335,.13136,.12924,.12714,.12507,.12302,.121,.119,.11702,.11507,.11314,.11123,.10935,.10749,.10565,.10383,.10204,.10027,.09853,.0968,.0951,.09342,.09176,.09012,.08851,.08692,.08534,.08379,.08226,.08076,.07927,.0778,.07636,.07493,.07353,.07215,.07078,.06944,.06811,.06681,.06552,.06426,.06301,.06178,.06057,.05938,.05821,.05705,.05592,.0548,.0537,.05262,.05155,.0505,.04947,.04846,.04746,.04648,.04551,.04457,.04363,.04272,.04182,.04093,.04006,.0392,.03836,.03754,.03673,.03593,.03515,.03438,.03362,.03288,.03216,.03144,.03074,.03005,.02938,.02872,.02807,.02743,.0268,.02619,.02559,.025,.02442,.02385,.0233,.02275,.02222,.02169,.02118,.02068,.02018,.0197,.01923,.01876,.01831,.01786,.01743,.017,.01659,.01618,.01578,.01539,.015,.01463,.01426,.0139,.01355,.01321,.01287,.01255,.01222,.01191,.0116,.0113,.01101,.01072,.01044,.01017,.0099,.00964,.00939,.00914,.00889,.00866,.00842,.0082,.00798,.00776,.00755,.00734,.00714,.00695,.00676,.00657,.00639,.00621,.00604,.00587,.0057,.00554,.00539,.00523,.00508,.00494,.0048,.00466,.00453,.0044,.00427,.00415,.00402,.00391,.00379,.00368,.00357,.00347,.00336,.00326,.00317,.00307,.00298,.00289,.0028,.00272,.00264,.00256,.00248,.0024,.00233,.00226,.00219,.00212,.00205,.00199,.00193,.00187,.00181,.00175,.00169,.00164,.00159,.00154,.00149,.00144,.00139,.00135,.00131,.00126,.00122,.00118,.00114,.00111,.00107,.00104,.001,97e-5,94e-5,9e-4,87e-5,84e-5,82e-5,79e-5,76e-5,74e-5,71e-5,69e-5,66e-5,64e-5,62e-5,6e-4,58e-5,56e-5,54e-5,52e-5,5e-4,48e-5,47e-5,45e-5,43e-5,42e-5,4e-4,39e-5,38e-5,36e-5,35e-5,34e-5,32e-5,31e-5,3e-4,29e-5,28e-5,27e-5,26e-5,25e-5,24e-5,23e-5,22e-5,22e-5,21e-5,2e-4,19e-5,19e-5,18e-5,17e-5,17e-5,16e-5,15e-5,15e-5,14e-5,14e-5,13e-5,13e-5,12e-5,12e-5,11e-5,11e-5,1e-4,1e-4,1e-4,9e-5,9e-5,8e-5,8e-5,8e-5,8e-5,7e-5,7e-5,7e-5,6e-5,6e-5,6e-5,6e-5,5e-5,5e-5,5e-5,5e-5,5e-5,4e-5,4e-5,4e-5,4e-5,4e-5,4e-5,3e-5,3e-5,3e-5,3e-5,3e-5,3e-5,3e-5,3e-5,2e-5,2e-5,2e-5,2e-5]});var Wn=c((Hx,Wl)=>{var{abs:Pl,assert:tw,dropNaNPairwise:nw,flatten:wt,isArray:Bl,isDataFrame:Vl,isEqual:rw,isSeries:Jl,mean:Yl,remap:sw,round:iw,shape:$l,sqrt:ow,std:Gl}=v(),uw=U(),Ll=Ul();function aw(t){return Pl(t)>4.1?0:Ll[iw(sw(Pl(t),0,4.1,0,Ll.length))]}function Ln(t,e){if(Vl(t)||Jl(t))return Ln(t.values,e);if(Vl(e)||Jl(e))return Ln(t,e.values);tw(Bl(t)&&Bl(e)&&rw($l(t),$l(e)),"You must pass two identically-shaped arrays, Series, or DataFrames into the `pValue` function!");let[n,r]=uw.shouldIgnoreNaNValues?nw(wt(t),wt(e)):[wt(t),wt(e)];if(n.length===0||r.length===0)return NaN;let s=Yl(n),i=Yl(r),o=Gl(n),u=Gl(r),a=n.length,l=r.length,f=(s-i)/ow(o*o/a+u*u/l);return 2*aw(f)}Wl.exports=Ln});var Zl=c((Xx,Ql)=>{var{assert:Kn,clamp:cw,DataFrame:vt,dropNaNPairwise:lw,isArray:Kl,isDataFrame:St,isJagged:Hl,isUndefined:fw,ndarray:hw}=v(),mw=U(),Xl=Wn();function Hn(t){let e="@jrc03c/js-data-science-helpers/get-p-value-matrix";return Object.defineProperty(t,e,{configurable:!1,enumerable:!1,writable:!1,value:Symbol.for(e)}),t}function Xn(t,e){if(fw(e)&&(e=t),St(t)){let r=new vt(Xn(t.values,e));return r.index=t.columns.slice(),r.columns=St(e)?e.columns.slice():new vt(e).columns.slice(),Hn(r)}if(St(e)){let r=new vt(Xn(t,e.values));return r.index=St(t)?t.columns.slice():new vt(t).columns.slice(),r.columns=e.columns.slice(),Hn(r)}Kn(Kl(t)&&Kl(e),"The `getPValueMatrix` function only works on 2-dimensional arrays and DataFrames!"),Kn(!Hl(t)&&!Hl(e),"The `getPValueMatrix` function only works on non-jagged 2-dimensional arrays and DataFrames!"),Kn(t.length===e.length,'The dimensions of the matrices you passed into the `getPValueMatrix` function aren\'t compatible! ([shape(a).join(", ")] vs. [shape(b).join(", ")]) The function expects that you\'ll be comparing the columns of two matrices where the columns are all of the same length, so please make sure that the matrices are oriented accordingly.');let n=hw([t[0].length,e[0].length]);for(let r=0;r<t[0].length;r++){let s=t.map(i=>i[r]);for(let i=0;i<e[0].length;i++){let o=e.map(u=>u[i]);mw.shouldIgnoreNaNValues?n[r][i]=Xl(...lw(s,o)):n[r][i]=Xl(s,o)}}return Hn(cw(n,0,1))}Ql.exports=Xn});var sf=c((Qx,rf)=>{var{assert:xt,intersect:dw,isDataFrame:ef,isSeries:tf,isUndefined:nf}=v(),fe=class{constructor(e){let n=this;xt(nf(e)||e===fe.DROP_NAN_MODE||e===fe.DROP_MISSING_MODE,"The `mode` value passed into the `IndexMatcher` constructor must be undefined or one of [IndexMatcher.DROP_NAN_MODE, IndexMatcher.DROP_MISSING_MODE]! (By default, the mode is `Indexer.DROP_MISSING_MODE`.)"),n.mode=nf(e)?fe.DROP_MISSING_MODE:e,n.index=null}fit(){let e=this,n=[];return Object.values(arguments).forEach(r=>{xt(ef(r)||tf(r),"The `IndexMatcher` only works on Series and DataFrames! To drop NaN values in a pair-wise fashion from regular arrays, use the `dropNaNPairwise` function from the @jrc03c/js-math-tools library."),e.mode===fe.DROP_MISSING_MODE?n.push(r.dropMissing().index):n.push(r.dropNaN().index)}),e.index=dw(...n),e}transform(){let e=this;xt(!!e.index,"The IndexMatcher hasn't been fitted yet! Please call the `fit` method before calling the `transform` method.");let n=Object.values(arguments).map(r=>(xt(ef(r)||tf(r),"The `IndexMatcher` only works on Series and DataFrames! To drop NaN values in a pair-wise fashion from regular arrays, use the `dropNaNPairwise` function from the @jrc03c/js-math-tools library."),r.get(e.index,null)));return n.length===1?n[0]:n}fitAndTransform(){return this.fit(...arguments).transform(...arguments)}},Ee=fe;It(Ee,"DROP_NAN_MODE","DROP_NAN_MODE"),It(Ee,"DROP_MISSING_MODE","DROP_MISSING_MODE");rf.exports=Ee});var Zn=c((Zx,lf)=>{var{assert:Qn,isArray:pw,isBoolean:gw,isDataFrame:of,isSeries:uf,int:qw,isNumber:yw,isUndefined:af,range:cf,set:bw,shape:Nw,shuffle:ww}=v();lf.exports=function(){let e=Array.from(arguments),n=e.find(b=>gw(b)),r=af(n)?!0:n,s=e.find(b=>yw(b)),i=af(s)?.1:s;Qn(i>0&&i<1,"`testSize` must be a number between 0 and 1 (exclusive on both ends)!");let o=e.filter(b=>pw(b)||of(b)||uf(b));Qn(o.length>0,"You must pass at least one dataset into the `trainTestSplit` function!");let u=o.map(b=>Nw(b)[0]);Qn(bw(u).length===1,`All datasets passed into the \`trainTestSplit\` function must be the same length at their shallowest dimension! The lengths of your datasets, though, are: ${u.join(", ")}`);let a=[],l=r?ww(cf(0,u[0])):cf(0,u[0]),f=qw((1-i)*l.length),m=l.slice(0,f),p=l.slice(f);return o.forEach(b=>{if(of(b))a.push(b.get(m,null)),a.push(b.get(p,null));else if(uf(b))a.push(b.get(m)),a.push(b.get(p));else{let M=[],O=[];b.forEach((ee,Sh)=>{m.indexOf(Sh)>-1?M.push(ee):O.push(ee)}),a.push(M),a.push(O)}}),a}});var Tt=c((e_,gf)=>{var{add:vw,argmin:Sw,assert:xw,flatten:ff,isArray:_w,isDataFrame:hf,isEqual:Tw,int:Ow,isNumber:Dw,isSeries:mf,normal:er,pow:Fw,random:Iw,range:Aw,scale:Ew,shape:_t,subtract:Mw,sum:jw}=v(),Cw=Zn();function tr(t,e){(hf(t)||mf(t))&&(t=t.values),(hf(e)||mf(e))&&(e=e.values),xw(Tw(_t(t),_t(e)),"`yPred` and `yTrue` must have the same shape!");let n=ff(t),r=ff(e),s=0;return n.forEach((i,o)=>{i===r[o]&&s++}),s/n.length}function kw(t){test(`tests that the \`${t.name}\` model works correctly`,()=>{let e=er([5,10]).map(m=>m.map(p=>p*100+er()*100)),n=[],r=Aw(0,500).map(()=>{let m=Ow(Iw()*e.length),p=e[m];return n.push(m),vw(p,Ew(5,er(_t(p))))}),[s,i,o,u]=Cw(r,n),a=new t({k:e.length});a.fit(s),a.centroids=df(e,a.centroids);let l=a.predict(s),f=a.predict(i);expect(tr(o,l)).toBeGreaterThan(.95),expect(tr(u,f)).toBeGreaterThan(.95)})}function zw(t){return _w(t)&&_t(t).length===2}function Rw(t){return Dw(t)&&parseInt(t)===t&&t>=0}function df(t,e){return t.map(n=>e[Sw(e.map(r=>pf(n,r)))])}function pf(t,e){return jw(Fw(Mw(t,e),2))}gf.exports={accuracy:tr,createGenericTest:kw,isMatrix:zw,isWholeNumber:Rw,orderCentroids:df,sse:pf}});var sr=c((t_,Nf)=>{var{add:qf,argmin:Uw,assert:Z,copy:Pw,distance:yf,divide:Bw,isDataFrame:Vw,isFunction:Jw,isUndefined:Ot,normal:Yw,random:$w,range:Gw,scale:Lw,shuffle:Ww,zeros:bf}=v(),{isMatrix:Kw,isWholeNumber:nr,sse:Hw}=Tt(),rr=class{constructor(e){Z(typeof e=="object","`config` must be an object! See the documentation for more information about the properties that the `config` object can contain."),Z(nr(e.k),"`k` must be a whole number!"),Z(nr(e.maxIterations)||Ot(e.maxIterations),"`maxIterations` must be a whole number or undefined!"),Z(nr(e.maxRestarts)||Ot(e.maxRestarts),"`maxRestarts` must be a whole number or undefined!"),Z(typeof e.tolerance=="number"||Ot(e.tolerance),"`tolerance` must be a number or undefined!");let n=this;n.k=e.k,n.maxRestarts=e.maxRestarts||25,n.maxIterations=e.maxIterations||100,n.tolerance=e.tolerance||1e-4,n.centroids=null,n._fitState=null}initializeCentroids(e){let n=this;return Ww(e).slice(0,n.k)}fitStep(e,n){let r=this;if(Z(Kw(e),"`x` must be a matrix!"),Vw(e)&&(e=e.values),Ot(n)||Z(Jw(n),"If defined, `progress` must be a function!"),r._fitState){if(r._fitState.isFinished)return r}else{let a=r.initializeCentroids(e);r._fitState={currentRestart:0,currentIteration:0,currentCentroids:a,bestCentroids:a,bestScore:-1/0,isFinished:!1}}let s=r.predict(e,r._fitState.currentCentroids),i=[],o=bf(r.k);e.forEach((a,l)=>{let f=s[l];i[f]||(i[f]=bf(a.length)),i[f]=qf(i[f],a),o[f]++});let u=Gw(0,r.k).map(a=>o[a]===0?qf(r._fitState.currentCentroids[parseInt($w()*r._fitState.currentCentroids.length)],Lw(.001,Yw(r._fitState.currentCentroids[0].length))):Bw(i[a],o[a]));if(yf(r._fitState.currentCentroids,u)<r.tolerance?r._fitState.currentIteration=r.maxIterations-1:r._fitState.currentCentroids=u,n&&n((r._fitState.currentRestart+r._fitState.currentIteration/r.maxIterations)/r.maxRestarts,r),r._fitState.currentIteration++,r._fitState.currentIteration>=r.maxIterations){let a=r.score(e,r._fitState.currentCentroids);if(a>r._fitState.bestScore&&(r._fitState.bestScore=a,r._fitState.bestCentroids=Pw(r._fitState.currentCentroids)),r._fitState.currentIteration=0,r._fitState.currentRestart++,r._fitState.currentRestart>=r.maxRestarts)r._fitState.isFinished=!0,r.centroids=r._fitState.bestCentroids,n&&n(1,r);else{let l=r.initializeCentroids(e);r._fitState.currentCentroids=l}}return r}fit(e,n){let r=this;for(r._fitState&&(r._fitState=null);!r._fitState||!r._fitState.isFinished;)r.fitStep(e,n);return r}predict(e,n){if(n=n||this.centroids,!n)throw new Error("No centroids were provided to the `predict` method, and the K-Means model hasn't been fitted yet. Please either pass centroids as a second parameter to the `predict` method or run the `fit` method first!");return e.map(s=>Uw(n.map(i=>yf(s,i))))}score(e,n){let r=this;if(n=n||r.centroids,!n)throw new Error("No centroids were provided to the `score` method, and the K-Means model hasn't been fitted yet. Please either pass centroids as a second parameter to the `score` method or run the `fit` method first!");let i=r.predict(e,n).map(o=>n[o]);return-Hw(e,i)}};Nf.exports=rr});var or=c((n_,Sf)=>{var{argmin:Xw,distance:wf,divide:Qw,max:Zw,random:vf}=v(),ev=sr(),ir=class extends ev{initializeCentroids(e){let n=this,r=[e[parseInt(vf()*e.length)]];for(;r.length<n.k;){let s=e.map(o=>wf(o,r[Xw(r.map(u=>wf(o,u)))])),i=Qw(s,Zw(s));r.push(e[i.findIndex(o=>vf()<o)])}return r}};Sf.exports=ir});var Tf=c((r_,_f)=>{var{assert:B,isArray:tv,isDataFrame:nv,isEqual:rv,isFunction:sv,isUndefined:he,range:iv,shape:xf}=v(),{isMatrix:ov,isWholeNumber:ur}=Tt(),uv=or(),ar=class{constructor(e){he(e)&&(e={}),B(typeof e=="object","`config` must be an object! See the documentation for more information about the properties that the `config` object can contain."),he(e.ks)&&(e.ks=iv(1,16)),B(tv(e.ks),"`ks` must be an array of whole numbers!"),e.ks.forEach(r=>{B(ur(r),"`ks` must be an array of whole numbers!")}),B(ur(e.maxIterations)||he(e.maxIterations),"`maxIterations` must be a whole number or undefined!"),B(ur(e.maxRestarts)||he(e.maxRestarts),"`maxRestarts` must be a whole number or undefined!"),B(typeof e.tolerance=="number"||he(e.tolerance),"`tolerance` must be a number or undefined!");let n=this;n.ks=e.ks,n.maxRestarts=e.maxRestarts||25,n.maxIterations=e.maxIterations||100,n.tolerance=e.tolerance||1e-4,n.scoreStopRatio=e.scoreStopRatio||.85,n.modelClass=e.modelClass||uv,n.fittedModel=null,n._fitState=null}fitStep(e,n){let r=this;if(B(ov(e),"`x` must be a matrix!"),nv(e)&&(e=e.values),he(n)||B(sv(n),"If defined, `progress` must be a function!"),!r._fitState)r._fitState={isFinished:!1,lastScore:-1/0,currentIndex:0};else if(r._fitState.isFinished)return r;let s=r.ks[r._fitState.currentIndex],i=new r.modelClass({k:s,maxRestarts:10,maxIterations:20});i.fit(e,u=>n?n((r._fitState.currentIndex+u)/(r.ks.length+1)):null);let o=i.score(e);return o/r._fitState.lastScore>r.scoreStopRatio?(r._fitState.isFinished=!0,r._fitState.currentIndex--):(r._fitState.lastScore=o,r._fitState.currentIndex+1>=r.ks.length?r._fitState.isFinished=!0:r._fitState.currentIndex++),r._fitState.isFinished&&(r.fittedModel=new r.modelClass({k:r.ks[r._fitState.currentIndex],maxRestarts:r.maxRestarts,maxIterations:r.maxIterations}),r.fittedModel.fit(e,u=>n?n((r.ks.length+u)/(r.ks.length+1)):null),n&&n(1)),r}fit(e,n){let r=this;for(r._fitState=null;!r._fitState||!r._fitState.isFinished;)r.fitStep(e,n);return r}predict(e,n){return this.fittedModel.predict(e,n)}score(e,n){return this.fittedModel.score(e,n)}get k(){return this.fittedModel.k}set k(e){throw new Error("You can't set the k-value manually! It has to be set automatically via the `fit` method.")}get centroids(){return this.fittedModel.centroids}set centroids(e){let n=this;B(rv(xf(e),xf(n.fittedModel.centroids)),"When assigning a new value to the `centroids` property, the new centroids must have the same shape as the old centroids!"),n.fittedModel.centroids=e}};_f.exports=ar});var Df=c((s_,Of)=>{Of.exports={KMeansMeta:Tf(),KMeansNaive:sr(),KMeansPlusPlus:or(),helpers:Tt()}});var cr=c((i_,jf)=>{var{apply:av,assert:cv,dropNaN:Ff,isArray:lv,isDataFrame:fv,isSeries:hv,mean:If,std:Af}=v(),Ef=U();function Mf(t){if(fv(t)||hv(t)){let r=t.copy();return r.values=Mf(r.values),r}cv(lv(t),"The `normalize` function only works on arrays, Series, and DataFrames!");let e=(()=>Ef.shouldIgnoreNaNValues?If(Ff(t)):If(t))(),n=(()=>Ef.shouldIgnoreNaNValues?Af(Ff(t)):Af(t))();return n===0?t:av(t,r=>(r-e)/n)}jf.exports=Mf});var fr=c((o_,Uf)=>{var{assert:me,dot:Cf,isArray:kf,isSeries:lr,scale:mv,Series:dv,shape:zf}=v(),Rf=le();function Dt(t,e){if(lr(t)){if(lr(e))return new dv(Dt(t.values,e.values));{let n=t.copy();return n.values=Dt(t.values,e),n}}if(lr(e)){let n=e.copy();return n.values=Dt(t,e.values),n}return me(kf(t),"`project` only works on vectors!"),me(kf(e),"`project` only works on vectors!"),me(Rf(t),"`project` only works on vectors of numbers!"),me(Rf(e),"`project` only works on vectors of numbers!"),me(zf(t).length===1,"`project` only works on vectors!"),me(zf(e).length===1,"`project` only works on vectors!"),mv(Cf(e,t)/Cf(e,e),e)}Uf.exports=Dt});var Yf=c((u_,Jf)=>{var{assert:Pf,copy:pv,DataFrame:gv,divide:qv,isArray:yv,isDataFrame:bv,isJagged:Nv,shape:wv,subtract:vv,transpose:Bf}=v(),Sv=le(),xv=$n(),_v=fr();function Vf(t){if(bv(t)){let s=new gv(Vf(t.values));return s.index=t.index.slice(),s.columns=t.columns.slice(),s}Pf(yv(t)&&!Nv(t)&&wv(t).length===2,"`orthonormalize` only works on matrices!"),Pf(Sv(t),"`orthonormalize` only works on matrices of numbers!");let e=Bf(t),n=[];e.forEach(s=>{let i=pv(s);n.forEach(o=>{i=vv(i,_v(i,o))}),n.push(i)});let r=n.map(s=>qv(s,xv(s)));return Bf(r)}Jf.exports=Vf});var Wf=c((p_,Lf)=>{var{assert:de,correl:a_,DataFrame:Tv,dropMissing:c_,inferType:Ov,isArray:Dv,isBrowser:l_,isDataFrame:Fv,isEqual:f_,isFunction:Iv,isJagged:Av,isNumber:Me,isUndefined:Ev,set:h_,shape:Mv}=v(),m_=kn(),d_=Gn(),$f=t=>Me(t)&&(parseInt(t)===t||t===1/0);function Gf(t,e){e=e||{};let n=Me(e.maxUniqueValues)?e.maxUniqueValues:7,r=Me(e.minNonMissingValues)?e.minNonMissingValues:15,s=Me(e.maxCorrelationThreshold)?e.maxCorrelationThreshold:1-1e-5,i=e.progress||null;if(Dv(t))return de(Mv(t).length===2&&!Av(t),"The `preprocess` function only works on non-jagged 2-dimensional arrays and DataFrames!"),Gf(new Tv(t));de(Fv(t),"You must pass a DataFrame into the `preprocess` function!"),de($f(n),"`maxUniqueValues` must be a whole number!"),de($f(r),"`minNonMissingValues` must be a whole number!"),de(Me(s),"`maxCorrelationThreshold` must be a number!"),Ev(i)||de(Iv(i),"If defined, `progress` must be a function!");let o={};t.apply(u=>{let a=Ov(u.values);a.type==="boolean"&&(a.values=a.values.map(l=>l?1:0)),a.type==="date"&&(a.values=a.values.map(l=>l.getTime())),a.type!=="null"&&(a.type,a.type)})}Lf.exports=Gf});var sh=c((g_,rh)=>{var{abs:jv,add:Cv,assert:je,isArray:Kf,isDataFrame:Hf,isEqual:kv,isSeries:Xf,mean:zv,pow:Qf,scale:Rv,shape:Zf,sign:Uv,sqrt:Pv,sum:eh}=v(),th=le(),nh=(t,e)=>Cv(t,Rv(e,-1));function hr(t,e){if(Hf(t)||Xf(t))return hr(t.values,e);if(Hf(e)||Xf(e))return hr(t,e.values);je(Kf(t),"You must pass two same-shaped numerical arrays into the `rScore` function!"),je(Kf(e),"You must pass two same-shaped numerical arrays into the `rScore` function!"),je(kv(Zf(t),Zf(e)),"You must pass two same-shaped numerical arrays into the `rScore` function!"),je(th(t),"You must pass two same-shaped numerical arrays into the `rScore` function!"),je(th(e),"You must pass two same-shaped numerical arrays into the `rScore` function!");let n=eh(Qf(nh(t,e),2)),r=eh(Qf(nh(t,zv(t)),2));if(r===0)return NaN;let s=1-n/r;return Uv(s)*Pv(jv(s))}rh.exports=hr});var ch=c((q_,ah)=>{var{argmax:ih,assert:Ce,copy:Bv,DataFrame:Vv,dot:Jv,isArray:Yv,isDataFrame:$v,isEqual:oh,isJagged:Gv,max:Lv,min:Wv,reverse:Kv,shape:Hv,transpose:Xv}=v();function uh(t){if(Yv(t)){Ce(Hv(t).length===2&&!Gv(t),"The `sortCorrelationMatrix` function only works on 2-dimensional arrays and DataFrames!");let s=new Vv(t);return s.index=s.columns.slice(),uh(s).values}Ce($v(t),"You must pass a DataFrame into the `sortCorrelationMatrix` function!"),Ce(Lv(t.values)<=1&&Wv(t.values)>=-1,"The correlation matrix passed into the `sortCorrelationMatrix` function must not contain values less than -1 or greater than 1!"),Ce(oh(t.values,Xv(t.values)),"The correlation matrix passed into the `sortCorrelationMatrix` function must be symmetrical!"),Ce(oh(t.index,t.columns),"The correlation matrix passed into the `sortCorrelationMatrix` function must be symmetrical! (In this case, although the values themselves are symmetrical, the row and column names differ.)");let e=Bv(t.index),n=[];for(;e.length>0;)if(n.length===0){let s=ih(t.values.map(i=>Jv(i,i)));n.push(e[s]),e.splice(s,1)}else{let s=t.index.indexOf(n.at(-1)),i=ih(e.map(u=>t.values[t.index.indexOf(u)][s])),o=e[i];n.push(o),e.splice(i,1)}let r=Kv(n);return t.get(r,r)}ah.exports=uh});var fh=c((y_,lh)=>{var Qv=cr();function Zv(){return Qv(...arguments)}lh.exports=Zv});var Nh=c((b_,bh)=>{var{assert:Ft,DataFrame:hh,dropNaN:eS,flatten:mh,isArray:tS,isDataFrame:mr,isSeries:dr,mean:dh,range:nS,Series:ph,shape:gh,stdev:qh,transpose:yh}=v(),rS=U(),pr=class{constructor(){let e=this;e.means=[],e.stdevs=[],e.wasFittedOnAVector=!1,e.hasBeenFitted=!1}_getDataArrayAndShape(e){if(mr(e))return[e.values,e.shape];if(dr(e)){let r=yh([e.values]);return[r,gh(r)]}Ft(tS(e),"`x` must be a 1- or 2-dimensional array, DataFrame, or Series!");let n=gh(e);return Ft(n.length<3,"`x` must be a 1- or 2-dimensional array, DataFrame, or Series!"),n.length===1&&(n.push(1),e=yh([e])),[e,n]}fit(e){let n=this,r=n._getDataArrayAndShape(e);e=r[0];let s=r[1];return n.wasFittedOnAVector=s.indexOf(1)>-1,n.means=[],n.stdevs=[],nS(0,s[1]).forEach(i=>{let o=e.map(u=>u[i]);if(rS.shouldIgnoreNaNValues){let u=eS(o);n.means.push(dh(u)),n.stdevs.push(qh(u))}else n.means.push(dh(o)),n.stdevs.push(qh(o))}),n.hasBeenFitted=!0,n}transform(e){let n=this;if(!n.hasBeenFitted)throw new Error("This `StandardScaler` instance hasn't been trained on any data yet! Please use the `fit` method to train it before calling the `transform` method.");if(mr(e)){let o=new hh(n.transform(e.values));return o.columns=e.columns,o.index=e.index,o}if(dr(e)){let o=new ph(n.transform(e.values));return o.name=e.name,o.index=e.index,o}let r=n._getDataArrayAndShape(e);e=r[0];let s=r[1];Ft(s[1]===n.means.length,"The data you passed into the `transform` function doesn't have the same number of columns as the data set on which this StandardScaler was fitted!");let i=e.map(o=>o.map((u,a)=>(u-n.means[a])/n.stdevs[a]));return n.wasFittedOnAVector?mh(i):i}untransform(e){let n=this;if(!n.hasBeenFitted)throw new Error("This `StandardScaler` instance hasn't been trained on any data yet! Please use the `fit` method to train it before calling the `transform` method.");if(mr(e)){let o=new hh(n.untransform(e.values));return o.columns=e.columns,o.index=e.index,o}if(dr(e)){let o=new ph(n.untransform(e.values));return o.name=e.name,o.index=e.index,o}let r=n._getDataArrayAndShape(e);e=r[0];let s=r[1];Ft(s[1]===n.means.length,"The data you passed into the `untransform` function doesn't have the same number of columns as the data set on which this StandardScaler was fitted!");let i=e.map(o=>o.map((u,a)=>u*n.stdevs[a]+n.means[a]));return n.wasFittedOnAVector?mh(i):i}};bh.exports=pr});var iS=c((N_,vh)=>{var{MathError:sS}=v(),wh={clipOutliers:kn(),cohensD:Rn(),cohensd:Rn(),common:U(),containsOnlyNumbers:le(),diagonalize:vl(),getCorrelationMatrix:Vn(),getHighlyCorrelatedColumns:Al(),getMagnitude:$n(),getOneHotEncodings:Gn(),getPercentages:Rl(),getPValueMatrix:Zl(),IndexMatcher:sf(),isBinary:Cn(),isCorrelationMatrix:Jn(),KMeans:Df(),normalize:cr(),orthonormalize:Yf(),convertToNumerical:Wf(),project:fr(),pValue:Wn(),rScore:sh(),sortCorrelationMatrix:ch(),standardize:fh(),StandardScaler:Nh(),trainTestSplit:Zn(),dump(){let t=this,e=typeof global<"u"?global:typeof window<"u"?window:null;if(!e)throw new sS("Cannot dump functions into global scope because neither `global` nor `window` exist in the current context!");Object.keys(t).forEach(n=>{try{Object.defineProperty(e,n,{configurable:!1,enumerable:!0,writable:!1,value:t[n]})}catch{e[n]=t[n]}})}};try{window.JSDataScienceHelpers=wh}catch{}try{vh.exports=wh}catch{}});iS();})();
